"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar NoLane =\n/*                          */\n0;\nvar SyncLane =\n/*                        */\n2;\nvar InputContinuousLane =\n/*             */\n8;\nvar DefaultLane =\n/*                     */\n32;\nvar IdleLane =\n/*                        */\n268435456;\n\nvar NoEventPriority = NoLane;\nvar DiscreteEventPriority = SyncLane;\nvar ContinuousEventPriority = InputContinuousLane;\nvar DefaultEventPriority = DefaultLane;\nvar IdleEventPriority = IdleLane;\n\nvar LegacyRoot = 0;\nvar ConcurrentRoot = 1;\n\nexports.ConcurrentRoot = ConcurrentRoot;\nexports.ContinuousEventPriority = ContinuousEventPriority;\nexports.DefaultEventPriority = DefaultEventPriority;\nexports.DiscreteEventPriority = DiscreteEventPriority;\nexports.IdleEventPriority = IdleEventPriority;\nexports.LegacyRoot = LegacyRoot;\nexports.NoEventPriority = NoEventPriority;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QiwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb3VsZW1hbmVzb3cvRG93bmxvYWRzL0NvZGUvM2QgR2xhc3Nlcy9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBOb0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIFN5bmNMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgSW5wdXRDb250aW51b3VzTGFuZSA9XG4vKiAgICAgICAgICAgICAqL1xuODtcbnZhciBEZWZhdWx0TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBJZGxlTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNjg0MzU0NTY7XG5cbnZhciBOb0V2ZW50UHJpb3JpdHkgPSBOb0xhbmU7XG52YXIgRGlzY3JldGVFdmVudFByaW9yaXR5ID0gU3luY0xhbmU7XG52YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lO1xudmFyIERlZmF1bHRFdmVudFByaW9yaXR5ID0gRGVmYXVsdExhbmU7XG52YXIgSWRsZUV2ZW50UHJpb3JpdHkgPSBJZGxlTGFuZTtcblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIENvbmN1cnJlbnRSb290ID0gMTtcblxuZXhwb3J0cy5Db25jdXJyZW50Um9vdCA9IENvbmN1cnJlbnRSb290O1xuZXhwb3J0cy5Db250aW51b3VzRXZlbnRQcmlvcml0eSA9IENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EZWZhdWx0RXZlbnRQcmlvcml0eSA9IERlZmF1bHRFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLklkbGVFdmVudFByaW9yaXR5ID0gSWRsZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLkxlZ2FjeVJvb3QgPSBMZWdhY3lSb290O1xuZXhwb3J0cy5Ob0V2ZW50UHJpb3JpdHkgPSBOb0V2ZW50UHJpb3JpdHk7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    module.exports = function $$$reconciler($$$config) {\n        var exports = {};\n        'use strict';\n        var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n        var Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n        var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n        // -----------------------------------------------------------------------------\n        // Killswitch\n        //\n        // Flags that exist solely to turn off a change in case it causes a regression\n        // when it rolls out to prod. We should remove these as soon as possible.\n        // -----------------------------------------------------------------------------\n        // -----------------------------------------------------------------------------\n        // Land or remove (moderate effort)\n        //\n        // Flags that can be probably deleted or landed, but might require extra effort\n        // like migrating internal callers or performance testing.\n        // -----------------------------------------------------------------------------\n        // TODO: Finish rolling out in www\n        var favorSafetyOverHydrationPerf = true;\n        var enableAsyncActions = true; // Need to remove didTimeout argument from Scheduler before landing\n        var disableDefaultPropsExceptForClasses = true; // -----------------------------------------------------------------------------\n        // Slated for removal in the future (significant effort)\n        //\n        // These are experiments that didn't work out, and never shipped, but we can't\n        // delete from the codebase until we migrate internal callers.\n        // -----------------------------------------------------------------------------\n        // Add a callback property to suspense to notify which promises are currently\n        // in the update queue. This allows reporting and tracing of what is causing\n        // the user to see a loading state.\n        //\n        // Also allows hydration callbacks to fire when a dehydrated boundary gets\n        // hydrated or deleted.\n        //\n        // This will eventually be replaced by the Transition Tracing proposal.\n        var enableSuspenseCallback = false; // Experimental Scope support.\n        var enableAsyncIterableChildren = false;\n        var enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        var alwaysThrottleRetries = true;\n        var passChildrenWhenCloningPersistedNodes = false;\n        var enableOwnerStacks = false;\n        var syncLaneExpirationMs = 250;\n        var transitionLaneExpirationMs = 5000; // -----------------------------------------------------------------------------\n        // This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n        // before removing them in stable in the next Major\n        var disableLegacyMode = true; // Make <Context> equivalent to <Context.Provider> instead of <Context.Consumer>\n        // Debugging and DevTools\n        // -----------------------------------------------------------------------------\n        // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n        // for an experimental timeline tool.\n        var enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n        var enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n        var enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n        var enableProfilerNestedUpdatePhase = true; // Adds verbose console logging for e.g. state updates, suspense, and work loop\n        var suppressWarning = false;\n        function setSuppressWarning(newSuppressWarning) {\n            {\n                suppressWarning = newSuppressWarning;\n            }\n        } // In DEV, calls to console.warn and console.error get replaced\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning('warn', format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning('error', format, args);\n                }\n            }\n        } // eslint-disable-next-line react-internal/no-production-logging\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var isErrorLogger = format === '%s\\n\\n%s\\n' || format === '%o\\n\\n%s\\n\\n%s\\n';\n                if (ReactSharedInternals.getCurrentStack) {\n                    // We only add the current stack to the console when createTask is not supported.\n                    // Since createTask requires DevTools to be open to work, this means that stacks\n                    // can be lost while DevTools isn't open but we can't detect this.\n                    var stack = ReactSharedInternals.getCurrentStack();\n                    if (stack !== '') {\n                        format += '%s';\n                        args = args.concat([\n                            stack\n                        ]);\n                    }\n                }\n                if (isErrorLogger) {\n                    // Don't prefix our default logging formatting in ReactFiberErrorLoggger.\n                    // Don't toString the arguments.\n                    args.unshift(format);\n                } else {\n                    // TODO: Remove this prefix and stop toStringing in the wrapper and\n                    // instead do it at each callsite as needed.\n                    // Careful: RN currently depends on this prefix\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    args = args.map(function(item) {\n                        return String(item);\n                    });\n                    args.unshift('Warning: ' + format);\n                } // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, args);\n            }\n        }\n        var assign = Object.assign;\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        var FunctionComponent = 0;\n        var ClassComponent = 1;\n        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n        var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n        var HostComponent = 5;\n        var HostText = 6;\n        var Fragment = 7;\n        var Mode = 8;\n        var ContextConsumer = 9;\n        var ContextProvider = 10;\n        var ForwardRef = 11;\n        var Profiler = 12;\n        var SuspenseComponent = 13;\n        var MemoComponent = 14;\n        var SimpleMemoComponent = 15;\n        var LazyComponent = 16;\n        var IncompleteClassComponent = 17;\n        var DehydratedFragment = 18;\n        var SuspenseListComponent = 19;\n        var ScopeComponent = 21;\n        var OffscreenComponent = 22;\n        var LegacyHiddenComponent = 23;\n        var CacheComponent = 24;\n        var TracingMarkerComponent = 25;\n        var HostHoistable = 26;\n        var HostSingleton = 27;\n        var IncompleteFunctionComponent = 28;\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element');\n        var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element');\n        var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n        var REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n        var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\n        var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n        var REACT_MEMO_TYPE = Symbol.for('react.memo');\n        var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n        var REACT_SCOPE_TYPE = Symbol.for('react.scope');\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\n        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\n        var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\n        var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = '@@iterator';\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== 'object') {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === 'function') {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName$1(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || '';\n            return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName$1(type) {\n            return type.displayName || 'Context';\n        }\n        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === 'function') {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === 'string') {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return 'Fragment';\n                case REACT_PORTAL_TYPE:\n                    return 'Portal';\n                case REACT_PROFILER_TYPE:\n                    return 'Profiler';\n                case REACT_STRICT_MODE_TYPE:\n                    return 'StrictMode';\n                case REACT_SUSPENSE_TYPE:\n                    return 'Suspense';\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return 'SuspenseList';\n            }\n            if (typeof type === 'object') {\n                {\n                    if (typeof type.tag === 'number') {\n                        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            return null;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        {\n                            return getContextName$1(context) + '.Provider';\n                        }\n                    case REACT_CONSUMER_TYPE:\n                        {\n                            var consumer = type;\n                            return getContextName$1(consumer._context) + '.Consumer';\n                        }\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName$1(type, type.render, 'ForwardRef');\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || 'Memo';\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var functionName = innerType.displayName || innerType.name || '';\n            return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n        } // Keep in sync with shared/getComponentNameFromType\n        function getContextName(type) {\n            return type.displayName || 'Context';\n        }\n        function getComponentNameFromOwner(owner) {\n            if (typeof owner.tag === 'number') {\n                return getComponentNameFromFiber(owner);\n            }\n            if (typeof owner.name === 'string') {\n                return owner.name;\n            }\n            return null;\n        }\n        function getComponentNameFromFiber(fiber) {\n            var tag = fiber.tag, type = fiber.type;\n            switch(tag){\n                case CacheComponent:\n                    return 'Cache';\n                case ContextConsumer:\n                    {\n                        var consumer = type;\n                        return getContextName(consumer._context) + '.Consumer';\n                    }\n                case ContextProvider:\n                    {\n                        var _context = type;\n                        return getContextName(_context) + '.Provider';\n                    }\n                case DehydratedFragment:\n                    return 'DehydratedFragment';\n                case ForwardRef:\n                    return getWrappedName(type, type.render, 'ForwardRef');\n                case Fragment:\n                    return 'Fragment';\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    // Host component type is the display name (e.g. \"div\", \"View\")\n                    return type;\n                case HostPortal:\n                    return 'Portal';\n                case HostRoot:\n                    return 'Root';\n                case HostText:\n                    return 'Text';\n                case LazyComponent:\n                    // Name comes from the type in this case; we don't have a tag.\n                    return getComponentNameFromType(type);\n                case Mode:\n                    if (type === REACT_STRICT_MODE_TYPE) {\n                        // Don't be less specific than shared/getComponentNameFromType\n                        return 'StrictMode';\n                    }\n                    return 'Mode';\n                case OffscreenComponent:\n                    return 'Offscreen';\n                case Profiler:\n                    return 'Profiler';\n                case ScopeComponent:\n                    return 'Scope';\n                case SuspenseComponent:\n                    return 'Suspense';\n                case SuspenseListComponent:\n                    return 'SuspenseList';\n                case TracingMarkerComponent:\n                    return 'TracingMarker';\n                // The display name for these tags come from the user-provided type:\n                case IncompleteClassComponent:\n                case IncompleteFunctionComponent:\n                    {\n                        break;\n                    }\n                // Fallthrough\n                case ClassComponent:\n                case FunctionComponent:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    if (typeof type === 'function') {\n                        return type.displayName || type.name || null;\n                    }\n                    if (typeof type === 'string') {\n                        return type;\n                    }\n                    break;\n            }\n            return null;\n        }\n        var NoFlags$1 = /*                      */ 0;\n        var PerformedWork = /*                */ 1;\n        var Placement = /*                    */ 2;\n        var DidCapture = /*                   */ 128;\n        var Hydrating = /*                    */ 4096; // You can change the rest (and add more).\n        var Update = /*                       */ 4;\n        /* Skipped value:                                 0b0000000000000000000000001000; */ var ChildDeletion = /*                */ 16;\n        var ContentReset = /*                 */ 32;\n        var Callback = /*                     */ 64;\n        /* Used by DidCapture:                            0b0000000000000000000010000000; */ var ForceClientRender = /*            */ 256;\n        var Ref = /*                          */ 512;\n        var Snapshot = /*                     */ 1024;\n        var Passive$1 = /*                      */ 2048;\n        /* Used by Hydrating:                             0b0000000000000001000000000000; */ var Visibility = /*                   */ 8192;\n        var StoreConsistency = /*             */ 16384; // It's OK to reuse these bits because these flags are mutually exclusive for\n        // different fiber types. We should really be doing this for as many flags as\n        // possible, because we're about to run out of bits.\n        var ScheduleRetry = StoreConsistency;\n        var ShouldSuspendCommit = Visibility;\n        var DidDefer = ContentReset;\n        var FormReset = Snapshot;\n        var HostEffectMask = /*               */ 32767; // These are not really side effects, but we still reuse this field.\n        var Incomplete = /*                   */ 32768;\n        var ShouldCapture = /*                */ 65536;\n        var ForceUpdateForLegacySuspense = /* */ 131072;\n        var Forked = /*                       */ 1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n        // e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n        // This enables us to defer more work in the unmount case,\n        // since we can defer traversing the tree during layout to look for Passive effects,\n        // and instead rely on the static flag as a signal that there may be cleanup work.\n        var RefStatic = /*                    */ 2097152;\n        var LayoutStatic = /*                 */ 4194304;\n        var PassiveStatic = /*                */ 8388608;\n        var MaySuspendCommit = /*             */ 16777216; // Flag used to identify newly inserted fibers. It isn't reset after commit unlike `Placement`.\n        var PlacementDEV = /*                 */ 33554432;\n        var MountLayoutDev = /*               */ 67108864;\n        var MountPassiveDev = /*              */ 134217728; // Groups of flags that are used in the commit phase to skip over trees that\n        // don't contain effects, by checking subtreeFlags.\n        var BeforeMutationMask = // flag logic (see #20043)\n        Update | Snapshot | 0;\n        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility | FormReset;\n        var LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n        var PassiveMask = Passive$1 | Visibility | ChildDeletion; // Union of tags that don't get reset on clones.\n        // This allows certain concepts to persist without recalculating them,\n        // e.g. whether a subtree contains passive effects or portals.\n        var StaticMask = LayoutStatic | PassiveStatic | RefStatic | MaySuspendCommit;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n                }\n            }\n        }\n        var prefix;\n        function describeBuiltInComponentFrame(name) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || '';\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return '\\n' + prefix + name;\n            }\n        }\n        function describeDebugInfoFrame(name, env) {\n            return describeBuiltInComponentFrame(name + (env ? ' (' + env + ')' : ''));\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap$1();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return '';\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher = null;\n            {\n                previousDispatcher = ReactSharedInternals.H; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactSharedInternals.H = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, 'props', {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === 'object' && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === 'function') {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === 'string') {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                'name', {\n                    value: 'DetermineComponentFrameRoot'\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split('\\n');\n                    var controlLines = controlStack.split('\\n');\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes('<anonymous>')) {\n                                            _frame = _frame.replace('<anonymous>', fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === 'function') {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactSharedInternals.H = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : '';\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n            {\n                if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        // TODO: Consider marking the whole bundle instead of these boundaries.\n        /** @noinline */ function callComponentInDEV(Component, props, secondArg) {\n            setIsRendering(true);\n            var result = Component(props, secondArg);\n            setIsRendering(false);\n            return result;\n        }\n        /** @noinline */ function callRenderInDEV(instance) {\n            setIsRendering(true);\n            var result = instance.render();\n            setIsRendering(false);\n            return result;\n        }\n        /** @noinline */ function callLazyInitInDEV(lazy) {\n            var payload = lazy._payload;\n            var init = lazy._init;\n            return init(payload);\n        }\n        function describeFiber(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    return describeBuiltInComponentFrame(fiber.type);\n                case LazyComponent:\n                    return describeBuiltInComponentFrame('Lazy');\n                case SuspenseComponent:\n                    return describeBuiltInComponentFrame('Suspense');\n                case SuspenseListComponent:\n                    return describeBuiltInComponentFrame('SuspenseList');\n                case FunctionComponent:\n                case SimpleMemoComponent:\n                    return describeFunctionComponentFrame(fiber.type);\n                case ForwardRef:\n                    return describeFunctionComponentFrame(fiber.type.render);\n                case ClassComponent:\n                    return describeClassComponentFrame(fiber.type);\n                default:\n                    return '';\n            }\n        }\n        function getStackByFiberInDevAndProd(workInProgress) {\n            try {\n                var info = '';\n                var node = workInProgress;\n                do {\n                    info += describeFiber(node);\n                    if (true) {\n                        // Add any Server Component stack frames in reverse order.\n                        var debugInfo = node._debugInfo;\n                        if (debugInfo) {\n                            for(var i = debugInfo.length - 1; i >= 0; i--){\n                                var entry = debugInfo[i];\n                                if (typeof entry.name === 'string') {\n                                    info += describeDebugInfoFrame(entry.name, entry.env);\n                                }\n                            }\n                        }\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.return;\n                }while (node);\n                return info;\n            } catch (x) {\n                return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n            }\n        }\n        var current = null;\n        var isRendering = false;\n        function getCurrentFiberStackInDev() {\n            {\n                if (current === null) {\n                    return '';\n                } // Safe because if current fiber exists, we are reconciling,\n                return getStackByFiberInDevAndProd(current);\n            }\n        }\n        function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {\n            {\n                var previousFiber = current;\n                setCurrentFiber(fiber);\n                try {\n                    if (enableOwnerStacks) ;\n                    return callback(arg0, arg1, arg2, arg3, arg4);\n                } finally{\n                    current = previousFiber;\n                }\n            }\n            // eslint-disable-next-line react-internal/prod-error-codes\n            throw new Error('runWithFiberInDEV should never be called in production. This is a bug in React.');\n        }\n        function resetCurrentFiber() {\n            {\n                ReactSharedInternals.getCurrentStack = null;\n                isRendering = false;\n            }\n            current = null;\n        }\n        function setCurrentFiber(fiber) {\n            {\n                ReactSharedInternals.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n                isRendering = false;\n            }\n            current = fiber;\n        }\n        function setIsRendering(rendering) {\n            {\n                isRendering = rendering;\n            }\n        }\n        function getNearestMountedFiber(fiber) {\n            var node = fiber;\n            var nearestMounted = fiber;\n            if (!fiber.alternate) {\n                // If there is no alternate, this might be a new tree that isn't inserted\n                // yet. If it is, then it will have a pending insertion effect on it.\n                var nextNode = node;\n                do {\n                    node = nextNode;\n                    if ((node.flags & (Placement | Hydrating)) !== NoFlags$1) {\n                        // This is an insertion or in-progress hydration. The nearest possible\n                        // mounted fiber is the parent but we need to continue to figure out\n                        // if that one is still mounted.\n                        nearestMounted = node.return;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    nextNode = node.return;\n                }while (nextNode);\n            } else {\n                while(node.return){\n                    node = node.return;\n                }\n            }\n            if (node.tag === HostRoot) {\n                // TODO: Check if this was a nested HostRoot when used with\n                // renderContainerIntoSubtree.\n                return nearestMounted;\n            } // If we didn't hit the root, that means that we're in an disconnected tree\n            // that has been unmounted.\n            return null;\n        }\n        function isMounted(component) {\n            {\n                var owner = current;\n                if (owner !== null && isRendering && owner.tag === ClassComponent) {\n                    var ownerFiber = owner;\n                    var instance = ownerFiber.stateNode;\n                    if (!instance._warnedAboutRefsInRender) {\n                        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');\n                    }\n                    instance._warnedAboutRefsInRender = true;\n                }\n            }\n            var fiber = get(component);\n            if (!fiber) {\n                return false;\n            }\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function assertIsMounted(fiber) {\n            if (getNearestMountedFiber(fiber) !== fiber) {\n                throw new Error('Unable to find node on an unmounted component.');\n            }\n        }\n        function findCurrentFiberUsingSlowPath(fiber) {\n            var alternate = fiber.alternate;\n            if (!alternate) {\n                // If there is no alternate, then we only need to check if it is mounted.\n                var nearestMounted = getNearestMountedFiber(fiber);\n                if (nearestMounted === null) {\n                    throw new Error('Unable to find node on an unmounted component.');\n                }\n                if (nearestMounted !== fiber) {\n                    return null;\n                }\n                return fiber;\n            } // If we have two possible branches, we'll walk backwards up to the root\n            // to see what path the root points to. On the way we may hit one of the\n            // special cases and we'll deal with them.\n            var a = fiber;\n            var b = alternate;\n            while(true){\n                var parentA = a.return;\n                if (parentA === null) {\n                    break;\n                }\n                var parentB = parentA.alternate;\n                if (parentB === null) {\n                    // There is no alternate. This is an unusual case. Currently, it only\n                    // happens when a Suspense component is hidden. An extra fragment fiber\n                    // is inserted in between the Suspense fiber and its children. Skip\n                    // over this extra fragment fiber and proceed to the next parent.\n                    var nextParent = parentA.return;\n                    if (nextParent !== null) {\n                        a = b = nextParent;\n                        continue;\n                    } // If there's no parent, we're at the root.\n                    break;\n                } // If both copies of the parent fiber point to the same child, we can\n                // assume that the child is current. This happens when we bailout on low\n                // priority: the bailed out fiber's child reuses the current child.\n                if (parentA.child === parentB.child) {\n                    var child = parentA.child;\n                    while(child){\n                        if (child === a) {\n                            // We've determined that A is the current branch.\n                            assertIsMounted(parentA);\n                            return fiber;\n                        }\n                        if (child === b) {\n                            // We've determined that B is the current branch.\n                            assertIsMounted(parentA);\n                            return alternate;\n                        }\n                        child = child.sibling;\n                    } // We should never have an alternate for any mounting node. So the only\n                    // way this could possibly happen is if this was unmounted, if at all.\n                    throw new Error('Unable to find node on an unmounted component.');\n                }\n                if (a.return !== b.return) {\n                    // The return pointer of A and the return pointer of B point to different\n                    // fibers. We assume that return pointers never criss-cross, so A must\n                    // belong to the child set of A.return, and B must belong to the child\n                    // set of B.return.\n                    a = parentA;\n                    b = parentB;\n                } else {\n                    // The return pointers point to the same fiber. We'll have to use the\n                    // default, slow path: scan the child sets of each parent alternate to see\n                    // which child belongs to which set.\n                    //\n                    // Search parent A's child set\n                    var didFindChild = false;\n                    var _child = parentA.child;\n                    while(_child){\n                        if (_child === a) {\n                            didFindChild = true;\n                            a = parentA;\n                            b = parentB;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = true;\n                            b = parentA;\n                            a = parentB;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) {\n                        // Search parent B's child set\n                        _child = parentB.child;\n                        while(_child){\n                            if (_child === a) {\n                                didFindChild = true;\n                                a = parentB;\n                                b = parentA;\n                                break;\n                            }\n                            if (_child === b) {\n                                didFindChild = true;\n                                b = parentB;\n                                a = parentA;\n                                break;\n                            }\n                            _child = _child.sibling;\n                        }\n                        if (!didFindChild) {\n                            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n                        }\n                    }\n                }\n                if (a.alternate !== b) {\n                    throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n                }\n            } // If the root is not a host container, we're in a disconnected tree. I.e.\n            // unmounted.\n            if (a.tag !== HostRoot) {\n                throw new Error('Unable to find node on an unmounted component.');\n            }\n            if (a.stateNode.current === a) {\n                // We've determined that A is the current branch.\n                return fiber;\n            } // Otherwise B has to be current branch.\n            return alternate;\n        }\n        function findCurrentHostFiber(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            var tag = node.tag;\n            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                var match = findCurrentHostFiberImpl(child);\n                if (match !== null) {\n                    return match;\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        function findCurrentHostFiberWithNoPortals(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberWithNoPortalsImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            var tag = node.tag;\n            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                if (child.tag !== HostPortal) {\n                    var match = findCurrentHostFiberWithNoPortalsImpl(child);\n                    if (match !== null) {\n                        return match;\n                    }\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // This is a host config that's used for the `react-reconciler` package on npm.\n        // It is only used by third-party renderers.\n        //\n        // Its API lets you pass the host config as an argument.\n        // However, inside the `react-reconciler` we treat host config as a module.\n        // This file is a shim between two worlds.\n        //\n        // It works because the `react-reconciler` bundle is wrapped in something like:\n        //\n        // module.exports = function ($$$config) {\n        //   /* reconciler code */\n        // }\n        //\n        // So `$$$config` looks like a global variable, but it's\n        // really an argument to a top-level wrapping function.\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        var getPublicInstance = $$$config.getPublicInstance;\n        var getRootHostContext = $$$config.getRootHostContext;\n        var getChildHostContext = $$$config.getChildHostContext;\n        var prepareForCommit = $$$config.prepareForCommit;\n        var resetAfterCommit = $$$config.resetAfterCommit;\n        var createInstance = $$$config.createInstance;\n        var appendInitialChild = $$$config.appendInitialChild;\n        var finalizeInitialChildren = $$$config.finalizeInitialChildren;\n        var shouldSetTextContent = $$$config.shouldSetTextContent;\n        var createTextInstance = $$$config.createTextInstance;\n        var scheduleTimeout = $$$config.scheduleTimeout;\n        var cancelTimeout = $$$config.cancelTimeout;\n        var noTimeout = $$$config.noTimeout;\n        var isPrimaryRenderer = $$$config.isPrimaryRenderer;\n        $$$config.warnsIfNotActing;\n        var supportsMutation = $$$config.supportsMutation;\n        var supportsPersistence = $$$config.supportsPersistence;\n        var supportsHydration = $$$config.supportsHydration;\n        var getInstanceFromNode = $$$config.getInstanceFromNode;\n        $$$config.beforeActiveInstanceBlur;\n        $$$config.afterActiveInstanceBlur;\n        var preparePortalMount = $$$config.preparePortalMount;\n        $$$config.prepareScopeUpdate;\n        $$$config.getInstanceFromScope;\n        var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority;\n        var getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority;\n        var resolveUpdatePriority = $$$config.resolveUpdatePriority;\n        var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition;\n        var detachDeletedInstance = $$$config.detachDeletedInstance;\n        $$$config.requestPostPaintCallback;\n        var maySuspendCommit = $$$config.maySuspendCommit;\n        var preloadInstance = $$$config.preloadInstance;\n        var startSuspendingCommit = $$$config.startSuspendingCommit;\n        var suspendInstance = $$$config.suspendInstance;\n        var waitForCommitToBeReady = $$$config.waitForCommitToBeReady;\n        var NotPendingTransition = $$$config.NotPendingTransition;\n        var resetFormInstance = $$$config.resetFormInstance; // -------------------\n        //      Microtasks\n        //     (optional)\n        // -------------------\n        var supportsMicrotasks = $$$config.supportsMicrotasks;\n        var scheduleMicrotask = $$$config.scheduleMicrotask; // -------------------\n        //      Test selectors\n        //     (optional)\n        // -------------------\n        var supportsTestSelectors = $$$config.supportsTestSelectors;\n        var findFiberRoot = $$$config.findFiberRoot;\n        var getBoundingRect = $$$config.getBoundingRect;\n        var getTextContent = $$$config.getTextContent;\n        var isHiddenSubtree = $$$config.isHiddenSubtree;\n        var matchAccessibilityRole = $$$config.matchAccessibilityRole;\n        var setFocusIfFocusable = $$$config.setFocusIfFocusable;\n        var setupIntersectionObserver = $$$config.setupIntersectionObserver; // -------------------\n        //      Mutation\n        //     (optional)\n        // -------------------\n        var appendChild = $$$config.appendChild;\n        var appendChildToContainer = $$$config.appendChildToContainer;\n        var commitTextUpdate = $$$config.commitTextUpdate;\n        var commitMount = $$$config.commitMount;\n        var commitUpdate = $$$config.commitUpdate;\n        var insertBefore = $$$config.insertBefore;\n        var insertInContainerBefore = $$$config.insertInContainerBefore;\n        var removeChild = $$$config.removeChild;\n        var removeChildFromContainer = $$$config.removeChildFromContainer;\n        var resetTextContent = $$$config.resetTextContent;\n        var hideInstance = $$$config.hideInstance;\n        var hideTextInstance = $$$config.hideTextInstance;\n        var unhideInstance = $$$config.unhideInstance;\n        var unhideTextInstance = $$$config.unhideTextInstance;\n        var clearContainer = $$$config.clearContainer; // -------------------\n        //     Persistence\n        //     (optional)\n        // -------------------\n        var cloneInstance = $$$config.cloneInstance;\n        var createContainerChildSet = $$$config.createContainerChildSet;\n        var appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet;\n        var finalizeContainerChildren = $$$config.finalizeContainerChildren;\n        var replaceContainerChildren = $$$config.replaceContainerChildren;\n        var cloneHiddenInstance = $$$config.cloneHiddenInstance;\n        var cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance; // -------------------\n        //     Hydration\n        //     (optional)\n        // -------------------\n        var isSuspenseInstancePending = $$$config.isSuspenseInstancePending;\n        var isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback;\n        var getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails;\n        var registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry;\n        var canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker;\n        var isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching;\n        var getNextHydratableSibling = $$$config.getNextHydratableSibling;\n        var getFirstHydratableChild = $$$config.getFirstHydratableChild;\n        var getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer;\n        var getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance;\n        var canHydrateInstance = $$$config.canHydrateInstance;\n        var canHydrateTextInstance = $$$config.canHydrateTextInstance;\n        var canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance;\n        var hydrateInstance = $$$config.hydrateInstance;\n        var hydrateTextInstance = $$$config.hydrateTextInstance;\n        var hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance;\n        var getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance;\n        var commitHydratedContainer = $$$config.commitHydratedContainer;\n        var commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance;\n        var clearSuspenseBoundary = $$$config.clearSuspenseBoundary;\n        var clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer;\n        var shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances;\n        var diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings;\n        var diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings;\n        var describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings;\n        var validateHydratableInstance = $$$config.validateHydratableInstance;\n        var validateHydratableTextInstance = $$$config.validateHydratableTextInstance; // -------------------\n        //     Resources\n        //     (optional)\n        // -------------------\n        // eslint-disable-line no-undef\n        var supportsResources = $$$config.supportsResources;\n        var isHostHoistableType = $$$config.isHostHoistableType;\n        var getHoistableRoot = $$$config.getHoistableRoot;\n        var getResource = $$$config.getResource;\n        var acquireResource = $$$config.acquireResource;\n        var releaseResource = $$$config.releaseResource;\n        var hydrateHoistable = $$$config.hydrateHoistable;\n        var mountHoistable = $$$config.mountHoistable;\n        var unmountHoistable = $$$config.unmountHoistable;\n        var createHoistableInstance = $$$config.createHoistableInstance;\n        var prepareToCommitHoistables = $$$config.prepareToCommitHoistables;\n        var mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit;\n        var preloadResource = $$$config.preloadResource;\n        var suspendResource = $$$config.suspendResource; // -------------------\n        //     Singletons\n        //     (optional)\n        // -------------------\n        var supportsSingletons = $$$config.supportsSingletons;\n        var resolveSingletonInstance = $$$config.resolveSingletonInstance;\n        var clearSingleton = $$$config.clearSingleton;\n        var acquireSingletonInstance = $$$config.acquireSingletonInstance;\n        var releaseSingletonInstance = $$$config.releaseSingletonInstance;\n        var isHostSingletonType = $$$config.isHostSingletonType;\n        var valueStack = [];\n        var fiberStack;\n        {\n            fiberStack = [];\n        }\n        var index = -1;\n        function createCursor(defaultValue) {\n            return {\n                current: defaultValue\n            };\n        }\n        function pop(cursor, fiber) {\n            if (index < 0) {\n                {\n                    error('Unexpected pop.');\n                }\n                return;\n            }\n            {\n                if (fiber !== fiberStack[index]) {\n                    error('Unexpected Fiber popped.');\n                }\n            }\n            cursor.current = valueStack[index];\n            valueStack[index] = null;\n            {\n                fiberStack[index] = null;\n            }\n            index--;\n        }\n        function push(cursor, value, fiber) {\n            index++;\n            valueStack[index] = cursor.current;\n            {\n                fiberStack[index] = fiber;\n            }\n            cursor.current = value;\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function hasContextChanged() {\n            {\n                return false;\n            }\n        }\n        function isContextProvider(type) {\n            {\n                return false;\n            }\n        }\n        function processChildContext(fiber, type, parentContext) {\n            {\n                return parentContext;\n            }\n        }\n        function findCurrentUnmaskedContext(fiber) {\n            {\n                return emptyContextObject;\n            }\n        }\n        // We use the existence of the state object as an indicator that the component\n        // is hidden.\n        var OffscreenVisible = /*                     */ 1;\n        var OffscreenDetached = /*                    */ 2;\n        var OffscreenPassiveEffectsConnected = /*     */ 4;\n        function isOffscreenManual(offscreenFiber) {\n            return offscreenFiber.memoizedProps !== null && offscreenFiber.memoizedProps.mode === 'manual';\n        }\n        var NoMode = /*                         */ 0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n        var ConcurrentMode = /*                 */ 1;\n        var ProfileMode = /*                    */ 2;\n        var StrictLegacyMode = /*               */ 8;\n        var StrictEffectsMode = /*              */ 16;\n        var NoStrictPassiveEffectsMode = /*     */ 64;\n        // TODO: This is pretty well supported by browsers. Maybe we can drop it.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log$1 = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log$1(asUint) / LN2 | 0) | 0;\n        }\n        // If those values are changed that package should be rebuilt and redeployed.\n        var TotalLanes = 31;\n        var NoLanes = /*                        */ 0;\n        var NoLane = /*                          */ 0;\n        var SyncHydrationLane = /*               */ 1;\n        var SyncLane = /*                        */ 2;\n        var SyncLaneIndex = 1;\n        var InputContinuousHydrationLane = /*    */ 4;\n        var InputContinuousLane = /*             */ 8;\n        var DefaultHydrationLane = /*            */ 16;\n        var DefaultLane = /*                     */ 32;\n        var SyncUpdateLanes = SyncLane | InputContinuousLane | DefaultLane;\n        var TransitionHydrationLane = /*                */ 64;\n        var TransitionLanes = /*                       */ 4194176;\n        var TransitionLane1 = /*                        */ 128;\n        var TransitionLane2 = /*                        */ 256;\n        var TransitionLane3 = /*                        */ 512;\n        var TransitionLane4 = /*                        */ 1024;\n        var TransitionLane5 = /*                        */ 2048;\n        var TransitionLane6 = /*                        */ 4096;\n        var TransitionLane7 = /*                        */ 8192;\n        var TransitionLane8 = /*                        */ 16384;\n        var TransitionLane9 = /*                        */ 32768;\n        var TransitionLane10 = /*                       */ 65536;\n        var TransitionLane11 = /*                       */ 131072;\n        var TransitionLane12 = /*                       */ 262144;\n        var TransitionLane13 = /*                       */ 524288;\n        var TransitionLane14 = /*                       */ 1048576;\n        var TransitionLane15 = /*                       */ 2097152;\n        var RetryLanes = /*                            */ 62914560;\n        var RetryLane1 = /*                             */ 4194304;\n        var RetryLane2 = /*                             */ 8388608;\n        var RetryLane3 = /*                             */ 16777216;\n        var RetryLane4 = /*                             */ 33554432;\n        var SomeRetryLane = RetryLane1;\n        var SelectiveHydrationLane = /*          */ 67108864;\n        var NonIdleLanes = /*                          */ 134217727;\n        var IdleHydrationLane = /*               */ 134217728;\n        var IdleLane = /*                        */ 268435456;\n        var OffscreenLane = /*                   */ 536870912;\n        var DeferredLane = /*                    */ 1073741824; // Any lane that might schedule an update. This is used to detect infinite\n        // update loops, so it doesn't include hydration lanes or retries.\n        var UpdateLanes = SyncLane | InputContinuousLane | DefaultLane | TransitionLanes; // This function is used for the experimental timeline (react-devtools-timeline)\n        // It should be kept in sync with the Lanes values above.\n        function getLabelForLane(lane) {\n            {\n                if (lane & SyncHydrationLane) {\n                    return 'SyncHydrationLane';\n                }\n                if (lane & SyncLane) {\n                    return 'Sync';\n                }\n                if (lane & InputContinuousHydrationLane) {\n                    return 'InputContinuousHydration';\n                }\n                if (lane & InputContinuousLane) {\n                    return 'InputContinuous';\n                }\n                if (lane & DefaultHydrationLane) {\n                    return 'DefaultHydration';\n                }\n                if (lane & DefaultLane) {\n                    return 'Default';\n                }\n                if (lane & TransitionHydrationLane) {\n                    return 'TransitionHydration';\n                }\n                if (lane & TransitionLanes) {\n                    return 'Transition';\n                }\n                if (lane & RetryLanes) {\n                    return 'Retry';\n                }\n                if (lane & SelectiveHydrationLane) {\n                    return 'SelectiveHydration';\n                }\n                if (lane & IdleHydrationLane) {\n                    return 'IdleHydration';\n                }\n                if (lane & IdleLane) {\n                    return 'Idle';\n                }\n                if (lane & OffscreenLane) {\n                    return 'Offscreen';\n                }\n                if (lane & DeferredLane) {\n                    return 'Deferred';\n                }\n            }\n        }\n        var NoTimestamp = -1;\n        var nextTransitionLane = TransitionLane1;\n        var nextRetryLane = RetryLane1;\n        function getHighestPriorityLanes(lanes) {\n            {\n                var pendingSyncLanes = lanes & SyncUpdateLanes;\n                if (pendingSyncLanes !== 0) {\n                    return pendingSyncLanes;\n                }\n            }\n            switch(getHighestPriorityLane(lanes)){\n                case SyncHydrationLane:\n                    return SyncHydrationLane;\n                case SyncLane:\n                    return SyncLane;\n                case InputContinuousHydrationLane:\n                    return InputContinuousHydrationLane;\n                case InputContinuousLane:\n                    return InputContinuousLane;\n                case DefaultHydrationLane:\n                    return DefaultHydrationLane;\n                case DefaultLane:\n                    return DefaultLane;\n                case TransitionHydrationLane:\n                    return TransitionHydrationLane;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                    return lanes & TransitionLanes;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                    return lanes & RetryLanes;\n                case SelectiveHydrationLane:\n                    return SelectiveHydrationLane;\n                case IdleHydrationLane:\n                    return IdleHydrationLane;\n                case IdleLane:\n                    return IdleLane;\n                case OffscreenLane:\n                    return OffscreenLane;\n                case DeferredLane:\n                    // This shouldn't be reachable because deferred work is always entangled\n                    // with something else.\n                    return NoLanes;\n                default:\n                    {\n                        error('Should have found matching lanes. This is a bug in React.');\n                    }\n                    return lanes;\n            }\n        }\n        function getNextLanes(root, wipLanes) {\n            // Early bailout if there's no pending work left.\n            var pendingLanes = root.pendingLanes;\n            if (pendingLanes === NoLanes) {\n                return NoLanes;\n            }\n            var nextLanes = NoLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n            // even if the work is suspended.\n            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n            if (nonIdlePendingLanes !== NoLanes) {\n                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n                if (nonIdleUnblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n                } else {\n                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n                    if (nonIdlePingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n                    }\n                }\n            } else {\n                // The only remaining work is Idle.\n                var unblockedLanes = pendingLanes & ~suspendedLanes;\n                if (unblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(unblockedLanes);\n                } else {\n                    if (pingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(pingedLanes);\n                    }\n                }\n            }\n            if (nextLanes === NoLanes) {\n                // This should only be reachable if we're suspended\n                // TODO: Consider warning in this path if a fallback timer is not scheduled.\n                return NoLanes;\n            } // If we're already in the middle of a render, switching lanes will interrupt\n            // it and we'll lose our progress. We should only do this if the new lanes are\n            // higher priority.\n            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n            // bother waiting until the root is complete.\n            (wipLanes & suspendedLanes) === NoLanes) {\n                var nextLane = getHighestPriorityLane(nextLanes);\n                var wipLane = getHighestPriorityLane(wipLanes);\n                if (// one. This works because the bits decrease in priority as you go left.\n                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n                // only difference between default updates and transition updates is that\n                // default updates do not support refresh transitions.\n                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n                    // Keep working on the existing in-progress tree. Do not interrupt.\n                    return wipLanes;\n                }\n            }\n            return nextLanes;\n        }\n        function getEntangledLanes(root, renderLanes) {\n            var entangledLanes = renderLanes;\n            if ((entangledLanes & InputContinuousLane) !== NoLanes) {\n                // When updates are sync by default, we entangle continuous priority updates\n                // and default updates, so they render in the same batch. The only reason\n                // they use separate lanes is because continuous updates should interrupt\n                // transitions, but default updates should not.\n                entangledLanes |= entangledLanes & DefaultLane;\n            } // Check for entangled lanes and add them to the batch.\n            //\n            // A lane is said to be entangled with another when it's not allowed to render\n            // in a batch that does not also include the other lane. Typically we do this\n            // when multiple updates have the same source, and we only want to respond to\n            // the most recent event from that source.\n            //\n            // Note that we apply entanglements *after* checking for partial work above.\n            // This means that if a lane is entangled during an interleaved event while\n            // it's already rendering, we won't interrupt it. This is intentional, since\n            // entanglement is usually \"best effort\": we'll try our best to render the\n            // lanes in the same batch, but it's not worth throwing out partially\n            // completed work in order to do it.\n            // TODO: Reconsider this. The counter-argument is that the partial work\n            // represents an intermediate state, which we don't want to show to the user.\n            // And by spending extra time finishing it, we're increasing the amount of\n            // time it takes to show the final state, which is what they are actually\n            // waiting for.\n            //\n            // For those exceptions where entanglement is semantically important,\n            // we should ensure that there is no partial work at the\n            // time we apply the entanglement.\n            var allEntangledLanes = root.entangledLanes;\n            if (allEntangledLanes !== NoLanes) {\n                var entanglements = root.entanglements;\n                var lanes = entangledLanes & allEntangledLanes;\n                while(lanes > 0){\n                    var index = pickArbitraryLaneIndex(lanes);\n                    var lane = 1 << index;\n                    entangledLanes |= entanglements[index];\n                    lanes &= ~lane;\n                }\n            }\n            return entangledLanes;\n        }\n        function computeExpirationTime(lane, currentTime) {\n            switch(lane){\n                case SyncHydrationLane:\n                case SyncLane:\n                case InputContinuousHydrationLane:\n                case InputContinuousLane:\n                    // User interactions should expire slightly more quickly.\n                    //\n                    // NOTE: This is set to the corresponding constant as in Scheduler.js.\n                    // When we made it larger, a product metric in www regressed, suggesting\n                    // there's a user interaction that's being starved by a series of\n                    // synchronous updates. If that theory is correct, the proper solution is\n                    // to fix the starvation. However, this scenario supports the idea that\n                    // expiration times are an important safeguard when starvation\n                    // does happen.\n                    return currentTime + syncLaneExpirationMs;\n                case DefaultHydrationLane:\n                case DefaultLane:\n                case TransitionHydrationLane:\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                    return currentTime + transitionLaneExpirationMs;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                    // TODO: Retries should be allowed to expire if they are CPU bound for\n                    // too long, but when I made this change it caused a spike in browser\n                    // crashes. There must be some other underlying bug; not super urgent but\n                    // ideally should figure out why and fix it. Unfortunately we don't have\n                    // a repro for the crashes, only detected via production metrics.\n                    return NoTimestamp;\n                case SelectiveHydrationLane:\n                case IdleHydrationLane:\n                case IdleLane:\n                case OffscreenLane:\n                case DeferredLane:\n                    // Anything idle priority or lower should never expire.\n                    return NoTimestamp;\n                default:\n                    {\n                        error('Should have found matching lanes. This is a bug in React.');\n                    }\n                    return NoTimestamp;\n            }\n        }\n        function markStarvedLanesAsExpired(root, currentTime) {\n            // TODO: This gets called every time we yield. We can optimize by storing\n            // the earliest expiration time on the root. Then use that to quickly bail out\n            // of this function.\n            var pendingLanes = root.pendingLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes;\n            var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n            // expiration time. If so, we'll assume the update is being starved and mark\n            // it as expired to force it to finish.\n            // TODO: We should be able to replace this with upgradePendingLanesToSync\n            //\n            // We exclude retry lanes because those must always be time sliced, in order\n            // to unwrap uncached promises.\n            // TODO: Write a test for this\n            var lanes = pendingLanes & ~RetryLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var expirationTime = expirationTimes[index];\n                if (expirationTime === NoTimestamp) {\n                    // Found a pending lane with no expiration time. If it's not suspended, or\n                    // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n                    // using the current time.\n                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n                        // Assumes timestamps are monotonically increasing.\n                        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n                    }\n                } else if (expirationTime <= currentTime) {\n                    // This lane expired\n                    root.expiredLanes |= lane;\n                }\n                lanes &= ~lane;\n            }\n        } // This returns the highest priority pending lanes regardless of whether they\n        // are suspended.\n        function getHighestPriorityPendingLanes(root) {\n            return getHighestPriorityLanes(root.pendingLanes);\n        }\n        function getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes) {\n            if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {\n                // The error recovery mechanism is disabled until these lanes are cleared.\n                return NoLanes;\n            }\n            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n            if (everythingButOffscreen !== NoLanes) {\n                return everythingButOffscreen;\n            }\n            if (everythingButOffscreen & OffscreenLane) {\n                return OffscreenLane;\n            }\n            return NoLanes;\n        }\n        function includesSyncLane(lanes) {\n            return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;\n        }\n        function includesNonIdleWork(lanes) {\n            return (lanes & NonIdleLanes) !== NoLanes;\n        }\n        function includesOnlyRetries(lanes) {\n            return (lanes & RetryLanes) === lanes;\n        }\n        function includesOnlyNonUrgentLanes(lanes) {\n            // TODO: Should hydration lanes be included here? This function is only\n            // used in `updateDeferredValueImpl`.\n            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n            return (lanes & UrgentLanes) === NoLanes;\n        }\n        function includesOnlyTransitions(lanes) {\n            return (lanes & TransitionLanes) === lanes;\n        }\n        function includesBlockingLane(root, lanes) {\n            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n            return (lanes & SyncDefaultLanes) !== NoLanes;\n        }\n        function includesExpiredLane(root, lanes) {\n            // This is a separate check from includesBlockingLane because a lane can\n            // expire after a render has already started.\n            return (lanes & root.expiredLanes) !== NoLanes;\n        }\n        function isTransitionLane(lane) {\n            return (lane & TransitionLanes) !== NoLanes;\n        }\n        function claimNextTransitionLane() {\n            // Cycle through the lanes, assigning each new transition to the next lane.\n            // In most cases, this means every transition gets its own lane, until we\n            // run out of lanes and cycle back to the beginning.\n            var lane = nextTransitionLane;\n            nextTransitionLane <<= 1;\n            if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n                nextTransitionLane = TransitionLane1;\n            }\n            return lane;\n        }\n        function claimNextRetryLane() {\n            var lane = nextRetryLane;\n            nextRetryLane <<= 1;\n            if ((nextRetryLane & RetryLanes) === NoLanes) {\n                nextRetryLane = RetryLane1;\n            }\n            return lane;\n        }\n        function getHighestPriorityLane(lanes) {\n            return lanes & -lanes;\n        }\n        function pickArbitraryLane(lanes) {\n            // This wrapper function gets inlined. Only exists so to communicate that it\n            // doesn't matter which bit is selected; you can pick any bit without\n            // affecting the algorithms where its used. Here I'm using\n            // getHighestPriorityLane because it requires the fewest operations.\n            return getHighestPriorityLane(lanes);\n        }\n        function pickArbitraryLaneIndex(lanes) {\n            return 31 - clz32(lanes);\n        }\n        function laneToIndex(lane) {\n            return pickArbitraryLaneIndex(lane);\n        }\n        function includesSomeLane(a, b) {\n            return (a & b) !== NoLanes;\n        }\n        function isSubsetOfLanes(set, subset) {\n            return (set & subset) === subset;\n        }\n        function mergeLanes(a, b) {\n            return a | b;\n        }\n        function removeLanes(set, subset) {\n            return set & ~subset;\n        }\n        function intersectLanes(a, b) {\n            return a & b;\n        } // Seems redundant, but it changes the type from a single lane (used for\n        // updates) to a group of lanes (used for flushing work).\n        function laneToLanes(lane) {\n            return lane;\n        }\n        function higherPriorityLane(a, b) {\n            // This works because the bit ranges decrease in priority as you go left.\n            return a !== NoLane && a < b ? a : b;\n        }\n        function createLaneMap(initial) {\n            // Intentionally pushing one by one.\n            // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n            var laneMap = [];\n            for(var i = 0; i < TotalLanes; i++){\n                laneMap.push(initial);\n            }\n            return laneMap;\n        }\n        function markRootUpdated$1(root, updateLane) {\n            root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n            // could unblock them. Clear the suspended lanes so that we can try rendering\n            // them again.\n            //\n            // TODO: We really only need to unsuspend only lanes that are in the\n            // `subtreeLanes` of the updated fiber, or the update lanes of the return\n            // path. This would exclude suspended updates in an unrelated sibling tree,\n            // since there's no way for this update to unblock it.\n            //\n            // We don't do this if the incoming update is idle, because we never process\n            // idle updates until after all the regular updates have finished; there's no\n            // way it could unblock a transition.\n            if (updateLane !== IdleLane) {\n                root.suspendedLanes = NoLanes;\n                root.pingedLanes = NoLanes;\n            }\n        }\n        function markRootSuspended$1(root, suspendedLanes, spawnedLane) {\n            root.suspendedLanes |= suspendedLanes;\n            root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n            var expirationTimes = root.expirationTimes;\n            var lanes = suspendedLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n            if (spawnedLane !== NoLane) {\n                markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n            }\n        }\n        function markRootPinged$1(root, pingedLanes) {\n            root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        }\n        function markRootFinished(root, remainingLanes, spawnedLane) {\n            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n            root.pendingLanes = remainingLanes; // Let's try everything again\n            root.suspendedLanes = NoLanes;\n            root.pingedLanes = NoLanes;\n            root.expiredLanes &= remainingLanes;\n            root.entangledLanes &= remainingLanes;\n            root.errorRecoveryDisabledLanes &= remainingLanes;\n            root.shellSuspendCounter = 0;\n            var entanglements = root.entanglements;\n            var expirationTimes = root.expirationTimes;\n            var hiddenUpdates = root.hiddenUpdates; // Clear the lanes that no longer have pending work\n            var lanes = noLongerPendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                entanglements[index] = NoLanes;\n                expirationTimes[index] = NoTimestamp;\n                var hiddenUpdatesForLane = hiddenUpdates[index];\n                if (hiddenUpdatesForLane !== null) {\n                    hiddenUpdates[index] = null; // \"Hidden\" updates are updates that were made to a hidden component. They\n                    // have special logic associated with them because they may be entangled\n                    // with updates that occur outside that tree. But once the outer tree\n                    // commits, they behave like regular updates.\n                    for(var i = 0; i < hiddenUpdatesForLane.length; i++){\n                        var update = hiddenUpdatesForLane[i];\n                        if (update !== null) {\n                            update.lane &= ~OffscreenLane;\n                        }\n                    }\n                }\n                lanes &= ~lane;\n            }\n            if (spawnedLane !== NoLane) {\n                markSpawnedDeferredLane(root, spawnedLane, // to entangle the spawned task with the parent task.\n                NoLanes);\n            }\n        }\n        function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n            // This render spawned a deferred task. Mark it as pending.\n            root.pendingLanes |= spawnedLane;\n            root.suspendedLanes &= ~spawnedLane; // Entangle the spawned lane with the DeferredLane bit so that we know it\n            // was the result of another render. This lets us avoid a useDeferredValue\n            // waterfall — only the first level will defer.\n            var spawnedLaneIndex = laneToIndex(spawnedLane);\n            root.entangledLanes |= spawnedLane;\n            root.entanglements[spawnedLaneIndex] |= DeferredLane | // If the parent render task suspended, we must also entangle those lanes\n            // with the spawned task, so that the deferred task includes all the same\n            // updates that the parent task did. We can exclude any lane that is not\n            // used for updates (e.g. Offscreen).\n            entangledLanes & UpdateLanes;\n        }\n        function markRootEntangled(root, entangledLanes) {\n            // In addition to entangling each of the given lanes with each other, we also\n            // have to consider _transitive_ entanglements. For each lane that is already\n            // entangled with *any* of the given lanes, that lane is now transitively\n            // entangled with *all* the given lanes.\n            //\n            // Translated: If C is entangled with A, then entangling A with B also\n            // entangles C with B.\n            //\n            // If this is hard to grasp, it might help to intentionally break this\n            // function and look at the tests that fail in ReactTransition-test.js. Try\n            // commenting out one of the conditions below.\n            var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n            var entanglements = root.entanglements;\n            var lanes = rootEntangledLanes;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                if (lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n                entanglements[index] & entangledLanes) {\n                    entanglements[index] |= entangledLanes;\n                }\n                lanes &= ~lane;\n            }\n        }\n        function upgradePendingLaneToSync(root, lane) {\n            // Since we're upgrading the priority of the given lane, there is now pending\n            // sync work.\n            root.pendingLanes |= SyncLane; // Entangle the sync lane with the lane we're upgrading. This means SyncLane\n            // will not be allowed to finish without also finishing the given lane.\n            root.entangledLanes |= SyncLane;\n            root.entanglements[SyncLaneIndex] |= lane;\n        }\n        function upgradePendingLanesToSync(root, lanesToUpgrade) {\n            // Same as upgradePendingLaneToSync but accepts multiple lanes, so it's a\n            // bit slower.\n            root.pendingLanes |= SyncLane;\n            root.entangledLanes |= SyncLane;\n            var lanes = lanesToUpgrade;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                root.entanglements[SyncLaneIndex] |= lane;\n                lanes &= ~lane;\n            }\n        }\n        function markHiddenUpdate(root, update, lane) {\n            var index = laneToIndex(lane);\n            var hiddenUpdates = root.hiddenUpdates;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (hiddenUpdatesForLane === null) {\n                hiddenUpdates[index] = [\n                    update\n                ];\n            } else {\n                hiddenUpdatesForLane.push(update);\n            }\n            update.lane = lane | OffscreenLane;\n        }\n        function getBumpedLaneForHydration(root, renderLanes) {\n            var renderLane = getHighestPriorityLane(renderLanes);\n            var lane;\n            if ((renderLane & SyncUpdateLanes) !== NoLane) {\n                lane = SyncHydrationLane;\n            } else {\n                switch(renderLane){\n                    case SyncLane:\n                        lane = SyncHydrationLane;\n                        break;\n                    case InputContinuousLane:\n                        lane = InputContinuousHydrationLane;\n                        break;\n                    case DefaultLane:\n                        lane = DefaultHydrationLane;\n                        break;\n                    case TransitionLane1:\n                    case TransitionLane2:\n                    case TransitionLane3:\n                    case TransitionLane4:\n                    case TransitionLane5:\n                    case TransitionLane6:\n                    case TransitionLane7:\n                    case TransitionLane8:\n                    case TransitionLane9:\n                    case TransitionLane10:\n                    case TransitionLane11:\n                    case TransitionLane12:\n                    case TransitionLane13:\n                    case TransitionLane14:\n                    case TransitionLane15:\n                    case RetryLane1:\n                    case RetryLane2:\n                    case RetryLane3:\n                    case RetryLane4:\n                        lane = TransitionHydrationLane;\n                        break;\n                    case IdleLane:\n                        lane = IdleHydrationLane;\n                        break;\n                    default:\n                        // Everything else is already either a hydration lane, or shouldn't\n                        // be retried at a hydration lane.\n                        lane = NoLane;\n                        break;\n                }\n            } // Check if the lane we chose is suspended. If so, that indicates that we\n            // already attempted and failed to hydrate at that level. Also check if we're\n            // already rendering that lane, which is rare but could happen.\n            if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n                // Give up trying to hydrate and fall back to client render.\n                return NoLane;\n            }\n            return lane;\n        }\n        function addFiberToLanesMap(root, fiber, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                updaters.add(fiber);\n                lanes &= ~lane;\n            }\n        }\n        function movePendingFibersToMemoized(root, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            var memoizedUpdaters = root.memoizedUpdaters;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                if (updaters.size > 0) {\n                    updaters.forEach(function(fiber) {\n                        var alternate = fiber.alternate;\n                        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                            memoizedUpdaters.add(fiber);\n                        }\n                    });\n                    updaters.clear();\n                }\n                lanes &= ~lane;\n            }\n        }\n        function getTransitionsForLanes(root, lanes) {\n            {\n                return null;\n            }\n        }\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        function higherEventPriority(a, b) {\n            return a !== 0 && a < b ? a : b;\n        }\n        function lowerEventPriority(a, b) {\n            return a === 0 || a > b ? a : b;\n        }\n        function isHigherEventPriority(a, b) {\n            return a !== 0 && a < b;\n        }\n        function eventPriorityToLane(updatePriority) {\n            return updatePriority;\n        }\n        function lanesToEventPriority(lanes) {\n            var lane = getHighestPriorityLane(lanes);\n            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n                return DiscreteEventPriority;\n            }\n            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n                return ContinuousEventPriority;\n            }\n            if (includesNonIdleWork(lane)) {\n                return DefaultEventPriority;\n            }\n            return IdleEventPriority;\n        }\n        // This module only exists as an ESM wrapper around the external CommonJS\n        var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;\n        var cancelCallback$1 = Scheduler.unstable_cancelCallback;\n        var shouldYield = Scheduler.unstable_shouldYield;\n        var requestPaint = Scheduler.unstable_requestPaint;\n        var now$1 = Scheduler.unstable_now;\n        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n        var NormalPriority$1 = Scheduler.unstable_NormalPriority;\n        var IdlePriority = Scheduler.unstable_IdlePriority; // this doesn't actually exist on the scheduler, but it *does*\n        // on scheduler/unstable_mock, which we'll need for internal testing\n        var log = Scheduler.log;\n        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n        var rendererID = null;\n        var injectedHook = null;\n        var injectedProfilingHooks = null;\n        var hasLoggedError = false;\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\n        function injectInternals(internals) {\n            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n                // No DevTools\n                return false;\n            }\n            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n            if (hook.isDisabled) {\n                // This isn't a real property on the hook, but it can be set to opt out\n                // of DevTools integration and associated warnings and logs.\n                // https://github.com/facebook/react/issues/3877\n                return true;\n            }\n            if (!hook.supportsFiber) {\n                {\n                    error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://react.dev/link/react-devtools');\n                }\n                return true;\n            }\n            try {\n                if (enableSchedulingProfiler) {\n                    // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n                    // This gives DevTools a way to feature detect that isn't tied to version number\n                    // (since profiling and timeline are controlled by different feature flags).\n                    internals = assign({}, internals, {\n                        getLaneLabelMap: getLaneLabelMap,\n                        injectProfilingHooks: injectProfilingHooks\n                    });\n                }\n                rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n                injectedHook = hook;\n            } catch (err) {\n                // Catch all errors because it is unsafe to throw during initialization.\n                {\n                    error('React instrumentation encountered an error: %s.', err);\n                }\n            }\n            if (hook.checkDCE) {\n                // This is the real DevTools.\n                return true;\n            } else {\n                // This is likely a hook installed by Fast Refresh runtime.\n                return false;\n            }\n        }\n        function onScheduleRoot(root, children) {\n            {\n                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {\n                    try {\n                        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n                    } catch (err) {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitRoot$1(root, eventPriority) {\n            if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {\n                try {\n                    var didError = (root.current.flags & DidCapture) === DidCapture;\n                    if (enableProfilerTimer) {\n                        var schedulerPriority;\n                        switch(eventPriority){\n                            case DiscreteEventPriority:\n                                schedulerPriority = ImmediatePriority;\n                                break;\n                            case ContinuousEventPriority:\n                                schedulerPriority = UserBlockingPriority;\n                                break;\n                            case DefaultEventPriority:\n                                schedulerPriority = NormalPriority$1;\n                                break;\n                            case IdleEventPriority:\n                                schedulerPriority = IdlePriority;\n                                break;\n                            default:\n                                schedulerPriority = NormalPriority$1;\n                                break;\n                        }\n                        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n                    }\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onPostCommitRoot(root) {\n            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {\n                try {\n                    injectedHook.onPostCommitFiberRoot(rendererID, root);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitUnmount(fiber) {\n            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {\n                try {\n                    injectedHook.onCommitFiberUnmount(rendererID, fiber);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function setIsStrictModeForDevtools(newIsStrictMode) {\n            {\n                if (typeof log === 'function') {\n                    // We're in a test because Scheduler.log only exists\n                    // in SchedulerMock. To reduce the noise in strict mode tests,\n                    // suppress warnings and disable scheduler yielding during the double render\n                    unstable_setDisableYieldValue(newIsStrictMode);\n                    setSuppressWarning(newIsStrictMode);\n                }\n                if (injectedHook && typeof injectedHook.setStrictMode === 'function') {\n                    try {\n                        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n                    } catch (err) {\n                        {\n                            if (!hasLoggedError) {\n                                hasLoggedError = true;\n                                error('React instrumentation encountered an error: %s', err);\n                            }\n                        }\n                    }\n                }\n            }\n        } // Profiler API hooks\n        function injectProfilingHooks(profilingHooks) {\n            injectedProfilingHooks = profilingHooks;\n        }\n        function getLaneLabelMap() {\n            {\n                var map = new Map();\n                var lane = 1;\n                for(var index = 0; index < TotalLanes; index++){\n                    var label = getLabelForLane(lane);\n                    map.set(lane, label);\n                    lane *= 2;\n                }\n                return map;\n            }\n        }\n        function markCommitStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {\n                    injectedProfilingHooks.markCommitStarted(lanes);\n                }\n            }\n        }\n        function markCommitStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {\n                    injectedProfilingHooks.markCommitStopped();\n                }\n            }\n        }\n        function markComponentRenderStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {\n                    injectedProfilingHooks.markComponentRenderStarted(fiber);\n                }\n            }\n        }\n        function markComponentRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {\n                    injectedProfilingHooks.markComponentRenderStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentErrored(fiber, thrownValue, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {\n                    injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n                }\n            }\n        }\n        function markComponentSuspended(fiber, wakeable, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {\n                    injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {\n                    injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {\n                    injectedProfilingHooks.markLayoutEffectsStopped();\n                }\n            }\n        }\n        function markPassiveEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {\n                    injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                }\n            }\n        }\n        function markPassiveEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {\n                    injectedProfilingHooks.markPassiveEffectsStopped();\n                }\n            }\n        }\n        function markRenderStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {\n                    injectedProfilingHooks.markRenderStarted(lanes);\n                }\n            }\n        }\n        function markRenderYielded() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {\n                    injectedProfilingHooks.markRenderYielded();\n                }\n            }\n        }\n        function markRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {\n                    injectedProfilingHooks.markRenderStopped();\n                }\n            }\n        }\n        function markRenderScheduled(lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {\n                    injectedProfilingHooks.markRenderScheduled(lane);\n                }\n            }\n        }\n        function markForceUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {\n                    injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        function markStateUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {\n                    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === 'function' ? Object.is : is;\n        // This is imported by the event replaying implementation in React DOM. It's\n        // in a separate file to break a circular dependency between the renderer and\n        // the reconciler.\n        function isRootDehydrated(root) {\n            var currentState = root.current.memoizedState;\n            return currentState.isDehydrated;\n        }\n        var CapturedStacks = new WeakMap();\n        function createCapturedValueAtFiber(value, source) {\n            // If the value is an error, call this function immediately after it is thrown\n            // so the stack is accurate.\n            var stack;\n            if (typeof value === 'object' && value !== null) {\n                var capturedStack = CapturedStacks.get(value);\n                if (typeof capturedStack === 'string') {\n                    stack = capturedStack;\n                } else {\n                    stack = getStackByFiberInDevAndProd(source);\n                    CapturedStacks.set(value, stack);\n                }\n            } else {\n                stack = getStackByFiberInDevAndProd(source);\n            }\n            return {\n                value: value,\n                source: source,\n                stack: stack\n            };\n        }\n        function createCapturedValueFromError(value, stack) {\n            if (typeof stack === 'string') {\n                CapturedStacks.set(value, stack);\n            }\n            return {\n                value: value,\n                source: null,\n                stack: stack\n            };\n        }\n        // Intentionally not using it yet to derisk the initial implementation, because\n        // the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n        // rather the ids be wrong than crash the whole reconciler.\n        var forkStack = [];\n        var forkStackIndex = 0;\n        var treeForkProvider = null;\n        var treeForkCount = 0;\n        var idStack = [];\n        var idStackIndex = 0;\n        var treeContextProvider = null;\n        var treeContextId = 1;\n        var treeContextOverflow = '';\n        function isForkedChild(workInProgress) {\n            warnIfNotHydrating();\n            return (workInProgress.flags & Forked) !== NoFlags$1;\n        }\n        function getForksAtLevel(workInProgress) {\n            warnIfNotHydrating();\n            return treeForkCount;\n        }\n        function getTreeId() {\n            var overflow = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeFork(workInProgress, totalChildren) {\n            // This is called right after we reconcile an array (or iterator) of child\n            // fibers, because that's the only place where we know how many children in\n            // the whole set without doing extra work later, or storing addtional\n            // information on the fiber.\n            //\n            // That's why this function is separate from pushTreeId — it's called during\n            // the render phase of the fork parent, not the child, which is where we push\n            // the other context values.\n            //\n            // In the Fizz implementation this is much simpler because the child is\n            // rendered in the same callstack as the parent.\n            //\n            // It might be better to just add a `forks` field to the Fiber type. It would\n            // make this module simpler.\n            warnIfNotHydrating();\n            forkStack[forkStackIndex++] = treeForkCount;\n            forkStack[forkStackIndex++] = treeForkProvider;\n            treeForkProvider = workInProgress;\n            treeForkCount = totalChildren;\n        }\n        function pushTreeId(workInProgress, totalChildren, index) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextProvider = workInProgress;\n            var baseIdWithLeadingBit = treeContextId;\n            var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                treeContextId = 1 << restOfLength | id;\n                treeContextOverflow = overflow;\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                treeContextId = 1 << length | _id;\n                treeContextOverflow = _overflow;\n            }\n        }\n        function pushMaterializedTreeId(workInProgress) {\n            warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n            // in its children.\n            var returnFiber = workInProgress.return;\n            if (returnFiber !== null) {\n                var numberOfForks = 1;\n                var slotIndex = 0;\n                pushTreeFork(workInProgress, numberOfForks);\n                pushTreeId(workInProgress, numberOfForks, slotIndex);\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        }\n        function popTreeContext(workInProgress) {\n            // Restore the previous values.\n            // This is a bit more complicated than other context-like modules in Fiber\n            // because the same Fiber may appear on the stack multiple times and for\n            // different reasons. We have to keep popping until the work-in-progress is\n            // no longer at the top of the stack.\n            while(workInProgress === treeForkProvider){\n                treeForkProvider = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n                treeForkCount = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n            }\n            while(workInProgress === treeContextProvider){\n                treeContextProvider = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextOverflow = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextId = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n            }\n        }\n        function getSuspendedTreeContext() {\n            warnIfNotHydrating();\n            if (treeContextProvider !== null) {\n                return {\n                    id: treeContextId,\n                    overflow: treeContextOverflow\n                };\n            } else {\n                return null;\n            }\n        }\n        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextId = suspendedContext.id;\n            treeContextOverflow = suspendedContext.overflow;\n            treeContextProvider = workInProgress;\n        }\n        function warnIfNotHydrating() {\n            {\n                if (!getIsHydrating()) {\n                    error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n                }\n            }\n        }\n        var contextStackCursor = createCursor(null);\n        var contextFiberStackCursor = createCursor(null);\n        var rootInstanceStackCursor = createCursor(null); // Represents the nearest host transition provider (in React DOM, a <form />)\n        // NOTE: Since forms cannot be nested, and this feature is only implemented by\n        // React DOM, we don't technically need this to be a stack. It could be a single\n        // module variable instead.\n        var hostTransitionProviderCursor = createCursor(null); // TODO: This should initialize to NotPendingTransition, a constant\n        // imported from the fiber config. However, because of a cycle in the module\n        // graph, that value isn't defined during this module's initialization. I can't\n        // think of a way to work around this without moving that value out of the\n        // fiber config. For now, the \"no provider\" case is handled when reading,\n        // inside useHostTransitionStatus.\n        var HostTransitionContext = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            Provider: null,\n            Consumer: null,\n            _currentValue: null,\n            _currentValue2: null,\n            _threadCount: 0\n        };\n        function requiredContext(c) {\n            {\n                if (c === null) {\n                    error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n                }\n            }\n            return c;\n        }\n        function getRootHostContainer() {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            return rootInstance;\n        }\n        function pushHostContainer(fiber, nextRootInstance) {\n            // Push current root instance onto the stack;\n            // This allows us to reset root when portals are popped.\n            push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n            // However, we can't just call getRootHostContext() and push it because\n            // we'd have a different number of entries on the stack depending on\n            // whether getRootHostContext() throws somewhere in renderer code or not.\n            // So we push an empty value first. This lets us safely unwind on errors.\n            push(contextStackCursor, null, fiber);\n            var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n            pop(contextStackCursor, fiber);\n            push(contextStackCursor, nextRootContext, fiber);\n        }\n        function popHostContainer(fiber) {\n            pop(contextStackCursor, fiber);\n            pop(contextFiberStackCursor, fiber);\n            pop(rootInstanceStackCursor, fiber);\n        }\n        function getHostContext() {\n            var context = requiredContext(contextStackCursor.current);\n            return context;\n        }\n        function pushHostContext(fiber) {\n            {\n                var stateHook = fiber.memoizedState;\n                if (stateHook !== null) {\n                    // Only provide context if this fiber has been upgraded by a host\n                    // transition. We use the same optimization for regular host context below.\n                    push(hostTransitionProviderCursor, fiber, fiber);\n                }\n            }\n            var context = requiredContext(contextStackCursor.current);\n            var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.\n            if (context !== nextContext) {\n                // Track the context and the Fiber that provided it.\n                // This enables us to pop only Fibers that provide unique contexts.\n                push(contextFiberStackCursor, fiber, fiber);\n                push(contextStackCursor, nextContext, fiber);\n            }\n        }\n        function popHostContext(fiber) {\n            if (contextFiberStackCursor.current === fiber) {\n                // Do not pop unless this Fiber provided the current context.\n                // pushHostContext() only pushes Fibers that provide unique contexts.\n                pop(contextStackCursor, fiber);\n                pop(contextFiberStackCursor, fiber);\n            }\n            {\n                if (hostTransitionProviderCursor.current === fiber) {\n                    // Do not pop unless this Fiber provided the current context. This is mostly\n                    // a performance optimization, but conveniently it also prevents a potential\n                    // data race where a host provider is upgraded (i.e. memoizedState becomes\n                    // non-null) during a concurrent event. This is a bit of a flaw in the way\n                    // we upgrade host components, but because we're accounting for it here, it\n                    // should be fine.\n                    pop(hostTransitionProviderCursor, fiber); // When popping the transition provider, we reset the context value back\n                    // to `null`. We can do this because you're not allowd to nest forms. If\n                    // we allowed for multiple nested host transition providers, then we'd\n                    // need to reset this to the parent provider's status.\n                    if (isPrimaryRenderer) {\n                        HostTransitionContext._currentValue = null;\n                    } else {\n                        HostTransitionContext._currentValue2 = null;\n                    }\n                }\n            }\n        }\n        var maxRowLength = 120;\n        var idealDepth = 15;\n        function findNotableNode(node, indent) {\n            if (node.serverProps === undefined && node.serverTail.length === 0 && node.children.length === 1 && node.distanceFromLeaf > 3 && node.distanceFromLeaf > idealDepth - indent) {\n                // This is not an interesting node for contextual purposes so we can skip it.\n                var child = node.children[0];\n                return findNotableNode(child, indent);\n            }\n            return node;\n        }\n        function indentation(indent) {\n            return '  ' + '  '.repeat(indent);\n        }\n        function added(indent) {\n            return '+ ' + '  '.repeat(indent);\n        }\n        function removed(indent) {\n            return '- ' + '  '.repeat(indent);\n        }\n        function describeFiberType(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    return fiber.type;\n                case LazyComponent:\n                    return 'Lazy';\n                case SuspenseComponent:\n                    return 'Suspense';\n                case SuspenseListComponent:\n                    return 'SuspenseList';\n                case FunctionComponent:\n                case SimpleMemoComponent:\n                    var fn = fiber.type;\n                    return fn.displayName || fn.name || null;\n                case ForwardRef:\n                    var render = fiber.type.render;\n                    return render.displayName || render.name || null;\n                case ClassComponent:\n                    var ctr = fiber.type;\n                    return ctr.displayName || ctr.name || null;\n                default:\n                    // Skip\n                    return null;\n            }\n        }\n        var needsEscaping = /[\"'&<>\\n\\t]/;\n        function describeTextNode(content, maxLength) {\n            if (needsEscaping.test(content)) {\n                var encoded = JSON.stringify(content);\n                if (encoded.length > maxLength - 2) {\n                    if (maxLength < 8) {\n                        return '{\"...\"}';\n                    }\n                    return '{' + encoded.slice(0, maxLength - 7) + '...\"}';\n                }\n                return '{' + encoded + '}';\n            } else {\n                if (content.length > maxLength) {\n                    if (maxLength < 5) {\n                        return '{\"...\"}';\n                    }\n                    return content.slice(0, maxLength - 3) + '...';\n                }\n                return content;\n            }\n        }\n        function describeTextDiff(clientText, serverProps, indent) {\n            var maxLength = maxRowLength - indent * 2;\n            if (serverProps === null) {\n                return added(indent) + describeTextNode(clientText, maxLength) + '\\n';\n            } else if (typeof serverProps === 'string') {\n                var serverText = serverProps;\n                var firstDiff = 0;\n                for(; firstDiff < serverText.length && firstDiff < clientText.length; firstDiff++){\n                    if (serverText.charCodeAt(firstDiff) !== clientText.charCodeAt(firstDiff)) {\n                        break;\n                    }\n                }\n                if (firstDiff > maxLength - 8 && firstDiff > 10) {\n                    // The first difference between the two strings would be cut off, so cut off in\n                    // the beginning instead.\n                    clientText = '...' + clientText.slice(firstDiff - 8);\n                    serverText = '...' + serverText.slice(firstDiff - 8);\n                }\n                return added(indent) + describeTextNode(clientText, maxLength) + '\\n' + removed(indent) + describeTextNode(serverText, maxLength) + '\\n';\n            } else {\n                return indentation(indent) + describeTextNode(clientText, maxLength) + '\\n';\n            }\n        }\n        function objectName(object) {\n            // $FlowFixMe[method-unbinding]\n            var name = Object.prototype.toString.call(object);\n            return name.replace(/^\\[object (.*)\\]$/, function(m, p0) {\n                return p0;\n            });\n        }\n        function describeValue(value, maxLength) {\n            switch(typeof value){\n                case 'string':\n                    {\n                        var encoded = JSON.stringify(value);\n                        if (encoded.length > maxLength) {\n                            if (maxLength < 5) {\n                                return '\"...\"';\n                            }\n                            return encoded.slice(0, maxLength - 4) + '...\"';\n                        }\n                        return encoded;\n                    }\n                case 'object':\n                    {\n                        if (value === null) {\n                            return 'null';\n                        }\n                        if (isArray(value)) {\n                            return '[...]';\n                        }\n                        if (value.$$typeof === REACT_ELEMENT_TYPE) {\n                            var type = getComponentNameFromType(value.type);\n                            return type ? '<' + type + '>' : '<...>';\n                        }\n                        var name = objectName(value);\n                        if (name === 'Object') {\n                            var properties = '';\n                            maxLength -= 2;\n                            for(var propName in value){\n                                if (!value.hasOwnProperty(propName)) {\n                                    continue;\n                                }\n                                var jsonPropName = JSON.stringify(propName);\n                                if (jsonPropName !== '\"' + propName + '\"') {\n                                    propName = jsonPropName;\n                                }\n                                maxLength -= propName.length - 2;\n                                var propValue = describeValue(value[propName], maxLength < 15 ? maxLength : 15);\n                                maxLength -= propValue.length;\n                                if (maxLength < 0) {\n                                    properties += properties === '' ? '...' : ', ...';\n                                    break;\n                                }\n                                properties += (properties === '' ? '' : ',') + propName + ':' + propValue;\n                            }\n                            return '{' + properties + '}';\n                        }\n                        return name;\n                    }\n                case 'function':\n                    {\n                        var _name = value.displayName || value.name;\n                        return _name ? 'function ' + _name : 'function';\n                    }\n                default:\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    return String(value);\n            }\n        }\n        function describePropValue(value, maxLength) {\n            if (typeof value === 'string' && !needsEscaping.test(value)) {\n                if (value.length > maxLength - 2) {\n                    if (maxLength < 5) {\n                        return '\"...\"';\n                    }\n                    return '\"' + value.slice(0, maxLength - 5) + '...\"';\n                }\n                return '\"' + value + '\"';\n            }\n            return '{' + describeValue(value, maxLength - 2) + '}';\n        }\n        function describeCollapsedElement(type, props, indent) {\n            // This function tries to fit the props into a single line for non-essential elements.\n            // We also ignore children because we're not going deeper.\n            var maxLength = maxRowLength - indent * 2 - type.length - 2;\n            var content = '';\n            for(var propName in props){\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n                if (propName === 'children') {\n                    continue;\n                }\n                var propValue = describePropValue(props[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (maxLength < 0) {\n                    content += ' ...';\n                    break;\n                }\n                content += ' ' + propName + '=' + propValue;\n            }\n            return indentation(indent) + '<' + type + content + '>\\n';\n        }\n        function describeExpandedElement(type, props, rowPrefix) {\n            // This function tries to fit the props into a single line for non-essential elements.\n            // We also ignore children because we're not going deeper.\n            var remainingRowLength = maxRowLength - rowPrefix.length - type.length; // We add the properties to a set so we can choose later whether we'll put it on one\n            // line or multiple lines.\n            var properties = [];\n            for(var propName in props){\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n                if (propName === 'children') {\n                    continue;\n                }\n                var maxLength = maxRowLength - rowPrefix.length - propName.length - 1;\n                var propValue = describePropValue(props[propName], maxLength);\n                remainingRowLength -= propName.length + propValue.length + 2;\n                properties.push(propName + '=' + propValue);\n            }\n            if (properties.length === 0) {\n                return rowPrefix + '<' + type + '>\\n';\n            } else if (remainingRowLength > 0) {\n                // We can fit all on one row.\n                return rowPrefix + '<' + type + ' ' + properties.join(' ') + '>\\n';\n            } else {\n                // Split into one row per property:\n                return rowPrefix + '<' + type + '\\n' + rowPrefix + '  ' + properties.join('\\n' + rowPrefix + '  ') + '\\n' + rowPrefix + '>\\n';\n            }\n        }\n        function describePropertiesDiff(clientObject, serverObject, indent) {\n            var properties = '';\n            var remainingServerProperties = assign({}, serverObject);\n            for(var propName in clientObject){\n                if (!clientObject.hasOwnProperty(propName)) {\n                    continue;\n                }\n                delete remainingServerProperties[propName];\n                var maxLength = maxRowLength - indent * 2 - propName.length - 2;\n                var clientValue = clientObject[propName];\n                var clientPropValue = describeValue(clientValue, maxLength);\n                if (serverObject.hasOwnProperty(propName)) {\n                    var serverValue = serverObject[propName];\n                    var serverPropValue = describeValue(serverValue, maxLength);\n                    properties += added(indent) + propName + ': ' + clientPropValue + '\\n';\n                    properties += removed(indent) + propName + ': ' + serverPropValue + '\\n';\n                } else {\n                    properties += added(indent) + propName + ': ' + clientPropValue + '\\n';\n                }\n            }\n            for(var _propName in remainingServerProperties){\n                if (!remainingServerProperties.hasOwnProperty(_propName)) {\n                    continue;\n                }\n                var _maxLength = maxRowLength - indent * 2 - _propName.length - 2;\n                var _serverValue = remainingServerProperties[_propName];\n                var _serverPropValue = describeValue(_serverValue, _maxLength);\n                properties += removed(indent) + _propName + ': ' + _serverPropValue + '\\n';\n            }\n            return properties;\n        }\n        function describeElementDiff(type, clientProps, serverProps, indent) {\n            var content = ''; // Maps any previously unmatched lower case server prop name to its full prop name\n            var serverPropNames = new Map();\n            for(var propName in serverProps){\n                if (!serverProps.hasOwnProperty(propName)) {\n                    continue;\n                }\n                serverPropNames.set(propName.toLowerCase(), propName);\n            }\n            if (serverPropNames.size === 1 && serverPropNames.has('children')) {\n                content += describeExpandedElement(type, clientProps, indentation(indent));\n            } else {\n                for(var _propName2 in clientProps){\n                    if (!clientProps.hasOwnProperty(_propName2)) {\n                        continue;\n                    }\n                    if (_propName2 === 'children') {\n                        continue;\n                    }\n                    var maxLength = maxRowLength - (indent + 1) * 2 - _propName2.length - 1;\n                    var serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                    if (serverPropName !== undefined) {\n                        serverPropNames.delete(_propName2.toLowerCase()); // There's a diff here.\n                        var clientValue = clientProps[_propName2];\n                        var serverValue = serverProps[serverPropName];\n                        var clientPropValue = describePropValue(clientValue, maxLength);\n                        var serverPropValue = describePropValue(serverValue, maxLength);\n                        if (typeof clientValue === 'object' && clientValue !== null && typeof serverValue === 'object' && serverValue !== null && objectName(clientValue) === 'Object' && objectName(serverValue) === 'Object' && (Object.keys(clientValue).length > 2 || Object.keys(serverValue).length > 2 || clientPropValue.indexOf('...') > -1 || serverPropValue.indexOf('...') > -1)) {\n                            // We're comparing two plain objects. We can diff the nested objects instead.\n                            content += indentation(indent + 1) + _propName2 + '={{\\n' + describePropertiesDiff(clientValue, serverValue, indent + 2) + indentation(indent + 1) + '}}\\n';\n                        } else {\n                            content += added(indent + 1) + _propName2 + '=' + clientPropValue + '\\n';\n                            content += removed(indent + 1) + _propName2 + '=' + serverPropValue + '\\n';\n                        }\n                    } else {\n                        // Considered equal.\n                        content += indentation(indent + 1) + _propName2 + '=' + describePropValue(clientProps[_propName2], maxLength) + '\\n';\n                    }\n                }\n                serverPropNames.forEach(function(propName) {\n                    if (propName === 'children') {\n                        // Handled below.\n                        return;\n                    }\n                    var maxLength = maxRowLength - (indent + 1) * 2 - propName.length - 1;\n                    content += removed(indent + 1) + propName + '=' + describePropValue(serverProps[propName], maxLength) + '\\n';\n                });\n                if (content === '') {\n                    // No properties\n                    content = indentation(indent) + '<' + type + '>\\n';\n                } else {\n                    // Had properties\n                    content = indentation(indent) + '<' + type + '\\n' + content + indentation(indent) + '>\\n';\n                }\n            }\n            var serverChildren = serverProps.children;\n            var clientChildren = clientProps.children;\n            if (typeof serverChildren === 'string' || typeof serverChildren === 'number' || typeof serverChildren === 'bigint') {\n                // There's a diff of the children.\n                // $FlowFixMe[unsafe-addition]\n                var serverText = '' + serverChildren;\n                var clientText = '';\n                if (typeof clientChildren === 'string' || typeof clientChildren === 'number' || typeof clientChildren === 'bigint') {\n                    // $FlowFixMe[unsafe-addition]\n                    clientText = '' + clientChildren;\n                }\n                content += describeTextDiff(clientText, serverText, indent + 1);\n            } else if (typeof clientChildren === 'string' || typeof clientChildren === 'number' || typeof clientChildren === 'bigint') {\n                // The client has children but it's not considered a difference from the server.\n                // $FlowFixMe[unsafe-addition]\n                content += describeTextDiff('' + clientChildren, undefined, indent + 1);\n            }\n            return content;\n        }\n        function describeSiblingFiber(fiber, indent) {\n            var type = describeFiberType(fiber);\n            if (type === null) {\n                // Skip this type of fiber. We currently treat this as a fragment\n                // so it's just part of the parent's children.\n                var flatContent = '';\n                var childFiber = fiber.child;\n                while(childFiber){\n                    flatContent += describeSiblingFiber(childFiber, indent);\n                    childFiber = childFiber.sibling;\n                }\n                return flatContent;\n            }\n            return indentation(indent) + '<' + type + '>' + '\\n';\n        }\n        function describeNode(node, indent) {\n            var skipToNode = findNotableNode(node, indent);\n            if (skipToNode !== node && (node.children.length !== 1 || node.children[0] !== skipToNode)) {\n                return indentation(indent) + '...\\n' + describeNode(skipToNode, indent + 1);\n            } // Prefix with any server components for context\n            var parentContent = '';\n            var debugInfo = node.fiber._debugInfo;\n            if (debugInfo) {\n                for(var i = 0; i < debugInfo.length; i++){\n                    var serverComponentName = debugInfo[i].name;\n                    if (typeof serverComponentName === 'string') {\n                        parentContent += indentation(indent) + '<' + serverComponentName + '>' + '\\n';\n                        indent++;\n                    }\n                }\n            } // Self\n            var selfContent = ''; // We use the pending props since we might be generating a diff before the complete phase\n            // when something throws.\n            var clientProps = node.fiber.pendingProps;\n            if (node.fiber.tag === HostText) {\n                // Text Node\n                selfContent = describeTextDiff(clientProps, node.serverProps, indent);\n            } else {\n                var type = describeFiberType(node.fiber);\n                if (type !== null) {\n                    // Element Node\n                    if (node.serverProps === undefined) {\n                        // Just a reference node for context.\n                        selfContent = describeCollapsedElement(type, clientProps, indent);\n                        indent++;\n                    } else if (node.serverProps === null) {\n                        selfContent = describeExpandedElement(type, clientProps, added(indent)); // If this was an insertion we won't step down further. Any tail\n                    // are considered siblings so we don't indent.\n                    // TODO: Model this a little better.\n                    } else if (typeof node.serverProps === 'string') {\n                        {\n                            error('Should not have matched a non HostText fiber to a Text node. This is a bug in React.');\n                        }\n                    } else {\n                        selfContent = describeElementDiff(type, clientProps, node.serverProps, indent);\n                        indent++;\n                    }\n                }\n            } // Compute children\n            var childContent = '';\n            var childFiber = node.fiber.child;\n            var diffIdx = 0;\n            while(childFiber && diffIdx < node.children.length){\n                var childNode = node.children[diffIdx];\n                if (childNode.fiber === childFiber) {\n                    // This was a match in the diff.\n                    childContent += describeNode(childNode, indent);\n                    diffIdx++;\n                } else {\n                    // This is an unrelated previous sibling.\n                    childContent += describeSiblingFiber(childFiber, indent);\n                }\n                childFiber = childFiber.sibling;\n            }\n            if (childFiber && node.children.length > 0) {\n                // If we had any further siblings after the last mismatch, we can't be sure if it's\n                // actually a valid match since it might not have found a match. So we exclude next\n                // siblings to avoid confusion.\n                childContent += indentation(indent) + '...' + '\\n';\n            } // Deleted tail nodes\n            var serverTail = node.serverTail;\n            for(var _i = 0; _i < serverTail.length; _i++){\n                var tailNode = serverTail[_i];\n                if (typeof tailNode === 'string') {\n                    // Removed text node\n                    childContent += removed(indent) + describeTextNode(tailNode, maxRowLength - indent * 2) + '\\n';\n                } else {\n                    // Removed element\n                    childContent += describeExpandedElement(tailNode.type, tailNode.props, removed(indent));\n                }\n            }\n            return parentContent + selfContent + childContent;\n        }\n        function describeDiff(rootNode) {\n            try {\n                return '\\n\\n' + describeNode(rootNode, 0);\n            } catch (x) {\n                return '';\n            }\n        }\n        // This may have been an insertion or a hydration.\n        var hydrationParentFiber = null;\n        var nextHydratableInstance = null;\n        var isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches\n        // due to earlier mismatches or a suspended fiber.\n        var didSuspendOrErrorDEV = false; // Hydration differences found that haven't yet been logged.\n        var hydrationDiffRootDEV = null; // Hydration errors that were thrown inside this boundary\n        var hydrationErrors = null;\n        var rootOrSingletonContext = false; // Builds a common ancestor tree from the root down for collecting diffs.\n        function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n            if (fiber.return === null) {\n                // We're at the root.\n                if (hydrationDiffRootDEV === null) {\n                    hydrationDiffRootDEV = {\n                        fiber: fiber,\n                        children: [],\n                        serverProps: undefined,\n                        serverTail: [],\n                        distanceFromLeaf: distanceFromLeaf\n                    };\n                } else if (hydrationDiffRootDEV.fiber !== fiber) {\n                    throw new Error('Saw multiple hydration diff roots in a pass. This is a bug in React.');\n                } else if (hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf) {\n                    hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf;\n                }\n                return hydrationDiffRootDEV;\n            }\n            var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children; // The same node may already exist in the parent. Since we currently always render depth first\n            // and rerender if we suspend or terminate early, if a shared ancestor was added we should still\n            // be inside of that shared ancestor which means it was the last one to be added. If this changes\n            // we may have to scan the whole set.\n            if (siblings.length > 0 && siblings[siblings.length - 1].fiber === fiber) {\n                var existing = siblings[siblings.length - 1];\n                if (existing.distanceFromLeaf > distanceFromLeaf) {\n                    existing.distanceFromLeaf = distanceFromLeaf;\n                }\n                return existing;\n            }\n            var newNode = {\n                fiber: fiber,\n                children: [],\n                serverProps: undefined,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            siblings.push(newNode);\n            return newNode;\n        }\n        function warnIfHydrating() {\n            {\n                if (isHydrating) {\n                    error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n                }\n            }\n        }\n        function markDidThrowWhileHydratingDEV() {\n            {\n                didSuspendOrErrorDEV = true;\n            }\n        }\n        function enterHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            var parentInstance = fiber.stateNode.containerInfo;\n            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspendOrErrorDEV = false;\n            hydrationDiffRootDEV = null;\n            rootOrSingletonContext = true;\n            return true;\n        }\n        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n            if (!supportsHydration) {\n                return false;\n            }\n            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspendOrErrorDEV = false;\n            hydrationDiffRootDEV = null;\n            rootOrSingletonContext = false;\n            if (treeContext !== null) {\n                restoreSuspendedTreeContext(fiber, treeContext);\n            }\n            return true;\n        }\n        function warnNonHydratedInstance(fiber, rejectedCandidate) {\n            {\n                if (didSuspendOrErrorDEV) {\n                    // Inside a boundary that already suspended. We're currently rendering the\n                    // siblings of a suspended node. The mismatch may be due to the missing\n                    // data, so it's probably a false positive.\n                    return;\n                } // Add this fiber to the diff tree.\n                var diffNode = buildHydrationDiffNode(fiber, 0); // We use null as a signal that there was no node to match.\n                diffNode.serverProps = null;\n                if (rejectedCandidate !== null) {\n                    var description = describeHydratableInstanceForDevWarnings(rejectedCandidate);\n                    diffNode.serverTail.push(description);\n                }\n            }\n        }\n        function tryHydrateInstance(fiber, nextInstance, hostContext) {\n            // fiber is a HostComponent Fiber\n            var instance = canHydrateInstance(nextInstance, fiber.type, fiber.pendingProps, rootOrSingletonContext);\n            if (instance !== null) {\n                fiber.stateNode = instance;\n                {\n                    if (!didSuspendOrErrorDEV) {\n                        var differences = diffHydratedPropsForDevWarnings(instance, fiber.type, fiber.pendingProps, hostContext);\n                        if (differences !== null) {\n                            var diffNode = buildHydrationDiffNode(fiber, 0);\n                            diffNode.serverProps = differences;\n                        }\n                    }\n                }\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n                rootOrSingletonContext = false;\n                return true;\n            }\n            return false;\n        }\n        function tryHydrateText(fiber, nextInstance) {\n            // fiber is a HostText Fiber\n            var text = fiber.pendingProps;\n            var textInstance = canHydrateTextInstance(nextInstance, text, rootOrSingletonContext);\n            if (textInstance !== null) {\n                fiber.stateNode = textInstance;\n                hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n                nextHydratableInstance = null;\n                return true;\n            }\n            return false;\n        }\n        function tryHydrateSuspense(fiber, nextInstance) {\n            // fiber is a SuspenseComponent Fiber\n            var suspenseInstance = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext);\n            if (suspenseInstance !== null) {\n                var suspenseState = {\n                    dehydrated: suspenseInstance,\n                    treeContext: getSuspendedTreeContext(),\n                    retryLane: OffscreenLane\n                };\n                fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n                // This simplifies the code for getHostSibling and deleting nodes,\n                // since it doesn't have to consider all Suspense boundaries and\n                // check if they're dehydrated ones or not.\n                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n                dehydratedFragment.return = fiber;\n                fiber.child = dehydratedFragment;\n                hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n                // it during the first pass. Instead, we'll reenter it later.\n                nextHydratableInstance = null;\n                return true;\n            }\n            return false;\n        }\n        var HydrationMismatchException = new Error('Hydration Mismatch Exception: This is not a real error, and should not leak into ' + \"userspace. If you're seeing this, it's likely a bug in React.\");\n        function throwOnHydrationMismatch(fiber) {\n            var diff = '';\n            {\n                // Consume the diff root for this mismatch.\n                // Any other errors will get their own diffs.\n                var diffRoot = hydrationDiffRootDEV;\n                if (diffRoot !== null) {\n                    hydrationDiffRootDEV = null;\n                    diff = describeDiff(diffRoot);\n                }\n            }\n            var error = new Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\" + '\\n' + \"- A server/client branch `if (typeof window !== 'undefined')`.\\n\" + \"- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n\" + \"- Date formatting in a user's locale which doesn't match the server.\\n\" + '- External changing data without sending a snapshot of it along with the HTML.\\n' + '- Invalid HTML tag nesting.\\n' + '\\n' + 'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n' + '\\n' + 'https://react.dev/link/hydration-mismatch' + diff);\n            queueHydrationError(createCapturedValueAtFiber(error, fiber));\n            throw HydrationMismatchException;\n        }\n        function claimHydratableSingleton(fiber) {\n            if (supportsSingletons) {\n                if (!isHydrating) {\n                    return;\n                }\n                var currentRootContainer = getRootHostContainer();\n                var currentHostContext = getHostContext();\n                var instance = fiber.stateNode = resolveSingletonInstance(fiber.type, fiber.pendingProps, currentRootContainer, currentHostContext, false);\n                {\n                    if (!didSuspendOrErrorDEV) {\n                        var differences = diffHydratedPropsForDevWarnings(instance, fiber.type, fiber.pendingProps, currentHostContext);\n                        if (differences !== null) {\n                            var diffNode = buildHydrationDiffNode(fiber, 0);\n                            diffNode.serverProps = differences;\n                        }\n                    }\n                }\n                hydrationParentFiber = fiber;\n                rootOrSingletonContext = true;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n            }\n        }\n        function tryToClaimNextHydratableInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            } // Validate that this is ok to render here before any mismatches.\n            var currentHostContext = getHostContext();\n            var shouldKeepWarning = validateHydratableInstance(fiber.type, fiber.pendingProps, currentHostContext);\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateInstance(fiber, nextInstance, currentHostContext)) {\n                if (shouldKeepWarning) {\n                    warnNonHydratedInstance(fiber, nextInstance);\n                }\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableTextInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var text = fiber.pendingProps;\n            var shouldKeepWarning = true; // Validate that this is ok to render here before any mismatches.\n            var currentHostContext = getHostContext();\n            shouldKeepWarning = validateHydratableTextInstance(text, currentHostContext);\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateText(fiber, nextInstance)) {\n                if (shouldKeepWarning) {\n                    warnNonHydratedInstance(fiber, nextInstance);\n                }\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableSuspenseInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateSuspense(fiber, nextInstance)) {\n                warnNonHydratedInstance(fiber, nextInstance);\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableFormMarkerInstance(fiber) {\n            if (!isHydrating) {\n                return false;\n            }\n            if (nextHydratableInstance) {\n                var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                if (markerInstance) {\n                    // Found the marker instance.\n                    nextHydratableInstance = getNextHydratableSibling(markerInstance); // Return true if this marker instance should use the state passed\n                    // to hydrateRoot.\n                    // TODO: As an optimization, Fizz should only emit these markers if form\n                    // state is passed at the root.\n                    return isFormStateMarkerMatching(markerInstance);\n                }\n            } // Should have found a marker instance. Throw an error to trigger client\n            // rendering. We don't bother to check if we're in a concurrent root because\n            // useActionState is a new API, so backwards compat is not an issue.\n            throwOnHydrationMismatch(fiber);\n            return false;\n        }\n        function prepareToHydrateHostInstance(fiber, hostContext) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var instance = fiber.stateNode;\n            var didHydrate = hydrateInstance(instance, fiber.type, fiber.memoizedProps, hostContext, fiber);\n            if (!didHydrate && favorSafetyOverHydrationPerf) {\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function prepareToHydrateHostTextInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var textInstance = fiber.stateNode;\n            var textContent = fiber.memoizedProps;\n            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n            var parentProps = null; // We assume that prepareToHydrateHostTextInstance is called in a context where the\n            // hydration parent is the parent host component of this host text.\n            var returnFiber = hydrationParentFiber;\n            if (returnFiber !== null) {\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        {\n                            {\n                                if (shouldWarnIfMismatchDev) {\n                                    var difference = diffHydratedTextForDevWarnings(textInstance, textContent, parentProps);\n                                    if (difference !== null) {\n                                        var diffNode = buildHydrationDiffNode(fiber, 0);\n                                        diffNode.serverProps = difference;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case HostSingleton:\n                    case HostComponent:\n                        {\n                            parentProps = returnFiber.memoizedProps;\n                            {\n                                if (shouldWarnIfMismatchDev) {\n                                    var _difference = diffHydratedTextForDevWarnings(textInstance, textContent, parentProps);\n                                    if (_difference !== null) {\n                                        var _diffNode = buildHydrationDiffNode(fiber, 0);\n                                        _diffNode.serverProps = _difference;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                } // TODO: What if it's a SuspenseInstance?\n            }\n            var didHydrate = hydrateTextInstance(textInstance, textContent, fiber, parentProps);\n            if (!didHydrate && favorSafetyOverHydrationPerf) {\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function prepareToHydrateHostSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            hydrateSuspenseInstance(suspenseInstance, fiber);\n        }\n        function skipPastDehydratedSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n        }\n        function popToNextHostParent(fiber) {\n            hydrationParentFiber = fiber.return;\n            while(hydrationParentFiber){\n                switch(hydrationParentFiber.tag){\n                    case HostRoot:\n                    case HostSingleton:\n                        rootOrSingletonContext = true;\n                        return;\n                    case HostComponent:\n                    case SuspenseComponent:\n                        rootOrSingletonContext = false;\n                        return;\n                    default:\n                        hydrationParentFiber = hydrationParentFiber.return;\n                }\n            }\n        }\n        function popHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            if (fiber !== hydrationParentFiber) {\n                // We're deeper than the current hydration context, inside an inserted\n                // tree.\n                return false;\n            }\n            if (!isHydrating) {\n                // If we're not currently hydrating but we're in a hydration context, then\n                // we were an insertion and now need to pop up reenter hydration of our\n                // siblings.\n                popToNextHostParent(fiber);\n                isHydrating = true;\n                return false;\n            }\n            var shouldClear = false;\n            if (supportsSingletons) {\n                // With float we never clear the Root, or Singleton instances. We also do not clear Instances\n                // that have singleton text content\n                if (fiber.tag !== HostRoot && fiber.tag !== HostSingleton && !(fiber.tag === HostComponent && (!shouldDeleteUnhydratedTailInstances(fiber.type) || shouldSetTextContent(fiber.type, fiber.memoizedProps)))) {\n                    shouldClear = true;\n                }\n            } else {\n                // If we have any remaining hydratable nodes, we need to delete them now.\n                // We only do this deeper than head and body since they tend to have random\n                // other nodes in them. We also ignore components with pure text content in\n                // side of them. We also don't delete anything inside the root container.\n                if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n                    shouldClear = true;\n                }\n            }\n            if (shouldClear) {\n                var nextInstance = nextHydratableInstance;\n                if (nextInstance) {\n                    warnIfUnhydratedTailNodes(fiber);\n                    throwOnHydrationMismatch(fiber);\n                }\n            }\n            popToNextHostParent(fiber);\n            if (fiber.tag === SuspenseComponent) {\n                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n            } else {\n                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n            }\n            return true;\n        }\n        function warnIfUnhydratedTailNodes(fiber) {\n            {\n                var nextInstance = nextHydratableInstance;\n                while(nextInstance){\n                    var diffNode = buildHydrationDiffNode(fiber, 0);\n                    var description = describeHydratableInstanceForDevWarnings(nextInstance);\n                    diffNode.serverTail.push(description);\n                    if (description.type === 'Suspense') {\n                        var suspenseInstance = nextInstance;\n                        nextInstance = getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n                    } else {\n                        nextInstance = getNextHydratableSibling(nextInstance);\n                    }\n                }\n            }\n        }\n        function resetHydrationState() {\n            if (!supportsHydration) {\n                return;\n            }\n            hydrationParentFiber = null;\n            nextHydratableInstance = null;\n            isHydrating = false;\n            didSuspendOrErrorDEV = false;\n        }\n        function upgradeHydrationErrorsToRecoverable() {\n            if (hydrationErrors !== null) {\n                // Successfully completed a forced client render. The errors that occurred\n                // during the hydration attempt are now recovered. We will log them in\n                // commit phase, once the entire tree has finished.\n                queueRecoverableErrors(hydrationErrors);\n                hydrationErrors = null;\n            }\n        }\n        function getIsHydrating() {\n            return isHydrating;\n        }\n        function queueHydrationError(error) {\n            if (hydrationErrors === null) {\n                hydrationErrors = [\n                    error\n                ];\n            } else {\n                hydrationErrors.push(error);\n            }\n        }\n        function emitPendingHydrationWarnings() {\n            {\n                // If we haven't yet thrown any hydration errors by the time we reach the end we've successfully\n                // hydrated, however, we might still have DEV-only mismatches that we log now.\n                var diffRoot = hydrationDiffRootDEV;\n                if (diffRoot !== null) {\n                    hydrationDiffRootDEV = null;\n                    var diff = describeDiff(diffRoot);\n                    error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. \" + 'This can happen if a SSR-ed Client Component used:\\n' + '\\n' + \"- A server/client branch `if (typeof window !== 'undefined')`.\\n\" + \"- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n\" + \"- Date formatting in a user's locale which doesn't match the server.\\n\" + '- External changing data without sending a snapshot of it along with the HTML.\\n' + '- Invalid HTML tag nesting.\\n' + '\\n' + 'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n' + '\\n' + '%s%s', 'https://react.dev/link/hydration-mismatch', diff);\n                }\n            }\n        }\n        // we wait until the current render is over (either finished or interrupted)\n        // before adding it to the fiber/hook queue. Push to this array so we can\n        // access the queue, fiber, update, et al later.\n        var concurrentQueues = [];\n        var concurrentQueuesIndex = 0;\n        var concurrentlyUpdatedLanes = NoLanes;\n        function finishQueueingConcurrentUpdates() {\n            var endIndex = concurrentQueuesIndex;\n            concurrentQueuesIndex = 0;\n            concurrentlyUpdatedLanes = NoLanes;\n            var i = 0;\n            while(i < endIndex){\n                var fiber = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var queue = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var update = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var lane = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                if (queue !== null && update !== null) {\n                    var pending = queue.pending;\n                    if (pending === null) {\n                        // This is the first update. Create a circular list.\n                        update.next = update;\n                    } else {\n                        update.next = pending.next;\n                        pending.next = update;\n                    }\n                    queue.pending = update;\n                }\n                if (lane !== NoLane) {\n                    markUpdateLaneFromFiberToRoot(fiber, update, lane);\n                }\n            }\n        }\n        function getConcurrentlyUpdatedLanes() {\n            return concurrentlyUpdatedLanes;\n        }\n        function enqueueUpdate$1(fiber, queue, update, lane) {\n            // Don't update the `childLanes` on the return path yet. If we already in\n            // the middle of rendering, wait until after it has completed.\n            concurrentQueues[concurrentQueuesIndex++] = fiber;\n            concurrentQueues[concurrentQueuesIndex++] = queue;\n            concurrentQueues[concurrentQueuesIndex++] = update;\n            concurrentQueues[concurrentQueuesIndex++] = lane;\n            concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane); // The fiber's `lane` field is used in some places to check if any work is\n            // scheduled, to perform an eager bailout, so we need to update it immediately.\n            // TODO: We should probably move this to the \"shared\" queue instead.\n            fiber.lanes = mergeLanes(fiber.lanes, lane);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            }\n        }\n        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);\n            return getRootForUpdatedFiber(fiber);\n        }\n        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update) {\n            // This function is used to queue an update that doesn't need a rerender. The\n            // only reason we queue it is in case there's a subsequent higher priority\n            // update that causes it to be rebased.\n            var lane = NoLane;\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane); // Usually we can rely on the upcoming render phase to process the concurrent\n            // queue. However, since this is a bail out, we're not scheduling any work\n            // here. So the update we just queued will leak until something else happens\n            // to schedule work (if ever).\n            //\n            // Check if we're currently in the middle of rendering a tree, and if not,\n            // process the queue immediately to prevent a leak.\n            var isConcurrentlyRendering = getWorkInProgressRoot() !== null;\n            if (!isConcurrentlyRendering) {\n                finishQueueingConcurrentUpdates();\n            }\n        }\n        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);\n            return getRootForUpdatedFiber(fiber);\n        }\n        function enqueueConcurrentRenderForLane(fiber, lane) {\n            enqueueUpdate$1(fiber, null, null, lane);\n            return getRootForUpdatedFiber(fiber);\n        } // Calling this function outside this module should only be done for backwards\n        // compatibility and should always be accompanied by a warning.\n        function unsafe_markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n            // NOTE: For Hyrum's Law reasons, if an infinite update loop is detected, it\n            // should throw before `markUpdateLaneFromFiberToRoot` is called. But this is\n            // undefined behavior and we can change it if we need to; it just so happens\n            // that, at the time of this writing, there's an internal product test that\n            // happens to rely on this.\n            var root = getRootForUpdatedFiber(sourceFiber);\n            markUpdateLaneFromFiberToRoot(sourceFiber, null, lane);\n            return root;\n        }\n        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n            // Update the source fiber's lanes\n            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n            var alternate = sourceFiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            } // Walk the parent path to the root and update the child lanes.\n            var isHidden = false;\n            var parent = sourceFiber.return;\n            var node = sourceFiber;\n            while(parent !== null){\n                parent.childLanes = mergeLanes(parent.childLanes, lane);\n                alternate = parent.alternate;\n                if (alternate !== null) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n                }\n                if (parent.tag === OffscreenComponent) {\n                    // Check if this offscreen boundary is currently hidden.\n                    //\n                    // The instance may be null if the Offscreen parent was unmounted. Usually\n                    // the parent wouldn't be reachable in that case because we disconnect\n                    // fibers from the tree when they are deleted. However, there's a weird\n                    // edge case where setState is called on a fiber that was interrupted\n                    // before it ever mounted. Because it never mounts, it also never gets\n                    // deleted. Because it never gets deleted, its return pointer never gets\n                    // disconnected. Which means it may be attached to a deleted Offscreen\n                    // parent node. (This discovery suggests it may be better for memory usage\n                    // if we don't attach the `return` pointer until the commit phase, though\n                    // in order to do that we'd need some other way to track the return\n                    // pointer during the initial render, like on the stack.)\n                    //\n                    // This case is always accompanied by a warning, but we still need to\n                    // account for it. (There may be other cases that we haven't discovered,\n                    // too.)\n                    var offscreenInstance = parent.stateNode;\n                    if (offscreenInstance !== null && !(offscreenInstance._visibility & OffscreenVisible)) {\n                        isHidden = true;\n                    }\n                }\n                node = parent;\n                parent = parent.return;\n            }\n            if (isHidden && update !== null && node.tag === HostRoot) {\n                var root = node.stateNode;\n                markHiddenUpdate(root, update, lane);\n            }\n        }\n        function getRootForUpdatedFiber(sourceFiber) {\n            // TODO: We will detect and infinite update loop and throw even if this fiber\n            // has already unmounted. This isn't really necessary but it happens to be the\n            // current behavior we've used for several release cycles. Consider not\n            // performing this check if the updated fiber already unmounted, since it's\n            // not possible for that to cause an infinite update loop.\n            throwIfInfiniteUpdateLoopDetected(); // When a setState happens, we must ensure the root is scheduled. Because\n            // update queues do not have a backpointer to the root, the only way to do\n            // this currently is to walk up the return path. This used to not be a big\n            // deal because we would have to walk up the return path to set\n            // the `childLanes`, anyway, but now those two traversals happen at\n            // different times.\n            // TODO: Consider adding a `root` backpointer on the update queue.\n            detectUpdateOnUnmountedFiber(sourceFiber, sourceFiber);\n            var node = sourceFiber;\n            var parent = node.return;\n            while(parent !== null){\n                detectUpdateOnUnmountedFiber(sourceFiber, node);\n                node = parent;\n                parent = node.return;\n            }\n            return node.tag === HostRoot ? node.stateNode : null;\n        }\n        function detectUpdateOnUnmountedFiber(sourceFiber, parent) {\n            {\n                var alternate = parent.alternate;\n                if (alternate === null && (parent.flags & (Placement | Hydrating)) !== NoFlags$1) {\n                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                }\n            }\n        }\n        // there's only a single root, but we do support multi root apps, hence this\n        // extra complexity. But this module is optimized for the single root case.\n        var firstScheduledRoot = null;\n        var lastScheduledRoot = null; // Used to prevent redundant mircotasks from being scheduled.\n        var didScheduleMicrotask = false; // `act` \"microtasks\" are scheduled on the `act` queue instead of an actual\n        // microtask, so we have to dedupe those separately. This wouldn't be an issue\n        // if we required all `act` calls to be awaited, which we might in the future.\n        var didScheduleMicrotask_act = false; // Used to quickly bail out of flushSync if there's no sync work to do.\n        var mightHavePendingSyncWork = false;\n        var isFlushingWork = false;\n        var currentEventTransitionLane = NoLane;\n        function ensureRootIsScheduled(root) {\n            // This function is called whenever a root receives an update. It does two\n            // things 1) it ensures the root is in the root schedule, and 2) it ensures\n            // there's a pending microtask to process the root schedule.\n            //\n            // Most of the actual scheduling logic does not happen until\n            // `scheduleTaskForRootDuringMicrotask` runs.\n            // Add the root to the schedule\n            if (root === lastScheduledRoot || root.next !== null) ;\n            else {\n                if (lastScheduledRoot === null) {\n                    firstScheduledRoot = lastScheduledRoot = root;\n                } else {\n                    lastScheduledRoot.next = root;\n                    lastScheduledRoot = root;\n                }\n            } // Any time a root received an update, we set this to true until the next time\n            // we process the schedule. If it's false, then we can quickly exit flushSync\n            // without consulting the schedule.\n            mightHavePendingSyncWork = true; // At the end of the current event, go through each of the roots and ensure\n            // there's a task scheduled for each one at the correct priority.\n            if (ReactSharedInternals.actQueue !== null) {\n                // We're inside an `act` scope.\n                if (!didScheduleMicrotask_act) {\n                    didScheduleMicrotask_act = true;\n                    scheduleImmediateTask(processRootScheduleInMicrotask);\n                }\n            } else {\n                if (!didScheduleMicrotask) {\n                    didScheduleMicrotask = true;\n                    scheduleImmediateTask(processRootScheduleInMicrotask);\n                }\n            }\n        }\n        function flushSyncWorkOnAllRoots() {\n            // This is allowed to be called synchronously, but the caller should check\n            // the execution context first.\n            flushSyncWorkAcrossRoots_impl(false);\n        }\n        function flushSyncWorkAcrossRoots_impl(onlyLegacy) {\n            if (isFlushingWork) {\n                // Prevent reentrancy.\n                // TODO: Is this overly defensive? The callers must check the execution\n                // context first regardless.\n                return;\n            }\n            if (!mightHavePendingSyncWork) {\n                // Fast path. There's no sync work to do.\n                return;\n            } // There may or may not be synchronous work scheduled. Let's check.\n            var didPerformSomeWork;\n            isFlushingWork = true;\n            do {\n                didPerformSomeWork = false;\n                var root = firstScheduledRoot;\n                while(root !== null){\n                    if (onlyLegacy && disableLegacyMode) ;\n                    else {\n                        var workInProgressRoot = getWorkInProgressRoot();\n                        var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();\n                        var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n                        if (includesSyncLane(nextLanes)) {\n                            // This root has pending sync work. Flush it now.\n                            didPerformSomeWork = true;\n                            performSyncWorkOnRoot(root, nextLanes);\n                        }\n                    }\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = false;\n        }\n        function processRootScheduleInMicrotask() {\n            // This function is always called inside a microtask. It should never be\n            // called synchronously.\n            didScheduleMicrotask = false;\n            {\n                didScheduleMicrotask_act = false;\n            }\n            mightHavePendingSyncWork = false;\n            var currentTime = now$1();\n            var prev = null;\n            var root = firstScheduledRoot;\n            while(root !== null){\n                var next = root.next;\n                if (currentEventTransitionLane !== NoLane && shouldAttemptEagerTransition()) {\n                    // A transition was scheduled during an event, but we're going to try to\n                    // render it synchronously anyway. We do this during a popstate event to\n                    // preserve the scroll position of the previous page.\n                    upgradePendingLaneToSync(root, currentEventTransitionLane);\n                }\n                var nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n                if (nextLanes === NoLane) {\n                    // This root has no more pending work. Remove it from the schedule. To\n                    // guard against subtle reentrancy bugs, this microtask is the only place\n                    // we do this — you can add roots to the schedule whenever, but you can\n                    // only remove them here.\n                    // Null this out so we know it's been removed from the schedule.\n                    root.next = null;\n                    if (prev === null) {\n                        // This is the new head of the list\n                        firstScheduledRoot = next;\n                    } else {\n                        prev.next = next;\n                    }\n                    if (next === null) {\n                        // This is the new tail of the list\n                        lastScheduledRoot = prev;\n                    }\n                } else {\n                    // This root still has work. Keep it in the list.\n                    prev = root;\n                    if (includesSyncLane(nextLanes)) {\n                        mightHavePendingSyncWork = true;\n                    }\n                }\n                root = next;\n            }\n            currentEventTransitionLane = NoLane; // At the end of the microtask, flush any pending synchronous work. This has\n            // to come at the end, because it does actual rendering work that might throw.\n            flushSyncWorkOnAllRoots();\n        }\n        function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n            // This function is always called inside a microtask, or at the very end of a\n            // rendering task right before we yield to the main thread. It should never be\n            // called synchronously.\n            //\n            // TODO: Unless enableDeferRootSchedulingToMicrotask is off. We need to land\n            // that ASAP to unblock additional features we have planned.\n            //\n            // This function also never performs React work synchronously; it should\n            // only schedule work to be performed later, in a separate task or microtask.\n            // Check if any lanes are being starved by other work. If so, mark them as\n            // expired so we know to work on those next.\n            markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n            var workInProgressRoot = getWorkInProgressRoot();\n            var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();\n            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            var existingCallbackNode = root.callbackNode;\n            if (nextLanes === NoLanes || // If this root is currently suspended and waiting for data to resolve, don't\n            // schedule a task to render it. We'll either wait for a ping, or wait to\n            // receive an update.\n            //\n            // Suspended render phase\n            root === workInProgressRoot && isWorkLoopSuspendedOnData() || // Suspended commit phase\n            root.cancelPendingCommit !== null) {\n                // Fast path: There's nothing to work on.\n                if (existingCallbackNode !== null) {\n                    cancelCallback(existingCallbackNode);\n                }\n                root.callbackNode = null;\n                root.callbackPriority = NoLane;\n                return NoLane;\n            } // Schedule a new callback in the host environment.\n            if (includesSyncLane(nextLanes)) {\n                // Synchronous work is always flushed at the end of the microtask, so we\n                // don't need to schedule an additional task.\n                if (existingCallbackNode !== null) {\n                    cancelCallback(existingCallbackNode);\n                }\n                root.callbackPriority = SyncLane;\n                root.callbackNode = null;\n                return SyncLane;\n            } else {\n                // We use the highest priority lane to represent the priority of the callback.\n                var existingCallbackPriority = root.callbackPriority;\n                var newCallbackPriority = getHighestPriorityLane(nextLanes);\n                if (newCallbackPriority === existingCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n                // Scheduler task, rather than an `act` task, cancel it and re-schedule\n                // on the `act` queue.\n                !(ReactSharedInternals.actQueue !== null && existingCallbackNode !== fakeActCallbackNode$1)) {\n                    // The priority hasn't changed. We can reuse the existing task.\n                    return newCallbackPriority;\n                } else {\n                    // Cancel the existing callback. We'll schedule a new one below.\n                    cancelCallback(existingCallbackNode);\n                }\n                var schedulerPriorityLevel;\n                switch(lanesToEventPriority(nextLanes)){\n                    case DiscreteEventPriority:\n                        schedulerPriorityLevel = ImmediatePriority;\n                        break;\n                    case ContinuousEventPriority:\n                        schedulerPriorityLevel = UserBlockingPriority;\n                        break;\n                    case DefaultEventPriority:\n                        schedulerPriorityLevel = NormalPriority$1;\n                        break;\n                    case IdleEventPriority:\n                        schedulerPriorityLevel = IdlePriority;\n                        break;\n                    default:\n                        schedulerPriorityLevel = NormalPriority$1;\n                        break;\n                }\n                var newCallbackNode = scheduleCallback$2(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n                root.callbackPriority = newCallbackPriority;\n                root.callbackNode = newCallbackNode;\n                return newCallbackPriority;\n            }\n        }\n        function getContinuationForRoot(root, originalCallbackNode) {\n            // This is called at the end of `performConcurrentWorkOnRoot` to determine\n            // if we need to schedule a continuation task.\n            //\n            // Usually `scheduleTaskForRootDuringMicrotask` only runs inside a microtask;\n            // however, since most of the logic for determining if we need a continuation\n            // versus a new task is the same, we cheat a bit and call it here. This is\n            // only safe to do because we know we're at the end of the browser task.\n            // So although it's not an actual microtask, it might as well be.\n            scheduleTaskForRootDuringMicrotask(root, now$1());\n            if (root.callbackNode === originalCallbackNode) {\n                // The task node scheduled for this root is the same one that's\n                // currently executed. Need to return a continuation.\n                return performConcurrentWorkOnRoot.bind(null, root);\n            }\n            return null;\n        }\n        var fakeActCallbackNode$1 = {};\n        function scheduleCallback$2(priorityLevel, callback) {\n            if (ReactSharedInternals.actQueue !== null) {\n                // Special case: We're inside an `act` scope (a testing utility).\n                // Instead of scheduling work in the host environment, add it to a\n                // fake internal queue that's managed by the `act` implementation.\n                ReactSharedInternals.actQueue.push(callback);\n                return fakeActCallbackNode$1;\n            } else {\n                return scheduleCallback$3(priorityLevel, callback);\n            }\n        }\n        function cancelCallback(callbackNode) {\n            if (callbackNode === fakeActCallbackNode$1) ;\n            else if (callbackNode !== null) {\n                cancelCallback$1(callbackNode);\n            }\n        }\n        function scheduleImmediateTask(cb) {\n            if (ReactSharedInternals.actQueue !== null) {\n                // Special case: Inside an `act` scope, we push microtasks to the fake `act`\n                // callback queue. This is because we currently support calling `act`\n                // without awaiting the result. The plan is to deprecate that, and require\n                // that you always await the result so that the microtasks have a chance to\n                // run. But it hasn't happened yet.\n                ReactSharedInternals.actQueue.push(function() {\n                    cb();\n                    return null;\n                });\n            } // TODO: Can we land supportsMicrotasks? Which environments don't support it?\n            // Alternatively, can we move this check to the host config?\n            if (supportsMicrotasks) {\n                scheduleMicrotask(function() {\n                    // In Safari, appending an iframe forces microtasks to run.\n                    // https://github.com/facebook/react/issues/22459\n                    // We don't support running callbacks in the middle of render\n                    // or commit so we need to check against that.\n                    var executionContext = getExecutionContext();\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                        // Note that this would still prematurely flush the callbacks\n                        // if this happens outside render or commit phase (e.g. in an event).\n                        // Intentionally using a macrotask instead of a microtask here. This is\n                        // wrong semantically but it prevents an infinite loop. The bug is\n                        // Safari's, not ours, so we just do our best to not crash even though\n                        // the behavior isn't completely correct.\n                        scheduleCallback$3(ImmediatePriority, cb);\n                        return;\n                    }\n                    cb();\n                });\n            } else {\n                // If microtasks are not supported, use Scheduler.\n                scheduleCallback$3(ImmediatePriority, cb);\n            }\n        }\n        function requestTransitionLane(// check that it's inside a transition before calling this function.\n        // TODO: Make this non-nullable. Requires a tweak to useOptimistic.\n        transition) {\n            // The algorithm for assigning an update to a lane should be stable for all\n            // updates at the same priority within the same event. To do this, the\n            // inputs to the algorithm must be the same.\n            //\n            // The trick we use is to cache the first of each of these inputs within an\n            // event. Then reset the cached values once we can be sure the event is\n            // over. Our heuristic for that is whenever we enter a concurrent work loop.\n            if (currentEventTransitionLane === NoLane) {\n                // All transitions within the same event are assigned the same lane.\n                currentEventTransitionLane = claimNextTransitionLane();\n            }\n            return currentEventTransitionLane;\n        }\n        // transition updates that occur while the async action is still in progress\n        // are treated as part of the action.\n        //\n        // The ideal behavior would be to treat each async function as an independent\n        // action. However, without a mechanism like AsyncContext, we can't tell which\n        // action an update corresponds to. So instead, we entangle them all into one.\n        // The listeners to notify once the entangled scope completes.\n        var currentEntangledListeners = null; // The number of pending async actions in the entangled scope.\n        var currentEntangledPendingCount = 0; // The transition lane shared by all updates in the entangled scope.\n        var currentEntangledLane = NoLane; // A thenable that resolves when the entangled scope completes. It does not\n        // resolve to a particular value because it's only used for suspending the UI\n        // until the async action scope has completed.\n        var currentEntangledActionThenable = null;\n        function entangleAsyncAction(transition, thenable) {\n            // `thenable` is the return value of the async action scope function. Create\n            // a combined thenable that resolves once every entangled scope function\n            // has finished.\n            if (currentEntangledListeners === null) {\n                // There's no outer async action scope. Create a new one.\n                var entangledListeners = currentEntangledListeners = [];\n                currentEntangledPendingCount = 0;\n                currentEntangledLane = requestTransitionLane();\n                var entangledThenable = {\n                    status: 'pending',\n                    value: undefined,\n                    then: function(resolve) {\n                        entangledListeners.push(resolve);\n                    }\n                };\n                currentEntangledActionThenable = entangledThenable;\n            }\n            currentEntangledPendingCount++;\n            thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n            return thenable;\n        }\n        function pingEngtangledActionScope() {\n            if (currentEntangledListeners !== null && --currentEntangledPendingCount === 0) {\n                // All the actions have finished. Close the entangled async action scope\n                // and notify all the listeners.\n                if (currentEntangledActionThenable !== null) {\n                    var fulfilledThenable = currentEntangledActionThenable;\n                    fulfilledThenable.status = 'fulfilled';\n                }\n                var listeners = currentEntangledListeners;\n                currentEntangledListeners = null;\n                currentEntangledLane = NoLane;\n                currentEntangledActionThenable = null;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i];\n                    listener();\n                }\n            }\n        }\n        function chainThenableValue(thenable, result) {\n            // Equivalent to: Promise.resolve(thenable).then(() => result), except we can\n            // cheat a bit since we know that that this thenable is only ever consumed\n            // by React.\n            //\n            // We don't technically require promise support on the client yet, hence this\n            // extra code.\n            var listeners = [];\n            var thenableWithOverride = {\n                status: 'pending',\n                value: null,\n                reason: null,\n                then: function(resolve) {\n                    listeners.push(resolve);\n                }\n            };\n            thenable.then(function(value) {\n                var fulfilledThenable = thenableWithOverride;\n                fulfilledThenable.status = 'fulfilled';\n                fulfilledThenable.value = result;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i];\n                    listener(result);\n                }\n            }, function(error) {\n                var rejectedThenable = thenableWithOverride;\n                rejectedThenable.status = 'rejected';\n                rejectedThenable.reason = error;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i]; // This is a perf hack where we call the `onFulfill` ping function\n                    // instead of `onReject`, because we know that React is the only\n                    // consumer of these promises, and it passes the same listener to both.\n                    // We also know that it will read the error directly off the\n                    // `.reason` field.\n                    listener(undefined);\n                }\n            });\n            return thenableWithOverride;\n        }\n        function peekEntangledActionLane() {\n            return currentEntangledLane;\n        }\n        function peekEntangledActionThenable() {\n            return currentEntangledActionThenable;\n        }\n        var UpdateState = 0;\n        var ReplaceState = 1;\n        var ForceUpdate = 2;\n        var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n        // It should only be read right after calling `processUpdateQueue`, via\n        // `checkHasForceUpdateAfterProcessing`.\n        var hasForceUpdate = false;\n        var didWarnUpdateInsideUpdate;\n        var currentlyProcessingQueue;\n        {\n            didWarnUpdateInsideUpdate = false;\n            currentlyProcessingQueue = null;\n        }\n        function initializeUpdateQueue(fiber) {\n            var queue = {\n                baseState: fiber.memoizedState,\n                firstBaseUpdate: null,\n                lastBaseUpdate: null,\n                shared: {\n                    pending: null,\n                    lanes: NoLanes,\n                    hiddenCallbacks: null\n                },\n                callbacks: null\n            };\n            fiber.updateQueue = queue;\n        }\n        function cloneUpdateQueue(current, workInProgress) {\n            // Clone the update queue from current. Unless it's already a clone.\n            var queue = workInProgress.updateQueue;\n            var currentQueue = current.updateQueue;\n            if (queue === currentQueue) {\n                var clone = {\n                    baseState: currentQueue.baseState,\n                    firstBaseUpdate: currentQueue.firstBaseUpdate,\n                    lastBaseUpdate: currentQueue.lastBaseUpdate,\n                    shared: currentQueue.shared,\n                    callbacks: null\n                };\n                workInProgress.updateQueue = clone;\n            }\n        }\n        function createUpdate(lane) {\n            var update = {\n                lane: lane,\n                tag: UpdateState,\n                payload: null,\n                callback: null,\n                next: null\n            };\n            return update;\n        }\n        function enqueueUpdate(fiber, update, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return null;\n            }\n            var sharedQueue = updateQueue.shared;\n            {\n                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n                    var componentName = getComponentNameFromFiber(fiber);\n                    error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.\\n\\nPlease update the following component: %s', componentName);\n                    didWarnUpdateInsideUpdate = true;\n                }\n            }\n            if (isUnsafeClassRenderPhaseUpdate()) {\n                // This is an unsafe render phase update. Add directly to the update\n                // queue so we can process it immediately during the current render.\n                var pending = sharedQueue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering\n                // this fiber. This is for backwards compatibility in the case where you\n                // update a different component during render phase than the one that is\n                // currently renderings (a pattern that is accompanied by a warning).\n                return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n            } else {\n                return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n            }\n        }\n        function entangleTransitions(root, fiber, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isTransitionLane(lane)) {\n                var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n                // have finished. We can remove them from the shared queue, which represents\n                // a superset of the actually pending lanes. In some cases we may entangle\n                // more than we need to, but that's OK. In fact it's worse if we *don't*\n                // entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n            // Captured updates are updates that are thrown by a child during the render\n            // phase. They should be discarded if the render is aborted. Therefore,\n            // we should only put them on the work-in-progress queue, not the current one.\n            var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n            var current = workInProgress.alternate;\n            if (current !== null) {\n                var currentQueue = current.updateQueue;\n                if (queue === currentQueue) {\n                    // The work-in-progress queue is the same as current. This happens when\n                    // we bail out on a parent fiber that then captures an error thrown by\n                    // a child. Since we want to append the update only to the work-in\n                    // -progress queue, we need to clone the updates. We usually clone during\n                    // processUpdateQueue, but that didn't happen in this case because we\n                    // skipped over the parent when we bailed out.\n                    var newFirst = null;\n                    var newLast = null;\n                    var firstBaseUpdate = queue.firstBaseUpdate;\n                    if (firstBaseUpdate !== null) {\n                        // Loop through the updates and clone them.\n                        var update = firstBaseUpdate;\n                        do {\n                            var clone = {\n                                lane: update.lane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                // When this update is rebased, we should not fire its\n                                // callback again.\n                                callback: null,\n                                next: null\n                            };\n                            if (newLast === null) {\n                                newFirst = newLast = clone;\n                            } else {\n                                newLast.next = clone;\n                                newLast = clone;\n                            } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                            update = update.next;\n                        }while (update !== null); // Append the captured update the end of the cloned list.\n                        if (newLast === null) {\n                            newFirst = newLast = capturedUpdate;\n                        } else {\n                            newLast.next = capturedUpdate;\n                            newLast = capturedUpdate;\n                        }\n                    } else {\n                        // There are no base updates.\n                        newFirst = newLast = capturedUpdate;\n                    }\n                    queue = {\n                        baseState: currentQueue.baseState,\n                        firstBaseUpdate: newFirst,\n                        lastBaseUpdate: newLast,\n                        shared: currentQueue.shared,\n                        callbacks: currentQueue.callbacks\n                    };\n                    workInProgress.updateQueue = queue;\n                    return;\n                }\n            } // Append the update to the end of the list.\n            var lastBaseUpdate = queue.lastBaseUpdate;\n            if (lastBaseUpdate === null) {\n                queue.firstBaseUpdate = capturedUpdate;\n            } else {\n                lastBaseUpdate.next = capturedUpdate;\n            }\n            queue.lastBaseUpdate = capturedUpdate;\n        }\n        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n            switch(update.tag){\n                case ReplaceState:\n                    {\n                        var payload = update.payload;\n                        if (typeof payload === 'function') {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            var nextState = payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                            return nextState;\n                        } // State object\n                        return payload;\n                    }\n                case CaptureUpdate:\n                    {\n                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n                    }\n                // Intentional fallthrough\n                case UpdateState:\n                    {\n                        var _payload = update.payload;\n                        var partialState;\n                        if (typeof _payload === 'function') {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            partialState = _payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        _payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                        } else {\n                            // Partial state object\n                            partialState = _payload;\n                        }\n                        if (partialState === null || partialState === undefined) {\n                            // Null and undefined are treated as no-ops.\n                            return prevState;\n                        } // Merge the partial state and the previous state.\n                        return assign({}, prevState, partialState);\n                    }\n                case ForceUpdate:\n                    {\n                        hasForceUpdate = true;\n                        return prevState;\n                    }\n            }\n            return prevState;\n        }\n        var didReadFromEntangledAsyncAction = false; // Each call to processUpdateQueue should be accompanied by a call to this. It's\n        // only in a separate function because in updateHostRoot, it must happen after\n        // all the context stacks have been pushed to, to prevent a stack mismatch. A\n        // bit unfortunate.\n        function suspendIfUpdateReadFromEntangledAsyncAction() {\n            // Check if this update is part of a pending async action. If so, we'll\n            // need to suspend until the action has finished, so that it's batched\n            // together with future updates in the same action.\n            // TODO: Once we support hooks inside useMemo (or an equivalent\n            // memoization boundary like Forget), hoist this logic so that it only\n            // suspends if the memo boundary produces a new value.\n            if (didReadFromEntangledAsyncAction) {\n                var entangledActionThenable = peekEntangledActionThenable();\n                if (entangledActionThenable !== null) {\n                    // TODO: Instead of the throwing the thenable directly, throw a\n                    // special object like `use` does so we can detect if it's captured\n                    // by userspace.\n                    throw entangledActionThenable;\n                }\n            }\n        }\n        function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n            didReadFromEntangledAsyncAction = false; // This is always non-null on a ClassComponent or HostRoot\n            var queue = workInProgress.updateQueue;\n            hasForceUpdate = false;\n            {\n                currentlyProcessingQueue = queue.shared;\n            }\n            var firstBaseUpdate = queue.firstBaseUpdate;\n            var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n            var pendingQueue = queue.shared.pending;\n            if (pendingQueue !== null) {\n                queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n                // and last so that it's non-circular.\n                var lastPendingUpdate = pendingQueue;\n                var firstPendingUpdate = lastPendingUpdate.next;\n                lastPendingUpdate.next = null; // Append pending updates to base queue\n                if (lastBaseUpdate === null) {\n                    firstBaseUpdate = firstPendingUpdate;\n                } else {\n                    lastBaseUpdate.next = firstPendingUpdate;\n                }\n                lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n                // we need to transfer the updates to that queue, too. Because the base\n                // queue is a singly-linked list with no cycles, we can append to both\n                // lists and take advantage of structural sharing.\n                // TODO: Pass `current` as argument\n                var current = workInProgress.alternate;\n                if (current !== null) {\n                    // This is always non-null on a ClassComponent or HostRoot\n                    var currentQueue = current.updateQueue;\n                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n                    if (currentLastBaseUpdate !== lastBaseUpdate) {\n                        if (currentLastBaseUpdate === null) {\n                            currentQueue.firstBaseUpdate = firstPendingUpdate;\n                        } else {\n                            currentLastBaseUpdate.next = firstPendingUpdate;\n                        }\n                        currentQueue.lastBaseUpdate = lastPendingUpdate;\n                    }\n                }\n            } // These values may change as we process the queue.\n            if (firstBaseUpdate !== null) {\n                // Iterate through the list of updates to compute the result.\n                var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n                // from the original lanes.\n                var newLanes = NoLanes;\n                var newBaseState = null;\n                var newFirstBaseUpdate = null;\n                var newLastBaseUpdate = null;\n                var update = firstBaseUpdate;\n                do {\n                    // An extra OffscreenLane bit is added to updates that were made to\n                    // a hidden tree, so that we can distinguish them from updates that were\n                    // already there when the tree was hidden.\n                    var updateLane = removeLanes(update.lane, OffscreenLane);\n                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n                    // it's not a \"base\" update and we should disregard the extra base lanes\n                    // that were added to renderLanes when we entered the Offscreen tree.\n                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n                    if (shouldSkipUpdate) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            tag: update.tag,\n                            payload: update.payload,\n                            callback: update.callback,\n                            next: null\n                        };\n                        if (newLastBaseUpdate === null) {\n                            newFirstBaseUpdate = newLastBaseUpdate = clone;\n                            newBaseState = newState;\n                        } else {\n                            newLastBaseUpdate = newLastBaseUpdate.next = clone;\n                        } // Update the remaining priority in the queue.\n                        newLanes = mergeLanes(newLanes, updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        // Check if this update is part of a pending async action. If so,\n                        // we'll need to suspend until the action has finished, so that it's\n                        // batched together with future updates in the same action.\n                        if (updateLane !== NoLane && updateLane === peekEntangledActionLane()) {\n                            didReadFromEntangledAsyncAction = true;\n                        }\n                        if (newLastBaseUpdate !== null) {\n                            var _clone = {\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                // When this update is rebased, we should not fire its\n                                // callback again.\n                                callback: null,\n                                next: null\n                            };\n                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n                        } // Process this update.\n                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n                        var callback = update.callback;\n                        if (callback !== null) {\n                            workInProgress.flags |= Callback;\n                            if (isHiddenUpdate) {\n                                workInProgress.flags |= Visibility;\n                            }\n                            var callbacks = queue.callbacks;\n                            if (callbacks === null) {\n                                queue.callbacks = [\n                                    callback\n                                ];\n                            } else {\n                                callbacks.push(callback);\n                            }\n                        }\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    update = update.next;\n                    if (update === null) {\n                        pendingQueue = queue.shared.pending;\n                        if (pendingQueue === null) {\n                            break;\n                        } else {\n                            // An update was scheduled from inside a reducer. Add the new\n                            // pending updates to the end of the list and keep processing.\n                            var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n                            // unravel them when transferring them to the base queue.\n                            var _firstPendingUpdate = _lastPendingUpdate.next;\n                            _lastPendingUpdate.next = null;\n                            update = _firstPendingUpdate;\n                            queue.lastBaseUpdate = _lastPendingUpdate;\n                            queue.shared.pending = null;\n                        }\n                    }\n                }while (true);\n                if (newLastBaseUpdate === null) {\n                    newBaseState = newState;\n                }\n                queue.baseState = newBaseState;\n                queue.firstBaseUpdate = newFirstBaseUpdate;\n                queue.lastBaseUpdate = newLastBaseUpdate;\n                if (firstBaseUpdate === null) {\n                    // `queue.lanes` is used for entangling transitions. We can set it back to\n                    // zero once the queue is empty.\n                    queue.shared.lanes = NoLanes;\n                } // Set the remaining expiration time to be whatever is remaining in the queue.\n                // This should be fine because the only two other things that contribute to\n                // expiration time are props and context. We're already in the middle of the\n                // begin phase by the time we start processing the queue, so we've already\n                // dealt with the props. Context in components that specify\n                // shouldComponentUpdate is tricky; but we'll have to account for\n                // that regardless.\n                markSkippedUpdateLanes(newLanes);\n                workInProgress.lanes = newLanes;\n                workInProgress.memoizedState = newState;\n            }\n            {\n                currentlyProcessingQueue = null;\n            }\n        }\n        function callCallback(callback, context) {\n            if (typeof callback !== 'function') {\n                throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + (\"received: \" + callback));\n            }\n            callback.call(context);\n        }\n        function resetHasForceUpdateBeforeProcessing() {\n            hasForceUpdate = false;\n        }\n        function checkHasForceUpdateAfterProcessing() {\n            return hasForceUpdate;\n        }\n        function deferHiddenCallbacks(updateQueue) {\n            // When an update finishes on a hidden component, its callback should not\n            // be fired until/unless the component is made visible again. Stash the\n            // callback on the shared queue object so it can be fired later.\n            var newHiddenCallbacks = updateQueue.callbacks;\n            if (newHiddenCallbacks !== null) {\n                var existingHiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n                if (existingHiddenCallbacks === null) {\n                    updateQueue.shared.hiddenCallbacks = newHiddenCallbacks;\n                } else {\n                    updateQueue.shared.hiddenCallbacks = existingHiddenCallbacks.concat(newHiddenCallbacks);\n                }\n            }\n        }\n        function commitHiddenCallbacks(updateQueue, context) {\n            // This component is switching from hidden -> visible. Commit any callbacks\n            // that were previously deferred.\n            var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n            if (hiddenCallbacks !== null) {\n                updateQueue.shared.hiddenCallbacks = null;\n                for(var i = 0; i < hiddenCallbacks.length; i++){\n                    var callback = hiddenCallbacks[i];\n                    callCallback(callback, context);\n                }\n            }\n        }\n        function commitCallbacks(updateQueue, context) {\n            var callbacks = updateQueue.callbacks;\n            if (callbacks !== null) {\n                updateQueue.callbacks = null;\n                for(var i = 0; i < callbacks.length; i++){\n                    var callback = callbacks[i];\n                    callCallback(callback, context);\n                }\n            }\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */ function shallowEqual(objA, objB) {\n            if (objectIs(objA, objB)) {\n                return true;\n            }\n            if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n                return false;\n            }\n            var keysA = Object.keys(objA);\n            var keysB = Object.keys(objB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            } // Test for A's keys different from B.\n            for(var i = 0; i < keysA.length; i++){\n                var currentKey = keysA[i];\n                if (!hasOwnProperty.call(objB, currentKey) || // $FlowFixMe[incompatible-use] lost refinement of `objB`\n                !objectIs(objA[currentKey], objB[currentKey])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        var ReactStrictModeWarnings = {\n            recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n            flushPendingUnsafeLifecycleWarnings: function() {},\n            recordLegacyContextWarning: function(fiber, instance) {},\n            flushLegacyContextWarning: function() {},\n            discardPendingWarnings: function() {}\n        };\n        {\n            var findStrictRoot = function(fiber) {\n                var maybeStrictRoot = null;\n                var node = fiber;\n                while(node !== null){\n                    if (node.mode & StrictLegacyMode) {\n                        maybeStrictRoot = node;\n                    }\n                    node = node.return;\n                }\n                return maybeStrictRoot;\n            };\n            var setToSortedString = function(set) {\n                var array = [];\n                set.forEach(function(value) {\n                    array.push(value);\n                });\n                return array.sort().join(', ');\n            };\n            var pendingComponentWillMountWarnings = [];\n            var pendingUNSAFE_ComponentWillMountWarnings = [];\n            var pendingComponentWillReceivePropsWarnings = [];\n            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            var pendingComponentWillUpdateWarnings = [];\n            var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n            var didWarnAboutUnsafeLifecycles = new Set();\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n                // Dedupe strategy: Warn once per component.\n                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n                    return;\n                }\n                if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.\n                instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillMountWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {\n                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillUpdateWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n                // We do an initial pass to gather component names\n                var componentWillMountUniqueNames = new Set();\n                if (pendingComponentWillMountWarnings.length > 0) {\n                    pendingComponentWillMountWarnings.forEach(function(fiber) {\n                        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillMountWarnings = [];\n                }\n                var UNSAFE_componentWillMountUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillMountWarnings = [];\n                }\n                var componentWillReceivePropsUniqueNames = new Set();\n                if (pendingComponentWillReceivePropsWarnings.length > 0) {\n                    pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillReceivePropsWarnings = [];\n                }\n                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                }\n                var componentWillUpdateUniqueNames = new Set();\n                if (pendingComponentWillUpdateWarnings.length > 0) {\n                    pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n                        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillUpdateWarnings = [];\n                }\n                var UNSAFE_componentWillUpdateUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                } // Finally, we flush all the warnings\n                // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n                if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n                    error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '\\nPlease update the following components: %s', sortedNames);\n                }\n                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n                    error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, \" + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n' + '\\nPlease update the following components: %s', _sortedNames);\n                }\n                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n                    error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '\\nPlease update the following components: %s', _sortedNames2);\n                }\n                if (componentWillMountUniqueNames.size > 0) {\n                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n                    warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames3);\n                }\n                if (componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n                    warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, refactor your \" + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames4);\n                }\n                if (componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n                    warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames5);\n                }\n            };\n            var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n            var didWarnAboutLegacyContext = new Set();\n            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n                var strictRoot = findStrictRoot(fiber);\n                if (strictRoot === null) {\n                    error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                    return;\n                } // Dedup strategy: Warn once per component.\n                if (didWarnAboutLegacyContext.has(fiber.type)) {\n                    return;\n                }\n                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n                    if (warningsForRoot === undefined) {\n                        warningsForRoot = [];\n                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n                    }\n                    warningsForRoot.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n                pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n                    if (fiberArray.length === 0) {\n                        return;\n                    }\n                    var firstFiber = fiberArray[0];\n                    var uniqueNames = new Set();\n                    fiberArray.forEach(function(fiber) {\n                        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutLegacyContext.add(fiber.type);\n                    });\n                    var sortedNames = setToSortedString(uniqueNames);\n                    runWithFiberInDEV(firstFiber, function() {\n                        error('Legacy context API has been detected within a strict-mode tree.' + '\\n\\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context', sortedNames);\n                    });\n                });\n            };\n            ReactStrictModeWarnings.discardPendingWarnings = function() {\n                pendingComponentWillMountWarnings = [];\n                pendingUNSAFE_ComponentWillMountWarnings = [];\n                pendingComponentWillReceivePropsWarnings = [];\n                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                pendingComponentWillUpdateWarnings = [];\n                pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                pendingLegacyContextWarning = new Map();\n            };\n        }\n        function getThenablesFromState(state) {\n            {\n                var devState = state;\n                return devState.thenables;\n            }\n        } // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + 'detail of `use` to interrupt the current render. You must either ' + 'rethrow it immediately, or move the `use` call outside of the ' + '`try/catch` block. Capturing without rethrowing will lead to ' + 'unexpected behavior.\\n\\n' + 'To handle async errors, wrap your component in an error boundary, or ' + \"call the promise's `.catch` method and pass the result to `use`\");\n        var SuspenseyCommitException = new Error('Suspense Exception: This is not a real error, and should not leak into ' + \"userspace. If you're seeing this, it's likely a bug in React.\"); // This is a noop thenable that we use to trigger a fallback in throwException.\n        // TODO: It would be better to refactor throwException into multiple functions\n        // so we can trigger a fallback directly without having to check the type. But\n        // for now this will do.\n        var noopSuspenseyCommitThenable = {\n            then: function() {\n                {\n                    error('Internal React error: A listener was unexpectedly attached to a ' + '\"noop\" thenable. This is a bug in React. Please file an issue.');\n                }\n            }\n        };\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            {\n                return {\n                    didWarnAboutUncachedPromise: false,\n                    thenables: []\n                };\n            }\n        }\n        function isThenableResolved(thenable) {\n            var status = thenable.status;\n            return status === 'fulfilled' || status === 'rejected';\n        }\n        function noop$1() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            if (ReactSharedInternals.actQueue !== null) {\n                ReactSharedInternals.didUsePromise = true;\n            }\n            var trackedThenables = getThenablesFromState(thenableState);\n            var previous = trackedThenables[index];\n            if (previous === undefined) {\n                trackedThenables.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    {\n                        var thenableStateDev = thenableState;\n                        if (!thenableStateDev.didWarnAboutUncachedPromise) {\n                            // We should only warn the first time an uncached thenable is\n                            // discovered per component, because if there are multiple, the\n                            // subsequent ones are likely derived from the first.\n                            //\n                            // We track this on the thenableState instead of deduping using the\n                            // component name like we usually do, because in the case of a\n                            // promise-as-React-node, the owner component is likely different from\n                            // the parent that's currently being reconciled. We'd have to track\n                            // the owner using state, which we're trying to move away from. Though\n                            // since this is dev-only, maybe that'd be OK.\n                            //\n                            // However, another benefit of doing it this way is we might\n                            // eventually have a thenableState per memo/Forget boundary instead\n                            // of per component, so this would allow us to have more\n                            // granular warnings.\n                            thenableStateDev.didWarnAboutUncachedPromise = true; // TODO: This warning should link to a corresponding docs page.\n                            error('A component was suspended by an uncached promise. Creating ' + 'promises inside a Client Component or hook is not yet ' + 'supported, except via a Suspense-compatible library or framework.');\n                        }\n                    }\n                    // intentionally ignore.\n                    thenable.then(noop$1, noop$1);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case 'fulfilled':\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case 'rejected':\n                    {\n                        var rejectedError = thenable.reason;\n                        checkIfUseWrappedInAsyncCatch(rejectedError);\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === 'string') {\n                            // Only instrument the thenable if the status if not defined. If\n                            // it's defined, but an unknown value, assume it's been instrumented by\n                            // some custom userspace implementation. We treat it as \"pending\".\n                            // Attach a dummy listener, to ensure that any lazy initialization can\n                            // happen. Flight lazily parses JSON when the value is actually awaited.\n                            thenable.then(noop$1, noop$1);\n                        } else {\n                            // This is an uncached thenable that we haven't seen before.\n                            // Detect infinite ping loops caused by uncached promises.\n                            var root = getWorkInProgressRoot();\n                            if (root !== null && root.shellSuspendCounter > 100) {\n                                // This root has suspended repeatedly in the shell without making any\n                                // progress (i.e. committing something). This is highly suggestive of\n                                // an infinite ping loop, often caused by an accidental Async Client\n                                // Component.\n                                //\n                                // During a transition, we can suspend the work loop until the promise\n                                // to resolve, but this is a sync render, so that's not an option. We\n                                // also can't show a fallback, because none was provided. So our last\n                                // resort is to throw an error.\n                                //\n                                // TODO: Remove this error in a future release. Other ways of handling\n                                // this case include forcing a concurrent render, or putting the whole\n                                // root into offscreen mode.\n                                throw new Error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + \"adding `'use client'` to a module that was originally written \" + 'for the server.');\n                            }\n                            var pendingThenable = thenable;\n                            pendingThenable.status = 'pending';\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === 'pending') {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = 'fulfilled';\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === 'pending') {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = 'rejected';\n                                    rejectedThenable.reason = error;\n                                }\n                            });\n                        } // Check one more time in case the thenable resolved synchronously.\n                        switch(thenable.status){\n                            case 'fulfilled':\n                                {\n                                    var fulfilledThenable = thenable;\n                                    return fulfilledThenable.value;\n                                }\n                            case 'rejected':\n                                {\n                                    var rejectedThenable = thenable;\n                                    var _rejectedError = rejectedThenable.reason;\n                                    checkIfUseWrappedInAsyncCatch(_rejectedError);\n                                    throw _rejectedError;\n                                }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        {\n                            needsToResetSuspendedThenableDEV = true;\n                        }\n                        throw SuspenseException;\n                    }\n            }\n        }\n        function suspendCommit() {\n            // This extra indirection only exists so it can handle passing\n            // noopSuspenseyCommitThenable through to throwException.\n            // TODO: Factor the thenable check out of throwException\n            suspendedThenable = noopSuspenseyCommitThenable;\n            throw SuspenseyCommitException;\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation — which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        var needsToResetSuspendedThenableDEV = false;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error('Expected a suspended thenable. This is a bug in React. Please file ' + 'an issue.');\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            {\n                needsToResetSuspendedThenableDEV = false;\n            }\n            return thenable;\n        }\n        function checkIfUseWrappedInTryCatch() {\n            {\n                // This was set right before SuspenseException was thrown, and it should\n                // have been cleared when the exception was handled. If it wasn't,\n                // it must have been caught by userspace.\n                if (needsToResetSuspendedThenableDEV) {\n                    needsToResetSuspendedThenableDEV = false;\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n            // This check runs in prod, too, because it prevents a more confusing\n            // downstream error, where SuspenseException is caught by a promise and\n            // thrown asynchronously.\n            // TODO: Another way to prevent SuspenseException from leaking into an async\n            // execution context is to check the dispatcher every time `use` is called,\n            // or some equivalent. That might be preferable for other reasons, too, since\n            // it matches how we prevent similar mistakes for other hooks.\n            if (rejectedReason === SuspenseException) {\n                throw new Error('Hooks are not supported inside an async component. This ' + \"error is often caused by accidentally adding `'use client'` \" + 'to a module that was originally written for the server.');\n            }\n        }\n        var thenableState$1 = null;\n        var thenableIndexCounter$1 = 0;\n        function mergeDebugInfo(outer, inner) {\n            if (inner == null) {\n                return outer;\n            } else if (outer === null) {\n                return inner;\n            } else {\n                // If we have two debugInfo, we need to create a new one. This makes the array no longer\n                // live so we'll miss any future updates if we received more so ideally we should always\n                // do this after both have fully resolved/unsuspended.\n                return outer.concat(inner);\n            }\n        }\n        var didWarnAboutMaps;\n        var didWarnAboutGenerators;\n        var ownerHasKeyUseWarning;\n        var ownerHasFunctionTypeWarning;\n        var ownerHasSymbolTypeWarning;\n        var warnForMissingKey = function(child, returnFiber) {};\n        {\n            didWarnAboutMaps = false;\n            didWarnAboutGenerators = false;\n            /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ ownerHasKeyUseWarning = {};\n            ownerHasFunctionTypeWarning = {};\n            ownerHasSymbolTypeWarning = {};\n            warnForMissingKey = function(child, returnFiber) {\n                if (child === null || typeof child !== 'object') {\n                    return;\n                }\n                if (!child._store || (child._store.validated || child.key != null) && child._store.validated !== 2) {\n                    return;\n                }\n                if (typeof child._store !== 'object') {\n                    throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                } // $FlowFixMe[cannot-write] unable to narrow type from mixed to writable object\n                child._store.validated = 1;\n                var componentName = getComponentNameFromFiber(returnFiber);\n                var componentKey = componentName || 'null';\n                if (ownerHasKeyUseWarning[componentKey]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[componentKey] = true;\n                var childOwner = child._owner;\n                var parentOwner = returnFiber._debugOwner;\n                var currentComponentErrorInfo = '';\n                if (parentOwner && typeof parentOwner.tag === 'number') {\n                    var name = getComponentNameFromFiber(parentOwner);\n                    if (name) {\n                        currentComponentErrorInfo = '\\n\\nCheck the render method of `' + name + '`.';\n                    }\n                }\n                if (!currentComponentErrorInfo) {\n                    if (componentName) {\n                        currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\";\n                    }\n                } // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwnerAppendix = '';\n                if (childOwner != null && parentOwner !== childOwner) {\n                    var ownerName = null;\n                    if (typeof childOwner.tag === 'number') {\n                        ownerName = getComponentNameFromFiber(childOwner);\n                    } else if (typeof childOwner.name === 'string') {\n                        ownerName = childOwner.name;\n                    }\n                    if (ownerName) {\n                        // Give the component that originally created this child.\n                        childOwnerAppendix = \" It was passed a child from \" + ownerName + \".\";\n                    }\n                } // We create a fake Fiber for the child to log the stack trace from.\n                // TODO: Refactor the warnForMissingKey calls to happen after fiber creation\n                // so that we can get access to the fiber that will eventually be created.\n                // That way the log can show up associated with the right instance in DevTools.\n                var fiber = createFiberFromElement(child, returnFiber.mode, 0);\n                fiber.return = returnFiber;\n                runWithFiberInDEV(fiber, function() {\n                    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                });\n            };\n        }\n        // We do this here instead of BeginWork because the Fragment fiber doesn't have\n        // the whole props object, only the children and is shared with arrays.\n        function validateFragmentProps(element, fiber, returnFiber) {\n            {\n                var keys = Object.keys(element.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== 'children' && key !== 'key') {\n                        if (fiber === null) {\n                            // For unkeyed root fragments there's no Fiber. We create a fake one just for\n                            // error stack handling.\n                            fiber = createFiberFromElement(element, returnFiber.mode, 0);\n                            fiber.return = returnFiber;\n                        }\n                        runWithFiberInDEV(fiber, function(erroredKey) {\n                            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', erroredKey);\n                        }, key);\n                        break;\n                    }\n                }\n            }\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter$1;\n            thenableIndexCounter$1 += 1;\n            if (thenableState$1 === null) {\n                thenableState$1 = createThenableState();\n            }\n            return trackUsedThenable(thenableState$1, thenable, index);\n        }\n        function coerceRef(returnFiber, current, workInProgress, element) {\n            var ref;\n            {\n                // TODO: This is a temporary, intermediate step. When enableRefAsProp is on,\n                // we should resolve the `ref` prop during the begin phase of the component\n                // it's attached to (HostComponent, ClassComponent, etc).\n                var refProp = element.props.ref;\n                ref = refProp !== undefined ? refProp : null;\n            }\n            // should always read the ref from the prop.\n            workInProgress.ref = ref;\n        }\n        function throwOnInvalidObjectType(returnFiber, newChild) {\n            if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) {\n                throw new Error('A React Element from an older version of React was rendered. ' + 'This is not supported. It can happen if:\\n' + '- Multiple copies of the \"react\" package is used.\\n' + '- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n' + '- A compiler tries to \"inline\" JSX instead of using the runtime.');\n            } // $FlowFixMe[method-unbinding]\n            var childString = Object.prototype.toString.call(newChild);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n        function warnOnFunctionType(returnFiber, invalidChild) {\n            {\n                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';\n                if (ownerHasFunctionTypeWarning[parentName]) {\n                    return;\n                }\n                ownerHasFunctionTypeWarning[parentName] = true;\n                var name = invalidChild.displayName || invalidChild.name || 'Component';\n                if (returnFiber.tag === HostRoot) {\n                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\\n' + '  root.render(%s)', name, name, name);\n                } else {\n                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\\n' + '  <%s>{%s}</%s>', name, name, parentName, name, parentName);\n                }\n            }\n        }\n        function warnOnSymbolType(returnFiber, invalidChild) {\n            {\n                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';\n                if (ownerHasSymbolTypeWarning[parentName]) {\n                    return;\n                }\n                ownerHasSymbolTypeWarning[parentName] = true; // eslint-disable-next-line react-internal/safe-string-coercion\n                var name = String(invalidChild);\n                if (returnFiber.tag === HostRoot) {\n                    error('Symbols are not valid as a React child.\\n' + '  root.render(%s)', name);\n                } else {\n                    error('Symbols are not valid as a React child.\\n' + '  <%s>%s</%s>', parentName, name, parentName);\n                }\n            }\n        }\n        function resolveLazy(lazyType) {\n            {\n                return callLazyInitInDEV(lazyType);\n            }\n        } // This wrapper function exists because I expect to clone the code in each path\n        // to be able to optimize each path individually by branching early. This needs\n        // a compiler or we can do it manually. Helpers that don't need this branching\n        // live outside of this function.\n        function createChildReconciler(shouldTrackSideEffects) {\n            function deleteChild(returnFiber, childToDelete) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return;\n                }\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        childToDelete\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(childToDelete);\n                }\n            }\n            function deleteRemainingChildren(returnFiber, currentFirstChild) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return null;\n                } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n                // assuming that after the first child we've already added everything.\n                var childToDelete = currentFirstChild;\n                while(childToDelete !== null){\n                    deleteChild(returnFiber, childToDelete);\n                    childToDelete = childToDelete.sibling;\n                }\n                return null;\n            }\n            function mapRemainingChildren(currentFirstChild) {\n                // Add the remaining children to a temporary map so that we can find them by\n                // keys quickly. Implicit (null) keys get added to this set with their index\n                // instead.\n                var existingChildren = new Map();\n                var existingChild = currentFirstChild;\n                while(existingChild !== null){\n                    if (existingChild.key !== null) {\n                        existingChildren.set(existingChild.key, existingChild);\n                    } else {\n                        existingChildren.set(existingChild.index, existingChild);\n                    }\n                    existingChild = existingChild.sibling;\n                }\n                return existingChildren;\n            }\n            function useFiber(fiber, pendingProps) {\n                // We currently set sibling to null and index to 0 here because it is easy\n                // to forget to do before returning it. E.g. for the single child case.\n                var clone = createWorkInProgress(fiber, pendingProps);\n                clone.index = 0;\n                clone.sibling = null;\n                return clone;\n            }\n            function placeChild(newFiber, lastPlacedIndex, newIndex) {\n                newFiber.index = newIndex;\n                if (!shouldTrackSideEffects) {\n                    // During hydration, the useId algorithm needs to know which fibers are\n                    // part of a list of children (arrays, iterators).\n                    newFiber.flags |= Forked;\n                    return lastPlacedIndex;\n                }\n                var current = newFiber.alternate;\n                if (current !== null) {\n                    var oldIndex = current.index;\n                    if (oldIndex < lastPlacedIndex) {\n                        // This is a move.\n                        newFiber.flags |= Placement | PlacementDEV;\n                        return lastPlacedIndex;\n                    } else {\n                        // This item can stay in place.\n                        return oldIndex;\n                    }\n                } else {\n                    // This is an insertion.\n                    newFiber.flags |= Placement | PlacementDEV;\n                    return lastPlacedIndex;\n                }\n            }\n            function placeSingleChild(newFiber) {\n                // This is simpler for the single child case. We only need to do a\n                // placement for inserting new children.\n                if (shouldTrackSideEffects && newFiber.alternate === null) {\n                    newFiber.flags |= Placement | PlacementDEV;\n                }\n                return newFiber;\n            }\n            function updateTextNode(returnFiber, current, textContent, lanes, debugInfo) {\n                if (current === null || current.tag !== HostText) {\n                    // Insert\n                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, textContent);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function updateElement(returnFiber, current, element, lanes, debugInfo) {\n                var elementType = element.type;\n                if (elementType === REACT_FRAGMENT_TYPE) {\n                    var updated = updateFragment(returnFiber, current, element.props.children, lanes, element.key, debugInfo);\n                    validateFragmentProps(element, updated, returnFiber);\n                    return updated;\n                }\n                if (current !== null) {\n                    if (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || // Lazy types should reconcile their resolved type.\n                    // We need to do this after the Hot Reloading check above,\n                    // because hot reloading has different semantics than prod because\n                    // it doesn't resuspend. So we can't let the call below suspend.\n                    typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n                        // Move based on index\n                        var existing = useFiber(current, element.props);\n                        coerceRef(returnFiber, current, existing, element);\n                        existing.return = returnFiber;\n                        {\n                            existing._debugOwner = element._owner;\n                            existing._debugInfo = debugInfo;\n                        }\n                        return existing;\n                    }\n                } // Insert\n                var created = createFiberFromElement(element, returnFiber.mode, lanes);\n                coerceRef(returnFiber, current, created, element);\n                created.return = returnFiber;\n                {\n                    created._debugInfo = debugInfo;\n                }\n                return created;\n            }\n            function updatePortal(returnFiber, current, portal, lanes, debugInfo) {\n                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n                    // Insert\n                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, portal.children || []);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function updateFragment(returnFiber, current, fragment, lanes, key, debugInfo) {\n                if (current === null || current.tag !== Fragment) {\n                    // Insert\n                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, fragment);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function createChild(returnFiber, newChild, lanes, debugInfo) {\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                                coerceRef(returnFiber, null, _created, newChild);\n                                _created.return = returnFiber;\n                                {\n                                    _created._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);\n                                }\n                                return _created;\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                                _created2.return = returnFiber;\n                                {\n                                    _created2._debugInfo = debugInfo;\n                                }\n                                return _created2;\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var resolvedChild;\n                                {\n                                    resolvedChild = callLazyInitInDEV(newChild);\n                                }\n                                return createChild(returnFiber, resolvedChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo) // call merge after init\n                                );\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n                        _created3.return = returnFiber;\n                        {\n                            _created3._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);\n                        }\n                        return _created3;\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return createChild(returnFiber, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return createChild(returnFiber, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            function updateSlot(returnFiber, oldFiber, newChild, lanes, debugInfo) {\n                // Update the fiber if the keys match, otherwise return null.\n                var key = oldFiber !== null ? oldFiber.key : null;\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    if (key !== null) {\n                        return null;\n                    }\n                    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes, debugInfo);\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updateElement(returnFiber, oldFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updatePortal(returnFiber, oldFiber, newChild, lanes, debugInfo);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var resolvedChild;\n                                {\n                                    resolvedChild = callLazyInitInDEV(newChild);\n                                }\n                                return updateSlot(returnFiber, oldFiber, resolvedChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        if (key !== null) {\n                            return null;\n                        }\n                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return updateSlot(returnFiber, oldFiber, unwrapThenable(thenable), lanes, debugInfo);\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes, debugInfo) {\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys, so we neither have to check the old nor\n                    // new node for the key. If both are text nodes, they match.\n                    var matchedFiber = existingChildren.get(newIdx) || null;\n                    return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes, debugInfo);\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updateElement(returnFiber, _matchedFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes, debugInfo);\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var resolvedChild;\n                                {\n                                    resolvedChild = callLazyInitInDEV(newChild);\n                                }\n                                return updateFromMap(existingChildren, returnFiber, newIdx, resolvedChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(thenable), lanes, debugInfo);\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            /**\n   * Warns if there is a duplicate or missing key\n   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {\n                {\n                    if (typeof child !== 'object' || child === null) {\n                        return knownKeys;\n                    }\n                    switch(child.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                        case REACT_PORTAL_TYPE:\n                            warnForMissingKey(child, returnFiber);\n                            var key = child.key;\n                            if (typeof key !== 'string') {\n                                break;\n                            }\n                            if (knownKeys === null) {\n                                knownKeys = new Set();\n                                knownKeys.add(key);\n                                break;\n                            }\n                            if (!knownKeys.has(key)) {\n                                knownKeys.add(key);\n                                break;\n                            }\n                            error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);\n                            break;\n                        case REACT_LAZY_TYPE:\n                            {\n                                var resolvedChild;\n                                {\n                                    resolvedChild = callLazyInitInDEV(child);\n                                }\n                                warnOnInvalidKey(resolvedChild, knownKeys, returnFiber);\n                                break;\n                            }\n                    }\n                }\n                return knownKeys;\n            }\n            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes, debugInfo) {\n                // This algorithm can't optimize by searching from both ends since we\n                // don't have backpointers on fibers. I'm trying to see how far we can get\n                // with that model. If it ends up not being worth the tradeoffs, we can\n                // add it later.\n                // Even with a two ended optimization, we'd want to optimize for the case\n                // where there are few changes and brute force the comparison instead of\n                // going for the Map. It'd like to explore hitting that path first in\n                // forward-only mode and only go for the Map once we notice that we need\n                // lots of look ahead. This doesn't handle reversal as well as two ended\n                // search but that's unusual. Besides, for the two ended optimization to\n                // work on Iterables, we'd need to copy the whole set.\n                // In this first iteration, we'll just live with hitting the bad case\n                // (adding everything to a Map) in for every insert/move.\n                // If you change this code, also update reconcileChildrenIterator() which\n                // uses the same algorithm.\n                {\n                    // First, validate keys.\n                    var knownKeys = null;\n                    for(var i = 0; i < newChildren.length; i++){\n                        var child = newChildren[i];\n                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                    }\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes, debugInfo);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (newIdx === newChildren.length) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; newIdx < newChildren.length; newIdx++){\n                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes, debugInfo);\n                        if (_newFiber === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber;\n                        } else {\n                            previousNewFiber.sibling = _newFiber;\n                        }\n                        previousNewFiber = _newFiber;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; newIdx < newChildren.length; newIdx++){\n                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes, debugInfo);\n                    if (_newFiber2 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber2.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber2;\n                        } else {\n                            previousNewFiber.sibling = _newFiber2;\n                        }\n                        previousNewFiber = _newFiber2;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks2 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks2);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileChildrenIteratable(returnFiber, currentFirstChild, newChildrenIterable, lanes, debugInfo) {\n                // This is the same implementation as reconcileChildrenArray(),\n                // but using the iterator instead.\n                var iteratorFn = getIteratorFn(newChildrenIterable);\n                if (typeof iteratorFn !== 'function') {\n                    throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n                }\n                var newChildren = iteratorFn.call(newChildrenIterable);\n                {\n                    if (newChildren === newChildrenIterable) {\n                        // We don't support rendering Generators as props because it's a mutation.\n                        // See https://github.com/facebook/react/issues/12995\n                        // We do support generators if they were created by a GeneratorFunction component\n                        // as its direct child since we can recreate those by rerendering the component\n                        // as needed.\n                        var isGeneratorComponent = returnFiber.tag === FunctionComponent && // $FlowFixMe[method-unbinding]\n                        Object.prototype.toString.call(returnFiber.type) === '[object GeneratorFunction]' && // $FlowFixMe[method-unbinding]\n                        Object.prototype.toString.call(newChildren) === '[object Generator]';\n                        if (!isGeneratorComponent) {\n                            if (!didWarnAboutGenerators) {\n                                error('Using Iterators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. You can also use an ' + 'Iterable that can iterate multiple times over the same items.');\n                            }\n                            didWarnAboutGenerators = true;\n                        }\n                    } else if (newChildrenIterable.entries === iteratorFn) {\n                        // Warn about using Maps as children\n                        if (!didWarnAboutMaps) {\n                            error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n                            didWarnAboutMaps = true;\n                        }\n                    }\n                }\n                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes, debugInfo);\n            }\n            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes, debugInfo) {\n                if (newChildren == null) {\n                    throw new Error('An iterable object provided no iterator.');\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                var knownKeys = null;\n                var step = newChildren.next();\n                {\n                    knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber);\n                }\n                for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes, debugInfo);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (step.done) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                        var _newFiber3 = createChild(returnFiber, step.value, lanes, debugInfo);\n                        if (_newFiber3 === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber3;\n                        } else {\n                            previousNewFiber.sibling = _newFiber3;\n                        }\n                        previousNewFiber = _newFiber3;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks3 = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks3);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes, debugInfo);\n                    if (_newFiber4 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber4.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber4;\n                        } else {\n                            previousNewFiber.sibling = _newFiber4;\n                        }\n                        previousNewFiber = _newFiber4;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks4 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks4);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n                // There's no need to check for keys on text nodes since we don't have a\n                // way to define them.\n                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n                    // We already have an existing node so let's just update it and delete\n                    // the rest.\n                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                    var existing = useFiber(currentFirstChild, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                } // The existing first child is not a text node so we need to create one\n                // and delete the existing ones.\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            }\n            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes, debugInfo) {\n                var key = element.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        var elementType = element.type;\n                        if (elementType === REACT_FRAGMENT_TYPE) {\n                            if (child.tag === Fragment) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var existing = useFiber(child, element.props.children);\n                                existing.return = returnFiber;\n                                {\n                                    existing._debugOwner = element._owner;\n                                    existing._debugInfo = debugInfo;\n                                }\n                                validateFragmentProps(element, existing, returnFiber);\n                                return existing;\n                            }\n                        } else {\n                            if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.\n                            // We need to do this after the Hot Reloading check above,\n                            // because hot reloading has different semantics than prod because\n                            // it doesn't resuspend. So we can't let the call below suspend.\n                            typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var _existing = useFiber(child, element.props);\n                                coerceRef(returnFiber, child, _existing, element);\n                                _existing.return = returnFiber;\n                                {\n                                    _existing._debugOwner = element._owner;\n                                    _existing._debugInfo = debugInfo;\n                                }\n                                return _existing;\n                            }\n                        } // Didn't match.\n                        deleteRemainingChildren(returnFiber, child);\n                        break;\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                if (element.type === REACT_FRAGMENT_TYPE) {\n                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    validateFragmentProps(element, created, returnFiber);\n                    return created;\n                } else {\n                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n                    coerceRef(returnFiber, currentFirstChild, _created4, element);\n                    _created4.return = returnFiber;\n                    {\n                        _created4._debugInfo = debugInfo;\n                    }\n                    return _created4;\n                }\n            }\n            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes, debugInfo) {\n                var key = portal.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                            deleteRemainingChildren(returnFiber, child.sibling);\n                            var existing = useFiber(child, portal.children || []);\n                            existing.return = returnFiber;\n                            return existing;\n                        } else {\n                            deleteRemainingChildren(returnFiber, child);\n                            break;\n                        }\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            } // This API will tag the children with the side-effect of the reconciliation\n            // itself. They will be added to the side-effect list as we pass through the\n            // children and the parent.\n            function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, debugInfo) {\n                // This function is only recursive for Usables/Lazy and not nested arrays.\n                // That's so that using a Lazy wrapper is unobservable to the Fragment\n                // convention.\n                // If the top level item is an array, we treat it as a set of children,\n                // not as a fragment. Nested arrays on the other hand will be treated as\n                // fragment nodes. Recursion happens at the normal flow.\n                // Handle top level unkeyed fragments as if they were arrays.\n                // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n                // We treat the ambiguous cases above the same.\n                // We don't use recursion here because a fragment inside a fragment\n                // is no longer considered \"top level\" for these purposes.\n                var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n                if (isUnkeyedTopLevelFragment) {\n                    validateFragmentProps(newChild, null, returnFiber);\n                    newChild = newChild.props.children;\n                } // Handle object types\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo)));\n                        case REACT_PORTAL_TYPE:\n                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_LAZY_TYPE:\n                            var payload = newChild._payload;\n                            var init = newChild._init;\n                            return reconcileChildFibersImpl(returnFiber, currentFirstChild, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (isArray(newChild)) {\n                        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (getIteratorFn(newChild)) {\n                        return reconcileChildrenIteratable(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    // a child position, it unwraps it using the same algorithm as `use`. For\n                    // example, for promises, React will throw an exception to unwind the\n                    // stack, then replay the component once the promise resolves.\n                    //\n                    // A difference from `use` is that React will keep unwrapping the value\n                    // until it reaches a non-Usable type.\n                    //\n                    // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                    //\n                    // The structure is a bit unfortunate. Ideally, we shouldn't need to\n                    // replay the entire begin phase of the parent fiber in order to reconcile\n                    // the children again. This would require a somewhat significant refactor,\n                    // because reconcilation happens deep within the begin phase, and\n                    // depending on the type of work, not always at the end. We should\n                    // consider as an future improvement.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, thenable._debugInfo));\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return deleteRemainingChildren(returnFiber, currentFirstChild);\n            }\n            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n                // This indirection only exists so we can reset `thenableState` at the end.\n                // It should get inlined by Closure.\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, null // debugInfo\n                );\n                thenableState$1 = null; // Don't bother to reset `thenableIndexCounter` to 0 because it always gets\n                // set at the beginning.\n                return firstChildFiber;\n            }\n            return reconcileChildFibers;\n        }\n        var reconcileChildFibers = createChildReconciler(true);\n        var mountChildFibers = createChildReconciler(false);\n        function resetChildReconcilerOnUnwind() {\n            // On unwind, clear any pending thenables that were used.\n            thenableState$1 = null;\n            thenableIndexCounter$1 = 0;\n        }\n        function cloneChildFibers(current, workInProgress) {\n            if (current !== null && workInProgress.child !== current.child) {\n                throw new Error('Resuming work not yet implemented.');\n            }\n            if (workInProgress.child === null) {\n                return;\n            }\n            var currentChild = workInProgress.child;\n            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n            workInProgress.child = newChild;\n            newChild.return = workInProgress;\n            while(currentChild.sibling !== null){\n                currentChild = currentChild.sibling;\n                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n                newChild.return = workInProgress;\n            }\n            newChild.sibling = null;\n        } // Reset a workInProgress child set to prepare it for a second pass.\n        function resetChildFibers(workInProgress, lanes) {\n            var child = workInProgress.child;\n            while(child !== null){\n                resetWorkInProgress(child, lanes);\n                child = child.sibling;\n            }\n        }\n        // TODO: This isn't being used yet, but it's intended to replace the\n        // InvisibleParentContext that is currently managed by SuspenseContext.\n        var currentTreeHiddenStackCursor = createCursor(null);\n        var prevEntangledRenderLanesCursor = createCursor(NoLanes);\n        function pushHiddenContext(fiber, context) {\n            var prevEntangledRenderLanes = getEntangledRenderLanes();\n            push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n            push(currentTreeHiddenStackCursor, context, fiber); // When rendering a subtree that's currently hidden, we must include all\n            // lanes that would have rendered if the hidden subtree hadn't been deferred.\n            // That is, in order to reveal content from hidden -> visible, we must commit\n            // all the updates that we skipped when we originally hid the tree.\n            setEntangledRenderLanes(mergeLanes(prevEntangledRenderLanes, context.baseLanes));\n        }\n        function reuseHiddenContextOnStack(fiber) {\n            // This subtree is not currently hidden, so we don't need to add any lanes\n            // to the render lanes. But we still need to push something to avoid a\n            // context mismatch. Reuse the existing context on the stack.\n            push(prevEntangledRenderLanesCursor, getEntangledRenderLanes(), fiber);\n            push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n        }\n        function popHiddenContext(fiber) {\n            // Restore the previous render lanes from the stack\n            setEntangledRenderLanes(prevEntangledRenderLanesCursor.current);\n            pop(currentTreeHiddenStackCursor, fiber);\n            pop(prevEntangledRenderLanesCursor, fiber);\n        }\n        function isCurrentTreeHidden() {\n            return currentTreeHiddenStackCursor.current !== null;\n        }\n        // suspends, i.e. it's the nearest `catch` block on the stack.\n        var suspenseHandlerStackCursor = createCursor(null); // Represents the outermost boundary that is not visible in the current tree.\n        // Everything above this is the \"shell\". When this is null, it means we're\n        // rendering in the shell of the app. If it's non-null, it means we're rendering\n        // deeper than the shell, inside a new tree that wasn't already visible.\n        //\n        // The main way we use this concept is to determine whether showing a fallback\n        // would result in a desirable or undesirable loading state. Activing a fallback\n        // in the shell is considered an undersirable loading state, because it would\n        // mean hiding visible (albeit stale) content in the current tree — we prefer to\n        // show the stale content, rather than switch to a fallback. But showing a\n        // fallback in a new tree is fine, because there's no stale content to\n        // prefer instead.\n        var shellBoundary = null;\n        function getShellBoundary() {\n            return shellBoundary;\n        }\n        function pushPrimaryTreeSuspenseHandler(handler) {\n            // TODO: Pass as argument\n            var current = handler.alternate;\n            // propagated a single level. For example, when ForceSuspenseFallback is set,\n            // it should only force the nearest Suspense boundary into fallback mode.\n            pushSuspenseListContext(handler, setDefaultShallowSuspenseListContext(suspenseStackCursor.current)); // Experimental feature: Some Suspense boundaries are marked as having an\n            // to push a nested Suspense handler, because it will get replaced by the\n            // outer fallback, anyway. Consider this as a future optimization.\n            push(suspenseHandlerStackCursor, handler, handler);\n            if (shellBoundary === null) {\n                if (current === null || isCurrentTreeHidden()) {\n                    // This boundary is not visible in the current UI.\n                    shellBoundary = handler;\n                } else {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        // This boundary is showing a fallback in the current UI.\n                        shellBoundary = handler;\n                    }\n                }\n            }\n        }\n        function pushFallbackTreeSuspenseHandler(fiber) {\n            // We're about to render the fallback. If something in the fallback suspends,\n            // it's akin to throwing inside of a `catch` block. This boundary should not\n            // capture. Reuse the existing handler on the stack.\n            reuseSuspenseHandlerOnStack(fiber);\n        }\n        function pushOffscreenSuspenseHandler(fiber) {\n            if (fiber.tag === OffscreenComponent) {\n                // A SuspenseList context is only pushed here to avoid a push/pop mismatch.\n                // Reuse the current value on the stack.\n                // TODO: We can avoid needing to push here by by forking popSuspenseHandler\n                // into separate functions for Suspense and Offscreen.\n                pushSuspenseListContext(fiber, suspenseStackCursor.current);\n                push(suspenseHandlerStackCursor, fiber, fiber);\n                if (shellBoundary !== null) ;\n                else {\n                    var current = fiber.alternate;\n                    if (current !== null) {\n                        var prevState = current.memoizedState;\n                        if (prevState !== null) {\n                            // This is the first boundary in the stack that's already showing\n                            // a fallback. So everything outside is considered the shell.\n                            shellBoundary = fiber;\n                        }\n                    }\n                }\n            } else {\n                // This is a LegacyHidden component.\n                reuseSuspenseHandlerOnStack(fiber);\n            }\n        }\n        function reuseSuspenseHandlerOnStack(fiber) {\n            pushSuspenseListContext(fiber, suspenseStackCursor.current);\n            push(suspenseHandlerStackCursor, getSuspenseHandler(), fiber);\n        }\n        function getSuspenseHandler() {\n            return suspenseHandlerStackCursor.current;\n        }\n        function popSuspenseHandler(fiber) {\n            pop(suspenseHandlerStackCursor, fiber);\n            if (shellBoundary === fiber) {\n                // Popping back into the shell.\n                shellBoundary = null;\n            }\n            popSuspenseListContext(fiber);\n        } // SuspenseList context\n        // TODO: Move to a separate module? We may change the SuspenseList\n        // implementation to hide/show in the commit phase, anyway.\n        var DefaultSuspenseContext = 0;\n        var SubtreeSuspenseContextMask = 1; // ForceSuspenseFallback can be used by SuspenseList to force newly added\n        // items into their fallback state during one of the render passes.\n        var ForceSuspenseFallback = 2;\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n        function hasSuspenseListContext(parentContext, flag) {\n            return (parentContext & flag) !== 0;\n        }\n        function setDefaultShallowSuspenseListContext(parentContext) {\n            return parentContext & SubtreeSuspenseContextMask;\n        }\n        function setShallowSuspenseListContext(parentContext, shallowContext) {\n            return parentContext & SubtreeSuspenseContextMask | shallowContext;\n        }\n        function pushSuspenseListContext(fiber, newContext) {\n            push(suspenseStackCursor, newContext, fiber);\n        }\n        function popSuspenseListContext(fiber) {\n            pop(suspenseStackCursor, fiber);\n        }\n        // A non-null SuspenseState means that it is blocked for one reason or another.\n        // - A non-null dehydrated field means it's blocked pending hydration.\n        //   - A non-null dehydrated field can use isSuspenseInstancePending or\n        //     isSuspenseInstanceFallback to query the reason for being dehydrated.\n        // - A null dehydrated field means it's blocked by something suspending and\n        //   we're currently showing a fallback instead.\n        function findFirstSuspended(row) {\n            var node = row;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        var dehydrated = state.dehydrated;\n                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                            return node;\n                        }\n                    }\n                } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n                // keep track of whether it suspended or not.\n                node.memoizedProps.revealOrder !== undefined) {\n                    var didSuspend = (node.flags & DidCapture) !== NoFlags$1;\n                    if (didSuspend) {\n                        return node;\n                    }\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === row) {\n                    return null;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === row) {\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n            return null;\n        }\n        var NoFlags = /*   */ 0; // Represents whether effect should fire.\n        var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.\n        var Insertion = /* */ 2;\n        var Layout = /*    */ 4;\n        var Passive = /*   */ 8;\n        var didWarnAboutMismatchedHooksForComponent;\n        var didWarnUncachedGetSnapshot;\n        var didWarnAboutUseWrappedInTryCatch;\n        var didWarnAboutAsyncClientComponent;\n        var didWarnAboutUseFormState;\n        {\n            didWarnAboutMismatchedHooksForComponent = new Set();\n            didWarnAboutUseWrappedInTryCatch = new Set();\n            didWarnAboutAsyncClientComponent = new Set();\n            didWarnAboutUseFormState = new Set();\n        }\n        // lifetime of an effect. In Rust terms, a RefCell. We use it to store the\n        // \"destroy\" function that is returned from an effect, because that is stateful.\n        // The field is `undefined` if the effect is unmounted, or if the effect ran\n        // but is not stateful. We don't explicitly track whether the effect is mounted\n        // or unmounted because that can be inferred by the hiddenness of the fiber in\n        // the tree, i.e. whether there is a hidden Offscreen fiber above it.\n        //\n        // It's unfortunate that this is stored on a separate object, because it adds\n        // more memory per effect instance, but it's conceptually sound. I think there's\n        // likely a better data structure we could use for effects; perhaps just one\n        // array of effect instances per fiber. But I think this is OK for now despite\n        // the additional memory and we can follow up with performance\n        // optimizations later.\n        // These are set right before calling the component.\n        var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n        // the work-in-progress hook.\n        var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n        // current hook list is the list that belongs to the current fiber. The\n        // work-in-progress hook list is a new list that will be added to the\n        // work-in-progress fiber.\n        var currentHook = null;\n        var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n        // does not get reset if we do another render pass; only when we're completely\n        // finished evaluating this component. This is an optimization so we know\n        // whether we need to clear render phase updates after a throw.\n        var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n        // gets reset after each attempt.\n        // TODO: Maybe there's some way to consolidate this with\n        // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n        var didScheduleRenderPhaseUpdateDuringThisPass = false;\n        var shouldDoubleInvokeUserFnsInHooksDEV = false; // Counts the number of useId hooks in this component.\n        var localIdCounter = 0; // Counts number of `use`-d thenables\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Used for ids that are generated completely client-side (i.e. not during\n        // hydration). This counter is global, so client ids are not stable across\n        // render attempts.\n        var globalClientIdCounter = 0;\n        var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n        // The list stores the order of hooks used during the initial render (mount).\n        // Subsequent renders (updates) reference this list.\n        var hookTypesDev = null;\n        var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n        // the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n        // When true, such Hooks will always be \"remounted\". Only used during hot reload.\n        var ignorePreviousDependencies = false;\n        function mountHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev === null) {\n                    hookTypesDev = [\n                        hookName\n                    ];\n                } else {\n                    hookTypesDev.push(hookName);\n                }\n            }\n        }\n        function updateHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev !== null) {\n                    hookTypesUpdateIndexDev++;\n                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n                        warnOnHookMismatchInDev(hookName);\n                    }\n                }\n            }\n        }\n        function checkDepsAreArrayDev(deps) {\n            {\n                if (deps !== undefined && deps !== null && !isArray(deps)) {\n                    // Verify deps, but only on mount to avoid extra checks.\n                    // It's unlikely their type would change as usually you define them inline.\n                    error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n                }\n            }\n        }\n        function warnOnHookMismatchInDev(currentHookName) {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n                    didWarnAboutMismatchedHooksForComponent.add(componentName);\n                    if (hookTypesDev !== null) {\n                        var table = '';\n                        var secondColumnStart = 30;\n                        for(var i = 0; i <= hookTypesUpdateIndexDev; i++){\n                            var oldHookName = hookTypesDev[i];\n                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                            var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n                            // lol @ IE not supporting String#repeat\n                            while(row.length < secondColumnStart){\n                                row += ' ';\n                            }\n                            row += newHookName + '\\n';\n                            table += row;\n                        }\n                        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n                    }\n                }\n            }\n        }\n        function warnOnUseFormStateInDev() {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutUseFormState.has(componentName)) {\n                    didWarnAboutUseFormState.add(componentName);\n                    error('ReactDOM.useFormState has been renamed to React.useActionState. ' + 'Please update %s to use React.useActionState.', componentName);\n                }\n            }\n        }\n        function warnIfAsyncClientComponent(Component) {\n            {\n                // This dev-only check only works for detecting native async functions,\n                // not transpiled ones. There's also a prod check that we use to prevent\n                // async client components from crashing the app; the prod one works even\n                // for transpiled async functions. Neither mechanism is completely\n                // bulletproof but together they cover the most common cases.\n                var isAsyncFunction = Object.prototype.toString.call(Component) === '[object AsyncFunction]' || // $FlowIgnore[method-unbinding]\n                Object.prototype.toString.call(Component) === '[object AsyncGeneratorFunction]';\n                if (isAsyncFunction) {\n                    // Encountered an async Client Component. This is not yet supported.\n                    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                    if (!didWarnAboutAsyncClientComponent.has(componentName)) {\n                        didWarnAboutAsyncClientComponent.add(componentName);\n                        error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + \"adding `'use client'` to a module that was originally written \" + 'for the server.');\n                    }\n                }\n            }\n        }\n        function throwInvalidHookError() {\n            throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            {\n                if (ignorePreviousDependencies) {\n                    // Only true when this component is being hot reloaded.\n                    return false;\n                }\n            }\n            if (prevDeps === null) {\n                {\n                    error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, \"[\" + prevDeps.join(', ') + \"]\", \"[\" + nextDeps.join(', ') + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n            renderLanes = nextRenderLanes;\n            currentlyRenderingFiber$1 = workInProgress;\n            {\n                hookTypesDev = current !== null ? current._debugHookTypes : null;\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n                warnIfAsyncClientComponent(Component);\n            }\n            workInProgress.memoizedState = null;\n            workInProgress.updateQueue = null;\n            workInProgress.lanes = NoLanes; // The following should have already been reset\n            // currentHook = null;\n            // workInProgressHook = null;\n            // didScheduleRenderPhaseUpdate = false;\n            // localIdCounter = 0;\n            // thenableIndexCounter = 0;\n            // thenableState = null;\n            // TODO Warn if no hooks are used at all during mount, then some are used during update.\n            // Currently we will identify the update render as a mount because memoizedState === null.\n            // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n            // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n            // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n            // so memoizedState would be null during updates and mounts.\n            {\n                if (current !== null && current.memoizedState !== null) {\n                    ReactSharedInternals.H = HooksDispatcherOnUpdateInDEV;\n                } else if (hookTypesDev !== null) {\n                    // This dispatcher handles an edge case where a component is updating,\n                    // but no stateful hooks have been used.\n                    // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n                    // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n                    // This dispatcher does that.\n                    ReactSharedInternals.H = HooksDispatcherOnMountWithHookTypesInDEV;\n                } else {\n                    ReactSharedInternals.H = HooksDispatcherOnMountInDEV;\n                }\n            }\n            // help detect side effects. The logic for how this is implemented for in\n            // hook components is a bit complex so let's break it down.\n            //\n            // We will invoke the entire component function twice. However, during the\n            // second invocation of the component, the hook state from the first\n            // invocation will be reused. That means things like `useMemo` functions won't\n            // run again, because the deps will match and the memoized result will\n            // be reused.\n            //\n            // We want memoized functions to run twice, too, so account for this, user\n            // functions are double invoked during the *first* invocation of the component\n            // function, and are *not* double invoked during the second incovation:\n            //\n            // - First execution of component function: user functions are double invoked\n            // - Second execution of component function (in Strict Mode, during\n            //   development): user functions are not double invoked.\n            //\n            // This is intentional for a few reasons; most importantly, it's because of\n            // how `use` works when something suspends: it reuses the promise that was\n            // passed during the first attempt. This is itself a form of memoization.\n            // We need to be able to memoize the reactive inputs to the `use` call using\n            // a hook (i.e. `useMemo`), which means, the reactive inputs to `use` must\n            // come from the same component invocation as the output.\n            //\n            // There are plenty of tests to ensure this behavior is correct.\n            var shouldDoubleRenderDEV = (workInProgress.mode & StrictLegacyMode) !== NoMode;\n            shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;\n            var children = callComponentInDEV(Component, props, secondArg);\n            shouldDoubleInvokeUserFnsInHooksDEV = false; // Check if there was a render phase update\n            if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                // Keep rendering until the component stabilizes (there are no more render\n                // phase updates).\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            }\n            if (shouldDoubleRenderDEV) {\n                // In development, components are invoked twice to help detect side effects.\n                setIsStrictModeForDevtools(true);\n                try {\n                    children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n                } finally{\n                    setIsStrictModeForDevtools(false);\n                }\n            }\n            finishRenderingHooks(current, workInProgress);\n            return children;\n        }\n        function finishRenderingHooks(current, workInProgress, Component) {\n            {\n                workInProgress._debugHookTypes = hookTypesDev;\n            }\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactSharedInternals.H = ContextOnlyDispatcher; // This check uses currentHook so that it works the same in DEV and prod bundles.\n            // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                currentHookNameInDev = null;\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n                // render. If this fires, it suggests that we incorrectly reset the static\n                // flags in some other part of the codebase. This has happened before, for\n                // example, in the SuspenseList implementation.\n                if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // and creates false positives. To make this work in legacy mode, we'd\n                // need to mark fibers that commit in an incomplete state, somehow. For\n                // now I'll disable the warning that most of the bugs that would trigger\n                // it are either exclusive to concurrent mode or exist in both.\n                disableLegacyMode) {\n                    error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n                }\n            }\n            didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n            // localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = null;\n            if (didRenderTooFewHooks) {\n                throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n            }\n            {\n                if (checkIfUseWrappedInTryCatch()) {\n                    var componentName = getComponentNameFromFiber(workInProgress) || 'Unknown';\n                    if (!didWarnAboutUseWrappedInTryCatch.has(componentName) && // This warning also fires if you suspend with `use` inside an\n                    // async component. Since we warn for that above, we'll silence this\n                    // second warning by checking here.\n                    !didWarnAboutAsyncClientComponent.has(componentName)) {\n                        didWarnAboutUseWrappedInTryCatch.add(componentName);\n                        error('`use` was called from inside a try/catch block. This is not allowed ' + 'and can lead to unexpected behavior. To handle errors triggered ' + 'by `use`, wrap your component in a error boundary.');\n                    }\n                }\n            }\n        }\n        function replaySuspendedComponentWithHooks(current, workInProgress, Component, props, secondArg) {\n            // This function is used to replay a component that previously suspended,\n            // after its data resolves.\n            //\n            // It's a simplified version of renderWithHooks, but it doesn't need to do\n            // most of the set up work because they weren't reset when we suspended; they\n            // only get reset when the component either completes (finishRenderingHooks)\n            // or unwinds (resetHooksOnUnwind).\n            {\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n            }\n            var children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            finishRenderingHooks(current, workInProgress);\n            return children;\n        }\n        function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n            // This is used to perform another render pass. It's used when setState is\n            // called during render, and for double invoking components in Strict Mode\n            // during development.\n            //\n            // The state from the previous pass is reused whenever possible. So, state\n            // updates that were already processed are not processed again, and memoized\n            // functions (`useMemo`) are not invoked again.\n            //\n            // Keep rendering in a loop for as long as render phase updates continue to\n            // be scheduled. Use a counter to prevent infinite loops.\n            currentlyRenderingFiber$1 = workInProgress;\n            var numberOfReRenders = 0;\n            var children;\n            do {\n                if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                    // It's possible that a use() value depended on a state that was updated in\n                    // this rerender, so we need to watch for different thenables this time.\n                    thenableState = null;\n                }\n                thenableIndexCounter = 0;\n                didScheduleRenderPhaseUpdateDuringThisPass = false;\n                if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                    throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n                }\n                numberOfReRenders += 1;\n                {\n                    // Even when hot reloading, allow dependencies to stabilize\n                    // after first render to prevent infinite render phase updates.\n                    ignorePreviousDependencies = false;\n                }\n                currentHook = null;\n                workInProgressHook = null;\n                workInProgress.updateQueue = null;\n                {\n                    // Also validate hook order for cascading updates.\n                    hookTypesUpdateIndexDev = -1;\n                }\n                ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n                children = callComponentInDEV(Component, props, secondArg);\n            }while (didScheduleRenderPhaseUpdateDuringThisPass);\n            return children;\n        }\n        function renderTransitionAwareHostComponentWithHooks(current, workInProgress, lanes) {\n            return renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, lanes);\n        }\n        function TransitionAwareHostComponent() {\n            var dispatcher = ReactSharedInternals.H;\n            var _dispatcher$useState = dispatcher.useState(), maybeThenable = _dispatcher$useState[0];\n            var nextState;\n            if (typeof maybeThenable.then === 'function') {\n                var thenable = maybeThenable;\n                nextState = useThenable(thenable);\n            } else {\n                var status = maybeThenable;\n                nextState = status;\n            } // The \"reset state\" is an object. If it changes, that means something\n            // requested that we reset the form.\n            var _dispatcher$useState2 = dispatcher.useState(), nextResetState = _dispatcher$useState2[0];\n            var prevResetState = currentHook !== null ? currentHook.memoizedState : null;\n            if (prevResetState !== nextResetState) {\n                // Schedule a form reset\n                currentlyRenderingFiber$1.flags |= FormReset;\n            }\n            return nextState;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every renderWithHooks call.\n            // Conceptually, it's part of the return value of renderWithHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            localIdCounter = 0;\n            return didRenderIdHook;\n        }\n        function bailoutHooks(current, workInProgress, lanes) {\n            workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n            // complete phase (bubbleProperties).\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive$1 | Update);\n            } else {\n                workInProgress.flags &= ~(Passive$1 | Update);\n            }\n            current.lanes = removeLanes(current.lanes, lanes);\n        }\n        function resetHooksAfterThrow() {\n            // This is called immediaetly after a throw. It shouldn't reset the entire\n            // module state, because the work loop might decide to replay the component\n            // again without rewinding.\n            //\n            // It should only reset things like the current dispatcher, to prevent hooks\n            // from being called outside of a component.\n            currentlyRenderingFiber$1 = null; // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactSharedInternals.H = ContextOnlyDispatcher;\n        }\n        function resetHooksOnUnwind(workInProgress) {\n            if (didScheduleRenderPhaseUpdate) {\n                // There were render phase updates. These are only valid for this render\n                // phase, which we are now aborting. Remove the updates from the queues so\n                // they do not persist to the next render. Do not remove updates from hooks\n                // that weren't processed.\n                //\n                // Only reset the updates from the queue if it has a clone. If it does\n                // not have a clone, that means it wasn't processed, and the updates were\n                // scheduled before we entered the render phase.\n                var hook = workInProgress.memoizedState;\n                while(hook !== null){\n                    var queue = hook.queue;\n                    if (queue !== null) {\n                        queue.pending = null;\n                    }\n                    hook = hook.next;\n                }\n                didScheduleRenderPhaseUpdate = false;\n            }\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1;\n                currentHookNameInDev = null;\n            }\n            didScheduleRenderPhaseUpdateDuringThisPass = false;\n            localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = null;\n        }\n        function mountWorkInProgressHook() {\n            var hook = {\n                memoizedState: null,\n                baseState: null,\n                baseQueue: null,\n                queue: null,\n                next: null\n            };\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n            } else {\n                // Append to the end of the list\n                workInProgressHook = workInProgressHook.next = hook;\n            }\n            return workInProgressHook;\n        }\n        function updateWorkInProgressHook() {\n            // This function is used both for updates and for re-renders triggered by a\n            // render phase update. It assumes there is either a current hook we can\n            // clone, or a work-in-progress hook from a previous render pass that we can\n            // use as a base.\n            var nextCurrentHook;\n            if (currentHook === null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    nextCurrentHook = current.memoizedState;\n                } else {\n                    nextCurrentHook = null;\n                }\n            } else {\n                nextCurrentHook = currentHook.next;\n            }\n            var nextWorkInProgressHook;\n            if (workInProgressHook === null) {\n                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n            } else {\n                nextWorkInProgressHook = workInProgressHook.next;\n            }\n            if (nextWorkInProgressHook !== null) {\n                // There's already a work-in-progress. Reuse it.\n                workInProgressHook = nextWorkInProgressHook;\n                nextWorkInProgressHook = workInProgressHook.next;\n                currentHook = nextCurrentHook;\n            } else {\n                // Clone from the current hook.\n                if (nextCurrentHook === null) {\n                    var currentFiber = currentlyRenderingFiber$1.alternate;\n                    if (currentFiber === null) {\n                        // This is the initial render. This branch is reached when the component\n                        // suspends, resumes, then renders an additional hook.\n                        // Should never be reached because we should switch to the mount dispatcher first.\n                        throw new Error('Update hook called on initial render. This is likely a bug in React. Please file an issue.');\n                    } else {\n                        // This is an update. We should always have a current hook.\n                        throw new Error('Rendered more hooks than during the previous render.');\n                    }\n                }\n                currentHook = nextCurrentHook;\n                var newHook = {\n                    memoizedState: currentHook.memoizedState,\n                    baseState: currentHook.baseState,\n                    baseQueue: currentHook.baseQueue,\n                    queue: currentHook.queue,\n                    next: null\n                };\n                if (workInProgressHook === null) {\n                    // This is the first hook in the list.\n                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n                } else {\n                    // Append to the end of the list.\n                    workInProgressHook = workInProgressHook.next = newHook;\n                }\n            }\n            return workInProgressHook;\n        } // NOTE: defining two versions of this function to avoid size impact when this feature is disabled.\n        // Previously this function was inlined, the additional `memoCache` property makes it not inlined.\n        var createFunctionComponentUpdateQueue;\n        {\n            createFunctionComponentUpdateQueue = function() {\n                return {\n                    lastEffect: null,\n                    events: null,\n                    stores: null,\n                    memoCache: null\n                };\n            };\n        }\n        function useThenable(thenable) {\n            // Track the position of the thenable within this fiber.\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            var result = trackUsedThenable(thenableState, thenable, index); // When something suspends with `use`, we replay the component with the\n            // \"re-render\" dispatcher instead of the \"mount\" or \"update\" dispatcher.\n            //\n            // But if there are additional hooks that occur after the `use` invocation\n            // that suspended, they wouldn't have been processed during the previous\n            // attempt. So after we invoke `use` again, we may need to switch from the\n            // \"re-render\" dispatcher back to the \"mount\" or \"update\" dispatcher. That's\n            // what the following logic accounts for.\n            //\n            // TODO: Theoretically this logic only needs to go into the rerender\n            // dispatcher. Could optimize, but probably not be worth it.\n            // This is the same logic as in updateWorkInProgressHook.\n            var workInProgressFiber = currentlyRenderingFiber$1;\n            var nextWorkInProgressHook = workInProgressHook === null ? // the fiber.\n            workInProgressFiber.memoizedState : workInProgressHook.next;\n            if (nextWorkInProgressHook !== null) ;\n            else {\n                // There are no remaining hooks from the previous attempt. We're no longer\n                // in \"re-render\" mode. Switch to the normal mount or update dispatcher.\n                //\n                // This is the same as the logic in renderWithHooks, except we don't bother\n                // to track the hook types debug information in this case (sufficient to\n                // only do that when nothing suspends).\n                var currentFiber = workInProgressFiber.alternate;\n                {\n                    if (currentFiber !== null && currentFiber.memoizedState !== null) {\n                        ReactSharedInternals.H = HooksDispatcherOnUpdateInDEV;\n                    } else {\n                        ReactSharedInternals.H = HooksDispatcherOnMountInDEV;\n                    }\n                }\n            }\n            return result;\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === 'object') {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === 'function') {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return useThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error('An unsupported type was passed to use(): ' + String(usable));\n        }\n        function useMemoCache(size) {\n            var memoCache = null; // Fast-path, load memo cache from wip fiber if already prepared\n            var updateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (updateQueue !== null) {\n                memoCache = updateQueue.memoCache;\n            } // Otherwise clone from the current fiber\n            if (memoCache == null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    var currentUpdateQueue = current.updateQueue;\n                    if (currentUpdateQueue !== null) {\n                        var currentMemoCache = currentUpdateQueue.memoCache;\n                        if (currentMemoCache != null) {\n                            memoCache = {\n                                // When enableNoCloningMemoCache is enabled, instead of treating the\n                                // cache as copy-on-write, like we do with fibers, we share the same\n                                // cache instance across all render attempts, even if the component\n                                // is interrupted before it commits.\n                                //\n                                // If an update is interrupted, either because it suspended or\n                                // because of another update, we can reuse the memoized computations\n                                // from the previous attempt. We can do this because the React\n                                // Compiler performs atomic writes to the memo cache, i.e. it will\n                                // not record the inputs to a memoization without also recording its\n                                // output.\n                                //\n                                // This gives us a form of \"resuming\" within components and hooks.\n                                //\n                                // This only works when updating a component that already mounted.\n                                // It has no impact during initial render, because the memo cache is\n                                // stored on the fiber, and since we have not implemented resuming\n                                // for fibers, it's always a fresh memo cache, anyway.\n                                //\n                                // However, this alone is pretty useful — it happens whenever you\n                                // update the UI with fresh data after a mutation/action, which is\n                                // extremely common in a Suspense-driven (e.g. RSC or Relay) app.\n                                data: currentMemoCache.data.map(function(array) {\n                                    return array.slice();\n                                }),\n                                index: 0\n                            };\n                        }\n                    }\n                }\n            } // Finally fall back to allocating a fresh instance of the cache\n            if (memoCache == null) {\n                memoCache = {\n                    data: [],\n                    index: 0\n                };\n            }\n            if (updateQueue === null) {\n                updateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = updateQueue;\n            }\n            updateQueue.memoCache = memoCache;\n            var data = memoCache.data[memoCache.index];\n            if (data === undefined) {\n                data = memoCache.data[memoCache.index] = new Array(size);\n                for(var i = 0; i < size; i++){\n                    data[i] = REACT_MEMO_CACHE_SENTINEL;\n                }\n            } else if (data.length !== size) {\n                // TODO: consider warning or throwing here\n                {\n                    error('Expected a constant size argument for each invocation of useMemoCache. ' + 'The previous cache was allocated with size %s but size %s was requested.', data.length, size);\n                }\n            }\n            memoCache.index++;\n            return data;\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === 'function' ? action(state) : action;\n        }\n        function mountReducer(reducer, initialArg, init) {\n            var hook = mountWorkInProgressHook();\n            var initialState;\n            if (init !== undefined) {\n                initialState = init(initialArg);\n                if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                    setIsStrictModeForDevtools(true);\n                    init(initialArg);\n                    setIsStrictModeForDevtools(false);\n                }\n            } else {\n                initialState = initialArg;\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: reducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            return updateReducerImpl(hook, currentHook, reducer);\n        }\n        function updateReducerImpl(hook, current, reducer) {\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error('Should have a queue. You are likely calling Hooks conditionally, ' + 'which is not allowed. (https://react.dev/link/invalid-hook-call)');\n            }\n            queue.lastRenderedReducer = reducer; // The last rebase update that is NOT part of the base state.\n            var baseQueue = hook.baseQueue; // The last pending update that hasn't been processed yet.\n            var pendingQueue = queue.pending;\n            if (pendingQueue !== null) {\n                // We have new updates that haven't been processed yet.\n                // We'll add them to the base queue.\n                if (baseQueue !== null) {\n                    // Merge the pending queue and the base queue.\n                    var baseFirst = baseQueue.next;\n                    var pendingFirst = pendingQueue.next;\n                    baseQueue.next = pendingFirst;\n                    pendingQueue.next = baseFirst;\n                }\n                {\n                    if (current.baseQueue !== baseQueue) {\n                        // Internal invariant that should never happen, but feasibly could in\n                        // the future if we implement resuming, or some form of that.\n                        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n                    }\n                }\n                current.baseQueue = baseQueue = pendingQueue;\n                queue.pending = null;\n            }\n            var baseState = hook.baseState;\n            if (baseQueue === null) {\n                // If there are no pending updates, then the memoized state should be the\n                // same as the base state. Currently these only diverge in the case of\n                // useOptimistic, because useOptimistic accepts a new baseState on\n                // every render.\n                hook.memoizedState = baseState; // We don't need to call markWorkInProgressReceivedUpdate because\n            // baseState is derived from other reactive values.\n            } else {\n                // We have a queue to process.\n                var first = baseQueue.next;\n                var newState = baseState;\n                var newBaseState = null;\n                var newBaseQueueFirst = null;\n                var newBaseQueueLast = null;\n                var update = first;\n                var didReadFromEntangledAsyncAction = false;\n                do {\n                    // An extra OffscreenLane bit is added to updates that were made to\n                    // a hidden tree, so that we can distinguish them from updates that were\n                    // already there when the tree was hidden.\n                    var updateLane = removeLanes(update.lane, OffscreenLane);\n                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n                    // it's not a \"base\" update and we should disregard the extra base lanes\n                    // that were added to renderLanes when we entered the Offscreen tree.\n                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n                    if (shouldSkipUpdate) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            revertLane: update.revertLane,\n                            action: update.action,\n                            hasEagerState: update.hasEagerState,\n                            eagerState: update.eagerState,\n                            next: null\n                        };\n                        if (newBaseQueueLast === null) {\n                            newBaseQueueFirst = newBaseQueueLast = clone;\n                            newBaseState = newState;\n                        } else {\n                            newBaseQueueLast = newBaseQueueLast.next = clone;\n                        } // Update the remaining priority in the queue.\n                        // TODO: Don't need to accumulate this. Instead, we can remove\n                        // renderLanes from the original lanes.\n                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n                        markSkippedUpdateLanes(updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        // Check if this is an optimistic update.\n                        var revertLane = update.revertLane;\n                        if (revertLane === NoLane) {\n                            // This is not an optimistic update, and we're going to apply it now.\n                            // But, if there were earlier updates that were skipped, we need to\n                            // leave this update in the queue so it can be rebased later.\n                            if (newBaseQueueLast !== null) {\n                                var _clone = {\n                                    // This update is going to be committed so we never want uncommit\n                                    // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                    // this will never be skipped by the check above.\n                                    lane: NoLane,\n                                    revertLane: NoLane,\n                                    action: update.action,\n                                    hasEagerState: update.hasEagerState,\n                                    eagerState: update.eagerState,\n                                    next: null\n                                };\n                                newBaseQueueLast = newBaseQueueLast.next = _clone;\n                            } // Check if this update is part of a pending async action. If so,\n                            // we'll need to suspend until the action has finished, so that it's\n                            // batched together with future updates in the same action.\n                            if (updateLane === peekEntangledActionLane()) {\n                                didReadFromEntangledAsyncAction = true;\n                            }\n                        } else {\n                            // This is an optimistic update. If the \"revert\" priority is\n                            // sufficient, don't apply the update. Otherwise, apply the update,\n                            // but leave it in the queue so it can be either reverted or\n                            // rebased in a subsequent render.\n                            if (isSubsetOfLanes(renderLanes, revertLane)) {\n                                // The transition that this optimistic update is associated with\n                                // has finished. Pretend the update doesn't exist by skipping\n                                // over it.\n                                update = update.next; // Check if this update is part of a pending async action. If so,\n                                // we'll need to suspend until the action has finished, so that it's\n                                // batched together with future updates in the same action.\n                                if (revertLane === peekEntangledActionLane()) {\n                                    didReadFromEntangledAsyncAction = true;\n                                }\n                                continue;\n                            } else {\n                                var _clone2 = {\n                                    // Once we commit an optimistic update, we shouldn't uncommit it\n                                    // until the transition it is associated with has finished\n                                    // (represented by revertLane). Using NoLane here works because 0\n                                    // is a subset of all bitmasks, so this will never be skipped by\n                                    // the check above.\n                                    lane: NoLane,\n                                    // Reuse the same revertLane so we know when the transition\n                                    // has finished.\n                                    revertLane: update.revertLane,\n                                    action: update.action,\n                                    hasEagerState: update.hasEagerState,\n                                    eagerState: update.eagerState,\n                                    next: null\n                                };\n                                if (newBaseQueueLast === null) {\n                                    newBaseQueueFirst = newBaseQueueLast = _clone2;\n                                    newBaseState = newState;\n                                } else {\n                                    newBaseQueueLast = newBaseQueueLast.next = _clone2;\n                                } // Update the remaining priority in the queue.\n                                // TODO: Don't need to accumulate this. Instead, we can remove\n                                // renderLanes from the original lanes.\n                                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, revertLane);\n                                markSkippedUpdateLanes(revertLane);\n                            }\n                        } // Process this update.\n                        var action = update.action;\n                        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                            reducer(newState, action);\n                        }\n                        if (update.hasEagerState) {\n                            // If this update is a state update (not a reducer) and was processed eagerly,\n                            // we can use the eagerly computed state\n                            newState = update.eagerState;\n                        } else {\n                            newState = reducer(newState, action);\n                        }\n                    }\n                    update = update.next;\n                }while (update !== null && update !== first);\n                if (newBaseQueueLast === null) {\n                    newBaseState = newState;\n                } else {\n                    newBaseQueueLast.next = newBaseQueueFirst;\n                } // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate(); // Check if this update is part of a pending async action. If so, we'll\n                    // need to suspend until the action has finished, so that it's batched\n                    // together with future updates in the same action.\n                    // TODO: Once we support hooks inside useMemo (or an equivalent\n                    // memoization boundary like Forget), hoist this logic so that it only\n                    // suspends if the memo boundary produces a new value.\n                    if (didReadFromEntangledAsyncAction) {\n                        var entangledActionThenable = peekEntangledActionThenable();\n                        if (entangledActionThenable !== null) {\n                            // TODO: Instead of the throwing the thenable directly, throw a\n                            // special object like `use` does so we can detect if it's captured\n                            // by userspace.\n                            throw entangledActionThenable;\n                        }\n                    }\n                }\n                hook.memoizedState = newState;\n                hook.baseState = newBaseState;\n                hook.baseQueue = newBaseQueueLast;\n                queue.lastRenderedState = newState;\n            }\n            if (baseQueue === null) {\n                // `queue.lanes` is used for entangling transitions. We can set it back to\n                // zero once the queue is empty.\n                queue.lanes = NoLanes;\n            }\n            var dispatch = queue.dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function rerenderReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error('Should have a queue. You are likely calling Hooks conditionally, ' + 'which is not allowed. (https://react.dev/link/invalid-hook-call)');\n            }\n            queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n            // work-in-progress hook.\n            var dispatch = queue.dispatch;\n            var lastRenderPhaseUpdate = queue.pending;\n            var newState = hook.memoizedState;\n            if (lastRenderPhaseUpdate !== null) {\n                // The queue doesn't persist past this render pass.\n                queue.pending = null;\n                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                var update = firstRenderPhaseUpdate;\n                do {\n                    // Process this render phase update. We don't have to check the\n                    // priority because it will always be the same as the current\n                    // render's.\n                    var action = update.action;\n                    newState = reducer(newState, action);\n                    update = update.next;\n                }while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n                // the base state unless the queue is empty.\n                // TODO: Not sure if this is the desired semantics, but it's what we\n                // do for gDSFP. I can't remember why.\n                if (hook.baseQueue === null) {\n                    hook.baseState = newState;\n                }\n                queue.lastRenderedState = newState;\n            }\n            return [\n                newState,\n                dispatch\n            ];\n        }\n        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = mountWorkInProgressHook();\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                if (getServerSnapshot === undefined) {\n                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n                }\n                nextSnapshot = getServerSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        if (nextSnapshot !== getServerSnapshot()) {\n                            error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error('The result of getSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                //\n                // We won't do this if we're hydrating server-rendered content, because if\n                // the content is stale, it's already visible anyway. Instead we'll patch\n                // it up in a passive effect.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                }\n                var rootRenderLanes = getWorkInProgressRootRenderLanes();\n                if (!includesBlockingLane(root, rootRenderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            } // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            hook.memoizedState = nextSnapshot;\n            var inst = {\n                value: nextSnapshot,\n                getSnapshot: getSnapshot\n            };\n            hook.queue = inst; // Schedule an effect to subscribe to the store.\n            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Schedule an effect to update the mutable instance fields. We will update\n            // this whenever subscribe, getSnapshot, or value changes. Because there's no\n            // clean-up function, and we track the deps correctly, we can call pushEffect\n            // directly, without storing any additional state. For the same reason, we\n            // don't need to set a static flag, either.\n            fiber.flags |= Passive$1;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null);\n            return nextSnapshot;\n        }\n        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                // Needed for strict mode double render\n                if (getServerSnapshot === undefined) {\n                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n                }\n                nextSnapshot = getServerSnapshot();\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error('The result of getSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            }\n            var prevSnapshot = (currentHook || hook).memoizedState;\n            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n            if (snapshotChanged) {\n                hook.memoizedState = nextSnapshot;\n                markWorkInProgressReceivedUpdate();\n            }\n            var inst = hook.queue;\n            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Whenever getSnapshot or subscribe changes, we need to check in the\n            // commit phase if there was an interleaved mutation. In concurrent mode\n            // this can happen all the time, but even in synchronous mode, an earlier\n            // effect may have mutated the store.\n            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the subscribe function changed. We can save some memory by\n            // checking whether we scheduled a subscription effect above.\n            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n                fiber.flags |= Passive$1;\n                pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null); // Unless we're rendering a blocking lane, schedule a consistency check.\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                }\n                if (!isHydrating && !includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            }\n            return nextSnapshot;\n        }\n        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n            fiber.flags |= StoreConsistency;\n            var check = {\n                getSnapshot: getSnapshot,\n                value: renderedSnapshot\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.stores = [\n                    check\n                ];\n            } else {\n                var stores = componentUpdateQueue.stores;\n                if (stores === null) {\n                    componentUpdateQueue.stores = [\n                        check\n                    ];\n                } else {\n                    stores.push(check);\n                }\n            }\n        }\n        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n            // These are updated in the passive phase\n            inst.value = nextSnapshot;\n            inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n            // have been in an event that fired before the passive effects, or it could\n            // have been in a layout effect. In that case, we would have used the old\n            // snapsho and getSnapshot values to bail out. We need to check one more time.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceStoreRerender(fiber);\n            }\n        }\n        function subscribeToStore(fiber, inst, subscribe) {\n            var handleStoreChange = function() {\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceStoreRerender(fiber);\n                }\n            }; // Subscribe to the store and return a clean-up function.\n            return subscribe(handleStoreChange);\n        }\n        function checkIfSnapshotChanged(inst) {\n            var latestGetSnapshot = inst.getSnapshot;\n            var prevValue = inst.value;\n            try {\n                var nextValue = latestGetSnapshot();\n                return !objectIs(prevValue, nextValue);\n            } catch (error) {\n                return true;\n            }\n        }\n        function forceStoreRerender(fiber) {\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function mountStateImpl(initialState) {\n            var hook = mountWorkInProgressHook();\n            if (typeof initialState === 'function') {\n                var initialStateInitializer = initialState; // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n                initialState = initialStateInitializer();\n                if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                    setIsStrictModeForDevtools(true); // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n                    initialStateInitializer();\n                    setIsStrictModeForDevtools(false);\n                }\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            return hook;\n        }\n        function mountState(initialState) {\n            var hook = mountStateImpl(initialState);\n            var queue = hook.queue;\n            var dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n            queue.dispatch = dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateState(initialState) {\n            return updateReducer(basicStateReducer);\n        }\n        function rerenderState(initialState) {\n            return rerenderReducer(basicStateReducer);\n        }\n        function mountOptimistic(passthrough, reducer) {\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = hook.baseState = passthrough;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                // Optimistic state does not use the eager update optimization.\n                lastRenderedReducer: null,\n                lastRenderedState: null\n            };\n            hook.queue = queue; // This is different than the normal setState function.\n            var dispatch = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, true, queue);\n            queue.dispatch = dispatch;\n            return [\n                passthrough,\n                dispatch\n            ];\n        }\n        function updateOptimistic(passthrough, reducer) {\n            var hook = updateWorkInProgressHook();\n            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        }\n        function updateOptimisticImpl(hook, current, passthrough, reducer) {\n            // Optimistic updates are always rebased on top of the latest value passed in\n            // as an argument. It's called a passthrough because if there are no pending\n            // updates, it will be returned as-is.\n            //\n            // Reset the base state to the passthrough. Future updates will be applied\n            // on top of this.\n            hook.baseState = passthrough; // If a reducer is not provided, default to the same one used by useState.\n            var resolvedReducer = typeof reducer === 'function' ? reducer : basicStateReducer;\n            return updateReducerImpl(hook, currentHook, resolvedReducer);\n        }\n        function rerenderOptimistic(passthrough, reducer) {\n            // Unlike useState, useOptimistic doesn't support render phase updates.\n            // Also unlike useState, we need to replay all pending updates again in case\n            // the passthrough value changed.\n            //\n            // So instead of a forked re-render implementation that knows how to handle\n            // render phase udpates, we can use the same implementation as during a\n            // regular mount or update.\n            var hook = updateWorkInProgressHook();\n            if (currentHook !== null) {\n                // This is an update. Process the update queue.\n                return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n            } // This is a mount. No updates to process.\n            // Reset the base state to the passthrough. Future updates will be applied\n            // on top of this.\n            hook.baseState = passthrough;\n            var dispatch = hook.queue.dispatch;\n            return [\n                passthrough,\n                dispatch\n            ];\n        } // useActionState actions run sequentially, because each action receives the\n        // previous state as an argument. We store pending actions on a queue.\n        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n            if (isRenderPhaseUpdate(fiber)) {\n                throw new Error('Cannot update form state while rendering.');\n            }\n            var currentAction = actionQueue.action;\n            if (currentAction === null) {\n                // An earlier action errored. Subsequent actions should not run.\n                return;\n            }\n            var actionNode = {\n                payload: payload,\n                action: currentAction,\n                next: null,\n                // circular\n                isTransition: true,\n                status: 'pending',\n                value: null,\n                reason: null,\n                listeners: [],\n                then: function(listener) {\n                    // We know the only thing that subscribes to these promises is `use` so\n                    // this implementation is simpler than a generic thenable. E.g. we don't\n                    // bother to check if the thenable is still pending because `use` already\n                    // does that.\n                    actionNode.listeners.push(listener);\n                }\n            }; // Check if we're inside a transition. If so, we'll need to restore the\n            // transition context when the action is run.\n            var prevTransition = ReactSharedInternals.T;\n            if (prevTransition !== null) {\n                // Optimistically update the pending state, similar to useTransition.\n                // This will be reverted automatically when all actions are finished.\n                setPendingState(true); // `actionNode` is a thenable that resolves to the return value of\n                // the action.\n                setState(actionNode);\n            } else {\n                // This is not a transition.\n                actionNode.isTransition = false;\n                setState(actionNode);\n            }\n            var last = actionQueue.pending;\n            if (last === null) {\n                // There are no pending actions; this is the first one. We can run\n                // it immediately.\n                actionNode.next = actionQueue.pending = actionNode;\n                runActionStateAction(actionQueue, actionNode);\n            } else {\n                // There's already an action running. Add to the queue.\n                var first = last.next;\n                actionNode.next = first;\n                actionQueue.pending = last.next = actionNode;\n            }\n        }\n        function runActionStateAction(actionQueue, node) {\n            // `node.action` represents the action function at the time it was dispatched.\n            // If this action was queued, it might be stale, i.e. it's not necessarily the\n            // most current implementation of the action, stored on `actionQueue`. This is\n            // intentional. The conceptual model for queued actions is that they are\n            // queued in a remote worker; the dispatch happens immediately, only the\n            // execution is delayed.\n            var action = node.action;\n            var payload = node.payload;\n            var prevState = actionQueue.state;\n            if (node.isTransition) {\n                // The original dispatch was part of a transition. We restore its\n                // transition context here.\n                // This is a fork of startTransition\n                var prevTransition = ReactSharedInternals.T;\n                var currentTransition = {};\n                ReactSharedInternals.T = currentTransition;\n                {\n                    ReactSharedInternals.T._updatedFibers = new Set();\n                }\n                try {\n                    var returnValue = action(prevState, payload);\n                    var onStartTransitionFinish = ReactSharedInternals.S;\n                    if (onStartTransitionFinish !== null) {\n                        onStartTransitionFinish(currentTransition, returnValue);\n                    }\n                    handleActionReturnValue(actionQueue, node, returnValue);\n                } catch (error) {\n                    onActionError(actionQueue, node, error);\n                } finally{\n                    ReactSharedInternals.T = prevTransition;\n                    {\n                        if (prevTransition === null && currentTransition._updatedFibers) {\n                            var updatedFibersCount = currentTransition._updatedFibers.size;\n                            currentTransition._updatedFibers.clear();\n                            if (updatedFibersCount > 10) {\n                                warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n                            }\n                        }\n                    }\n                }\n            } else {\n                // The original dispatch was not part of a transition.\n                try {\n                    var _returnValue = action(prevState, payload);\n                    handleActionReturnValue(actionQueue, node, _returnValue);\n                } catch (error) {\n                    onActionError(actionQueue, node, error);\n                }\n            }\n        }\n        function handleActionReturnValue(actionQueue, node, returnValue) {\n            if (returnValue !== null && typeof returnValue === 'object' && // $FlowFixMe[method-unbinding]\n            typeof returnValue.then === 'function') {\n                var thenable = returnValue; // Attach a listener to read the return state of the action. As soon as\n                // this resolves, we can run the next action in the sequence.\n                thenable.then(function(nextState) {\n                    onActionSuccess(actionQueue, node, nextState);\n                }, function(error) {\n                    return onActionError(actionQueue, node, error);\n                });\n                {\n                    if (!node.isTransition) {\n                        error('An async function was passed to useActionState, but it was ' + 'dispatched outside of an action context. This is likely not ' + 'what you intended. Either pass the dispatch function to an ' + '`action` prop, or dispatch manually inside `startTransition`');\n                    }\n                }\n            } else {\n                var nextState = returnValue;\n                onActionSuccess(actionQueue, node, nextState);\n            }\n        }\n        function onActionSuccess(actionQueue, actionNode, nextState) {\n            // The action finished running.\n            actionNode.status = 'fulfilled';\n            actionNode.value = nextState;\n            notifyActionListeners(actionNode);\n            actionQueue.state = nextState; // Pop the action from the queue and run the next pending action, if there\n            // are any.\n            var last = actionQueue.pending;\n            if (last !== null) {\n                var first = last.next;\n                if (first === last) {\n                    // This was the last action in the queue.\n                    actionQueue.pending = null;\n                } else {\n                    // Remove the first node from the circular queue.\n                    var next = first.next;\n                    last.next = next; // Run the next action.\n                    runActionStateAction(actionQueue, next);\n                }\n            }\n        }\n        function onActionError(actionQueue, actionNode, error) {\n            // Mark all the following actions as rejected.\n            var last = actionQueue.pending;\n            actionQueue.pending = null;\n            if (last !== null) {\n                var first = last.next;\n                do {\n                    actionNode.status = 'rejected';\n                    actionNode.reason = error;\n                    notifyActionListeners(actionNode);\n                    actionNode = actionNode.next;\n                }while (actionNode !== first);\n            } // Prevent subsequent actions from being dispatched.\n            actionQueue.action = null;\n        }\n        function notifyActionListeners(actionNode) {\n            // Notify React that the action has finished.\n            var listeners = actionNode.listeners;\n            for(var i = 0; i < listeners.length; i++){\n                // This is always a React internal listener, so we don't need to worry\n                // about it throwing.\n                var listener = listeners[i];\n                listener();\n            }\n        }\n        function actionStateReducer(oldState, newState) {\n            return newState;\n        }\n        function mountActionState(action, initialStateProp, permalink) {\n            var initialState = initialStateProp;\n            if (getIsHydrating()) {\n                var root = getWorkInProgressRoot();\n                var ssrFormState = root.formState; // If a formState option was passed to the root, there are form state\n                // markers that we need to hydrate. These indicate whether the form state\n                // matches this hook instance.\n                if (ssrFormState !== null) {\n                    var isMatching = tryToClaimNextHydratableFormMarkerInstance(currentlyRenderingFiber$1);\n                    if (isMatching) {\n                        initialState = ssrFormState[0];\n                    }\n                }\n            } // State hook. The state is stored in a thenable which is then unwrapped by\n            // the `use` algorithm during render.\n            var stateHook = mountWorkInProgressHook();\n            stateHook.memoizedState = stateHook.baseState = initialState; // TODO: Typing this \"correctly\" results in recursion limit errors\n            // const stateQueue: UpdateQueue<S | Awaited<S>, S | Awaited<S>> = {\n            var stateQueue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: actionStateReducer,\n                lastRenderedState: initialState\n            };\n            stateHook.queue = stateQueue;\n            var setState = dispatchSetState.bind(null, currentlyRenderingFiber$1, stateQueue);\n            stateQueue.dispatch = setState; // Pending state. This is used to store the pending state of the action.\n            // Tracked optimistically, like a transition pending state.\n            var pendingStateHook = mountStateImpl(false);\n            var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, false, pendingStateHook.queue); // Action queue hook. This is used to queue pending actions. The queue is\n            // shared between all instances of the hook. Similar to a regular state queue,\n            // but different because the actions are run sequentially, and they run in\n            // an event instead of during render.\n            var actionQueueHook = mountWorkInProgressHook();\n            var actionQueue = {\n                state: initialState,\n                dispatch: null,\n                // circular\n                action: action,\n                pending: null\n            };\n            actionQueueHook.queue = actionQueue;\n            var dispatch = dispatchActionState.bind(null, currentlyRenderingFiber$1, actionQueue, setPendingState, setState);\n            actionQueue.dispatch = dispatch; // Stash the action function on the memoized state of the hook. We'll use this\n            // to detect when the action function changes so we can update it in\n            // an effect.\n            actionQueueHook.memoizedState = action;\n            return [\n                initialState,\n                dispatch,\n                false\n            ];\n        }\n        function updateActionState(action, initialState, permalink) {\n            var stateHook = updateWorkInProgressHook();\n            var currentStateHook = currentHook;\n            return updateActionStateImpl(stateHook, currentStateHook, action);\n        }\n        function updateActionStateImpl(stateHook, currentStateHook, action, initialState, permalink) {\n            var _updateReducerImpl = updateReducerImpl(stateHook, currentStateHook, actionStateReducer), actionResult = _updateReducerImpl[0];\n            var _updateState = updateState(), isPending = _updateState[0]; // This will suspend until the action finishes.\n            var state = typeof actionResult === 'object' && actionResult !== null && // $FlowFixMe[method-unbinding]\n            typeof actionResult.then === 'function' ? useThenable(actionResult) : actionResult;\n            var actionQueueHook = updateWorkInProgressHook();\n            var actionQueue = actionQueueHook.queue;\n            var dispatch = actionQueue.dispatch; // Check if a new action was passed. If so, update it in an effect.\n            var prevAction = actionQueueHook.memoizedState;\n            if (action !== prevAction) {\n                currentlyRenderingFiber$1.flags |= Passive$1;\n                pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), createEffectInstance(), null);\n            }\n            return [\n                state,\n                dispatch,\n                isPending\n            ];\n        }\n        function actionStateActionEffect(actionQueue, action) {\n            actionQueue.action = action;\n        }\n        function rerenderActionState(action, initialState, permalink) {\n            // Unlike useState, useActionState doesn't support render phase updates.\n            // Also unlike useState, we need to replay all pending updates again in case\n            // the passthrough value changed.\n            //\n            // So instead of a forked re-render implementation that knows how to handle\n            // render phase udpates, we can use the same implementation as during a\n            // regular mount or update.\n            var stateHook = updateWorkInProgressHook();\n            var currentStateHook = currentHook;\n            if (currentStateHook !== null) {\n                // This is an update. Process the update queue.\n                return updateActionStateImpl(stateHook, currentStateHook, action);\n            }\n            updateWorkInProgressHook(); // State\n            // This is a mount. No updates to process.\n            var state = stateHook.memoizedState;\n            var actionQueueHook = updateWorkInProgressHook();\n            var actionQueue = actionQueueHook.queue;\n            var dispatch = actionQueue.dispatch; // This may have changed during the rerender.\n            actionQueueHook.memoizedState = action; // For mount, pending is always false.\n            return [\n                state,\n                dispatch,\n                false\n            ];\n        }\n        function pushEffect(tag, create, inst, deps) {\n            var effect = {\n                tag: tag,\n                create: create,\n                inst: inst,\n                deps: deps,\n                // Circular\n                next: null\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.lastEffect = effect.next = effect;\n            } else {\n                var lastEffect = componentUpdateQueue.lastEffect;\n                if (lastEffect === null) {\n                    componentUpdateQueue.lastEffect = effect.next = effect;\n                } else {\n                    var firstEffect = lastEffect.next;\n                    lastEffect.next = effect;\n                    effect.next = firstEffect;\n                    componentUpdateQueue.lastEffect = effect;\n                }\n            }\n            return effect;\n        }\n        function createEffectInstance() {\n            return {\n                destroy: undefined\n            };\n        }\n        function mountRef(initialValue) {\n            var hook = mountWorkInProgressHook();\n            var ref = {\n                current: initialValue\n            };\n            hook.memoizedState = ref;\n            return ref;\n        }\n        function updateRef(initialValue) {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, createEffectInstance(), nextDeps);\n        }\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var effect = hook.memoizedState;\n            var inst = effect.inst; // currentHook is null on initial mount when rerendering after a render phase\n            // state update or for strict mode.\n            if (currentHook !== null) {\n                if (nextDeps !== null) {\n                    var prevEffect = currentHook.memoizedState;\n                    var prevDeps = prevEffect.deps;\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);\n                        return;\n                    }\n                }\n            }\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, nextDeps);\n        }\n        function mountEffect(create, deps) {\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode) {\n                mountEffectImpl(MountPassiveDev | Passive$1 | PassiveStatic, Passive, create, deps);\n            } else {\n                mountEffectImpl(Passive$1 | PassiveStatic, Passive, create, deps);\n            }\n        }\n        function updateEffect(create, deps) {\n            updateEffectImpl(Passive$1, Passive, create, deps);\n        }\n        function mountInsertionEffect(create, deps) {\n            mountEffectImpl(Update, Insertion, create, deps);\n        }\n        function updateInsertionEffect(create, deps) {\n            return updateEffectImpl(Update, Insertion, create, deps);\n        }\n        function mountLayoutEffect(create, deps) {\n            var fiberFlags = Update | LayoutStatic;\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, create, deps);\n        }\n        function updateLayoutEffect(create, deps) {\n            return updateEffectImpl(Update, Layout, create, deps);\n        }\n        function imperativeHandleEffect(create, ref) {\n            if (typeof ref === 'function') {\n                var refCallback = ref;\n                var inst = create();\n                var refCleanup = refCallback(inst);\n                return function() {\n                    if (typeof refCleanup === 'function') {\n                        // $FlowFixMe[incompatible-use] we need to assume no parameters\n                        refCleanup();\n                    } else {\n                        refCallback(null);\n                    }\n                };\n            } else if (ref !== null && ref !== undefined) {\n                var refObject = ref;\n                {\n                    if (!refObject.hasOwnProperty('current')) {\n                        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n                    }\n                }\n                var _inst = create();\n                refObject.current = _inst;\n                return function() {\n                    refObject.current = null;\n                };\n            }\n        }\n        function mountImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== 'function') {\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            var fiberFlags = Update | LayoutStatic;\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function updateImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== 'function') {\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function mountDebugValue(value, formatterFn) {\n        // The react-debug-hooks package injects its own implementation\n        // so that e.g. DevTools can display custom hook values.\n        }\n        var updateDebugValue = mountDebugValue;\n        function mountCallback(callback, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function updateCallback(callback, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (nextDeps !== null) {\n                var prevDeps = prevState[1];\n                if (areHookInputsEqual(nextDeps, prevDeps)) {\n                    return prevState[0];\n                }\n            }\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function mountMemo(nextCreate, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var nextValue = nextCreate();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(true);\n                nextCreate();\n                setIsStrictModeForDevtools(false);\n            }\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function updateMemo(nextCreate, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState; // Assume these are defined. If they're not, areHookInputsEqual will warn.\n            if (nextDeps !== null) {\n                var prevDeps = prevState[1];\n                if (areHookInputsEqual(nextDeps, prevDeps)) {\n                    return prevState[0];\n                }\n            }\n            var nextValue = nextCreate();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(true);\n                nextCreate();\n                setIsStrictModeForDevtools(false);\n            }\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function mountDeferredValue(value, initialValue) {\n            var hook = mountWorkInProgressHook();\n            return mountDeferredValueImpl(hook, value, initialValue);\n        }\n        function updateDeferredValue(value, initialValue) {\n            var hook = updateWorkInProgressHook();\n            var resolvedCurrentHook = currentHook;\n            var prevValue = resolvedCurrentHook.memoizedState;\n            return updateDeferredValueImpl(hook, prevValue, value, initialValue);\n        }\n        function rerenderDeferredValue(value, initialValue) {\n            var hook = updateWorkInProgressHook();\n            if (currentHook === null) {\n                // This is a rerender during a mount.\n                return mountDeferredValueImpl(hook, value, initialValue);\n            } else {\n                // This is a rerender during an update.\n                var prevValue = currentHook.memoizedState;\n                return updateDeferredValueImpl(hook, prevValue, value, initialValue);\n            }\n        }\n        function mountDeferredValueImpl(hook, value, initialValue) {\n            if (// current render is not synchronous.\n            initialValue !== undefined && // However, to avoid waterfalls, we do not defer if this render\n            // was itself spawned by an earlier useDeferredValue. Check if DeferredLane\n            // is part of the render lanes.\n            !includesSomeLane(renderLanes, DeferredLane)) {\n                // Render with the initial value\n                hook.memoizedState = initialValue; // Schedule a deferred render to switch to the final value.\n                var deferredLane = requestDeferredLane();\n                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n                markSkippedUpdateLanes(deferredLane);\n                return initialValue;\n            } else {\n                hook.memoizedState = value;\n                return value;\n            }\n        }\n        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n            if (objectIs(value, prevValue)) {\n                // The incoming value is referentially identical to the currently rendered\n                // value, so we can bail out quickly.\n                return value;\n            } else {\n                // Received a new value that's different from the current value.\n                // Check if we're inside a hidden tree\n                if (isCurrentTreeHidden()) {\n                    // Revealing a prerendered tree is considered the same as mounting new\n                    // one, so we reuse the \"mount\" path in this case.\n                    var resultValue = mountDeferredValueImpl(hook, value, initialValue); // Unlike during an actual mount, we need to mark this as an update if\n                    // the value changed.\n                    if (!objectIs(resultValue, prevValue)) {\n                        markWorkInProgressReceivedUpdate();\n                    }\n                    return resultValue;\n                }\n                var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n                if (shouldDeferValue) {\n                    // This is an urgent update. Since the value has changed, keep using the\n                    // previous value and spawn a deferred render to update it later.\n                    // Schedule a deferred render\n                    var deferredLane = requestDeferredLane();\n                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n                    markSkippedUpdateLanes(deferredLane); // Reuse the previous value. We do not need to mark this as an update,\n                    // because we did not render a new value.\n                    return prevValue;\n                } else {\n                    // This is not an urgent update, so we can use the latest value regardless\n                    // of what it is. No need to defer it.\n                    // Mark this as an update to prevent the fiber from bailing out.\n                    markWorkInProgressReceivedUpdate();\n                    hook.memoizedState = value;\n                    return value;\n                }\n            }\n        }\n        function startTransition(fiber, queue, pendingState, finishedState, callback, options) {\n            var previousPriority = getCurrentUpdatePriority();\n            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n            var prevTransition = ReactSharedInternals.T;\n            var currentTransition = {};\n            {\n                // We don't really need to use an optimistic update here, because we\n                // schedule a second \"revert\" update below (which we use to suspend the\n                // transition until the async action scope has finished). But we'll use an\n                // optimistic update anyway to make it less likely the behavior accidentally\n                // diverges; for example, both an optimistic update and this one should\n                // share the same lane.\n                ReactSharedInternals.T = currentTransition;\n                dispatchOptimisticSetState(fiber, false, queue, pendingState);\n            }\n            {\n                currentTransition._updatedFibers = new Set();\n            }\n            try {\n                if (enableAsyncActions) {\n                    var returnValue = callback();\n                    var onStartTransitionFinish = ReactSharedInternals.S;\n                    if (onStartTransitionFinish !== null) {\n                        onStartTransitionFinish(currentTransition, returnValue);\n                    } // Check if we're inside an async action scope. If so, we'll entangle\n                    // this new action with the existing scope.\n                    //\n                    // If we're not already inside an async action scope, and this action is\n                    // async, then we'll create a new async scope.\n                    //\n                    // In the async case, the resulting render will suspend until the async\n                    // action scope has finished.\n                    if (returnValue !== null && typeof returnValue === 'object' && typeof returnValue.then === 'function') {\n                        var thenable = returnValue; // Create a thenable that resolves to `finishedState` once the async\n                        // action has completed.\n                        var thenableForFinishedState = chainThenableValue(thenable, finishedState);\n                        dispatchSetState(fiber, queue, thenableForFinishedState);\n                    } else {\n                        dispatchSetState(fiber, queue, finishedState);\n                    }\n                }\n            } catch (error) {\n                {\n                    // This is a trick to get the `useTransition` hook to rethrow the error.\n                    // When it unwraps the thenable with the `use` algorithm, the error\n                    // will be thrown.\n                    var rejectedThenable = {\n                        then: function() {},\n                        status: 'rejected',\n                        reason: error\n                    };\n                    dispatchSetState(fiber, queue, rejectedThenable);\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n                        }\n                    }\n                }\n            }\n        }\n        var noop = function() {};\n        function startHostTransition(formFiber, pendingState, action, formData) {\n            if (formFiber.tag !== HostComponent) {\n                throw new Error('Expected the form instance to be a HostComponent. This ' + 'is a bug in React.');\n            }\n            var stateHook = ensureFormComponentIsStateful(formFiber);\n            var queue = stateHook.queue;\n            startTransition(formFiber, queue, pendingState, NotPendingTransition, // the action, if one is provided. Consider refactoring these two\n            // concerns to avoid the extra lambda.\n            action === null ? // set the pending form status.\n            noop : function() {\n                // Automatically reset the form when the action completes.\n                requestFormReset(formFiber);\n                return action(formData);\n            });\n        }\n        function ensureFormComponentIsStateful(formFiber) {\n            var existingStateHook = formFiber.memoizedState;\n            if (existingStateHook !== null) {\n                // This fiber was already upgraded to be stateful.\n                return existingStateHook;\n            } // Upgrade this host component fiber to be stateful. We're going to pretend\n            // it was stateful all along so we can reuse most of the implementation\n            // for function components and useTransition.\n            //\n            // Create the state hook used by TransitionAwareHostComponent. This is\n            // essentially an inlined version of mountState.\n            var newQueue = {\n                pending: null,\n                lanes: NoLanes,\n                // We're going to cheat and intentionally not create a bound dispatch\n                // method, because we can call it directly in startTransition.\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            };\n            var stateHook = {\n                memoizedState: NotPendingTransition,\n                baseState: NotPendingTransition,\n                baseQueue: null,\n                queue: newQueue,\n                next: null\n            }; // We use another state hook to track whether the form needs to be reset.\n            // The state is an empty object. To trigger a reset, we update the state\n            // to a new object. Then during rendering, we detect that the state has\n            // changed and schedule a commit effect.\n            var initialResetState = {};\n            var newResetStateQueue = {\n                pending: null,\n                lanes: NoLanes,\n                // We're going to cheat and intentionally not create a bound dispatch\n                // method, because we can call it directly in startTransition.\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            };\n            var resetStateHook = {\n                memoizedState: initialResetState,\n                baseState: initialResetState,\n                baseQueue: null,\n                queue: newResetStateQueue,\n                next: null\n            };\n            stateHook.next = resetStateHook; // Add the hook list to both fiber alternates. The idea is that the fiber\n            // had this hook all along.\n            formFiber.memoizedState = stateHook;\n            var alternate = formFiber.alternate;\n            if (alternate !== null) {\n                alternate.memoizedState = stateHook;\n            }\n            return stateHook;\n        }\n        function requestFormReset(formFiber) {\n            var transition = requestCurrentTransition();\n            {\n                if (transition === null) {\n                    // An optimistic update occurred, but startTransition is not on the stack.\n                    // The form reset will be scheduled at default (sync) priority, which\n                    // is probably not what the user intended. Most likely because the\n                    // requestFormReset call happened after an `await`.\n                    // TODO: Theoretically, requestFormReset is still useful even for\n                    // non-transition updates because it allows you to update defaultValue\n                    // synchronously and then wait to reset until after the update commits.\n                    // I've chosen to warn anyway because it's more likely the `await` mistake\n                    // described above. But arguably we shouldn't.\n                    error('requestFormReset was called outside a transition or action. To ' + 'fix, move to an action, or wrap with startTransition.');\n                }\n            }\n            var stateHook = ensureFormComponentIsStateful(formFiber);\n            var newResetState = {};\n            var resetStateHook = stateHook.next;\n            var resetStateQueue = resetStateHook.queue;\n            dispatchSetState(formFiber, resetStateQueue, newResetState);\n        }\n        function mountTransition() {\n            var stateHook = mountStateImpl(false); // The `start` method never changes.\n            var start = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, true, false);\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = start;\n            return [\n                false,\n                start\n            ];\n        }\n        function updateTransition() {\n            var _updateState2 = updateState(), booleanOrThenable = _updateState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);\n            return [\n                isPending,\n                start\n            ];\n        }\n        function rerenderTransition() {\n            var _rerenderState = rerenderState(), booleanOrThenable = _rerenderState[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);\n            return [\n                isPending,\n                start\n            ];\n        }\n        function useHostTransitionStatus() {\n            var status = readContext(HostTransitionContext);\n            return status !== null ? status : NotPendingTransition;\n        }\n        function mountId() {\n            var hook = mountWorkInProgressHook();\n            var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n            // should do this in Fiber, too? Deferring this decision for now because\n            // there's no other place to store the prefix except for an internal field on\n            // the public createRoot object, which the fiber tree does not currently have\n            // a reference to.\n            var identifierPrefix = root.identifierPrefix;\n            var id;\n            if (getIsHydrating()) {\n                var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n                id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n                // that represents the position of this useId hook among all the useId\n                // hooks for this fiber.\n                var localId = localIdCounter++;\n                if (localId > 0) {\n                    id += 'H' + localId.toString(32);\n                }\n                id += ':';\n            } else {\n                // Use a lowercase r prefix for client-generated ids.\n                var globalClientId = globalClientIdCounter++;\n                id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n            }\n            hook.memoizedState = id;\n            return id;\n        }\n        function updateId() {\n            var hook = updateWorkInProgressHook();\n            var id = hook.memoizedState;\n            return id;\n        }\n        function mountRefresh() {\n            var hook = mountWorkInProgressHook();\n            var refresh = hook.memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n            return refresh;\n        }\n        function updateRefresh() {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function refreshCache(fiber, seedKey, seedValue) {\n            // TODO: Consider warning if the refresh is at discrete priority, or if we\n            // otherwise suspect that it wasn't batched properly.\n            var provider = fiber.return;\n            while(provider !== null){\n                switch(provider.tag){\n                    case CacheComponent:\n                    case HostRoot:\n                        {\n                            // Schedule an update on the cache boundary to trigger a refresh.\n                            var lane = requestUpdateLane(provider);\n                            var refreshUpdate = createUpdate(lane);\n                            var root = enqueueUpdate(provider, refreshUpdate, lane);\n                            if (root !== null) {\n                                scheduleUpdateOnFiber(root, provider, lane);\n                                entangleTransitions(root, provider, lane);\n                            } // TODO: If a refresh never commits, the new cache created here must be\n                            // released. A simple case is start refreshing a cache boundary, but then\n                            // unmount that boundary before the refresh completes.\n                            var seededCache = createCache();\n                            if (seedKey !== null && seedKey !== undefined && root !== null) {\n                                {\n                                    {\n                                        error('The seed argument is not enabled outside experimental channels.');\n                                    }\n                                }\n                            }\n                            var payload = {\n                                cache: seededCache\n                            };\n                            refreshUpdate.payload = payload;\n                            return;\n                        }\n                }\n                provider = provider.return;\n            } // TODO: Warn if unmounted?\n        }\n        function dispatchReducerAction(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === 'function') {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                revertLane: NoLane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchSetState(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === 'function') {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                revertLane: NoLane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                var alternate = fiber.alternate;\n                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n                    // The queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. If the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    var lastRenderedReducer = queue.lastRenderedReducer;\n                    if (lastRenderedReducer !== null) {\n                        var prevDispatcher = null;\n                        {\n                            prevDispatcher = ReactSharedInternals.H;\n                            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                        }\n                        try {\n                            var currentState = queue.lastRenderedState;\n                            var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. If the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.hasEagerState = true;\n                            update.eagerState = eagerState;\n                            if (objectIs(eagerState, currentState)) {\n                                // Fast path. We can bail out without scheduling React to re-render.\n                                // It's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                // TODO: Do we still need to entangle transitions in this case?\n                                enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);\n                                return;\n                            }\n                        } catch (error) {} finally{\n                            {\n                                ReactSharedInternals.H = prevDispatcher;\n                            }\n                        }\n                    }\n                }\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n            var transition = requestCurrentTransition();\n            {\n                if (transition === null) {\n                    // An optimistic update occurred, but startTransition is not on the stack.\n                    // There are two likely scenarios.\n                    // One possibility is that the optimistic update is triggered by a regular\n                    // event handler (e.g. `onSubmit`) instead of an action. This is a mistake\n                    // and we will warn.\n                    // The other possibility is the optimistic update is inside an async\n                    // action, but after an `await`. In this case, we can make it \"just work\"\n                    // by associating the optimistic update with the pending async action.\n                    // Technically it's possible that the optimistic update is unrelated to\n                    // the pending action, but we don't have a way of knowing this for sure\n                    // because browsers currently do not provide a way to track async scope.\n                    // (The AsyncContext proposal, if it lands, will solve this in the\n                    // future.) However, this is no different than the problem of unrelated\n                    // transitions being grouped together — it's not wrong per se, but it's\n                    // not ideal.\n                    // Once AsyncContext starts landing in browsers, we will provide better\n                    // warnings in development for these cases.\n                    if (peekEntangledActionLane() !== NoLane) ;\n                    else {\n                        // There's no pending async action. The most likely cause is that we're\n                        // inside a regular event handler (e.g. onSubmit) instead of an action.\n                        error('An optimistic state update occurred outside a transition or ' + 'action. To fix, move the update to an action, or wrap ' + 'with startTransition.');\n                    }\n                }\n            }\n            var update = {\n                // An optimistic update commits synchronously.\n                lane: SyncLane,\n                // After committing, the optimistic update is \"reverted\" using the same\n                // lane as the transition it's associated with.\n                revertLane: requestTransitionLane(),\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                // When calling startTransition during render, this warns instead of\n                // throwing because throwing would be a breaking change. setOptimisticState\n                // is a new API so it's OK to throw.\n                if (throwIfDuringRender) {\n                    throw new Error('Cannot update optimistic state while rendering.');\n                } else {\n                    // startTransition was called during render. We don't need to do anything\n                    // besides warn here because the render phase update would be overidden by\n                    // the second update, anyway. We can remove this branch and make it throw\n                    // in a future release.\n                    {\n                        error('Cannot call startTransition while rendering.');\n                    }\n                }\n            } else {\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, SyncLane);\n                if (root !== null) {\n                    // NOTE: The optimistic update implementation assumes that the transition\n                    // will never be attempted before the optimistic update. This currently\n                    // holds because the optimistic update is always synchronous. If we ever\n                    // change that, we'll need to account for this.\n                    scheduleUpdateOnFiber(root, fiber, SyncLane); // Optimistic updates are always synchronous, so we don't need to call\n                // entangleTransitionUpdate here.\n                }\n            }\n            markUpdateInDevTools(fiber, SyncLane);\n        }\n        function isRenderPhaseUpdate(fiber) {\n            var alternate = fiber.alternate;\n            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n        }\n        function enqueueRenderPhaseUpdate(queue, update) {\n            // This is a render phase update. Stash it in a lazily-created map of\n            // queue -> linked list of updates. After this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n            var pending = queue.pending;\n            if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n            } else {\n                update.next = pending.next;\n                pending.next = update;\n            }\n            queue.pending = update;\n        } // TODO: Move to ReactFiberConcurrentUpdates?\n        function entangleTransitionUpdate(root, queue, lane) {\n            if (isTransitionLane(lane)) {\n                var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n                // must have finished. We can remove them from the shared queue, which\n                // represents a superset of the actually pending lanes. In some cases we\n                // may entangle more than we need to, but that's OK. In fact it's worse if\n                // we *don't* entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function markUpdateInDevTools(fiber, lane, action) {\n            {\n                markStateUpdateScheduled(fiber, lane);\n            }\n        }\n        var ContextOnlyDispatcher = {\n            readContext: readContext,\n            use: use,\n            useCallback: throwInvalidHookError,\n            useContext: throwInvalidHookError,\n            useEffect: throwInvalidHookError,\n            useImperativeHandle: throwInvalidHookError,\n            useLayoutEffect: throwInvalidHookError,\n            useInsertionEffect: throwInvalidHookError,\n            useMemo: throwInvalidHookError,\n            useReducer: throwInvalidHookError,\n            useRef: throwInvalidHookError,\n            useState: throwInvalidHookError,\n            useDebugValue: throwInvalidHookError,\n            useDeferredValue: throwInvalidHookError,\n            useTransition: throwInvalidHookError,\n            useSyncExternalStore: throwInvalidHookError,\n            useId: throwInvalidHookError\n        };\n        {\n            ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n            ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n            ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n        }\n        var HooksDispatcherOnMountInDEV = null;\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\n        var HooksDispatcherOnUpdateInDEV = null;\n        var HooksDispatcherOnRerenderInDEV = null;\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n        {\n            var warnInvalidContextAccess = function() {\n                error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n            };\n            var warnInvalidHookAccess = function() {\n                error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://react.dev/link/rules-of-hooks');\n            };\n            HooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    mountHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    mountHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                HooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    mountHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n                HooksDispatcherOnMountInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                HooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    mountHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            HooksDispatcherOnMountWithHookTypesInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return mountActionState(action, initialState);\n                };\n                HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            HooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return updateDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                HooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return updateActionState(action);\n                };\n                HooksDispatcherOnUpdateInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return updateOptimistic(passthrough, reducer);\n                };\n            }\n            HooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                HooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return rerenderActionState(action);\n                };\n                HooksDispatcherOnRerenderInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return rerenderOptimistic(passthrough, reducer);\n                };\n            }\n            InvalidNestedHooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    mountHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n                InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            InvalidNestedHooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateOptimistic(passthrough, reducer);\n                };\n            }\n            InvalidNestedHooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderOptimistic(passthrough, reducer);\n                };\n            }\n        }\n        var now = Scheduler.unstable_now;\n        var commitTime = 0;\n        var layoutEffectStartTime = -1;\n        var profilerStartTime = -1;\n        var passiveEffectStartTime = -1;\n        /**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */ var currentUpdateIsNested = false;\n        var nestedUpdateScheduled = false;\n        function isCurrentUpdateNested() {\n            return currentUpdateIsNested;\n        }\n        function markNestedUpdateScheduled() {\n            {\n                nestedUpdateScheduled = true;\n            }\n        }\n        function resetNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = false;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function syncNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = nestedUpdateScheduled;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function getCommitTime() {\n            return commitTime;\n        }\n        function recordCommitTime() {\n            commitTime = now();\n        }\n        function startProfilerTimer(fiber) {\n            profilerStartTime = now();\n            if (fiber.actualStartTime < 0) {\n                fiber.actualStartTime = now();\n            }\n        }\n        function stopProfilerTimerIfRunning(fiber) {\n            profilerStartTime = -1;\n        }\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n            if (profilerStartTime >= 0) {\n                var elapsedTime = now() - profilerStartTime;\n                fiber.actualDuration += elapsedTime;\n                if (overrideBaseTime) {\n                    fiber.selfBaseDuration = elapsedTime;\n                }\n                profilerStartTime = -1;\n            }\n        }\n        function recordLayoutEffectDuration(fiber) {\n            if (layoutEffectStartTime >= 0) {\n                var elapsedTime = now() - layoutEffectStartTime;\n                layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            root.effectDuration += elapsedTime;\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            parentStateNode.effectDuration += elapsedTime;\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function recordPassiveEffectDuration(fiber) {\n            if (passiveEffectStartTime >= 0) {\n                var elapsedTime = now() - passiveEffectStartTime;\n                passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            if (root !== null) {\n                                root.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            if (parentStateNode !== null) {\n                                // Detached fibers have their state node cleared out.\n                                // In this case, the return pointer is also cleared out,\n                                // so we won't be able to report the time spent in this Profiler's subtree.\n                                parentStateNode.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function startLayoutEffectTimer() {\n            layoutEffectStartTime = now();\n        }\n        function startPassiveEffectTimer() {\n            passiveEffectStartTime = now();\n        }\n        function transferActualDuration(fiber) {\n            // Transfer time spent rendering these children so we don't lose it\n            // after we rerender. This is used as a helper in special cases\n            // where we should count the work of multiple passes.\n            var child = fiber.child;\n            while(child){\n                // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                fiber.actualDuration += child.actualDuration;\n                child = child.sibling;\n            }\n        }\n        var fakeInternalInstance = {};\n        var didWarnAboutStateAssignmentForComponent;\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutStateAssignmentForComponent = new Set();\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set(); // This is so gross but it's at least non-critical and can be removed if\n            // it causes problems. This is meant to give a nicer error message for\n            // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n            // ...)) which otherwise throws a \"_processChildContext is not a function\"\n            // exception.\n            Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n                enumerable: false,\n                value: function() {\n                    throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n                }\n            });\n            Object.freeze(fakeInternalInstance);\n        }\n        function warnOnInvalidCallback(callback) {\n            {\n                if (callback === null || typeof callback === 'function') {\n                    return;\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var key = String(callback);\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error('Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || 'Component';\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n                    }\n                }\n            }\n        }\n        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n            var prevState = workInProgress.memoizedState;\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        // Invoke the function an extra time to help detect side-effects.\n                        partialState = getDerivedStateFromProps(nextProps, prevState);\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n            // base state.\n            if (workInProgress.lanes === NoLanes) {\n                // Queue is always non-null for classes\n                var updateQueue = workInProgress.updateQueue;\n                updateQueue.baseState = memoizedState;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: isMounted,\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.tag = ReplaceState;\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.tag = ForceUpdate;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        };\n        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n            var instance = workInProgress.stateNode;\n            if (typeof instance.shouldComponentUpdate === 'function') {\n                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            // Invoke the function an extra time to help detect side-effects.\n                            shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    if (shouldUpdate === undefined) {\n                        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n                    }\n                }\n                return shouldUpdate;\n            }\n            if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n            }\n            return true;\n        }\n        function checkClassInstance(workInProgress, ctor, newProps) {\n            var instance = workInProgress.stateNode;\n            {\n                var name = getComponentNameFromType(ctor) || 'Component';\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n                        error('No `render` method found on the %s ' + 'instance: did you accidentally return an object from the constructor?', name);\n                    } else {\n                        error('No `render` method found on the %s ' + 'instance: you may have forgotten to define `render`.', name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n                }\n                if (instance.propTypes) {\n                    error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n                }\n                if (instance.contextType) {\n                    error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n                }\n                {\n                    if (ctor.childContextTypes) {\n                        error('%s uses the legacy childContextTypes API which was removed in React 19. ' + 'Use React.createContext() instead.', name);\n                    }\n                    if (ctor.contextTypes) {\n                        error('%s uses the legacy contextTypes API which was removed in React 19. ' + 'Use React.createContext() with static contextType instead.', name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === 'function') {\n                    error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n                    error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n                }\n                if (typeof instance.componentDidUnmount === 'function') {\n                    error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n                }\n                if (typeof instance.componentDidReceiveProps === 'function') {\n                    error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n                }\n                if (typeof instance.componentWillRecieveProps === 'function') {\n                    error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n                    error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error('When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name);\n                }\n                if (instance.defaultProps) {\n                    error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === 'function') {\n                    error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n                }\n                if (typeof instance.getDerivedStateFromError === 'function') {\n                    error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n                    error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== 'object' || isArray(state))) {\n                    error('%s.state: must be set to an object or null', name);\n                }\n                if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n                    error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n                }\n            }\n        }\n        function constructClassInstance(workInProgress, ctor, props) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if ('contextType' in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE;\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = '';\n                        if (contextType === undefined) {\n                            addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n                        } else if (typeof contextType !== 'object') {\n                            addendum = ' However, it is set to a ' + typeof contextType + '.';\n                        } else if (contextType.$$typeof === REACT_CONSUMER_TYPE) {\n                            addendum = ' Did you accidentally pass the Context.Consumer instead?';\n                        } else {\n                            addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n                        }\n                        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n                    }\n                }\n            }\n            if (typeof contextType === 'object' && contextType !== null) {\n                context = readContext(contextType);\n            }\n            var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        instance = new ctor(props, context); // eslint-disable-line no-new\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n            }\n            var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n            set(instance, workInProgress);\n            {\n                instance._reactInternalInstance = fakeInternalInstance;\n            }\n            {\n                if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n                    var componentName = getComponentNameFromType(ctor) || 'Component';\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = 'componentWillMount';\n                    } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                        foundWillMountName = 'UNSAFE_componentWillMount';\n                    }\n                    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = 'componentWillReceiveProps';\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n                    }\n                    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = 'componentWillUpdate';\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || 'Component';\n                        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://react.dev/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : '', foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : '', foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : '');\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function callComponentWillMount(workInProgress, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === 'function') {\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillReceiveProps === 'function') {\n                instance.componentWillReceiveProps(newProps, nextContext);\n            }\n            if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n            }\n            if (instance.state !== oldState) {\n                {\n                    var componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n                    if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n                        didWarnAboutStateAssignmentForComponent.add(componentName);\n                        error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n                    }\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            {\n                checkClassInstance(workInProgress, ctor, newProps);\n            }\n            var instance = workInProgress.stateNode;\n            instance.props = newProps;\n            instance.state = workInProgress.memoizedState;\n            instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            var contextType = ctor.contextType;\n            if (typeof contextType === 'object' && contextType !== null) {\n                instance.context = readContext(contextType);\n            } else {\n                instance.context = emptyContextObject;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || 'Component';\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n                }\n                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n            }\n            instance.state = workInProgress.memoizedState;\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                instance.state = workInProgress.memoizedState;\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n                callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n                suspendIfUpdateReadFromEntangledAsyncAction();\n                instance.state = workInProgress.memoizedState;\n            }\n            if (typeof instance.componentDidMount === 'function') {\n                workInProgress.flags |= Update | LayoutStatic;\n            }\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags |= MountLayoutDev;\n            }\n        }\n        function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = resolveClassComponentProps(ctor, unresolvedOldProps);\n            instance.props = oldProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === 'object' && contextType !== null) {\n                nextContext = readContext(contextType);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // When comparing whether props changed, we should compare using the\n            // unresolved props object that is stored on the fiber, rather than the\n            // one that gets assigned to the instance, because that object may have been\n            // cloned to resolve default props and/or remove `ref`.\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var didReceiveNewProps = unresolvedNewProps !== unresolvedOldProps; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n                if (didReceiveNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            newState = workInProgress.memoizedState;\n            if (!didReceiveNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n                    if (typeof instance.componentWillMount === 'function') {\n                        instance.componentWillMount();\n                    }\n                    if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                        instance.UNSAFE_componentWillMount();\n                    }\n                }\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        } // Invokes the update life-cycles and returns false if it shouldn't rerender.\n        function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            cloneUpdateQueue(current, workInProgress);\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = resolveClassComponentProps(ctor, unresolvedOldProps);\n            instance.props = oldProps;\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === 'object' && contextType !== null) {\n                nextContext = readContext(contextType);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n                if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            newState = workInProgress.memoizedState;\n            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n            // both before and after `shouldComponentUpdate` has been called. Not ideal,\n            // but I'm loath to refactor this function. This only happens for memoized\n            // components so it's not that common.\n            enableLazyContextPropagation;\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n                    if (typeof instance.componentWillUpdate === 'function') {\n                        instance.componentWillUpdate(newProps, newState, nextContext);\n                    }\n                    if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n                    }\n                }\n                if (typeof instance.componentDidUpdate === 'function') {\n                    workInProgress.flags |= Update;\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    workInProgress.flags |= Snapshot;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized props/state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        }\n        function resolveClassComponentProps(Component, baseProps, // would have already been resolved by the JSX runtime.\n        // TODO: We're going to remove default prop resolution from the JSX runtime\n        // and keep it only for class components. As part of that change, we should\n        // remove this extra check.\n        alreadyResolvedDefaultProps) {\n            var newProps = baseProps;\n            {\n                // Remove ref from the props object, if it exists.\n                if ('ref' in baseProps) {\n                    newProps = {};\n                    for(var propName in baseProps){\n                        if (propName !== 'ref') {\n                            newProps[propName] = baseProps[propName];\n                        }\n                    }\n                }\n            }\n            var defaultProps = Component.defaultProps;\n            if (defaultProps && // default props here in the reconciler, rather than in the JSX runtime.\n            disableDefaultPropsExceptForClasses) {\n                // We may have already copied the props object above to remove ref. If so,\n                // we can modify that. Otherwise, copy the props object with Object.assign.\n                if (newProps === baseProps) {\n                    newProps = assign({}, newProps);\n                } // Taken from old JSX runtime, where this used to live.\n                for(var _propName in defaultProps){\n                    if (newProps[_propName] === undefined) {\n                        newProps[_propName] = defaultProps[_propName];\n                    }\n                }\n            }\n            return newProps;\n        }\n        var reportGlobalError = typeof reportError === 'function' ? // emulating an uncaught JavaScript error.\n        reportError : function(error) {\n            if (false) { var shouldLog, event, message; } else if (typeof process === 'object' && // $FlowFixMe[method-unbinding]\n            typeof process.emit === 'function') {\n                // Node Polyfill\n                process.emit('uncaughtException', error);\n                return;\n            } // eslint-disable-next-line react-internal/no-production-logging\n            console['error'](error);\n        };\n        var componentName = null;\n        var errorBoundaryName = null;\n        function defaultOnUncaughtError(error, errorInfo) {\n            // Overriding this can silence these warnings e.g. for tests.\n            // See https://github.com/facebook/react/pull/13384\n            // For uncaught root errors we report them as uncaught to the browser's\n            // onerror callback. This won't have component stacks and the error addendum.\n            // So we add those into a separate console.warn.\n            reportGlobalError(error);\n            {\n                var componentNameMessage = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : 'An error occurred in one of your React components.';\n                var errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://react.dev/link/error-boundaries to learn more about error boundaries.';\n                {\n                    // The current Fiber is disconnected at this point which means that console printing\n                    // cannot add a component stack since it terminates at the deletion node. This is not\n                    // a problem for owner stacks which are not disconnected but for the parent component\n                    // stacks we need to use the snapshot we've previously extracted.\n                    var componentStack = errorInfo.componentStack != null ? errorInfo.componentStack : ''; // Don't transform to our wrapper\n                    console['warn']('%s\\n\\n%s\\n%s', componentNameMessage, errorBoundaryMessage, componentStack);\n                }\n            }\n        }\n        function defaultOnCaughtError(error$1, errorInfo) {\n            // Overriding this can silence these warnings e.g. for tests.\n            // See https://github.com/facebook/react/pull/13384\n            // Caught by error boundary\n            {\n                var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : 'The above error occurred in one of your React components.'; // In development, we provide our own message which includes the component stack\n                // in addition to the error.\n                var recreateMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + (errorBoundaryName || 'Anonymous') + \".\");\n                {\n                    // The current Fiber is disconnected at this point which means that console printing\n                    // cannot add a component stack since it terminates at the deletion node. This is not\n                    // a problem for owner stacks which are not disconnected but for the parent component\n                    // stacks we need to use the snapshot we've previously extracted.\n                    var componentStack = errorInfo.componentStack != null ? errorInfo.componentStack : ''; // Don't transform to our wrapper\n                    console['error']('%o\\n\\n%s\\n\\n%s\\n%s', error$1, componentNameMessage, recreateMessage, componentStack);\n                }\n            }\n        }\n        function defaultOnRecoverableError(error, errorInfo) {\n            reportGlobalError(error);\n        }\n        function logUncaughtError(root, errorInfo) {\n            try {\n                if (true) {\n                    componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n                    errorBoundaryName = null;\n                }\n                var error = errorInfo.value;\n                if ( true && ReactSharedInternals.actQueue !== null) {\n                    // For uncaught errors inside act, we track them on the act and then\n                    // rethrow them into the test.\n                    ReactSharedInternals.thrownErrors.push(error);\n                    return;\n                }\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        function logCaughtError(root, boundary, errorInfo) {\n            try {\n                if (true) {\n                    componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n                    errorBoundaryName = getComponentNameFromFiber(boundary);\n                }\n                var error = errorInfo.value;\n                var onCaughtError = root.onCaughtError;\n                onCaughtError(error, {\n                    componentStack: errorInfo.stack,\n                    errorBoundary: boundary.tag === ClassComponent ? boundary.stateNode // This should always be the case as long as we only have class boundaries\n                     : null\n                });\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        function createRootErrorUpdate(root, errorInfo, lane) {\n            var update = createUpdate(lane); // Unmount the root by rendering null.\n            update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: null\n            };\n            update.callback = function() {\n                {\n                    runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);\n                }\n            };\n            return update;\n        }\n        function createClassErrorUpdate(lane) {\n            var update = createUpdate(lane);\n            update.tag = CaptureUpdate;\n            return update;\n        }\n        function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n            if (typeof getDerivedStateFromError === 'function') {\n                var error$1 = errorInfo.value;\n                update.payload = function() {\n                    return getDerivedStateFromError(error$1);\n                };\n                update.callback = function() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    {\n                        runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n                    }\n                };\n            }\n            var inst = fiber.stateNode;\n            if (inst !== null && typeof inst.componentDidCatch === 'function') {\n                // $FlowFixMe[missing-this-annot]\n                update.callback = function callback() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    {\n                        runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n                    }\n                    if (typeof getDerivedStateFromError !== 'function') {\n                        // To preserve the preexisting retry behavior of error boundaries,\n                        // we keep track of which ones already failed during this batch.\n                        // This gets reset before we yield back to the browser.\n                        // TODO: Warn in strict mode if getDerivedStateFromError is\n                        // not defined.\n                        markLegacyErrorBoundaryAsFailed(this);\n                    }\n                    var error$1 = errorInfo.value;\n                    var stack = errorInfo.stack;\n                    this.componentDidCatch(error$1, {\n                        componentStack: stack !== null ? stack : ''\n                    });\n                    {\n                        if (typeof getDerivedStateFromError !== 'function') {\n                            // If componentDidCatch is the only error boundary method defined,\n                            // then it needs to call setState to recover from errors.\n                            // If no state update is scheduled then the boundary will swallow the error.\n                            if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                                error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n                            }\n                        }\n                    }\n                };\n            }\n        }\n        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n            // with the normal suspend path.\n            //\n            // After this we'll use a set of heuristics to determine whether this\n            // render pass will run to completion or restart or \"suspend\" the commit.\n            // The actual logic for this is spread out in different places.\n            //\n            // This first principle is that if we're going to suspend when we complete\n            // a root, then we should also restart if we get an update or ping that\n            // might unsuspend it, and vice versa. The only reason to suspend is\n            // because you think you might want to restart before committing. However,\n            // it doesn't make sense to restart only while in the period we're suspended.\n            //\n            // Restarting too aggressively is also not good because it starves out any\n            // intermediate loading state. So we use heuristics to determine when.\n            // Suspense Heuristics\n            //\n            // If nothing threw a Promise or all the same fallbacks are already showing,\n            // then don't suspend/restart.\n            //\n            // If this is an initial render of a new tree of Suspense boundaries and\n            // those trigger a fallback, then don't suspend/restart. We want to ensure\n            // that we can show the initial loading state as quickly as possible.\n            //\n            // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n            // a fallback, then we should always suspend/restart. Transitions apply\n            // to this case. If none is defined, JND is used instead.\n            //\n            // If we're already showing a fallback and it gets \"retried\", allowing us to show\n            // another level, but there's still an inner boundary that would show a fallback,\n            // then we suspend/restart for 500ms since the last time we showed a fallback\n            // anywhere in the tree. This effectively throttles progressive loading into a\n            // consistent train of commits. This also gives us an opportunity to restart to\n            // get to the completed state slightly earlier.\n            //\n            // If there's ambiguity due to batching it's resolved in preference of:\n            // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n            //\n            // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n            // ensure that new initial loading states can commit as soon as possible.\n            suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n            // the begin phase to prevent an early bailout.\n            suspenseBoundary.lanes = rootRenderLanes;\n            return suspenseBoundary;\n        }\n        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n            // The source fiber did not complete.\n            sourceFiber.flags |= Incomplete;\n            {\n                if (isDevToolsPresent) {\n                    // If we have pending work still, restore the original updaters\n                    restorePendingUpdaters(root, rootRenderLanes);\n                }\n            }\n            if (value !== null && typeof value === 'object') {\n                if (typeof value.then === 'function') {\n                    // This is a wakeable. The component suspended.\n                    var wakeable = value;\n                    {\n                        if (getIsHydrating() && disableLegacyMode) {\n                            markDidThrowWhileHydratingDEV();\n                        }\n                    }\n                    var suspenseBoundary = getSuspenseHandler();\n                    if (suspenseBoundary !== null) {\n                        switch(suspenseBoundary.tag){\n                            case SuspenseComponent:\n                                {\n                                    // If this suspense boundary is not already showing a fallback, mark\n                                    // the in-progress render as suspended. We try to perform this logic\n                                    // as soon as soon as possible during the render phase, so the work\n                                    // loop can know things like whether it's OK to switch to other tasks,\n                                    // or whether it can wait for data to resolve before continuing.\n                                    // TODO: Most of these checks are already performed when entering a\n                                    // Suspense boundary. We should track the information on the stack so\n                                    // we don't have to recompute it on demand. This would also allow us\n                                    // to unify with `use` which needs to perform this logic even sooner,\n                                    // before `throwException` is called.\n                                    {\n                                        if (getShellBoundary() === null) {\n                                            // Suspended in the \"shell\" of the app. This is an undesirable\n                                            // loading state. We should avoid committing this tree.\n                                            renderDidSuspendDelayIfPossible();\n                                        } else {\n                                            // If we suspended deeper than the shell, we don't need to delay\n                                            // the commmit. However, we still call renderDidSuspend if this is\n                                            // a new boundary, to tell the work loop that a new fallback has\n                                            // appeared during this render.\n                                            // TODO: Theoretically we should be able to delete this branch.\n                                            // It's currently used for two things: 1) to throttle the\n                                            // appearance of successive loading states, and 2) in\n                                            // SuspenseList, to determine whether the children include any\n                                            // pending fallbacks. For 1, we should apply throttling to all\n                                            // retries, not just ones that render an additional fallback. For\n                                            // 2, we should check subtreeFlags instead. Then we can delete\n                                            // this branch.\n                                            var current = suspenseBoundary.alternate;\n                                            if (current === null) {\n                                                renderDidSuspend();\n                                            }\n                                        }\n                                    }\n                                    suspenseBoundary.flags &= ~ForceClientRender;\n                                    markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Retry listener\n                                    //\n                                    // If the fallback does commit, we need to attach a different type of\n                                    // listener. This one schedules an update on the Suspense boundary to\n                                    // turn the fallback state off.\n                                    //\n                                    // Stash the wakeable on the boundary fiber so we can access it in the\n                                    // commit phase.\n                                    //\n                                    // When the wakeable resolves, we'll attempt to render the boundary\n                                    // again (\"retry\").\n                                    // Check if this is a Suspensey resource. We do not attach retry\n                                    // listeners to these, because we don't actually need them for\n                                    // rendering. Only for committing. Instead, if a fallback commits\n                                    // and the only thing that suspended was a Suspensey resource, we\n                                    // retry immediately.\n                                    // TODO: Refactor throwException so that we don't have to do this type\n                                    // check. The caller already knows what the cause was.\n                                    var isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;\n                                    if (isSuspenseyResource) {\n                                        suspenseBoundary.flags |= ScheduleRetry;\n                                    } else {\n                                        var retryQueue = suspenseBoundary.updateQueue;\n                                        if (retryQueue === null) {\n                                            suspenseBoundary.updateQueue = new Set([\n                                                wakeable\n                                            ]);\n                                        } else {\n                                            retryQueue.add(wakeable);\n                                        } // We only attach ping listeners in concurrent mode. Legacy\n                                        // Suspense always commits fallbacks synchronously, so there are\n                                        // no pings.\n                                        {\n                                            attachPingListener(root, wakeable, rootRenderLanes);\n                                        }\n                                    }\n                                    return false;\n                                }\n                            case OffscreenComponent:\n                                {\n                                    {\n                                        suspenseBoundary.flags |= ShouldCapture;\n                                        var _isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;\n                                        if (_isSuspenseyResource) {\n                                            suspenseBoundary.flags |= ScheduleRetry;\n                                        } else {\n                                            var offscreenQueue = suspenseBoundary.updateQueue;\n                                            if (offscreenQueue === null) {\n                                                var newOffscreenQueue = {\n                                                    transitions: null,\n                                                    markerInstances: null,\n                                                    retryQueue: new Set([\n                                                        wakeable\n                                                    ])\n                                                };\n                                                suspenseBoundary.updateQueue = newOffscreenQueue;\n                                            } else {\n                                                var _retryQueue = offscreenQueue.retryQueue;\n                                                if (_retryQueue === null) {\n                                                    offscreenQueue.retryQueue = new Set([\n                                                        wakeable\n                                                    ]);\n                                                } else {\n                                                    _retryQueue.add(wakeable);\n                                                }\n                                            }\n                                            attachPingListener(root, wakeable, rootRenderLanes);\n                                        }\n                                        return false;\n                                    }\n                                }\n                        }\n                        throw new Error(\"Unexpected Suspense handler tag (\" + suspenseBoundary.tag + \"). This \" + 'is a bug in React.');\n                    } else {\n                        // No boundary was found. Unless this is a sync update, this is OK.\n                        // We can suspend and wait for more data to arrive.\n                        {\n                            // In a concurrent root, suspending without a Suspense boundary is\n                            // allowed. It will suspend indefinitely without committing.\n                            //\n                            // TODO: Should we have different behavior for discrete updates? What\n                            // about flushSync? Maybe it should put the tree into an inert state,\n                            // and potentially log a warning. Revisit this for a future release.\n                            attachPingListener(root, wakeable, rootRenderLanes);\n                            renderDidSuspendDelayIfPossible();\n                            return false;\n                        }\n                    }\n                }\n            } // This is a regular error, not a Suspense wakeable.\n            if (getIsHydrating() && disableLegacyMode) {\n                markDidThrowWhileHydratingDEV();\n                var _suspenseBoundary = getSuspenseHandler(); // If the error was thrown during hydration, we may be able to recover by\n                // discarding the dehydrated content and switching to a client render.\n                // Instead of surfacing the error, find the nearest Suspense boundary\n                // and render it again without hydration.\n                if (_suspenseBoundary !== null) {\n                    if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags$1) {\n                        // Set a flag to indicate that we should try rendering the normal\n                        // children again, not the fallback.\n                        _suspenseBoundary.flags |= ForceClientRender;\n                    }\n                    markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n                    // still log it so it can be fixed.\n                    if (value !== HydrationMismatchException) {\n                        var _wrapperError = new Error('There was an error while hydrating but React was able to recover by ' + 'instead client rendering from the nearest Suspense boundary.', {\n                            cause: value\n                        });\n                        queueHydrationError(createCapturedValueAtFiber(_wrapperError, sourceFiber));\n                    }\n                    return false;\n                } else {\n                    if (value !== HydrationMismatchException) {\n                        var _wrapperError2 = new Error('There was an error while hydrating but React was able to recover by ' + 'instead client rendering the entire root.', {\n                            cause: value\n                        });\n                        queueHydrationError(createCapturedValueAtFiber(_wrapperError2, sourceFiber));\n                    }\n                    var _workInProgress = root.current.alternate; // Schedule an update at the root to log the error but this shouldn't\n                    // actually happen because we should recover.\n                    _workInProgress.flags |= ShouldCapture;\n                    var lane = pickArbitraryLane(rootRenderLanes);\n                    _workInProgress.lanes = mergeLanes(_workInProgress.lanes, lane);\n                    var rootErrorInfo = createCapturedValueAtFiber(value, sourceFiber);\n                    var update = createRootErrorUpdate(_workInProgress.stateNode, rootErrorInfo, lane);\n                    enqueueCapturedUpdate(_workInProgress, update);\n                    renderDidError();\n                    return false;\n                }\n            }\n            var wrapperError = new Error('There was an error during concurrent rendering but React was able to recover by ' + 'instead synchronously rendering the entire root.', {\n                cause: value\n            });\n            queueConcurrentError(createCapturedValueAtFiber(wrapperError, sourceFiber));\n            renderDidError(); // We didn't find a boundary that could handle this type of exception. Start\n            // over and traverse parent path again, this time treating the exception\n            // as an error.\n            if (returnFiber === null) {\n                // There's no return fiber, which means the root errored. This should never\n                // happen. Return `true` to trigger a fatal error (panic).\n                return true;\n            }\n            var errorInfo = createCapturedValueAtFiber(value, sourceFiber);\n            var workInProgress = returnFiber;\n            do {\n                switch(workInProgress.tag){\n                    case HostRoot:\n                        {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane);\n                            var _update = createRootErrorUpdate(workInProgress.stateNode, errorInfo, _lane);\n                            enqueueCapturedUpdate(workInProgress, _update);\n                            return false;\n                        }\n                    case ClassComponent:\n                        // Capture and retry\n                        var ctor = workInProgress.type;\n                        var instance = workInProgress.stateNode;\n                        if ((workInProgress.flags & DidCapture) === NoFlags$1 && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane2 = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane2); // Schedule the error boundary to re-render using updated state\n                            var _update2 = createClassErrorUpdate(_lane2);\n                            initializeClassErrorUpdate(_update2, root, workInProgress, errorInfo);\n                            enqueueCapturedUpdate(workInProgress, _update2);\n                            return false;\n                        }\n                        break;\n                } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                workInProgress = workInProgress.return;\n            }while (workInProgress !== null);\n            return false;\n        }\n        // into a dehydrated boundary.\n        var SelectiveHydrationException = new Error(\"This is not a real error. It's an implementation detail of React's \" + \"selective hydration feature. If this leaks into userspace, it's a bug in \" + 'React. Please file an issue.');\n        var didReceiveUpdate = false;\n        var didWarnAboutBadClass;\n        var didWarnAboutContextTypeOnFunctionComponent;\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\n        var didWarnAboutReassigningProps;\n        var didWarnAboutRevealOrder;\n        var didWarnAboutTailOptions;\n        {\n            didWarnAboutBadClass = {};\n            didWarnAboutContextTypeOnFunctionComponent = {};\n            didWarnAboutGetDerivedStateOnFunctionComponent = {};\n            didWarnAboutReassigningProps = false;\n            didWarnAboutRevealOrder = {};\n            didWarnAboutTailOptions = {};\n        }\n        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n            if (current === null) {\n                // If this is a fresh new component that hasn't been rendered yet, we\n                // won't update its child set by applying minimal side-effects. Instead,\n                // we will add them all to the child before it gets rendered. That means\n                // we can optimize this reconciliation pass by not tracking side-effects.\n                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                // If the current child is the same as the work in progress, it means that\n                // we haven't yet started any work on these children. Therefore, we use\n                // the clone algorithm to create a copy of all the current children.\n                // If we had any progressed work already, that is invalid at this point so\n                // let's throw it out.\n                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n            }\n        }\n        function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n            // This function is fork of reconcileChildren. It's used in cases where we\n            // want to reconcile without matching against the existing set. This has the\n            // effect of all current children being unmounted; even if the type and key\n            // are the same, the old child is unmounted and a new child is created.\n            //\n            // To do this, we're going to go through the reconcile algorithm twice. In\n            // the first pass, we schedule a deletion for all the current children by\n            // passing null.\n            workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n            // pass null in place of where we usually pass the current child set. This has\n            // the effect of remounting all children regardless of whether their\n            // identities match.\n            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n        }\n        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens after the first render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            var render = Component.render;\n            var ref = workInProgress.ref;\n            var propsWithoutRef;\n            if ('ref' in nextProps) {\n                // `ref` is just a prop now, but `forwardRef` expects it to not appear in\n                // the props object. This used to happen in the JSX runtime, but now we do\n                // it here.\n                propsWithoutRef = {};\n                for(var key in nextProps){\n                    // Since `ref` should only appear in props via the JSX transform, we can\n                    // assume that this is a plain object. So we don't need a\n                    // hasOwnProperty check.\n                    if (key !== 'ref') {\n                        propsWithoutRef[key] = nextProps[key];\n                    }\n                }\n            } else {\n                propsWithoutRef = nextProps;\n            } // The rest is a fork of updateFunctionComponent\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                nextChildren = renderWithHooks(current, workInProgress, render, propsWithoutRef, ref, renderLanes);\n                hasId = checkDidRenderIdHook();\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            if (current === null) {\n                var type = Component.type;\n                if (isSimpleFunctionComponent(type) && Component.compare === null && disableDefaultPropsExceptForClasses) {\n                    var resolvedType = type;\n                    {\n                        resolvedType = resolveFunctionForHotReloading(type);\n                    }\n                    // and with only the default shallow comparison, we upgrade it\n                    // to a SimpleMemoComponent to allow fast path updates.\n                    workInProgress.tag = SimpleMemoComponent;\n                    workInProgress.type = resolvedType;\n                    {\n                        validateFunctionComponentInDev(workInProgress, type);\n                    }\n                    return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n                }\n                var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n                child.ref = workInProgress.ref;\n                child.return = workInProgress;\n                workInProgress.child = child;\n                return child;\n            }\n            var currentChild = current.child; // This is always exactly one child\n            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n            if (!hasScheduledUpdateOrContext) {\n                // This will be the props with resolved defaultProps,\n                // unlike current.memoizedProps which will be the unresolved ones.\n                var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n                var compare = Component.compare;\n                compare = compare !== null ? compare : shallowEqual;\n                if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            var newChild = createWorkInProgress(currentChild, nextProps);\n            newChild.ref = workInProgress.ref;\n            newChild.return = workInProgress;\n            workInProgress.child = newChild;\n            return newChild;\n        }\n        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens when the inner render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            if (current !== null) {\n                var prevProps = current.memoizedProps;\n                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {\n                    didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we\n                    // would during a normal fiber bailout.\n                    //\n                    // We don't have strong guarantees that the props object is referentially\n                    // equal during updates where we can't bail out anyway — like if the props\n                    // are shallowly equal, but there's a local state or context update in the\n                    // same batch.\n                    //\n                    // However, as a principle, we should aim to make the behavior consistent\n                    // across different ways of memoizing a component. For example, React.memo\n                    // has a different internal Fiber layout if you pass a normal function\n                    // component (SimpleMemoComponent) versus if you pass a different type\n                    // like forwardRef (MemoComponent). But this is an implementation detail.\n                    // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n                    // affect whether the props object is reused during a bailout.\n                    workInProgress.pendingProps = nextProps = prevProps;\n                    if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n                        // The pending lanes were cleared at the beginning of beginWork. We're\n                        // about to bail out, but there might be other lanes that weren't\n                        // included in the current render. Usually, the priority level of the\n                        // remaining updates is accumulated during the evaluation of the\n                        // component (i.e. when processing the update queue). But since since\n                        // we're bailing out early *without* evaluating the component, we need\n                        // to account for it here, too. Reset to the value of the current fiber.\n                        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n                        // because a MemoComponent fiber does not have hooks or an update queue;\n                        // rather, it wraps around an inner component, which may or may not\n                        // contains hooks.\n                        // TODO: Move the reset at in beginWork out of the common path so that\n                        // this is no longer necessary.\n                        workInProgress.lanes = current.lanes;\n                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags$1) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    }\n                }\n            }\n            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n        }\n        function updateOffscreenComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            var nextIsDetached = (workInProgress.stateNode._pendingVisibility & OffscreenDetached) !== 0;\n            var prevState = current !== null ? current.memoizedState : null;\n            markRef(current, workInProgress);\n            if (nextProps.mode === 'hidden' || enableLegacyHidden || nextIsDetached) {\n                // Rendering a hidden tree.\n                var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags$1;\n                if (didSuspend) {\n                    // Something suspended inside a hidden tree\n                    // Include the base lanes from the last render\n                    var nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n                    if (current !== null) {\n                        // Reset to the current children\n                        var currentChild = workInProgress.child = current.child; // The current render suspended, but there may be other lanes with\n                        // pending work. We can't read `childLanes` from the current Offscreen\n                        // fiber because we reset it when it was deferred; however, we can read\n                        // the pending lanes from the child fibers.\n                        var currentChildLanes = NoLanes;\n                        while(currentChild !== null){\n                            currentChildLanes = mergeLanes(mergeLanes(currentChildLanes, currentChild.lanes), currentChild.childLanes);\n                            currentChild = currentChild.sibling;\n                        }\n                        var lanesWeJustAttempted = nextBaseLanes;\n                        var remainingChildLanes = removeLanes(currentChildLanes, lanesWeJustAttempted);\n                        workInProgress.childLanes = remainingChildLanes;\n                    } else {\n                        workInProgress.childLanes = NoLanes;\n                        workInProgress.child = null;\n                    }\n                    return deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes);\n                }\n                if (!includesSomeLane(renderLanes, OffscreenLane)) {\n                    // We're hidden, and we're not rendering at Offscreen. We will bail out\n                    // and resume this tree later.\n                    // Schedule this fiber to re-render at Offscreen priority\n                    workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane); // Include the base lanes from the last render\n                    var _nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n                    return deferHiddenOffscreenComponent(current, workInProgress, _nextBaseLanes);\n                } else {\n                    // This is the second render. The surrounding visible content has already\n                    // committed. Now we resume rendering the hidden tree.\n                    // Rendering at offscreen, so we can clear the base lanes.\n                    var _nextState = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = _nextState;\n                    if (current !== null) {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        var prevCachePool = prevState !== null ? prevState.cachePool : null; // TODO: Consider if and how Offscreen pre-rendering should\n                        // be attributed to the transition that spawned it\n                        pushTransition(workInProgress, prevCachePool);\n                    } // Push the lanes that were skipped when we bailed out.\n                    if (prevState !== null) {\n                        pushHiddenContext(workInProgress, prevState);\n                    } else {\n                        reuseHiddenContextOnStack(workInProgress);\n                    }\n                    pushOffscreenSuspenseHandler(workInProgress);\n                }\n            } else {\n                // Rendering a visible tree.\n                if (prevState !== null) {\n                    // We're going from hidden -> visible.\n                    var _prevCachePool = null;\n                    {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        _prevCachePool = prevState.cachePool;\n                    }\n                    pushTransition(workInProgress, _prevCachePool); // Push the lanes that were skipped when we bailed out.\n                    pushHiddenContext(workInProgress, prevState);\n                    reuseSuspenseHandlerOnStack(workInProgress); // Since we're not hidden anymore, reset the state\n                    workInProgress.memoizedState = null;\n                } else {\n                    // We weren't previously hidden, and we still aren't, so there's nothing\n                    // special to do. Need to push to the stack regardless, though, to avoid\n                    // a push/pop misalignment.\n                    {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        if (current !== null) {\n                            pushTransition(workInProgress, null);\n                        }\n                    }\n                    // to avoid a push/pop misalignment.\n                    reuseHiddenContextOnStack(workInProgress);\n                    reuseSuspenseHandlerOnStack(workInProgress);\n                }\n            }\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n            var nextState = {\n                baseLanes: nextBaseLanes,\n                // Save the cache pool so we can resume later.\n                cachePool: getOffscreenDeferredCache()\n            };\n            workInProgress.memoizedState = nextState;\n            {\n                // push the cache pool even though we're going to bail out\n                // because otherwise there'd be a context mismatch\n                if (current !== null) {\n                    pushTransition(workInProgress, null);\n                }\n            }\n            // to avoid a push/pop misalignment.\n            reuseHiddenContextOnStack(workInProgress);\n            pushOffscreenSuspenseHandler(workInProgress);\n            return null;\n        } // Note: These happen to have identical begin phases, for now. We shouldn't hold\n        function updateCacheComponent(current, workInProgress, renderLanes) {\n            prepareToReadContext(workInProgress, renderLanes);\n            var parentCache = readContext(CacheContext);\n            if (current === null) {\n                // Initial mount. Request a fresh cache from the pool.\n                var freshCache = requestCacheFromPool(renderLanes);\n                var initialState = {\n                    parent: parentCache,\n                    cache: freshCache\n                };\n                workInProgress.memoizedState = initialState;\n                initializeUpdateQueue(workInProgress);\n                pushCacheProvider(workInProgress, freshCache);\n            } else {\n                // Check for updates\n                if (includesSomeLane(current.lanes, renderLanes)) {\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, null, null, renderLanes);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                }\n                var prevState = current.memoizedState;\n                var nextState = workInProgress.memoizedState; // Compare the new parent cache to the previous to see detect there was\n                // a refresh.\n                if (prevState.parent !== parentCache) {\n                    // Refresh in parent. Update the parent.\n                    var derivedState = {\n                        parent: parentCache,\n                        cache: parentCache\n                    }; // Copied from getDerivedStateFromProps implementation. Once the update\n                    // queue is empty, persist the derived state onto the base state.\n                    workInProgress.memoizedState = derivedState;\n                    if (workInProgress.lanes === NoLanes) {\n                        var updateQueue = workInProgress.updateQueue;\n                        workInProgress.memoizedState = updateQueue.baseState = derivedState;\n                    }\n                    pushCacheProvider(workInProgress, parentCache); // No need to propagate a context change because the refreshed parent\n                // already did.\n                } else {\n                    // The parent didn't refresh. Now check if this cache did.\n                    var nextCache = nextState.cache;\n                    pushCacheProvider(workInProgress, nextCache);\n                    if (nextCache !== prevState.cache) {\n                        // This cache refreshed. Propagate a context change.\n                        propagateContextChange(workInProgress, CacheContext, renderLanes);\n                    }\n                }\n            }\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        } // This should only be called if the name changes\n        function updateFragment(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMode(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateProfiler(current, workInProgress, renderLanes) {\n            {\n                workInProgress.flags |= Update;\n                {\n                    // Reset effect durations for the next eventual effect phase.\n                    // These are reset during render to allow the DevTools commit hook a chance to read them,\n                    var stateNode = workInProgress.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                }\n            }\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markRef(current, workInProgress) {\n            // TODO: Check props.ref instead of fiber.ref when enableRefAsProp is on.\n            var ref = workInProgress.ref;\n            if (ref === null) {\n                if (current !== null && current.ref !== null) {\n                    // Schedule a Ref effect\n                    workInProgress.flags |= Ref | RefStatic;\n                }\n            } else {\n                if (typeof ref !== 'function' && typeof ref !== 'object') {\n                    throw new Error('Expected ref to be a function, an object returned by React.createRef(), or undefined/null.');\n                }\n                if (current === null || current.ref !== ref) {\n                    workInProgress.flags |= Ref | RefStatic;\n                }\n            }\n        }\n        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                if (Component.prototype && typeof Component.prototype.render === 'function') {\n                    var componentName = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n                }\n                if (current === null) {\n                    // Some validations were previously done in mountIndeterminateComponent however and are now run\n                    // in updateFuntionComponent but only on mount\n                    validateFunctionComponentInDev(workInProgress, workInProgress.type);\n                    if (Component.contextTypes) {\n                        error('%s uses the legacy contextTypes API which was removed in React 19. ' + 'Use React.createContext() with React.useContext() instead.', getComponentNameFromType(Component) || 'Unknown');\n                    }\n                }\n            }\n            var context;\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n            // This function is used to replay a component that previously suspended,\n            // after its data resolves. It's a simplified version of\n            // updateFunctionComponent that reuses the hooks from the previous attempt.\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var nextChildren = replaySuspendedComponentWithHooks(current, workInProgress, Component, nextProps, secondArg);\n            var hasId = checkDidRenderIdHook();\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                // This is used by DevTools to force a boundary to error.\n                switch(shouldError(workInProgress)){\n                    case false:\n                        {\n                            var _instance = workInProgress.stateNode;\n                            var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n                            // Is there a better way to do this?\n                            var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n                            var state = tempInstance.state;\n                            _instance.updater.enqueueSetState(_instance, state, null);\n                            break;\n                        }\n                    case true:\n                        {\n                            workInProgress.flags |= DidCapture;\n                            workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n                            var error$1 = new Error('Simulated error coming from DevTools');\n                            var lane = pickArbitraryLane(renderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n                            var root = getWorkInProgressRoot();\n                            if (root === null) {\n                                throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                            }\n                            var update = createClassErrorUpdate(lane);\n                            initializeClassErrorUpdate(update, root, workInProgress, createCapturedValueAtFiber(error$1, workInProgress));\n                            enqueueCapturedUpdate(workInProgress, update);\n                            break;\n                        }\n                }\n            }\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider()) {\n                hasContext = true;\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var instance = workInProgress.stateNode;\n            var shouldUpdate;\n            if (instance === null) {\n                constructClassInstance(workInProgress, Component, nextProps);\n                mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n                shouldUpdate = true;\n            } else if (current === null) {\n                // In a resume, we'll already have an instance we can reuse.\n                shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            } else {\n                shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n            }\n            var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n            {\n                var inst = workInProgress.stateNode;\n                if (shouldUpdate && inst.props !== nextProps) {\n                    if (!didWarnAboutReassigningProps) {\n                        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            return nextUnitOfWork;\n        }\n        function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n            // Refs should update even if shouldComponentUpdate returns false\n            markRef(current, workInProgress);\n            var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags$1;\n            if (!shouldUpdate && !didCaptureError) {\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            var instance = workInProgress.stateNode; // Rerender\n            {\n                setCurrentFiber(workInProgress);\n            }\n            var nextChildren;\n            if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n                // If we captured an error, but getDerivedStateFromError is not defined,\n                // unmount all the children. componentDidCatch will schedule an update to\n                // re-render a fallback. This is temporary until we migrate everyone to\n                // the new API.\n                // TODO: Warn in a future release.\n                nextChildren = null;\n                {\n                    stopProfilerTimerIfRunning();\n                }\n            } else {\n                {\n                    markComponentRenderStarted(workInProgress);\n                }\n                {\n                    nextChildren = callRenderInDEV(instance);\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            callRenderInDEV(instance);\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                }\n                {\n                    markComponentRenderStopped();\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            if (current !== null && didCaptureError) {\n                // If we're recovering from an error, reconcile without reusing any of\n                // the existing children. Conceptually, the normal children and the children\n                // that are shown on error are two different sets, so we shouldn't reuse\n                // normal children even if their identities match.\n                forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            } // Memoize state using the values we just used to render.\n            // TODO: Restructure so we never read values from the instance.\n            workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n            return workInProgress.child;\n        }\n        function pushHostRootContext(workInProgress) {\n            var root = workInProgress.stateNode;\n            pushHostContainer(workInProgress, root.containerInfo);\n        }\n        function updateHostRoot(current, workInProgress, renderLanes) {\n            pushHostRootContext(workInProgress);\n            if (current === null) {\n                throw new Error('Should have a current fiber. This is a bug in React.');\n            }\n            var nextProps = workInProgress.pendingProps;\n            var prevState = workInProgress.memoizedState;\n            var prevChildren = prevState.element;\n            cloneUpdateQueue(current, workInProgress);\n            processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n            var nextState = workInProgress.memoizedState;\n            {\n                var nextCache = nextState.cache;\n                pushCacheProvider(workInProgress, nextCache);\n                if (nextCache !== prevState.cache) {\n                    // The root cache refreshed.\n                    propagateContextChange(workInProgress, CacheContext, renderLanes);\n                }\n            }\n            // it needs to happen after the `pushCacheProvider` call above to avoid a\n            // context stack mismatch. A bit unfortunate.\n            suspendIfUpdateReadFromEntangledAsyncAction(); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            var nextChildren = nextState.element;\n            if (supportsHydration && prevState.isDehydrated) {\n                // This is a hydration root whose shell has not yet hydrated. We should\n                // attempt to hydrate.\n                // Flip isDehydrated to false to indicate that when this render\n                // finishes, the root will no longer be dehydrated.\n                var overrideState = {\n                    element: nextChildren,\n                    isDehydrated: false,\n                    cache: nextState.cache\n                };\n                var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n                // have reducer functions so it doesn't need rebasing.\n                updateQueue.baseState = overrideState;\n                workInProgress.memoizedState = overrideState;\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during a previous attempt to hydrate the shell, so we\n                    // forced a client render. We should have a recoverable error already scheduled.\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes);\n                } else if (nextChildren !== prevChildren) {\n                    var recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);\n                    queueHydrationError(recoverableError);\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes);\n                } else {\n                    // The outermost shell has not hydrated yet. Start hydrating.\n                    enterHydrationState(workInProgress);\n                    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n                    workInProgress.child = child;\n                    var node = child;\n                    while(node){\n                        // Mark each child as hydrating. This is a fast path to know whether this\n                        // tree is part of a hydrating tree. This is used to determine if a child\n                        // node has fully mounted yet, and for scheduling event replaying.\n                        // Conceptually this is similar to Placement in that a new subtree is\n                        // inserted into the React tree here. It just happens to not need DOM\n                        // mutations because it already exists.\n                        node.flags = node.flags & ~Placement | Hydrating;\n                        node = node.sibling;\n                    }\n                }\n            } else {\n                // Root is not dehydrated. Either this is a client-only root, or it\n                // already hydrated.\n                resetHydrationState();\n                if (nextChildren === prevChildren) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n            // Revert to client rendering.\n            resetHydrationState();\n            workInProgress.flags |= ForceClientRender;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostComponent$1(current, workInProgress, renderLanes) {\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            }\n            pushHostContext(workInProgress);\n            var type = workInProgress.type;\n            var nextProps = workInProgress.pendingProps;\n            var prevProps = current !== null ? current.memoizedProps : null;\n            var nextChildren = nextProps.children;\n            var isDirectTextChild = shouldSetTextContent(type, nextProps);\n            if (isDirectTextChild) {\n                // We special case a direct text child of a host node. This is a common\n                // case. We won't handle it as a reified child. We will instead handle\n                // this in the host environment that also has access to this prop. That\n                // avoids allocating another HostText fiber and traversing it.\n                nextChildren = null;\n            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n                // If we're switching from a direct text child to a normal child, or to\n                // empty, we need to schedule the text content to be reset.\n                workInProgress.flags |= ContentReset;\n            }\n            {\n                var memoizedState = workInProgress.memoizedState;\n                if (memoizedState !== null) {\n                    // This fiber has been upgraded to a stateful component. The only way\n                    // happens currently is for form actions. We use hooks to track the\n                    // pending and error state of the form.\n                    //\n                    // Once a fiber is upgraded to be stateful, it remains stateful for the\n                    // rest of its lifetime.\n                    var newState = renderTransitionAwareHostComponentWithHooks(current, workInProgress, renderLanes); // If the transition state changed, propagate the change to all the\n                    // descendents. We use Context as an implementation detail for this.\n                    //\n                    // This is intentionally set here instead of pushHostContext because\n                    // pushHostContext gets called before we process the state hook, to avoid\n                    // a state mismatch in the event that something suspends.\n                    //\n                    // NOTE: This assumes that there cannot be nested transition providers,\n                    // because the only renderer that implements this feature is React DOM,\n                    // and forms cannot be nested. If we did support nested providers, then\n                    // we would need to push a context value even for host fibers that\n                    // haven't been upgraded yet.\n                    if (isPrimaryRenderer) {\n                        HostTransitionContext._currentValue = newState;\n                    } else {\n                        HostTransitionContext._currentValue2 = newState;\n                    }\n                    {\n                        if (didReceiveUpdate) {\n                            if (current !== null) {\n                                var oldStateHook = current.memoizedState;\n                                var oldState = oldStateHook.memoizedState; // This uses regular equality instead of Object.is because we assume\n                                // that host transition state doesn't include NaN as a valid type.\n                                if (oldState !== newState) {\n                                    propagateContextChange(workInProgress, HostTransitionContext, renderLanes);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            markRef(current, workInProgress);\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostHoistable(current, workInProgress, renderLanes) {\n            markRef(current, workInProgress);\n            if (current === null) {\n                var resource = getResource(workInProgress.type, null, workInProgress.pendingProps, null);\n                if (resource) {\n                    workInProgress.memoizedState = resource;\n                } else {\n                    if (!getIsHydrating()) {\n                        // This is not a Resource Hoistable and we aren't hydrating so we construct the instance.\n                        workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, getRootHostContainer(), workInProgress);\n                    }\n                }\n            } else {\n                // Get Resource may or may not return a resource. either way we stash the result\n                // on memoized state.\n                workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState);\n            } // Resources never have reconciler managed children. It is possible for\n            // the host implementation of getResource to consider children in the\n            // resource construction but they will otherwise be discarded. In practice\n            // this precludes all but the simplest children and Host specific warnings\n            // should be implemented to warn when children are passsed when otherwise not\n            // expected\n            return null;\n        }\n        function updateHostSingleton(current, workInProgress, renderLanes) {\n            pushHostContext(workInProgress);\n            if (current === null) {\n                claimHydratableSingleton(workInProgress);\n            }\n            var nextChildren = workInProgress.pendingProps.children;\n            if (current === null && !getIsHydrating()) {\n                // Similar to Portals we append Singleton children in the commit phase. So we\n                // Track insertions even on mount.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            markRef(current, workInProgress);\n            return workInProgress.child;\n        }\n        function updateHostText$1(current, workInProgress) {\n            if (current === null) {\n                tryToClaimNextHydratableTextInstance(workInProgress);\n            } // Nothing to do here. This is terminal. We'll do the completion step\n            // immediately after.\n            return null;\n        }\n        function mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n            var props = workInProgress.pendingProps;\n            var lazyComponent = elementType;\n            var Component;\n            {\n                Component = callLazyInitInDEV(lazyComponent);\n            }\n            workInProgress.type = Component;\n            if (typeof Component === 'function') {\n                if (isFunctionClassComponent(Component)) {\n                    var resolvedProps = resolveClassComponentProps(Component, props);\n                    workInProgress.tag = ClassComponent;\n                    {\n                        workInProgress.type = Component = resolveClassForHotReloading(Component);\n                    }\n                    return updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                } else {\n                    var _resolvedProps = props;\n                    workInProgress.tag = FunctionComponent;\n                    {\n                        validateFunctionComponentInDev(workInProgress, Component);\n                        workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n                    }\n                    return updateFunctionComponent(null, workInProgress, Component, _resolvedProps, renderLanes);\n                }\n            } else if (Component !== undefined && Component !== null) {\n                var $$typeof = Component.$$typeof;\n                if ($$typeof === REACT_FORWARD_REF_TYPE) {\n                    var _resolvedProps2 = props;\n                    workInProgress.tag = ForwardRef;\n                    {\n                        workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n                    }\n                    return updateForwardRef(null, workInProgress, Component, _resolvedProps2, renderLanes);\n                } else if ($$typeof === REACT_MEMO_TYPE) {\n                    var _resolvedProps3 = props;\n                    workInProgress.tag = MemoComponent;\n                    return updateMemoComponent(null, workInProgress, Component, _resolvedProps3, renderLanes);\n                }\n            }\n            var hint = '';\n            {\n                if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n                    hint = ' Did you wrap a component in React.lazy() more than once?';\n                }\n            }\n            // because the fact that it's a separate type of work is an\n            // implementation detail.\n            throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n        }\n        function validateFunctionComponentInDev(workInProgress, Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error('childContextTypes cannot be defined on a function component.\\n' + '  %s.childContextTypes = ...', Component.displayName || Component.name || 'Component');\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === 'function') {\n                    var _componentName2 = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]) {\n                        error('%s: Function components do not support getDerivedStateFromProps.', _componentName2);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true;\n                    }\n                }\n                if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n                    var _componentName3 = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName3]) {\n                        error('%s: Function components do not support contextType.', _componentName3);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n            }\n        }\n        var SUSPENDED_MARKER = {\n            dehydrated: null,\n            treeContext: null,\n            retryLane: NoLane\n        };\n        function mountSuspenseOffscreenState(renderLanes) {\n            return {\n                baseLanes: renderLanes,\n                cachePool: getSuspendedCache()\n            };\n        }\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n            var cachePool = null;\n            {\n                var prevCachePool = prevOffscreenState.cachePool;\n                if (prevCachePool !== null) {\n                    var parentCache = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2;\n                    if (prevCachePool.parent !== parentCache) {\n                        // Detected a refresh in the parent. This overrides any previously\n                        // suspended cache.\n                        cachePool = {\n                            parent: parentCache,\n                            pool: parentCache\n                        };\n                    } else {\n                        // We can reuse the cache from last time. The only thing that would have\n                        // overridden it is a parent refresh, which we checked for above.\n                        cachePool = prevCachePool;\n                    }\n                } else {\n                    // If there's no previous cache pool, grab the current one.\n                    cachePool = getSuspendedCache();\n                }\n            }\n            return {\n                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n                cachePool: cachePool\n            };\n        } // TODO: Probably should inline this back\n        function shouldRemainOnFallback(current, workInProgress, renderLanes) {\n            // If we're already showing a fallback, there are cases where we need to\n            // remain on that fallback regardless of whether the content has resolved.\n            // For example, SuspenseList coordinates when nested content appears.\n            // TODO: For compatibility with offscreen prerendering, this should also check\n            // whether the current fiber (if it exists) was visible in the previous tree.\n            if (current !== null) {\n                var suspenseState = current.memoizedState;\n                if (suspenseState === null) {\n                    // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n                    // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n                    // Note: This is a factoring smell. Can't remain on a fallback if there's\n                    // no fallback to remain on.\n                    return false;\n                }\n            } // Not currently showing content. Consult the Suspense context.\n            var suspenseContext = suspenseStackCursor.current;\n            return hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n        }\n        function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n            var remainingLanes = current !== null ? removeLanes(current.childLanes, renderLanes) : NoLanes;\n            if (primaryTreeDidDefer) {\n                // A useDeferredValue hook spawned a deferred task inside the primary tree.\n                // Ensure that we retry this component at the deferred priority.\n                // TODO: We could make this a per-subtree value instead of a global one.\n                // Would need to track it on the context stack somehow, similar to what\n                // we'd have to do for resumable contexts.\n                remainingLanes = mergeLanes(remainingLanes, peekDeferredLane());\n            }\n            return remainingLanes;\n        }\n        function updateSuspenseComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n            {\n                if (shouldSuspend(workInProgress)) {\n                    workInProgress.flags |= DidCapture;\n                }\n            }\n            var showFallback = false;\n            var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags$1;\n            if (didSuspend || shouldRemainOnFallback(current)) {\n                // Something in this boundary's subtree already suspended. Switch to\n                // rendering the fallback children.\n                showFallback = true;\n                workInProgress.flags &= ~DidCapture;\n            } // Check if the primary children spawned a deferred task (useDeferredValue)\n            // during the first pass.\n            var didPrimaryChildrenDefer = (workInProgress.flags & DidDefer) !== NoFlags$1;\n            workInProgress.flags &= ~DidDefer; // OK, the next part is confusing. We're about to reconcile the Suspense\n            // boundary's children. This involves some custom reconciliation logic. Two\n            // main reasons this is so complicated.\n            //\n            // First, Legacy Mode has different semantics for backwards compatibility. The\n            // primary tree will commit in an inconsistent state, so when we do the\n            // second pass to render the fallback, we do some exceedingly, uh, clever\n            // hacks to make that not totally break. Like transferring effects and\n            // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n            // because we bailout on the primary tree completely and leave it in its old\n            // state, no effects. Same as what we do for Offscreen (except that\n            // Offscreen doesn't have the first render pass).\n            //\n            // Second is hydration. During hydration, the Suspense fiber has a slightly\n            // different layout, where the child points to a dehydrated fragment, which\n            // contains the DOM rendered by the server.\n            //\n            // Third, even if you set all that aside, Suspense is like error boundaries in\n            // that we first we try to render one tree, and if that fails, we render again\n            // and switch to a different tree. Like a try/catch block. So we have to track\n            // which branch we're currently rendering. Ideally we would model this using\n            // a stack.\n            if (current === null) {\n                // Initial mount\n                // Special path for hydration\n                // If we're currently hydrating, try to hydrate this boundary.\n                if (getIsHydrating()) {\n                    // We must push the suspense handler context *before* attempting to\n                    // hydrate, to avoid a mismatch in case it errors.\n                    if (showFallback) {\n                        pushPrimaryTreeSuspenseHandler(workInProgress);\n                    } else {\n                        pushFallbackTreeSuspenseHandler(workInProgress);\n                    }\n                    tryToClaimNextHydratableSuspenseInstance(workInProgress); // This could've been a dehydrated suspense component.\n                    var suspenseState = workInProgress.memoizedState;\n                    if (suspenseState !== null) {\n                        var dehydrated = suspenseState.dehydrated;\n                        if (dehydrated !== null) {\n                            return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n                        }\n                    } // If hydration didn't succeed, fall through to the normal Suspense path.\n                    // To avoid a stack mismatch we need to pop the Suspense handler that we\n                    // pushed above. This will become less awkward when move the hydration\n                    // logic to its own fiber.\n                    popSuspenseHandler(workInProgress);\n                }\n                var nextPrimaryChildren = nextProps.children;\n                var nextFallbackChildren = nextProps.fallback;\n                if (showFallback) {\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var primaryChildFragment = workInProgress.child;\n                    primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackFragment;\n                } else {\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n                }\n            } else {\n                // This is an update.\n                // Special path for hydration\n                var prevState = current.memoizedState;\n                if (prevState !== null) {\n                    var _dehydrated = prevState.dehydrated;\n                    if (_dehydrated !== null) {\n                        return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, didPrimaryChildrenDefer, nextProps, _dehydrated, prevState, renderLanes);\n                    }\n                }\n                if (showFallback) {\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var _nextFallbackChildren = nextProps.fallback;\n                    var _nextPrimaryChildren = nextProps.children;\n                    var fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n                    var _primaryChildFragment2 = workInProgress.child;\n                    var prevOffscreenState = current.child.memoizedState;\n                    _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n                    _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackChildFragment;\n                } else {\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    var _nextPrimaryChildren2 = nextProps.children;\n                    var _primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2);\n                    workInProgress.memoizedState = null;\n                    return _primaryChildFragment3;\n                }\n            }\n        }\n        function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'visible',\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n            primaryChildFragment.return = workInProgress;\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'hidden',\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            var fallbackChildFragment;\n            {\n                primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            }\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n            // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n            // this wrapper function to constrain it.\n            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n        }\n        function updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n            // The props argument to `createWorkInProgress` is `any` typed, so we use this\n            // wrapper function to constrain it.\n            return createWorkInProgress(current, offscreenProps);\n        }\n        function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n                mode: 'visible',\n                children: primaryChildren\n            });\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = null;\n            if (currentFallbackChildFragment !== null) {\n                // Delete the fallback child fragment\n                var deletions = workInProgress.deletions;\n                if (deletions === null) {\n                    workInProgress.deletions = [\n                        currentFallbackChildFragment\n                    ];\n                    workInProgress.flags |= ChildDeletion;\n                } else {\n                    deletions.push(currentFallbackChildFragment);\n                }\n            }\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildProps = {\n                mode: 'hidden',\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            {\n                primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); // Since we're reusing a current tree, we need to reuse the flags, too.\n                // (We don't do this in legacy mode, because in legacy mode we don't re-use\n                // the current tree; see previous branch.)\n                primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n            }\n            var fallbackChildFragment;\n            if (currentFallbackChildFragment !== null) {\n                fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n            } else {\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n                // mounted but this is a new fiber.\n                fallbackChildFragment.flags |= Placement;\n            }\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n            // Falling back to client rendering. Because this has performance\n            // implications, it's considered a recoverable error, even though the user\n            // likely won't observe anything wrong with the UI.\n            // This will add the old fiber to the deletion list\n            reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n            var nextProps = workInProgress.pendingProps;\n            var primaryChildren = nextProps.children;\n            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n            // mounted but this is a new fiber.\n            primaryChildFragment.flags |= Placement;\n            workInProgress.memoizedState = null;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var fiberMode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'visible',\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n            // boundary) already mounted but this is a new fiber.\n            fallbackChildFragment.flags |= Placement;\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            {\n                // We will have dropped the effect list which contains the\n                // deletion. We need to reconcile to delete the current child.\n                reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n            }\n            return fallbackChildFragment;\n        }\n        function mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n            // During the first pass, we'll bail out and not drill into the children.\n            // Instead, we'll leave the content in place and try to hydrate it later.\n            if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This is a client-only boundary. Since we won't get any content from the server\n                // for this, we need to schedule that at a higher priority based on when it would\n                // have timed out. In theory we could render it in this pass but it would have the\n                // wrong priority associated with it and will prevent hydration of parent path.\n                // Instead, we'll leave work left on it to render it in a separate commit.\n                // TODO This time should be the time at which the server rendered response that is\n                // a parent to this boundary was displayed. However, since we currently don't have\n                // a protocol to transfer that time, we'll just estimate it by using the current\n                // time. This will mean that Suspense timeouts are slightly shifted to later than\n                // they should be.\n                // Schedule a normal pri update to render this content.\n                workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n            } else {\n                // We'll continue hydrating the rest at offscreen priority since we'll already\n                // be showing the right content coming from the server, it is no rush.\n                workInProgress.lanes = laneToLanes(OffscreenLane);\n            }\n            return null;\n        }\n        function updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, didPrimaryChildrenDefer, nextProps, suspenseInstance, suspenseState, renderLanes) {\n            if (!didSuspend) {\n                // This is the first render pass. Attempt to hydrate.\n                pushPrimaryTreeSuspenseHandler(workInProgress); // We should never be hydrating at this point because it is the first pass,\n                // but after we've already committed once.\n                warnIfHydrating();\n                if (isSuspenseInstanceFallback(suspenseInstance)) {\n                    // This boundary is in a permanent fallback state. In this case, we'll never\n                    // get an update and we'll never be able to hydrate the final content. Let's just try the\n                    // client side render instead.\n                    var digest;\n                    var message;\n                    var stack = null;\n                    var componentStack = null;\n                    {\n                        var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n                        digest = _getSuspenseInstanceF.digest;\n                        message = _getSuspenseInstanceF.message;\n                        stack = _getSuspenseInstanceF.stack;\n                        componentStack = _getSuspenseInstanceF.componentStack;\n                    }\n                    {\n                        var error;\n                        if (message) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            error = new Error(message);\n                        } else {\n                            error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. ' + 'Switched to client rendering.');\n                        } // Replace the stack with the server stack\n                        error.stack = stack || '';\n                        error.digest = digest;\n                        var capturedValue = createCapturedValueFromError(error, componentStack === undefined ? null : componentStack);\n                        queueHydrationError(capturedValue);\n                    }\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                }\n                // any context has changed, we need to treat is as if the input might have changed.\n                var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n                if (didReceiveUpdate || hasContextChanged) {\n                    // This boundary has changed since the first render. This means that we are now unable to\n                    // hydrate it. We might still be able to hydrate it using a higher priority lane.\n                    var root = getWorkInProgressRoot();\n                    if (root !== null) {\n                        var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n                        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                            // Intentionally mutating since this render will get interrupted. This\n                            // is one of the very rare times where we mutate the current tree\n                            // during the render phase.\n                            suspenseState.retryLane = attemptHydrationAtLane;\n                            enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);\n                            scheduleUpdateOnFiber(root, current, attemptHydrationAtLane); // Throw a special object that signals to the work loop that it should\n                            // interrupt the current render.\n                            //\n                            // Because we're inside a React-only execution stack, we don't\n                            // strictly need to throw here — we could instead modify some internal\n                            // work loop state. But using an exception means we don't need to\n                            // check for this case on every iteration of the work loop. So doing\n                            // it this way moves the check out of the fast path.\n                            throw SelectiveHydrationException;\n                        }\n                    } // If we did not selectively hydrate, we'll continue rendering without\n                    // hydrating. Mark this tree as suspended to prevent it from committing\n                    // outside a transition.\n                    //\n                    // This path should only happen if the hydration lane already suspended.\n                    // Currently, it also happens during sync updates because there is no\n                    // hydration lane for sync updates.\n                    // TODO: We should ideally have a sync hydration lane that we can apply to do\n                    // a pass where we hydrate this subtree in place using the previous Context and then\n                    // reapply the update afterwards.\n                    if (isSuspenseInstancePending(suspenseInstance)) ;\n                    else {\n                        renderDidSuspendDelayIfPossible();\n                    }\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                } else if (isSuspenseInstancePending(suspenseInstance)) {\n                    // This component is still pending more data from the server, so we can't hydrate its\n                    // content. We treat it as if this component suspended itself. It might seem as if\n                    // we could just try to render it client-side instead. However, this will perform a\n                    // lot of unnecessary work and is unlikely to complete since it often will suspend\n                    // on missing data anyway. Additionally, the server might be able to render more\n                    // than we can on the client yet. In that case we'd end up with more fallback states\n                    // on the client than if we just leave it alone. If the server times out or errors\n                    // these should update this boundary to the permanent Fallback state instead.\n                    // Mark it as having captured (i.e. suspended).\n                    workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n                    workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n                    var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n                    registerSuspenseInstanceRetry(suspenseInstance, retry);\n                    return null;\n                } else {\n                    // This is the first attempt.\n                    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n                    var primaryChildren = nextProps.children;\n                    var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n                    // tree is part of a hydrating tree. This is used to determine if a child\n                    // node has fully mounted yet, and for scheduling event replaying.\n                    // Conceptually this is similar to Placement in that a new subtree is\n                    // inserted into the React tree here. It just happens to not need DOM\n                    // mutations because it already exists.\n                    primaryChildFragment.flags |= Hydrating;\n                    return primaryChildFragment;\n                }\n            } else {\n                // This is the second render pass. We already attempted to hydrated, but\n                // something either suspended or errored.\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during hydration. Try again without hydrating.\n                    // The error should've already been logged in throwException.\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    workInProgress.flags &= ~ForceClientRender;\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                } else if (workInProgress.memoizedState !== null) {\n                    // Something suspended and we should still be in dehydrated mode.\n                    // Leave the existing child in place.\n                    // Push to avoid a mismatch\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n                    // but the normal suspense pass doesn't.\n                    workInProgress.flags |= DidCapture;\n                    return null;\n                } else {\n                    // Suspended but we should no longer be in dehydrated mode.\n                    // Therefore we now have to render the fallback.\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var nextPrimaryChildren = nextProps.children;\n                    var nextFallbackChildren = nextProps.fallback;\n                    var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var _primaryChildFragment4 = workInProgress.child;\n                    _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    _primaryChildFragment4.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackChildFragment;\n                }\n            }\n        }\n        function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n            }\n            scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n        }\n        function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n            // Mark any Suspense boundaries with fallbacks as having work to do.\n            // If they were previously forced into fallbacks, they may now be able\n            // to unblock.\n            var node = firstChild;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                    }\n                } else if (node.tag === SuspenseListComponent) {\n                    // If the tail is hidden there might not be an Suspense boundaries\n                    // to schedule work on. In this case we have to schedule it on the\n                    // list itself.\n                    // We don't have to traverse to the children of the list since\n                    // the list will propagate the change when it rerenders.\n                    scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === workInProgress) {\n                    return;\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                while(node.sibling === null){\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    if (node.return === null || node.return === workInProgress) {\n                        return;\n                    }\n                    node = node.return;\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function findLastContentRow(firstChild) {\n            // This is going to find the last row among these children that is already\n            // showing content on the screen, as opposed to being in fallback state or\n            // new. If a row has multiple Suspense boundaries, any of them being in the\n            // fallback state, counts as the whole row being in a fallback state.\n            // Note that the \"rows\" will be workInProgress, but any nested children\n            // will still be current since we haven't rendered them yet. The mounted\n            // order may not be the same as the new order. We use the new order.\n            var row = firstChild;\n            var lastContentRow = null;\n            while(row !== null){\n                var currentRow = row.alternate; // New rows can't be content rows.\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                    lastContentRow = row;\n                }\n                row = row.sibling;\n            }\n            return lastContentRow;\n        }\n        function validateRevealOrder(revealOrder) {\n            {\n                if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n                    didWarnAboutRevealOrder[revealOrder] = true;\n                    if (typeof revealOrder === 'string') {\n                        switch(revealOrder.toLowerCase()){\n                            case 'together':\n                            case 'forwards':\n                            case 'backwards':\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            case 'forward':\n                            case 'backward':\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            default:\n                                error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                                break;\n                        }\n                    } else {\n                        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                    }\n                }\n            }\n        }\n        function validateTailOptions(tailMode, revealOrder) {\n            {\n                if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n                    if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n                    } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n                    }\n                }\n            }\n        }\n        function validateSuspenseListNestedChild(childSlot, index) {\n            {\n                var isAnArray = isArray(childSlot);\n                var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n                if (isAnArray || isIterable) {\n                    var type = isAnArray ? 'array' : 'iterable';\n                    error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n                    return false;\n                }\n            }\n            return true;\n        }\n        function validateSuspenseListChildren(children, revealOrder) {\n            {\n                if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n                    if (isArray(children)) {\n                        for(var i = 0; i < children.length; i++){\n                            if (!validateSuspenseListNestedChild(children[i], i)) {\n                                return;\n                            }\n                        }\n                    } else {\n                        var iteratorFn = getIteratorFn(children);\n                        if (typeof iteratorFn === 'function') {\n                            var childrenIterator = iteratorFn.call(children);\n                            if (childrenIterator) {\n                                var step = childrenIterator.next();\n                                var _i = 0;\n                                for(; !step.done; step = childrenIterator.next()){\n                                    if (!validateSuspenseListNestedChild(step.value, _i)) {\n                                        return;\n                                    }\n                                    _i++;\n                                }\n                            }\n                        } else {\n                            error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n                        }\n                    }\n                }\n            }\n        }\n        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n            var renderState = workInProgress.memoizedState;\n            if (renderState === null) {\n                workInProgress.memoizedState = {\n                    isBackwards: isBackwards,\n                    rendering: null,\n                    renderingStartTime: 0,\n                    last: lastContentRow,\n                    tail: tail,\n                    tailMode: tailMode\n                };\n            } else {\n                // We can reuse the existing object from previous renders.\n                renderState.isBackwards = isBackwards;\n                renderState.rendering = null;\n                renderState.renderingStartTime = 0;\n                renderState.last = lastContentRow;\n                renderState.tail = tail;\n                renderState.tailMode = tailMode;\n            }\n        } // This can end up rendering this component multiple passes.\n        // The first pass splits the children fibers into two sets. A head and tail.\n        // We first render the head. If anything is in fallback state, we do another\n        // pass through beginWork to rerender all children (including the tail) with\n        // the force suspend context. If the first render didn't have anything in\n        // in fallback state. Then we render each row in the tail one-by-one.\n        // That happens in the completeWork phase without going back to beginWork.\n        function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var revealOrder = nextProps.revealOrder;\n            var tailMode = nextProps.tail;\n            var newChildren = nextProps.children;\n            validateRevealOrder(revealOrder);\n            validateTailOptions(tailMode, revealOrder);\n            validateSuspenseListChildren(newChildren, revealOrder);\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            var suspenseContext = suspenseStackCursor.current;\n            var shouldForceFallback = hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n            if (shouldForceFallback) {\n                suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n                workInProgress.flags |= DidCapture;\n            } else {\n                var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags$1;\n                if (didSuspendBefore) {\n                    // If we previously forced a fallback, we need to schedule work\n                    // on any nested boundaries to let them know to try to render\n                    // again. This is the same as context updating.\n                    propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n                }\n                suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n            }\n            pushSuspenseListContext(workInProgress, suspenseContext);\n            {\n                switch(revealOrder){\n                    case 'forwards':\n                        {\n                            var lastContentRow = findLastContentRow(workInProgress.child);\n                            var tail;\n                            if (lastContentRow === null) {\n                                // The whole list is part of the tail.\n                                // TODO: We could fast path by just rendering the tail now.\n                                tail = workInProgress.child;\n                                workInProgress.child = null;\n                            } else {\n                                // Disconnect the tail rows after the content row.\n                                // We're going to render them separately later.\n                                tail = lastContentRow.sibling;\n                                lastContentRow.sibling = null;\n                            }\n                            initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode);\n                            break;\n                        }\n                    case 'backwards':\n                        {\n                            // We're going to find the first row that has existing content.\n                            // At the same time we're going to reverse the list of everything\n                            // we pass in the meantime. That's going to be our tail in reverse\n                            // order.\n                            var _tail = null;\n                            var row = workInProgress.child;\n                            workInProgress.child = null;\n                            while(row !== null){\n                                var currentRow = row.alternate; // New rows can't be content rows.\n                                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                                    // This is the beginning of the main content.\n                                    workInProgress.child = row;\n                                    break;\n                                }\n                                var nextRow = row.sibling;\n                                row.sibling = _tail;\n                                _tail = row;\n                                row = nextRow;\n                            } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n                            initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode);\n                            break;\n                        }\n                    case 'together':\n                        {\n                            initSuspenseListRenderState(workInProgress, false, null, null, undefined);\n                            break;\n                        }\n                    default:\n                        {\n                            // The default reveal order is the same as not having\n                            // a boundary.\n                            workInProgress.memoizedState = null;\n                        }\n                }\n            }\n            return workInProgress.child;\n        }\n        function updatePortalComponent(current, workInProgress, renderLanes) {\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            var nextChildren = workInProgress.pendingProps;\n            if (current === null) {\n                // Portals are special because we don't append the children during mount\n                // but at commit. Therefore we need to track insertions which the normal\n                // flow doesn't do during mount. This doesn't happen at the root because\n                // the root always starts with a \"current\" with a null child.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n        function updateContextProvider(current, workInProgress, renderLanes) {\n            var context;\n            {\n                context = workInProgress.type;\n            }\n            var newProps = workInProgress.pendingProps;\n            var oldProps = workInProgress.memoizedProps;\n            var newValue = newProps.value;\n            {\n                if (!('value' in newProps)) {\n                    if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n                        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n                        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n                    }\n                }\n            }\n            pushProvider(workInProgress, context, newValue);\n            {\n                if (oldProps !== null) {\n                    var oldValue = oldProps.value;\n                    if (objectIs(oldValue, newValue)) {\n                        // No change. Bailout early if children are the same.\n                        if (oldProps.children === newProps.children && !hasContextChanged()) {\n                            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                        }\n                    } else {\n                        // The context value changed. Search for matching consumers and schedule\n                        // them to update.\n                        propagateContextChange(workInProgress, context, renderLanes);\n                    }\n                }\n            }\n            var newChildren = newProps.children;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateContextConsumer(current, workInProgress, renderLanes) {\n            var context;\n            {\n                var consumerType = workInProgress.type;\n                context = consumerType._context;\n            }\n            var newProps = workInProgress.pendingProps;\n            var render = newProps.children;\n            {\n                if (typeof render !== 'function') {\n                    error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n                }\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var newValue = readContext(context);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var newChildren;\n            {\n                newChildren = callComponentInDEV(render, newValue, undefined);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markWorkInProgressReceivedUpdate() {\n            didReceiveUpdate = true;\n        }\n        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n            if (current !== null) {\n                // Reuse previous dependencies\n                workInProgress.dependencies = current.dependencies;\n            }\n            {\n                // Don't update \"base\" render times for bailouts.\n                stopProfilerTimerIfRunning();\n            }\n            markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n                // The children don't have any work either. We can skip them.\n                // TODO: Once we add back resuming, we should check if the children are\n                // a work-in-progress set. If so, we need to transfer their effects.\n                {\n                    return null;\n                }\n            } // This fiber doesn't have work, but its subtree does. Clone the child\n            // fibers and continue.\n            cloneChildFibers(current, workInProgress);\n            return workInProgress.child;\n        }\n        function remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n            {\n                var returnFiber = oldWorkInProgress.return;\n                if (returnFiber === null) {\n                    // eslint-disable-next-line react-internal/prod-error-codes\n                    throw new Error('Cannot swap the root fiber.');\n                } // Disconnect from the old current.\n                // It will get deleted.\n                current.alternate = null;\n                oldWorkInProgress.alternate = null; // Connect to the new tree.\n                newWorkInProgress.index = oldWorkInProgress.index;\n                newWorkInProgress.sibling = oldWorkInProgress.sibling;\n                newWorkInProgress.return = oldWorkInProgress.return;\n                newWorkInProgress.ref = oldWorkInProgress.ref;\n                {\n                    newWorkInProgress._debugInfo = oldWorkInProgress._debugInfo;\n                }\n                if (oldWorkInProgress === returnFiber.child) {\n                    returnFiber.child = newWorkInProgress;\n                } else {\n                    var prevSibling = returnFiber.child;\n                    if (prevSibling === null) {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error('Expected parent to have a child.');\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(prevSibling.sibling !== oldWorkInProgress){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        prevSibling = prevSibling.sibling;\n                        if (prevSibling === null) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error('Expected to find the previous sibling.');\n                        }\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    prevSibling.sibling = newWorkInProgress;\n                } // Delete the old fiber and place the new one.\n                // Since the old fiber is disconnected, we have to schedule it manually.\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        current\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(current);\n                }\n                newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n                return newWorkInProgress;\n            }\n        }\n        function checkScheduledUpdateOrContext(current, renderLanes) {\n            // Before performing an early bailout, we must check if there are pending\n            // updates or context.\n            var updateLanes = current.lanes;\n            if (includesSomeLane(updateLanes, renderLanes)) {\n                return true;\n            } // No pending update, but because context is propagated lazily, we need\n            return false;\n        }\n        function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n            // This fiber does not have any pending work. Bailout without entering\n            // the begin phase. There's still some bookkeeping we that needs to be done\n            // in this optimized path, mostly pushing stuff onto the stack.\n            switch(workInProgress.tag){\n                case HostRoot:\n                    pushHostRootContext(workInProgress);\n                    {\n                        var cache = current.memoizedState.cache;\n                        pushCacheProvider(workInProgress, cache);\n                    }\n                    resetHydrationState();\n                    break;\n                case HostSingleton:\n                case HostComponent:\n                    pushHostContext(workInProgress);\n                    break;\n                case ClassComponent:\n                    {\n                        break;\n                    }\n                case HostPortal:\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    break;\n                case ContextProvider:\n                    {\n                        var newValue = workInProgress.memoizedProps.value;\n                        var context;\n                        {\n                            context = workInProgress.type;\n                        }\n                        pushProvider(workInProgress, context, newValue);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        // Profiler should only call onRender when one of its descendants actually rendered.\n                        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (hasChildWork) {\n                            workInProgress.flags |= Update;\n                        }\n                        {\n                            // Reset effect durations for the next eventual effect phase.\n                            // These are reset during render to allow the DevTools commit hook a chance to read them,\n                            var stateNode = workInProgress.stateNode;\n                            stateNode.effectDuration = 0;\n                            stateNode.passiveEffectDuration = 0;\n                        }\n                    }\n                    break;\n                case SuspenseComponent:\n                    {\n                        var state = workInProgress.memoizedState;\n                        if (state !== null) {\n                            if (state.dehydrated !== null) {\n                                // We're not going to render the children, so this is just to maintain\n                                // push/pop symmetry\n                                pushPrimaryTreeSuspenseHandler(workInProgress); // We know that this component will suspend again because if it has\n                                // been unsuspended it has committed as a resolved Suspense component.\n                                // If it needs to be retried, it should have work scheduled on it.\n                                workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n                                // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n                                return null;\n                            } // If this boundary is currently timed out, we need to decide\n                            // whether to retry the primary children, or to skip over it and\n                            // go straight to the fallback. Check the priority of the primary\n                            // child fragment.\n                            var primaryChildFragment = workInProgress.child;\n                            var primaryChildLanes = primaryChildFragment.childLanes;\n                            if (includesSomeLane(renderLanes, primaryChildLanes)) {\n                                // The primary children have pending work. Use the normal path\n                                // to attempt to render the primary children again.\n                                return updateSuspenseComponent(current, workInProgress, renderLanes);\n                            } else {\n                                // The primary child fragment does not have pending work marked\n                                // on it\n                                pushPrimaryTreeSuspenseHandler(workInProgress); // The primary children do not have pending work with sufficient\n                                // priority. Bailout.\n                                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                                if (child !== null) {\n                                    // The fallback children have pending work. Skip over the\n                                    // primary children and work on the fallback.\n                                    return child.sibling;\n                                } else {\n                                    // Note: We can return `null` here because we already checked\n                                    // whether there were nested context consumers, via the call to\n                                    // `bailoutOnAlreadyFinishedWork` above.\n                                    return null;\n                                }\n                            }\n                        } else {\n                            pushPrimaryTreeSuspenseHandler(workInProgress);\n                        }\n                        break;\n                    }\n                case SuspenseListComponent:\n                    {\n                        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags$1;\n                        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (didSuspendBefore) {\n                            if (_hasChildWork) {\n                                // If something was in fallback state last time, and we have all the\n                                // same children then we're still in progressive loading state.\n                                // Something might get unblocked by state updates or retries in the\n                                // tree which will affect the tail. So we need to use the normal\n                                // path to compute the correct tail.\n                                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                            } // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            workInProgress.flags |= DidCapture;\n                        } // If nothing suspended before and we're rendering the same children,\n                        // then the tail doesn't matter. Anything new that suspends will work\n                        // in the \"together\" mode, so we can continue from the state we had.\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState !== null) {\n                            // Reset to the \"together\" mode in case we've started a different\n                            // update in the past but didn't complete it.\n                            renderState.rendering = null;\n                            renderState.tail = null;\n                            renderState.lastEffect = null;\n                        }\n                        pushSuspenseListContext(workInProgress, suspenseStackCursor.current);\n                        if (_hasChildWork) {\n                            break;\n                        } else {\n                            // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            return null;\n                        }\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        // Need to check if the tree still needs to be deferred. This is\n                        // almost identical to the logic used in the normal update path,\n                        // so we'll just enter that. The only difference is we'll bail out\n                        // at the next level instead of this one, because the child props\n                        // have not changed. Which is fine.\n                        // TODO: Probably should refactor `beginWork` to split the bailout\n                        // path from the normal path. I'm tempted to do a labeled break here\n                        // but I won't :)\n                        workInProgress.lanes = NoLanes;\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _cache = current.memoizedState.cache;\n                            pushCacheProvider(workInProgress, _cache);\n                        }\n                        break;\n                    }\n            }\n            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        function beginWork(current, workInProgress, renderLanes) {\n            {\n                if (workInProgress._debugNeedsRemount && current !== null) {\n                    // This will restart the begin phase with a new fiber.\n                    var copiedFiber = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);\n                    return remountFiber(current, workInProgress, copiedFiber);\n                }\n            }\n            if (current !== null) {\n                var oldProps = current.memoizedProps;\n                var newProps = workInProgress.pendingProps;\n                if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type) {\n                    // If props or context changed, mark the fiber as having performed work.\n                    // This may be unset if the props are determined to be equal later (memo).\n                    didReceiveUpdate = true;\n                } else {\n                    // Neither props nor legacy context changes. Check if there's a pending\n                    // update or context change.\n                    var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n                    if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n                    // may not be work scheduled on `current`, so we check for this flag.\n                    (workInProgress.flags & DidCapture) === NoFlags$1) {\n                        // No pending updates or context. Bail out now.\n                        didReceiveUpdate = false;\n                        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n                    }\n                    if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags$1) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    } else {\n                        // An update was scheduled on this fiber, but there are no new props\n                        // nor legacy context. Set this to false. If an update queue or context\n                        // consumer produces a changed value, it will set this to true. Otherwise,\n                        // the component will assume the children have not changed and bail out.\n                        didReceiveUpdate = false;\n                    }\n                }\n            } else {\n                didReceiveUpdate = false;\n                if (getIsHydrating() && isForkedChild(workInProgress)) {\n                    // Check if this child belongs to a list of muliple children in\n                    // its parent.\n                    //\n                    // In a true multi-threaded implementation, we would render children on\n                    // parallel threads. This would represent the beginning of a new render\n                    // thread for this subtree.\n                    //\n                    // We only use this for id generation during hydration, which is why the\n                    // logic is located in this special branch.\n                    var slotIndex = workInProgress.index;\n                    var numberOfForks = getForksAtLevel();\n                    pushTreeId(workInProgress, numberOfForks, slotIndex);\n                }\n            } // Before entering the begin phase, clear pending update priority.\n            // TODO: This assumes that we're about to evaluate the component and process\n            // the update queue. However, there's an exception: SimpleMemoComponent\n            // sometimes bails out later in the begin phase. This indicates that we should\n            // move this assignment out of the common path and into each branch.\n            workInProgress.lanes = NoLanes;\n            switch(workInProgress.tag){\n                case LazyComponent:\n                    {\n                        var elementType = workInProgress.elementType;\n                        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n                    }\n                case FunctionComponent:\n                    {\n                        var Component = workInProgress.type;\n                        var unresolvedProps = workInProgress.pendingProps;\n                        var resolvedProps = unresolvedProps;\n                        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n                    }\n                case ClassComponent:\n                    {\n                        var _Component = workInProgress.type;\n                        var _unresolvedProps = workInProgress.pendingProps;\n                        var _resolvedProps4 = resolveClassComponentProps(_Component, _unresolvedProps);\n                        return updateClassComponent(current, workInProgress, _Component, _resolvedProps4, renderLanes);\n                    }\n                case HostRoot:\n                    return updateHostRoot(current, workInProgress, renderLanes);\n                case HostHoistable:\n                    if (supportsResources) {\n                        return updateHostHoistable(current, workInProgress);\n                    }\n                // Fall through\n                case HostSingleton:\n                    if (supportsSingletons) {\n                        return updateHostSingleton(current, workInProgress, renderLanes);\n                    }\n                // Fall through\n                case HostComponent:\n                    return updateHostComponent$1(current, workInProgress, renderLanes);\n                case HostText:\n                    return updateHostText$1(current, workInProgress);\n                case SuspenseComponent:\n                    return updateSuspenseComponent(current, workInProgress, renderLanes);\n                case HostPortal:\n                    return updatePortalComponent(current, workInProgress, renderLanes);\n                case ForwardRef:\n                    {\n                        var type = workInProgress.type;\n                        var _unresolvedProps2 = workInProgress.pendingProps;\n                        var _resolvedProps5 = _unresolvedProps2;\n                        return updateForwardRef(current, workInProgress, type, _resolvedProps5, renderLanes);\n                    }\n                case Fragment:\n                    return updateFragment(current, workInProgress, renderLanes);\n                case Mode:\n                    return updateMode(current, workInProgress, renderLanes);\n                case Profiler:\n                    return updateProfiler(current, workInProgress, renderLanes);\n                case ContextProvider:\n                    return updateContextProvider(current, workInProgress, renderLanes);\n                case ContextConsumer:\n                    return updateContextConsumer(current, workInProgress, renderLanes);\n                case MemoComponent:\n                    {\n                        var _type = workInProgress.type;\n                        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n                        var _resolvedProps6 = _unresolvedProps3;\n                        _resolvedProps6 = _resolvedProps6;\n                        return updateMemoComponent(current, workInProgress, _type, _resolvedProps6, renderLanes);\n                    }\n                case SimpleMemoComponent:\n                    {\n                        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n                    }\n                case IncompleteClassComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case IncompleteFunctionComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case SuspenseListComponent:\n                    {\n                        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            return updateCacheComponent(current, workInProgress, renderLanes);\n                        }\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n        }\n        var valueCursor = createCursor(null);\n        var rendererCursorDEV;\n        {\n            rendererCursorDEV = createCursor(null);\n        }\n        var renderer2CursorDEV;\n        {\n            renderer2CursorDEV = createCursor(null);\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        var currentlyRenderingFiber = null;\n        var lastContextDependency = null;\n        var lastFullyObservedContext = null;\n        var isDisallowedContextReadInDEV = false;\n        function resetContextDependencies() {\n            // This is called right before React yields execution, to ensure `readContext`\n            // cannot be called outside the render phase.\n            currentlyRenderingFiber = null;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function enterDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = true;\n            }\n        }\n        function exitDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function pushProvider(providerFiber, context, nextValue) {\n            if (isPrimaryRenderer) {\n                push(valueCursor, context._currentValue, providerFiber);\n                context._currentValue = nextValue;\n                {\n                    push(rendererCursorDEV, context._currentRenderer, providerFiber);\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            } else {\n                push(valueCursor, context._currentValue2, providerFiber);\n                context._currentValue2 = nextValue;\n                {\n                    push(renderer2CursorDEV, context._currentRenderer2, providerFiber);\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n        }\n        function popProvider(context, providerFiber) {\n            var currentValue = valueCursor.current;\n            if (isPrimaryRenderer) {\n                context._currentValue = currentValue;\n                {\n                    var currentRenderer = rendererCursorDEV.current;\n                    pop(rendererCursorDEV, providerFiber);\n                    context._currentRenderer = currentRenderer;\n                }\n            } else {\n                context._currentValue2 = currentValue;\n                {\n                    var currentRenderer2 = renderer2CursorDEV.current;\n                    pop(renderer2CursorDEV, providerFiber);\n                    context._currentRenderer2 = currentRenderer2;\n                }\n            }\n            pop(valueCursor, providerFiber);\n        }\n        function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n            // Update the child lanes of all the ancestors, including the alternates.\n            var node = parent;\n            while(node !== null){\n                var alternate = node.alternate;\n                if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n                    node.childLanes = mergeLanes(node.childLanes, renderLanes);\n                    if (alternate !== null) {\n                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                    }\n                } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                } else ;\n                if (node === propagationRoot) {\n                    break;\n                }\n                node = node.return;\n            }\n            {\n                if (node !== propagationRoot) {\n                    error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                }\n            }\n        }\n        function propagateContextChange(workInProgress, context, renderLanes) {\n            {\n                propagateContextChange_eager(workInProgress, context, renderLanes);\n            }\n        }\n        function propagateContextChange_eager(workInProgress, context, renderLanes) {\n            var fiber = workInProgress.child;\n            if (fiber !== null) {\n                // Set the return pointer of the child to the work-in-progress fiber.\n                fiber.return = workInProgress;\n            }\n            while(fiber !== null){\n                var nextFiber = void 0; // Visit this fiber.\n                var list = fiber.dependencies;\n                if (list !== null) {\n                    nextFiber = fiber.child;\n                    var dependency = list.firstContext;\n                    while(dependency !== null){\n                        // Check if the context matches.\n                        if (dependency.context === context) {\n                            // Match! Schedule an update on this fiber.\n                            if (fiber.tag === ClassComponent) {\n                                // Schedule a force update on the work-in-progress.\n                                var lane = pickArbitraryLane(renderLanes);\n                                var update = createUpdate(lane);\n                                update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n                                // update to the current fiber, too, which means it will persist even if\n                                // this render is thrown away. Since it's a race condition, not sure it's\n                                // worth fixing.\n                                // Inlined `enqueueUpdate` to remove interleaved update check\n                                var updateQueue = fiber.updateQueue;\n                                if (updateQueue === null) ;\n                                else {\n                                    var sharedQueue = updateQueue.shared;\n                                    var pending = sharedQueue.pending;\n                                    if (pending === null) {\n                                        // This is the first update. Create a circular list.\n                                        update.next = update;\n                                    } else {\n                                        update.next = pending.next;\n                                        pending.next = update;\n                                    }\n                                    sharedQueue.pending = update;\n                                }\n                            }\n                            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n                            var alternate = fiber.alternate;\n                            if (alternate !== null) {\n                                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n                            }\n                            scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n                            list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n                            break;\n                        }\n                        dependency = dependency.next;\n                    }\n                } else if (fiber.tag === ContextProvider) {\n                    // Don't scan deeper if this is a matching provider\n                    nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n                } else if (fiber.tag === DehydratedFragment) {\n                    // If a dehydrated suspense boundary is in this subtree, we don't know\n                    // if it will have any context consumers in it. The best we can do is\n                    // mark it as having updates.\n                    var parentSuspense = fiber.return;\n                    if (parentSuspense === null) {\n                        throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');\n                    }\n                    parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n                    var _alternate = parentSuspense.alternate;\n                    if (_alternate !== null) {\n                        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n                    } // This is intentionally passing this fiber as the parent\n                    // because we want to schedule this fiber as having work\n                    // on its children. We'll use the childLanes on\n                    // this fiber to indicate that a context has changed.\n                    scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n                    nextFiber = fiber.sibling;\n                } else {\n                    // Traverse down.\n                    nextFiber = fiber.child;\n                }\n                if (nextFiber !== null) {\n                    // Set the return pointer of the child to the work-in-progress fiber.\n                    nextFiber.return = fiber;\n                } else {\n                    // No child. Traverse to next sibling.\n                    nextFiber = fiber;\n                    while(nextFiber !== null){\n                        if (nextFiber === workInProgress) {\n                            // We're back to the root of this subtree. Exit.\n                            nextFiber = null;\n                            break;\n                        }\n                        var sibling = nextFiber.sibling;\n                        if (sibling !== null) {\n                            // Set the return pointer of the sibling to the work-in-progress fiber.\n                            sibling.return = nextFiber.return;\n                            nextFiber = sibling;\n                            break;\n                        } // No more siblings. Traverse up.\n                        nextFiber = nextFiber.return;\n                    }\n                }\n                fiber = nextFiber;\n            }\n        }\n        function prepareToReadContext(workInProgress, renderLanes) {\n            currentlyRenderingFiber = workInProgress;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            var dependencies = workInProgress.dependencies;\n            if (dependencies !== null) {\n                {\n                    var firstContext = dependencies.firstContext;\n                    if (firstContext !== null) {\n                        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n                            // Context list has a pending update. Mark that this fiber performed work.\n                            markWorkInProgressReceivedUpdate();\n                        } // Reset the work-in-progress list\n                        dependencies.firstContext = null;\n                    }\n                }\n            }\n        }\n        function readContext(context) {\n            {\n                // This warning would fire if you read context inside a Hook like useMemo.\n                // Unlike the class check below, it's not enforced in production for perf.\n                if (isDisallowedContextReadInDEV) {\n                    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n                }\n            }\n            return readContextForConsumer(currentlyRenderingFiber, context);\n        }\n        function readContextDuringReconciliation(consumer, context, renderLanes) {\n            if (currentlyRenderingFiber === null) {\n                prepareToReadContext(consumer, renderLanes);\n            }\n            return readContextForConsumer(consumer, context);\n        }\n        function readContextForConsumer(consumer, context) {\n            var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n            if (lastFullyObservedContext === context) ;\n            else {\n                var contextItem = {\n                    context: context,\n                    memoizedValue: value,\n                    next: null\n                };\n                if (lastContextDependency === null) {\n                    if (consumer === null) {\n                        throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n                    } // This is the first dependency for this component. Create a new list.\n                    lastContextDependency = contextItem;\n                    consumer.dependencies = {\n                        lanes: NoLanes,\n                        firstContext: contextItem\n                    };\n                } else {\n                    // Append a new context item.\n                    lastContextDependency = lastContextDependency.next = contextItem;\n                }\n            }\n            return value;\n        }\n        // replace it with a lightweight shim that only has the features we use.\n        var AbortControllerLocal = typeof AbortController !== 'undefined' ? AbortController : // $FlowFixMe[prop-missing]\n        function AbortControllerShim() {\n            var listeners = [];\n            var signal = this.signal = {\n                aborted: false,\n                addEventListener: function(type, listener) {\n                    listeners.push(listener);\n                }\n            };\n            this.abort = function() {\n                signal.aborted = true;\n                listeners.forEach(function(listener) {\n                    return listener();\n                });\n            };\n        }; // Intentionally not named imports because Rollup would\n        // use dynamic dispatch for CommonJS interop named imports.\n        var scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority;\n        var CacheContext = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            // We don't use Consumer/Provider for Cache components. So we'll cheat.\n            Consumer: null,\n            Provider: null,\n            // We'll initialize these at the root.\n            _currentValue: null,\n            _currentValue2: null,\n            _threadCount: 0\n        };\n        {\n            CacheContext._currentRenderer = null;\n            CacheContext._currentRenderer2 = null;\n        }\n        // for retaining the cache once it is in use (retainCache), and releasing the cache\n        // once it is no longer needed (releaseCache).\n        function createCache() {\n            var cache = {\n                controller: new AbortControllerLocal(),\n                data: new Map(),\n                refCount: 0\n            };\n            return cache;\n        }\n        function retainCache(cache) {\n            {\n                if (cache.controller.signal.aborted) {\n                    warn('A cache instance was retained after it was already freed. ' + 'This likely indicates a bug in React.');\n                }\n            }\n            cache.refCount++;\n        } // Cleanup a cache instance, potentially freeing it if there are no more references\n        function releaseCache(cache) {\n            cache.refCount--;\n            {\n                if (cache.refCount < 0) {\n                    warn('A cache instance was released after it was already freed. ' + 'This likely indicates a bug in React.');\n                }\n            }\n            if (cache.refCount === 0) {\n                scheduleCallback$1(NormalPriority, function() {\n                    cache.controller.abort();\n                });\n            }\n        }\n        function pushCacheProvider(workInProgress, cache) {\n            pushProvider(workInProgress, CacheContext, cache);\n        }\n        function popCacheProvider(workInProgress, cache) {\n            popProvider(CacheContext, workInProgress);\n        }\n        // the shared internals object. This is used by the isomorphic implementation of\n        // startTransition to compose all the startTransitions together.\n        //\n        //   function startTransition(fn) {\n        //     return startTransitionDOM(() => {\n        //       return startTransitionART(() => {\n        //         return startTransitionThreeFiber(() => {\n        //           // and so on...\n        //           return fn();\n        //         });\n        //       });\n        //     });\n        //   }\n        //\n        // Currently we only compose together the code that runs at the end of each\n        // startTransition, because for now that's sufficient — the part that sets\n        // isTransition=true on the stack uses a separate shared internal field. But\n        // really we should delete the shared field and track isTransition per\n        // reconciler. Leaving this for a future PR.\n        var prevOnStartTransitionFinish = ReactSharedInternals.S;\n        ReactSharedInternals.S = function onStartTransitionFinishForReconciler(transition, returnValue) {\n            if (typeof returnValue === 'object' && returnValue !== null && typeof returnValue.then === 'function') {\n                // This is an async action\n                var thenable = returnValue;\n                entangleAsyncAction(transition, thenable);\n            }\n            if (prevOnStartTransitionFinish !== null) {\n                prevOnStartTransitionFinish(transition, returnValue);\n            }\n        };\n        function requestCurrentTransition() {\n            return ReactSharedInternals.T;\n        } // When retrying a Suspense/Offscreen boundary, we restore the cache that was\n        // used during the previous render by placing it here, on the stack.\n        var resumedCache = createCursor(null); // During the render/synchronous commit phase, we don't actually process the\n        function peekCacheFromPool() {\n            // If we're rendering inside a Suspense boundary that is currently hidden,\n            // we should use the same cache that we used during the previous render, if\n            // one exists.\n            var cacheResumedFromPreviousRender = resumedCache.current;\n            if (cacheResumedFromPreviousRender !== null) {\n                return cacheResumedFromPreviousRender;\n            } // Otherwise, check the root's cache pool.\n            var root = getWorkInProgressRoot();\n            var cacheFromRootCachePool = root.pooledCache;\n            return cacheFromRootCachePool;\n        }\n        function requestCacheFromPool(renderLanes) {\n            // Similar to previous function, except if there's not already a cache in the\n            // pool, we allocate a new one.\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool !== null) {\n                return cacheFromPool;\n            } // Create a fresh cache and add it to the root cache pool. A cache can have\n            // multiple owners:\n            // - A cache pool that lives on the FiberRoot. This is where all fresh caches\n            //   are originally created (TODO: except during refreshes, until we implement\n            //   this correctly). The root takes ownership immediately when the cache is\n            //   created. Conceptually, root.pooledCache is an Option<Arc<Cache>> (owned),\n            //   and the return value of this function is a &Arc<Cache> (borrowed).\n            // - One of several fiber types: host root, cache boundary, suspense\n            //   component. These retain and release in the commit phase.\n            var root = getWorkInProgressRoot();\n            var freshCache = createCache();\n            root.pooledCache = freshCache;\n            retainCache(freshCache);\n            if (freshCache !== null) {\n                root.pooledCacheLanes |= renderLanes;\n            }\n            return freshCache;\n        }\n        function pushTransition(offscreenWorkInProgress, prevCachePool, newTransitions) {\n            {\n                if (prevCachePool === null) {\n                    push(resumedCache, resumedCache.current, offscreenWorkInProgress);\n                } else {\n                    push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n                }\n            }\n        }\n        function popTransition(workInProgress, current) {\n            if (current !== null) {\n                {\n                    pop(resumedCache, workInProgress);\n                }\n            }\n        }\n        function getSuspendedCache() {\n            // cache that would have been used to render fresh data during this render,\n            // if there was any, so that we can resume rendering with the same cache when\n            // we receive more data.\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool === null) {\n                return null;\n            }\n            return {\n                // We must also save the parent, so that when we resume we can detect\n                // a refresh.\n                parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n                pool: cacheFromPool\n            };\n        }\n        function getOffscreenDeferredCache() {\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool === null) {\n                return null;\n            }\n            return {\n                // We must also store the parent, so that when we resume we can detect\n                // a refresh.\n                parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n                pool: cacheFromPool\n            };\n        }\n        /**\n * Tag the fiber with an update effect. This turns a Placement into\n * a PlacementAndUpdate.\n */ function markUpdate(workInProgress) {\n            workInProgress.flags |= Update;\n        }\n        /**\n * In persistent mode, return whether this update needs to clone the subtree.\n */ function doesRequireClone(current, completedWork) {\n            var didBailout = current !== null && current.child === completedWork.child;\n            if (didBailout) {\n                return false;\n            }\n            if ((completedWork.flags & ChildDeletion) !== NoFlags$1) {\n                return true;\n            } // TODO: If we move the `doesRequireClone` call after `bubbleProperties`\n            // then we only have to check the `completedWork.subtreeFlags`.\n            var child = completedWork.child;\n            while(child !== null){\n                if ((child.flags & MutationMask) !== NoFlags$1 || (child.subtreeFlags & MutationMask) !== NoFlags$1) {\n                    return true;\n                }\n                child = child.sibling;\n            }\n            return false;\n        }\n        function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n            if (supportsMutation) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent || node.tag === HostText) {\n                        appendInitialChild(parent, node.stateNode);\n                    } else if (node.tag === HostPortal || (supportsSingletons ? node.tag === HostSingleton : false)) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            } else if (supportsPersistence) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var _node = workInProgress.child;\n                while(_node !== null){\n                    if (_node.tag === HostComponent) {\n                        var instance = _node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = _node.memoizedProps;\n                            var type = _node.type;\n                            instance = cloneHiddenInstance(instance, type, props);\n                        }\n                        appendInitialChild(parent, instance);\n                    } else if (_node.tag === HostText) {\n                        var _instance = _node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = _node.memoizedProps;\n                            _instance = cloneHiddenTextInstance(_instance, text);\n                        }\n                        appendInitialChild(parent, _instance);\n                    } else if (_node.tag === HostPortal) ;\n                    else if (_node.tag === OffscreenComponent && _node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = _node.child;\n                        if (child !== null) {\n                            child.return = _node;\n                        }\n                        appendAllChildren(parent, _node, /* needsVisibilityToggle */ true, /* isHidden */ true);\n                    } else if (_node.child !== null) {\n                        _node.child.return = _node;\n                        _node = _node.child;\n                        continue;\n                    }\n                    if (_node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(_node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (_node.return === null || _node.return === workInProgress) {\n                            return;\n                        }\n                        _node = _node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    _node.sibling.return = _node.return;\n                    _node = _node.sibling;\n                }\n            }\n        } // An unfortunate fork of appendAllChildren because we have two different parent types.\n        function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n            if (supportsPersistence) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance2 = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance2 = cloneHiddenTextInstance(_instance2, text);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, _instance2);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        } // If Offscreen is not in manual mode, detached tree is hidden from user space.\n                        var _needsVisibilityToggle = !isOffscreenManual(node);\n                        appendAllChildrenToContainer(containerChildSet, node, /* needsVisibilityToggle */ _needsVisibilityToggle, /* isHidden */ true);\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function updateHostContainer(current, workInProgress) {\n            if (supportsPersistence) {\n                if (doesRequireClone(current, workInProgress)) {\n                    var portalOrRoot = workInProgress.stateNode;\n                    var container = portalOrRoot.containerInfo;\n                    var newChildSet = createContainerChildSet(); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                    portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n                    markUpdate(workInProgress);\n                    finalizeContainerChildren(container, newChildSet);\n                }\n            }\n        }\n        function updateHostComponent(current, workInProgress, type, newProps, renderLanes) {\n            if (supportsMutation) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps;\n                if (oldProps === newProps) {\n                    // In mutation mode, this is sufficient for a bailout because\n                    // we won't touch this node even if children changed.\n                    return;\n                }\n                markUpdate(workInProgress);\n            } else if (supportsPersistence) {\n                var currentInstance = current.stateNode;\n                var _oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n                // This guarantees that we can reuse all of them.\n                var requiresClone = doesRequireClone(current, workInProgress);\n                if (!requiresClone && _oldProps === newProps) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var currentHostContext = getHostContext();\n                var newChildSet = null;\n                if (requiresClone && passChildrenWhenCloningPersistedNodes) {\n                    newChildSet = createContainerChildSet(); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                }\n                var newInstance = cloneInstance(currentInstance, type, _oldProps, newProps, !requiresClone, newChildSet);\n                if (newInstance === currentInstance) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                } // Certain renderers require commit-time effects for initial mount.\n                // (eg DOM renderer supports auto-focus for certain elements).\n                // Make sure such renderers get scheduled for later work.\n                if (finalizeInitialChildren(newInstance, type, newProps, currentHostContext)) {\n                    markUpdate(workInProgress);\n                }\n                workInProgress.stateNode = newInstance;\n                if (!requiresClone) {\n                    // If there are no other effects in this tree, we need to flag this node as having one.\n                    // Even though we're not going to use it for anything.\n                    // Otherwise parents won't know that there are new children to propagate upwards.\n                    markUpdate(workInProgress);\n                } else {\n                    // If children might have changed, we have to add them all to the set.\n                    appendAllChildren(newInstance, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                }\n            }\n        } // This function must be called at the very end of the complete phase, because\n        // it might throw to suspend, and if the resource immediately loads, the work\n        // loop will resume rendering as if the work-in-progress completed. So it must\n        // fully complete.\n        // TODO: This should ideally move to begin phase, but currently the instance is\n        // not created until the complete phase. For our existing use cases, host nodes\n        // that suspend don't have children, so it doesn't matter. But that might not\n        // always be true in the future.\n        function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props, renderLanes) {\n            if (!maySuspendCommit(type, props)) {\n                // If this flag was set previously, we can remove it. The flag\n                // represents whether this particular set of props might ever need to\n                // suspend. The safest thing to do is for maySuspendCommit to always\n                // return true, but if the renderer is reasonably confident that the\n                // underlying resource won't be evicted, it can return false as a\n                // performance optimization.\n                workInProgress.flags &= ~MaySuspendCommit;\n                return;\n            } // Mark this fiber with a flag. This gets set on all host instances\n            // that might possibly suspend, even if they don't need to suspend\n            // currently. We use this when revealing a prerendered tree, because\n            // even though the tree has \"mounted\", its resources might not have\n            // loaded yet.\n            workInProgress.flags |= MaySuspendCommit; // preload the instance if necessary. Even if this is an urgent render there\n            // could be benefits to preloading early.\n            // @TODO we should probably do the preload in begin work\n            var isReady = preloadInstance(type, props);\n            if (!isReady) {\n                if (shouldRemainOnPreviousScreen()) {\n                    workInProgress.flags |= ShouldSuspendCommit;\n                } else {\n                    suspendCommit();\n                }\n            }\n        }\n        function preloadResourceAndSuspendIfNeeded(workInProgress, resource, type, props, renderLanes) {\n            // This is a fork of preloadInstanceAndSuspendIfNeeded, but for resources.\n            if (!mayResourceSuspendCommit(resource)) {\n                workInProgress.flags &= ~MaySuspendCommit;\n                return;\n            }\n            workInProgress.flags |= MaySuspendCommit;\n            var isReady = preloadResource(resource);\n            if (!isReady) {\n                if (shouldRemainOnPreviousScreen()) {\n                    workInProgress.flags |= ShouldSuspendCommit;\n                } else {\n                    suspendCommit();\n                }\n            }\n        }\n        function scheduleRetryEffect(workInProgress, retryQueue) {\n            var wakeables = retryQueue;\n            if (wakeables !== null) {\n                // Schedule an effect to attach a retry listener to the promise.\n                // TODO: Move to passive phase\n                workInProgress.flags |= Update;\n            } else {\n                // This boundary suspended, but no wakeables were added to the retry\n                // queue. Check if the renderer suspended commit. If so, this means\n                // that once the fallback is committed, we can immediately retry\n                // rendering again, because rendering wasn't actually blocked. Only\n                // the commit phase.\n                // TODO: Consider a model where we always schedule an immediate retry, even\n                // for normal Suspense. That way the retry can partially render up to the\n                // first thing that suspends.\n                if (workInProgress.flags & ScheduleRetry) {\n                    var retryLane = // I also suspect that we need some further consolidation of offscreen\n                    // and retry lanes.\n                    workInProgress.tag !== OffscreenComponent ? claimNextRetryLane() : OffscreenLane;\n                    workInProgress.lanes = mergeLanes(workInProgress.lanes, retryLane);\n                }\n            }\n        }\n        function updateHostText(current, workInProgress, oldText, newText) {\n            if (supportsMutation) {\n                // If the text differs, mark it as an update. All the work in done in commitWork.\n                if (oldText !== newText) {\n                    markUpdate(workInProgress);\n                }\n            } else if (supportsPersistence) {\n                if (oldText !== newText) {\n                    // If the text content differs, we'll create a new text instance for it.\n                    var rootContainerInstance = getRootHostContainer();\n                    var currentHostContext = getHostContext();\n                    workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n                    // This lets the parents know that at least one of their children has changed.\n                    markUpdate(workInProgress);\n                } else {\n                    workInProgress.stateNode = current.stateNode;\n                }\n            }\n        }\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n            if (getIsHydrating()) {\n                // If we're hydrating, we should consume as many items as we can\n                // so we don't leave any behind.\n                return;\n            }\n            switch(renderState.tailMode){\n                case 'hidden':\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var tailNode = renderState.tail;\n                        var lastTailNode = null;\n                        while(tailNode !== null){\n                            if (tailNode.alternate !== null) {\n                                lastTailNode = tailNode;\n                            }\n                            tailNode = tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            renderState.tail = null;\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n                case 'collapsed':\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var _tailNode = renderState.tail;\n                        var _lastTailNode = null;\n                        while(_tailNode !== null){\n                            if (_tailNode.alternate !== null) {\n                                _lastTailNode = _tailNode;\n                            }\n                            _tailNode = _tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (_lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            if (!hasRenderedATailFallback && renderState.tail !== null) {\n                                // We suspended during the head. We want to show at least one\n                                // row at the tail. So we'll keep on and cut off the rest.\n                                renderState.tail.sibling = null;\n                            } else {\n                                renderState.tail = null;\n                            }\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            _lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n            }\n        }\n        function bubbleProperties(completedWork) {\n            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n            var newChildLanes = NoLanes;\n            var subtreeFlags = NoFlags$1;\n            if (!didBailout) {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var actualDuration = completedWork.actualDuration;\n                    var treeBaseDuration = completedWork.selfBaseDuration;\n                    var child = completedWork.child;\n                    while(child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n                        subtreeFlags |= child.subtreeFlags;\n                        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n                        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n                        // When work is done, it should bubble to the parent's actualDuration. If\n                        // the fiber has not been cloned though, (meaning no work was done), then\n                        // this value will reflect the amount of time spent working on a previous\n                        // render. In that case it should not bubble. We determine whether it was\n                        // cloned by comparing the child pointer.\n                        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        actualDuration += child.actualDuration; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        treeBaseDuration += child.treeBaseDuration;\n                        child = child.sibling;\n                    }\n                    completedWork.actualDuration = actualDuration;\n                    completedWork.treeBaseDuration = treeBaseDuration;\n                } else {\n                    var _child = completedWork.child;\n                    while(_child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n                        subtreeFlags |= _child.subtreeFlags;\n                        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child.return = completedWork;\n                        _child = _child.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            } else {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var _treeBaseDuration = completedWork.selfBaseDuration;\n                    var _child2 = completedWork.child;\n                    while(_child2 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child2.flags & StaticMask; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        _treeBaseDuration += _child2.treeBaseDuration;\n                        _child2 = _child2.sibling;\n                    }\n                    completedWork.treeBaseDuration = _treeBaseDuration;\n                } else {\n                    var _child3 = completedWork.child;\n                    while(_child3 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child3.return = completedWork;\n                        _child3 = _child3.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            }\n            completedWork.childLanes = newChildLanes;\n            return didBailout;\n        }\n        function completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {\n            var wasHydrated = popHydrationState(workInProgress);\n            if (nextState !== null && nextState.dehydrated !== null) {\n                // We might be inside a hydration state the first time we're picking up this\n                // Suspense boundary, and also after we've reentered it for further hydration.\n                if (current === null) {\n                    if (!wasHydrated) {\n                        throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n                    }\n                    prepareToHydrateHostSuspenseInstance(workInProgress);\n                    bubbleProperties(workInProgress);\n                    {\n                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                            var isTimedOutSuspense = nextState !== null;\n                            if (isTimedOutSuspense) {\n                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                var primaryChildFragment = workInProgress.child;\n                                if (primaryChildFragment !== null) {\n                                    // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                } else {\n                    emitPendingHydrationWarnings(); // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n                    // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n                    resetHydrationState();\n                    if ((workInProgress.flags & DidCapture) === NoFlags$1) {\n                        // This boundary did not suspend so it's now hydrated and unsuspended.\n                        workInProgress.memoizedState = null;\n                    } // If nothing suspended, we need to schedule an effect to mark this boundary\n                    // as having hydrated so events know that they're free to be invoked.\n                    // It's also a signal to replay events and the suspense callback.\n                    // If something suspended, schedule an effect to attach retry listeners.\n                    // So we might as well always mark this.\n                    workInProgress.flags |= Update;\n                    bubbleProperties(workInProgress);\n                    {\n                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                            var _isTimedOutSuspense = nextState !== null;\n                            if (_isTimedOutSuspense) {\n                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                var _primaryChildFragment = workInProgress.child;\n                                if (_primaryChildFragment !== null) {\n                                    // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                    workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                }\n            } else {\n                // Successfully completed this tree. If this was a forced client render,\n                // there may have been recoverable errors during first hydration\n                // attempt. If so, add them to a queue so we can log them in the\n                // commit phase.\n                upgradeHydrationErrorsToRecoverable(); // Fall through to normal Suspense path\n                return true;\n            }\n        }\n        function completeWork(current, workInProgress, renderLanes) {\n            var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case IncompleteFunctionComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case LazyComponent:\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                case ForwardRef:\n                case Fragment:\n                case Mode:\n                case Profiler:\n                case ContextConsumer:\n                case MemoComponent:\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ClassComponent:\n                    {\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        var fiberRoot = workInProgress.stateNode;\n                        {\n                            var previousCache = null;\n                            if (current !== null) {\n                                previousCache = current.memoizedState.cache;\n                            }\n                            var cache = workInProgress.memoizedState.cache;\n                            if (cache !== previousCache) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                            popCacheProvider(workInProgress);\n                        }\n                        popHostContainer(workInProgress);\n                        if (fiberRoot.pendingContext) {\n                            fiberRoot.context = fiberRoot.pendingContext;\n                            fiberRoot.pendingContext = null;\n                        }\n                        if (current === null || current.child === null) {\n                            // If we hydrated, pop so that we can delete any remaining children\n                            // that weren't hydrated.\n                            var wasHydrated = popHydrationState(workInProgress);\n                            if (wasHydrated) {\n                                emitPendingHydrationWarnings(); // If we hydrated, then we'll need to schedule an update for\n                                // the commit side-effects on the root.\n                                markUpdate(workInProgress);\n                            } else {\n                                if (current !== null) {\n                                    var prevState = current.memoizedState;\n                                    if (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n                                    (workInProgress.flags & ForceClientRender) !== NoFlags$1) {\n                                        // Schedule an effect to clear this container at the start of the\n                                        // next commit. This handles the case of React rendering into a\n                                        // container with previous children. It's also safe to do for\n                                        // updates too, because current.child would only be null if the\n                                        // previous render was null (so the container would already\n                                        // be empty).\n                                        workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                                        // recoverable errors during first hydration attempt. If so, add\n                                        // them to a queue so we can log them in the commit phase.\n                                        upgradeHydrationErrorsToRecoverable();\n                                    }\n                                }\n                            }\n                        }\n                        updateHostContainer(current, workInProgress);\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            // The branching here is more complicated than you might expect because\n                            // a HostHoistable sometimes corresponds to a Resource and sometimes\n                            // corresponds to an Instance. It can also switch during an update.\n                            var type = workInProgress.type;\n                            var nextResource = workInProgress.memoizedState;\n                            if (current === null) {\n                                // We are mounting and must Update this Hoistable in this commit\n                                // @TODO refactor this block to create the instance here in complete\n                                // phase if we are not hydrating.\n                                markUpdate(workInProgress);\n                                if (nextResource !== null) {\n                                    // This is a Hoistable Resource\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadResourceAndSuspendIfNeeded(workInProgress, nextResource);\n                                    return null;\n                                } else {\n                                    // This is a Hoistable Instance\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadInstanceAndSuspendIfNeeded(workInProgress, type, newProps);\n                                    return null;\n                                }\n                            } else {\n                                // This is an update.\n                                if (nextResource) {\n                                    // This is a Resource\n                                    if (nextResource !== current.memoizedState) {\n                                        // we have a new Resource. we need to update\n                                        markUpdate(workInProgress); // This must come at the very end of the complete phase.\n                                        bubbleProperties(workInProgress); // This must come at the very end of the complete phase, because it might\n                                        // throw to suspend, and if the resource immediately loads, the work loop\n                                        // will resume rendering as if the work-in-progress completed. So it must\n                                        // fully complete.\n                                        preloadResourceAndSuspendIfNeeded(workInProgress, nextResource);\n                                        return null;\n                                    } else {\n                                        // This must come at the very end of the complete phase.\n                                        bubbleProperties(workInProgress);\n                                        workInProgress.flags &= ~MaySuspendCommit;\n                                        return null;\n                                    }\n                                } else {\n                                    // This is an Instance\n                                    // We may have props to update on the Hoistable instance.\n                                    if (supportsMutation) {\n                                        var oldProps = current.memoizedProps;\n                                        if (oldProps !== newProps) {\n                                            markUpdate(workInProgress);\n                                        }\n                                    } else {\n                                        // We use the updateHostComponent path becuase it produces\n                                        // the update queue we need for Hoistables.\n                                        updateHostComponent(current, workInProgress, type, newProps);\n                                    } // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadInstanceAndSuspendIfNeeded(workInProgress, type, newProps);\n                                    return null;\n                                }\n                            }\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            popHostContext(workInProgress);\n                            var rootContainerInstance = getRootHostContainer();\n                            var _type = workInProgress.type;\n                            if (current !== null && workInProgress.stateNode != null) {\n                                if (supportsMutation) {\n                                    var _oldProps2 = current.memoizedProps;\n                                    if (_oldProps2 !== newProps) {\n                                        markUpdate(workInProgress);\n                                    }\n                                } else {\n                                    updateHostComponent(current, workInProgress, _type, newProps);\n                                }\n                            } else {\n                                if (!newProps) {\n                                    if (workInProgress.stateNode === null) {\n                                        throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                    } // This can happen when we abort work.\n                                    bubbleProperties(workInProgress);\n                                    return null;\n                                }\n                                var currentHostContext = getHostContext();\n                                var _wasHydrated = popHydrationState(workInProgress);\n                                var instance;\n                                if (_wasHydrated) {\n                                    // We ignore the boolean indicating there is an updateQueue because\n                                    // it is used only to set text children and HostSingletons do not\n                                    // use them.\n                                    prepareToHydrateHostInstance(workInProgress, currentHostContext);\n                                    instance = workInProgress.stateNode;\n                                } else {\n                                    instance = resolveSingletonInstance(_type, newProps, rootContainerInstance, currentHostContext, true);\n                                    workInProgress.stateNode = instance;\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                            bubbleProperties(workInProgress);\n                            return null;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(workInProgress);\n                        var _type2 = workInProgress.type;\n                        if (current !== null && workInProgress.stateNode != null) {\n                            updateHostComponent(current, workInProgress, _type2, newProps);\n                        } else {\n                            if (!newProps) {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                } // This can happen when we abort work.\n                                bubbleProperties(workInProgress);\n                                return null;\n                            }\n                            var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                            // \"stack\" as the parent. Then append children as we go in beginWork\n                            // or completeWork depending on whether we want to add them top->down or\n                            // bottom->up. Top->down is faster in IE11.\n                            var _wasHydrated2 = popHydrationState(workInProgress);\n                            if (_wasHydrated2) {\n                                // TODO: Move this and createInstance step into the beginPhase\n                                // to consolidate.\n                                prepareToHydrateHostInstance(workInProgress, _currentHostContext);\n                            } else {\n                                var _rootContainerInstance = getRootHostContainer();\n                                var _instance3 = createInstance(_type2, newProps, _rootContainerInstance, _currentHostContext, workInProgress); // TODO: For persistent renderers, we should pass children as part\n                                // of the initial instance creation\n                                appendAllChildren(_instance3, workInProgress, false, false);\n                                workInProgress.stateNode = _instance3; // Certain renderers require commit-time effects for initial mount.\n                                // (eg DOM renderer supports auto-focus for certain elements).\n                                // Make sure such renderers get scheduled for later work.\n                                if (finalizeInitialChildren(_instance3, _type2, newProps, _currentHostContext)) {\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                        }\n                        bubbleProperties(workInProgress); // This must come at the very end of the complete phase, because it might\n                        // throw to suspend, and if the resource immediately loads, the work loop\n                        // will resume rendering as if the work-in-progress completed. So it must\n                        // fully complete.\n                        preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                        return null;\n                    }\n                case HostText:\n                    {\n                        var newText = newProps;\n                        if (current && workInProgress.stateNode != null) {\n                            var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                            // to schedule a side-effect to do the updates.\n                            updateHostText(current, workInProgress, oldText, newText);\n                        } else {\n                            if (typeof newText !== 'string') {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                } // This can happen when we abort work.\n                            }\n                            var _rootContainerInstance2 = getRootHostContainer();\n                            var _currentHostContext2 = getHostContext();\n                            var _wasHydrated3 = popHydrationState(workInProgress);\n                            if (_wasHydrated3) {\n                                prepareToHydrateHostTextInstance(workInProgress);\n                            } else {\n                                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance2, _currentHostContext2, workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this\n                        // to its own fiber type so that we can add other kinds of hydration\n                        // boundaries that aren't associated with a Suspense tree. In anticipation\n                        // of such a refactor, all the hydration logic is contained in\n                        // this branch.\n                        if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {\n                            var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);\n                            if (!fallthroughToNormalSuspensePath) {\n                                if (workInProgress.flags & ForceClientRender) {\n                                    popSuspenseHandler(workInProgress); // Special case. There were remaining unhydrated nodes. We treat\n                                    // this as a mismatch. Revert to client rendering.\n                                    return workInProgress;\n                                } else {\n                                    popSuspenseHandler(workInProgress); // Did not finish hydrating, either because this is the initial\n                                    // render or because something suspended.\n                                    return null;\n                                }\n                            } // Continue with the normal Suspense path.\n                        }\n                        popSuspenseHandler(workInProgress);\n                        if ((workInProgress.flags & DidCapture) !== NoFlags$1) {\n                            // Something suspended. Re-render with the fallback children.\n                            workInProgress.lanes = renderLanes; // Do not reset the effect list.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            } // Don't bubble properties in this case.\n                            return workInProgress;\n                        }\n                        var nextDidTimeout = nextState !== null;\n                        var prevDidTimeout = current !== null && current.memoizedState !== null;\n                        if (nextDidTimeout) {\n                            var offscreenFiber = workInProgress.child;\n                            var _previousCache = null;\n                            if (offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null && offscreenFiber.alternate.memoizedState.cachePool !== null) {\n                                _previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\n                            }\n                            var _cache = null;\n                            if (offscreenFiber.memoizedState !== null && offscreenFiber.memoizedState.cachePool !== null) {\n                                _cache = offscreenFiber.memoizedState.cachePool.pool;\n                            }\n                            if (_cache !== _previousCache) {\n                                // Run passive effects to retain/release the cache.\n                                offscreenFiber.flags |= Passive$1;\n                            }\n                        } // If the suspended state of the boundary changes, we need to schedule\n                        // a passive effect, which is when we process the transitions\n                        if (nextDidTimeout !== prevDidTimeout) {\n                            // an effect to toggle the subtree's visibility. When we switch from\n                            // fallback -> primary, the inner Offscreen fiber schedules this effect\n                            // as part of its normal complete phase. But when we switch from\n                            // primary -> fallback, the inner Offscreen fiber does not have a complete\n                            // phase. So we need to schedule its effect here.\n                            //\n                            // We also use this flag to connect/disconnect the effects, but the same\n                            // logic applies: when re-connecting, the Offscreen fiber's complete\n                            // phase will handle scheduling the effect. It's only when the fallback\n                            // is active that we have to do anything special.\n                            if (nextDidTimeout) {\n                                var _offscreenFiber2 = workInProgress.child;\n                                _offscreenFiber2.flags |= Visibility;\n                            }\n                        }\n                        var retryQueue = workInProgress.updateQueue;\n                        scheduleRetryEffect(workInProgress, retryQueue);\n                        bubbleProperties(workInProgress);\n                        {\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                if (nextDidTimeout) {\n                                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                    var primaryChildFragment = workInProgress.child;\n                                    if (primaryChildFragment !== null) {\n                                        // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                        workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    updateHostContainer(current, workInProgress);\n                    if (current === null) {\n                        preparePortalMount(workInProgress.stateNode.containerInfo);\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ContextProvider:\n                    // Pop provider fiber\n                    var context;\n                    {\n                        context = workInProgress.type;\n                    }\n                    popProvider(context, workInProgress);\n                    bubbleProperties(workInProgress);\n                    return null;\n                case IncompleteClassComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseListContext(workInProgress);\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState === null) {\n                            // We're running in the default, \"independent\" mode.\n                            // We don't do anything in this mode.\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags$1;\n                        var renderedTail = renderState.rendering;\n                        if (renderedTail === null) {\n                            // We just rendered the head.\n                            if (!didSuspendAlready) {\n                                // This is the first pass. We need to figure out if anything is still\n                                // suspended in the rendered set.\n                                // If new content unsuspended, but there's still some content that\n                                // didn't. Then we need to do a second pass that forces everything\n                                // to keep showing their fallbacks.\n                                // We might be suspended if something in this render pass suspended, or\n                                // something in the previous committed pass suspended. Otherwise,\n                                // there's no chance so we can skip the expensive call to\n                                // findFirstSuspended.\n                                var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags$1);\n                                if (!cannotBeSuspended) {\n                                    var row = workInProgress.child;\n                                    while(row !== null){\n                                        var suspended = findFirstSuspended(row);\n                                        if (suspended !== null) {\n                                            didSuspendAlready = true;\n                                            workInProgress.flags |= DidCapture;\n                                            cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                                            // part of the second pass. In that case nothing will subscribe to\n                                            // its thenables. Instead, we'll transfer its thenables to the\n                                            // SuspenseList so that it can retry if they resolve.\n                                            // There might be multiple of these in the list but since we're\n                                            // going to wait for all of them anyway, it doesn't really matter\n                                            // which ones gets to ping. In theory we could get clever and keep\n                                            // track of how many dependencies remain but it gets tricky because\n                                            // in the meantime, we can add/remove/change items and dependencies.\n                                            // We might bail out of the loop before finding any but that\n                                            // doesn't matter since that means that the other boundaries that\n                                            // we did find already has their listeners attached.\n                                            var _retryQueue = suspended.updateQueue;\n                                            workInProgress.updateQueue = _retryQueue;\n                                            scheduleRetryEffect(workInProgress, _retryQueue); // Rerender the whole list, but this time, we'll force fallbacks\n                                            // to stay in place.\n                                            // Reset the effect flags before doing the second pass since that's now invalid.\n                                            // Reset the child fibers to their original state.\n                                            workInProgress.subtreeFlags = NoFlags$1;\n                                            resetChildFibers(workInProgress, renderLanes); // Set up the Suspense List Context to force suspense and\n                                            // immediately rerender the children.\n                                            pushSuspenseListContext(workInProgress, setShallowSuspenseListContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n                                            return workInProgress.child;\n                                        }\n                                        row = row.sibling;\n                                    }\n                                }\n                                if (renderState.tail !== null && now$1() > getRenderTargetTime()) {\n                                    // We have already passed our CPU deadline but we still have rows\n                                    // left in the tail. We'll just give up further attempts to render\n                                    // the main content and only render fallbacks.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            } else {\n                                cutOffTailIfNeeded(renderState, false);\n                            } // Next we're going to render the tail.\n                        } else {\n                            // Append the rendered row to the child list.\n                            if (!didSuspendAlready) {\n                                var _suspended = findFirstSuspended(renderedTail);\n                                if (_suspended !== null) {\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n                                    // get lost if this row ends up dropped during a second pass.\n                                    var _retryQueue2 = _suspended.updateQueue;\n                                    workInProgress.updateQueue = _retryQueue2;\n                                    scheduleRetryEffect(workInProgress, _retryQueue2);\n                                    cutOffTailIfNeeded(renderState, true); // This might have been modified.\n                                    if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n                                    ) {\n                                        // We're done.\n                                        bubbleProperties(workInProgress);\n                                        return null;\n                                    }\n                                } else if (// time we have to render. So rendering one more row would likely\n                                // exceed it.\n                                now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n                                    // We have now passed our CPU deadline and we'll just give up further\n                                    // attempts to render the main content and only render fallbacks.\n                                    // The assumption is that this is usually faster.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            }\n                            if (renderState.isBackwards) {\n                                // The effect list of the backwards tail will have been added\n                                // to the end. This breaks the guarantee that life-cycles fire in\n                                // sibling order but that isn't a strong guarantee promised by React.\n                                // Especially since these might also just pop in during future commits.\n                                // Append to the beginning of the list.\n                                renderedTail.sibling = workInProgress.child;\n                                workInProgress.child = renderedTail;\n                            } else {\n                                var previousSibling = renderState.last;\n                                if (previousSibling !== null) {\n                                    previousSibling.sibling = renderedTail;\n                                } else {\n                                    workInProgress.child = renderedTail;\n                                }\n                                renderState.last = renderedTail;\n                            }\n                        }\n                        if (renderState.tail !== null) {\n                            // We still have tail rows to render.\n                            // Pop a row.\n                            var next = renderState.tail;\n                            renderState.rendering = next;\n                            renderState.tail = next.sibling;\n                            renderState.renderingStartTime = now$1();\n                            next.sibling = null; // Restore the context.\n                            // TODO: We can probably just avoid popping it instead and only\n                            // setting it the first time we go from not suspended to suspended.\n                            var suspenseContext = suspenseStackCursor.current;\n                            if (didSuspendAlready) {\n                                suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n                            } else {\n                                suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n                            }\n                            pushSuspenseListContext(workInProgress, suspenseContext); // Do a pass over the next row.\n                            // Don't bubble properties in this case.\n                            return next;\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        popHiddenContext(workInProgress);\n                        var _nextState = workInProgress.memoizedState;\n                        var nextIsHidden = _nextState !== null; // Schedule a Visibility effect if the visibility has changed\n                        {\n                            if (current !== null) {\n                                var _prevState = current.memoizedState;\n                                var prevIsHidden = _prevState !== null;\n                                if (prevIsHidden !== nextIsHidden) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            } else {\n                                // On initial mount, we only need a Visibility effect if the tree\n                                // is hidden.\n                                if (nextIsHidden) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            }\n                        }\n                        if (!nextIsHidden || !disableLegacyMode) {\n                            bubbleProperties(workInProgress);\n                        } else {\n                            // Don't bubble properties for hidden children unless we're rendering\n                            // at offscreen priority.\n                            if (includesSomeLane(renderLanes, OffscreenLane) && // Also don't bubble if the tree suspended\n                            (workInProgress.flags & DidCapture) === NoLanes) {\n                                bubbleProperties(workInProgress); // Check if there was an insertion or update in the hidden subtree.\n                                // If so, we need to hide those nodes in the commit phase, so\n                                // schedule a visibility effect.\n                                if (workInProgress.subtreeFlags & (Placement | Update)) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            }\n                        }\n                        var offscreenQueue = workInProgress.updateQueue;\n                        if (offscreenQueue !== null) {\n                            var _retryQueue3 = offscreenQueue.retryQueue;\n                            scheduleRetryEffect(workInProgress, _retryQueue3);\n                        }\n                        {\n                            var _previousCache2 = null;\n                            if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                                _previousCache2 = current.memoizedState.cachePool.pool;\n                            }\n                            var _cache2 = null;\n                            if (workInProgress.memoizedState !== null && workInProgress.memoizedState.cachePool !== null) {\n                                _cache2 = workInProgress.memoizedState.cachePool.pool;\n                            }\n                            if (_cache2 !== _previousCache2) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                        }\n                        popTransition(workInProgress, current);\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _previousCache3 = null;\n                            if (current !== null) {\n                                _previousCache3 = current.memoizedState.cache;\n                            }\n                            var _cache3 = workInProgress.memoizedState.cache;\n                            if (_cache3 !== _previousCache3) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                            popCacheProvider(workInProgress);\n                            bubbleProperties(workInProgress);\n                        }\n                        return null;\n                    }\n                case TracingMarkerComponent:\n                    {\n                        return null;\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n        }\n        function unwindWork(current, workInProgress, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case ClassComponent:\n                    {\n                        var flags = workInProgress.flags;\n                        if (flags & ShouldCapture) {\n                            workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        {\n                            popCacheProvider(workInProgress);\n                        }\n                        popHostContainer(workInProgress);\n                        var _flags = workInProgress.flags;\n                        if ((_flags & ShouldCapture) !== NoFlags$1 && (_flags & DidCapture) === NoFlags$1) {\n                            // There was an error during render that wasn't captured by a suspense\n                            // boundary. Do a second pass on the root to unmount the children.\n                            workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n                            return workInProgress;\n                        } // We unwound to the root without completing it. Exit.\n                        return null;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        // TODO: popHydrationState\n                        popHostContext(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        var suspenseState = workInProgress.memoizedState;\n                        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                            if (workInProgress.alternate === null) {\n                                throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n                            }\n                            resetHydrationState();\n                        }\n                        var _flags2 = workInProgress.flags;\n                        if (_flags2 & ShouldCapture) {\n                            workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseListContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n                        // caught by a nested boundary. If not, it should bubble through.\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    return null;\n                case ContextProvider:\n                    var context;\n                    {\n                        context = workInProgress.type;\n                    }\n                    popProvider(context, workInProgress);\n                    return null;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        popHiddenContext(workInProgress);\n                        popTransition(workInProgress, current);\n                        var _flags3 = workInProgress.flags;\n                        if (_flags3 & ShouldCapture) {\n                            workInProgress.flags = _flags3 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        popCacheProvider(workInProgress);\n                    }\n                    return null;\n                case TracingMarkerComponent:\n                    return null;\n                default:\n                    return null;\n            }\n        }\n        function unwindInterruptedWork(current, interruptedWork, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(interruptedWork);\n            switch(interruptedWork.tag){\n                case ClassComponent:\n                    {\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        {\n                            popCacheProvider(interruptedWork);\n                        }\n                        popHostContainer(interruptedWork);\n                        break;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        popHostContext(interruptedWork);\n                        break;\n                    }\n                case HostPortal:\n                    popHostContainer(interruptedWork);\n                    break;\n                case SuspenseComponent:\n                    popSuspenseHandler(interruptedWork);\n                    break;\n                case SuspenseListComponent:\n                    popSuspenseListContext(interruptedWork);\n                    break;\n                case ContextProvider:\n                    var context;\n                    {\n                        context = interruptedWork.type;\n                    }\n                    popProvider(context, interruptedWork);\n                    break;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popSuspenseHandler(interruptedWork);\n                    popHiddenContext(interruptedWork);\n                    popTransition(interruptedWork, current);\n                    break;\n                case CacheComponent:\n                    {\n                        popCacheProvider(interruptedWork);\n                    }\n                    break;\n            }\n        }\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n        {\n            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n        }\n        // Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n        var offscreenSubtreeIsHidden = false;\n        var offscreenSubtreeWasHidden = false; // Used to track if a form needs to be reset at the end of the mutation phase.\n        var needsFormReset = false;\n        var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n        var nextEffect = null; // Used for Profiling builds to track updaters.\n        var inProgressLanes = null;\n        var inProgressRoot = null;\n        function shouldProfile(current) {\n            return (current.mode & ProfileMode) !== NoMode && (getExecutionContext() & CommitContext) !== NoContext;\n        }\n        function callComponentWillUnmountWithTimer(current, instance) {\n            instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n            instance.state = current.memoizedState;\n            if (shouldProfile(current)) {\n                try {\n                    startLayoutEffectTimer();\n                    instance.componentWillUnmount();\n                } finally{\n                    recordLayoutEffectDuration(current);\n                }\n            } else {\n                instance.componentWillUnmount();\n            }\n        } // Capture errors so they don't interrupt unmounting.\n        function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n            try {\n                callComponentWillUnmountWithTimer(current, instance);\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyAttachRef(current, nearestMountedAncestor) {\n            try {\n                commitAttachRef(current);\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        function safelyDetachRef(current, nearestMountedAncestor) {\n            var ref = current.ref;\n            var refCleanup = current.refCleanup;\n            if (ref !== null) {\n                if (typeof refCleanup === 'function') {\n                    try {\n                        if (shouldProfile(current)) {\n                            try {\n                                startLayoutEffectTimer();\n                                refCleanup();\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            refCleanup();\n                        }\n                    } catch (error) {\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    } finally{\n                        // `refCleanup` has been called. Nullify all references to it to prevent double invocation.\n                        current.refCleanup = null;\n                        var finishedWork = current.alternate;\n                        if (finishedWork != null) {\n                            finishedWork.refCleanup = null;\n                        }\n                    }\n                } else if (typeof ref === 'function') {\n                    try {\n                        if (shouldProfile(current)) {\n                            try {\n                                startLayoutEffectTimer();\n                                ref(null);\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            ref(null);\n                        }\n                    } catch (error) {\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    }\n                } else {\n                    // $FlowFixMe[incompatible-use] unable to narrow type to RefObject\n                    ref.current = null;\n                }\n            }\n        }\n        function safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        var shouldFireAfterActiveInstanceBlur = false;\n        function commitBeforeMutationEffects(root, firstChild) {\n            prepareForCommit(root.containerInfo);\n            nextEffect = firstChild;\n            commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n            var shouldFire = shouldFireAfterActiveInstanceBlur;\n            shouldFireAfterActiveInstanceBlur = false;\n            return shouldFire;\n        }\n        function commitBeforeMutationEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags$1 && child !== null) {\n                    child.return = fiber;\n                    nextEffect = child;\n                } else {\n                    commitBeforeMutationEffects_complete();\n                }\n            }\n        }\n        function commitBeforeMutationEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                try {\n                    if (true) {\n                        runWithFiberInDEV(fiber, commitBeforeMutationEffectsOnFiber, fiber);\n                    }\n                } catch (error) {\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitBeforeMutationEffectsOnFiber(finishedWork) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                    {\n                        break;\n                    }\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            if (current !== null) {\n                                var prevProps = current.memoizedProps;\n                                var prevState = current.memoizedState;\n                                var instance = finishedWork.stateNode; // We could update instance props and state here,\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                {\n                                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                                        }\n                                    }\n                                }\n                                var snapshot = instance.getSnapshotBeforeUpdate(resolveClassComponentProps(finishedWork.type, prevProps), prevState);\n                                {\n                                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                                        didWarnSet.add(finishedWork.type);\n                                        error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n                                    }\n                                }\n                                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                            }\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            if (supportsMutation) {\n                                var root = finishedWork.stateNode;\n                                clearContainer(root.containerInfo);\n                            }\n                        }\n                        break;\n                    }\n                case HostComponent:\n                case HostHoistable:\n                case HostSingleton:\n                case HostText:\n                case HostPortal:\n                case IncompleteClassComponent:\n                    break;\n                default:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n                        }\n                    }\n            }\n        }\n        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        // Unmount\n                        var inst = effect.inst;\n                        var destroy = inst.destroy;\n                        if (destroy !== undefined) {\n                            inst.destroy = undefined;\n                            {\n                                if ((flags & Passive) !== NoFlags) {\n                                    markComponentPassiveEffectUnmountStarted(finishedWork);\n                                } else if ((flags & Layout) !== NoFlags) {\n                                    markComponentLayoutEffectUnmountStarted(finishedWork);\n                                }\n                            }\n                            {\n                                if ((flags & Insertion) !== NoFlags) {\n                                    setIsRunningInsertionEffect(true);\n                                }\n                            }\n                            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                            {\n                                if ((flags & Insertion) !== NoFlags) {\n                                    setIsRunningInsertionEffect(false);\n                                }\n                            }\n                            {\n                                if ((flags & Passive) !== NoFlags) {\n                                    markComponentPassiveEffectUnmountStopped();\n                                } else if ((flags & Layout) !== NoFlags) {\n                                    markComponentLayoutEffectUnmountStopped();\n                                }\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitHookEffectListMount(flags, finishedWork) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        {\n                            if ((flags & Passive) !== NoFlags) {\n                                markComponentPassiveEffectMountStarted(finishedWork);\n                            } else if ((flags & Layout) !== NoFlags) {\n                                markComponentLayoutEffectMountStarted(finishedWork);\n                            }\n                        }\n                        var create = effect.create;\n                        {\n                            if ((flags & Insertion) !== NoFlags) {\n                                setIsRunningInsertionEffect(true);\n                            }\n                        }\n                        var inst = effect.inst;\n                        var destroy = create();\n                        inst.destroy = destroy;\n                        {\n                            if ((flags & Insertion) !== NoFlags) {\n                                setIsRunningInsertionEffect(false);\n                            }\n                        }\n                        {\n                            if ((flags & Passive) !== NoFlags) {\n                                markComponentPassiveEffectMountStopped();\n                            } else if ((flags & Layout) !== NoFlags) {\n                                markComponentLayoutEffectMountStopped();\n                            }\n                        }\n                        {\n                            if (destroy !== undefined && typeof destroy !== 'function') {\n                                var hookName = void 0;\n                                if ((effect.tag & Layout) !== NoFlags$1) {\n                                    hookName = 'useLayoutEffect';\n                                } else if ((effect.tag & Insertion) !== NoFlags$1) {\n                                    hookName = 'useInsertionEffect';\n                                } else {\n                                    hookName = 'useEffect';\n                                }\n                                var addendum = void 0;\n                                if (destroy === null) {\n                                    addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n                                } else if (typeof destroy.then === 'function') {\n                                    addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching';\n                                } else {\n                                    addendum = ' You returned: ' + destroy;\n                                }\n                                error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n            if (getExecutionContext() & CommitContext) {\n                // Only Profilers with work in their subtree will have an Update effect scheduled.\n                if ((finishedWork.flags & Update) !== NoFlags$1) {\n                    switch(finishedWork.tag){\n                        case Profiler:\n                            {\n                                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n                                // It does not get reset until the start of the next commit phase.\n                                var commitTime = getCommitTime();\n                                var phase = finishedWork.alternate === null ? 'mount' : 'update';\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = 'nested-update';\n                                    }\n                                }\n                                if (typeof onPostCommit === 'function') {\n                                    onPostCommit(id, phase, passiveEffectDuration, commitTime);\n                                } // Bubble times to the next nearest ancestor Profiler.\n                                // After we process that Profiler, we'll bubble further up.\n                                var parentFiber = finishedWork.return;\n                                outer: while(parentFiber !== null){\n                                    switch(parentFiber.tag){\n                                        case HostRoot:\n                                            var root = parentFiber.stateNode;\n                                            root.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                        case Profiler:\n                                            var parentStateNode = parentFiber.stateNode;\n                                            parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                    }\n                                    parentFiber = parentFiber.return;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function commitHookLayoutEffects(finishedWork, hookFlags) {\n            // At this point layout effects have already been destroyed (during mutation phase).\n            // This is done to prevent sibling component effects from interfering with each other,\n            // e.g. a destroy function in one component should never override a ref set\n            // by a create function in another component during the same commit.\n            if (shouldProfile(finishedWork)) {\n                try {\n                    startLayoutEffectTimer();\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n                recordLayoutEffectDuration(finishedWork);\n            } else {\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitClassLayoutLifecycles(finishedWork, current) {\n            var instance = finishedWork.stateNode;\n            if (current === null) {\n                // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                if (shouldProfile(finishedWork)) {\n                    try {\n                        startLayoutEffectTimer();\n                        instance.componentDidMount();\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    recordLayoutEffectDuration(finishedWork);\n                } else {\n                    try {\n                        instance.componentDidMount();\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            } else {\n                var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                var prevState = current.memoizedState; // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                if (shouldProfile(finishedWork)) {\n                    try {\n                        startLayoutEffectTimer();\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    recordLayoutEffectDuration(finishedWork);\n                } else {\n                    try {\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            }\n        }\n        function commitClassCallbacks(finishedWork) {\n            // TODO: I think this is now always non-null by the time it reaches the\n            // commit phase. Consider removing the type check.\n            var updateQueue = finishedWork.updateQueue;\n            if (updateQueue !== null) {\n                var instance = finishedWork.stateNode;\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                try {\n                    commitCallbacks(updateQueue, instance);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitHostComponentMount(finishedWork) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            var instance = finishedWork.stateNode;\n            try {\n                commitMount(instance, type, props, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n        function commitProfilerUpdate(finishedWork, current) {\n            if (getExecutionContext() & CommitContext) {\n                try {\n                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                    var effectDuration = finishedWork.stateNode.effectDuration;\n                    var commitTime = getCommitTime();\n                    var phase = current === null ? 'mount' : 'update';\n                    if (enableProfilerNestedUpdatePhase) {\n                        if (isCurrentUpdateNested()) {\n                            phase = 'nested-update';\n                        }\n                    }\n                    if (typeof onRender === 'function') {\n                        onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n                    }\n                    if (enableProfilerCommitHooks) {\n                        if (typeof onCommit === 'function') {\n                            onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n                        } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n                        // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n                        // because the effect is also where times bubble to parent Profilers.\n                        enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n                        // Do not reset these values until the next render so DevTools has a chance to read them first.\n                        var parentFiber = finishedWork.return;\n                        outer: while(parentFiber !== null){\n                            switch(parentFiber.tag){\n                                case HostRoot:\n                                    var root = parentFiber.stateNode;\n                                    root.effectDuration += effectDuration;\n                                    break outer;\n                                case Profiler:\n                                    var parentStateNode = parentFiber.stateNode;\n                                    parentStateNode.effectDuration += effectDuration;\n                                    break outer;\n                            }\n                            parentFiber = parentFiber.return;\n                        }\n                    }\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n            // When updating this function, also update reappearLayoutEffects, which does\n            // most of the same things when an offscreen tree goes from hidden -> visible.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n                        if (flags & Update) {\n                            commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                        }\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n                        if (flags & Update) {\n                            commitClassLayoutLifecycles(finishedWork, current);\n                        }\n                        if (flags & Callback) {\n                            commitClassCallbacks(finishedWork);\n                        }\n                        if (flags & Ref) {\n                            safelyAttachRef(finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n                        if (flags & Callback) {\n                            // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                var instance = null;\n                                if (finishedWork.child !== null) {\n                                    switch(finishedWork.child.tag){\n                                        case HostSingleton:\n                                        case HostComponent:\n                                            instance = getPublicInstance(finishedWork.child.stateNode);\n                                            break;\n                                        case ClassComponent:\n                                            instance = finishedWork.child.stateNode;\n                                            break;\n                                    }\n                                }\n                                try {\n                                    commitCallbacks(updateQueue, instance);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n                            if (flags & Ref) {\n                                safelyAttachRef(finishedWork, finishedWork.return);\n                            }\n                            break;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes); // Renderers may schedule work to be done after host components are mounted\n                        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                        // These effects should only be committed when components are first mounted,\n                        // aka when there is no current/alternate.\n                        if (current === null && flags & Update) {\n                            commitHostComponentMount(finishedWork);\n                        }\n                        if (flags & Ref) {\n                            safelyAttachRef(finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n                case Profiler:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes); // TODO: Should this fire inside an offscreen tree? Or should it wait to\n                        // fire when the tree becomes visible again.\n                        if (flags & Update) {\n                            commitProfilerUpdate(finishedWork, current);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n                        if (flags & Update) {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var isModernRoot = disableLegacyMode;\n                        if (isModernRoot) {\n                            var isHidden = finishedWork.memoizedState !== null;\n                            var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n                            if (newOffscreenSubtreeIsHidden) ;\n                            else {\n                                // The Offscreen tree is visible.\n                                var wasHidden = current !== null && current.memoizedState !== null;\n                                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n                                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n                                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n                                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                                    // This is the root of a reappearing boundary. As we continue\n                                    // traversing the layout effects, we must also re-mount layout\n                                    // effects that were unmounted when the Offscreen subtree was\n                                    // hidden. So this is a superset of the normal commitLayoutEffects.\n                                    var includeWorkInProgressEffects = (finishedWork.subtreeFlags & LayoutMask) !== NoFlags$1;\n                                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                                } else {\n                                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n                                }\n                                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                            }\n                        } else {\n                            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n                        }\n                        if (flags & Ref) {\n                            var props = finishedWork.memoizedProps;\n                            if (props.mode === 'manual') {\n                                safelyAttachRef(finishedWork, finishedWork.return);\n                            } else {\n                                safelyDetachRef(finishedWork, finishedWork.return);\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n                        break;\n                    }\n            }\n        }\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\n            // Only hide or unhide the top-most host nodes.\n            var hostSubtreeRoot = null;\n            if (supportsMutation) {\n                // We only have the top Fiber that was inserted but we need to recurse down its\n                // children to find all the terminal nodes.\n                var node = finishedWork;\n                while(true){\n                    if (node.tag === HostComponent || (supportsResources ? node.tag === HostHoistable : false) || (supportsSingletons ? node.tag === HostSingleton : false)) {\n                        if (hostSubtreeRoot === null) {\n                            hostSubtreeRoot = node;\n                            try {\n                                var instance = node.stateNode;\n                                if (isHidden) {\n                                    hideInstance(instance);\n                                } else {\n                                    unhideInstance(node.stateNode, node.memoizedProps);\n                                }\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    } else if (node.tag === HostText) {\n                        if (hostSubtreeRoot === null) {\n                            try {\n                                var _instance = node.stateNode;\n                                if (isHidden) {\n                                    hideTextInstance(_instance);\n                                } else {\n                                    unhideTextInstance(_instance, node.memoizedProps);\n                                }\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === finishedWork) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === finishedWork) {\n                            return;\n                        }\n                        if (hostSubtreeRoot === node) {\n                            hostSubtreeRoot = null;\n                        }\n                        node = node.return;\n                    }\n                    if (hostSubtreeRoot === node) {\n                        hostSubtreeRoot = null;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function commitAttachRef(finishedWork) {\n            var ref = finishedWork.ref;\n            if (ref !== null) {\n                var instance = finishedWork.stateNode;\n                var instanceToUse;\n                switch(finishedWork.tag){\n                    case HostHoistable:\n                    case HostSingleton:\n                    case HostComponent:\n                        instanceToUse = getPublicInstance(instance);\n                        break;\n                    default:\n                        instanceToUse = instance;\n                } // Moved outside to ensure DCE works with this flag\n                if (typeof ref === 'function') {\n                    if (shouldProfile(finishedWork)) {\n                        try {\n                            startLayoutEffectTimer();\n                            finishedWork.refCleanup = ref(instanceToUse);\n                        } finally{\n                            recordLayoutEffectDuration(finishedWork);\n                        }\n                    } else {\n                        finishedWork.refCleanup = ref(instanceToUse);\n                    }\n                } else {\n                    {\n                        // TODO: We should move these warnings to happen during the render\n                        // phase (markRef).\n                        if (typeof ref === 'string') {\n                            error('String refs are no longer supported.');\n                        } else if (!ref.hasOwnProperty('current')) {\n                            error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                    ref.current = instanceToUse;\n                }\n            }\n        }\n        function detachFiberMutation(fiber) {\n            // Cut off the return pointer to disconnect it from the tree.\n            // This enables us to detect and warn against state updates on an unmounted component.\n            // It also prevents events from bubbling from within disconnected components.\n            //\n            // Ideally, we should also clear the child pointer of the parent alternate to let this\n            // get GC:ed but we don't know which for sure which parent is the current\n            // one so we'll settle for GC:ing the subtree of this child.\n            // This child itself will be GC:ed when the parent updates the next time.\n            //\n            // Note that we can't clear child or sibling pointers yet.\n            // They're needed for passive effects and for findDOMNode.\n            // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n            //\n            // Don't reset the alternate yet, either. We need that so we can detach the\n            // alternate's fields in the passive phase. Clearing the return pointer is\n            // sufficient for findDOMNode semantics.\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.return = null;\n            }\n            fiber.return = null;\n        }\n        function detachFiberAfterEffects(fiber) {\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                fiber.alternate = null;\n                detachFiberAfterEffects(alternate);\n            } // Clear cyclical Fiber fields. This level alone is designed to roughly\n            // approximate the planned Fiber refactor. In that world, `setState` will be\n            // bound to a special \"instance\" object instead of a Fiber. The Instance\n            // object will not have any of these fields. It will only be connected to\n            // the fiber tree via a single link at the root. So if this level alone is\n            // sufficient to fix memory issues, that bodes well for our plans.\n            fiber.child = null;\n            fiber.deletions = null;\n            fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n            // tree, which has its own pointers to children, parents, and siblings.\n            // The other host nodes also point back to fibers, so we should detach that\n            // one, too.\n            if (fiber.tag === HostComponent) {\n                var hostInstance = fiber.stateNode;\n                if (hostInstance !== null) {\n                    detachDeletedInstance(hostInstance);\n                }\n            }\n            fiber.stateNode = null;\n            {\n                fiber._debugOwner = null;\n            }\n            // disconnected the fiber from the tree. So even if something leaks this\n            // particular fiber, it won't leak anything else.\n            fiber.return = null;\n            fiber.dependencies = null;\n            fiber.memoizedProps = null;\n            fiber.memoizedState = null;\n            fiber.pendingProps = null;\n            fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n            fiber.updateQueue = null;\n        }\n        function emptyPortalContainer(current) {\n            if (!supportsPersistence) {\n                return;\n            }\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet();\n            replaceContainerChildren(containerInfo, emptyChildSet);\n        }\n        function getHostParentFiber(fiber) {\n            var parent = fiber.return;\n            while(parent !== null){\n                if (isHostParent(parent)) {\n                    return parent;\n                }\n                parent = parent.return;\n            }\n            throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n        }\n        function isHostParent(fiber) {\n            return fiber.tag === HostComponent || fiber.tag === HostRoot || (supportsResources ? fiber.tag === HostHoistable : false) || (supportsSingletons ? fiber.tag === HostSingleton : false) || fiber.tag === HostPortal;\n        }\n        function getHostSibling(fiber) {\n            // We're going to search forward into the tree until we find a sibling host\n            // node. Unfortunately, if multiple insertions are done in a row we have to\n            // search past them. This leads to exponential search for the next sibling.\n            // TODO: Find a more efficient way to do this.\n            var node = fiber;\n            siblings: while(true){\n                // If we didn't find anything, let's try the next sibling.\n                while(node.sibling === null){\n                    if (node.return === null || isHostParent(node.return)) {\n                        // If we pop out of the root or hit the parent the fiber we are the\n                        // last sibling.\n                        return null;\n                    } // $FlowFixMe[incompatible-type] found when upgrading Flow\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n                while(node.tag !== HostComponent && node.tag !== HostText && (!supportsSingletons ? true : node.tag !== HostSingleton) && node.tag !== DehydratedFragment){\n                    // If it is not host node and, we might have a host node inside it.\n                    // Try to search down until we find one.\n                    if (node.flags & Placement) {\n                        continue siblings;\n                    } // If we don't have a child, try the siblings instead.\n                    // We also skip portals because they are not part of this host tree.\n                    if (node.child === null || node.tag === HostPortal) {\n                        continue siblings;\n                    } else {\n                        node.child.return = node;\n                        node = node.child;\n                    }\n                } // Check if this host node is stable or about to be placed.\n                if (!(node.flags & Placement)) {\n                    // Found it!\n                    return node.stateNode;\n                }\n            }\n        }\n        function commitPlacement(finishedWork) {\n            if (!supportsMutation) {\n                return;\n            }\n            if (supportsSingletons) {\n                if (finishedWork.tag === HostSingleton) {\n                    // Singletons are already in the Host and don't need to be placed\n                    // Since they operate somewhat like Portals though their children will\n                    // have Placement and will get placed inside them\n                    return;\n                }\n            } // Recursively insert all host nodes into the parent.\n            var parentFiber = getHostParentFiber(finishedWork);\n            switch(parentFiber.tag){\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            var parent = parentFiber.stateNode;\n                            var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                            // children to find all the terminal nodes.\n                            insertOrAppendPlacementNode(finishedWork, before, parent);\n                            break;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        var _parent = parentFiber.stateNode;\n                        if (parentFiber.flags & ContentReset) {\n                            // Reset the text content of the parent before doing any insertions\n                            resetTextContent(_parent); // Clear ContentReset from the effect tag\n                            parentFiber.flags &= ~ContentReset;\n                        }\n                        var _before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                        // children to find all the terminal nodes.\n                        insertOrAppendPlacementNode(finishedWork, _before, _parent);\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var _parent2 = parentFiber.stateNode.containerInfo;\n                        var _before2 = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before2, _parent2);\n                        break;\n                    }\n                default:\n                    throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n            }\n        }\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertInContainerBefore(parent, stateNode, before);\n                } else {\n                    appendChildToContainer(parent, stateNode);\n                }\n            } else if (tag === HostPortal || (supportsSingletons ? tag === HostSingleton : false)) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function insertOrAppendPlacementNode(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertBefore(parent, stateNode, before);\n                } else {\n                    appendChild(parent, stateNode);\n                }\n            } else if (tag === HostPortal || (supportsSingletons ? tag === HostSingleton : false)) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNode(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNode(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        } // These are tracked on the stack as we recursively traverse a\n        // deleted subtree.\n        // TODO: Update these during the whole mutation phase, not just during\n        // a deletion.\n        var hostParent = null;\n        var hostParentIsContainer = false;\n        function commitDeletionEffects(root, returnFiber, deletedFiber) {\n            if (supportsMutation) {\n                // We only have the top Fiber that was deleted but we need to recurse down its\n                // children to find all the terminal nodes.\n                // Recursively delete all host nodes from the parent, detach refs, clean\n                // up mounted layout effects, and call componentWillUnmount.\n                // We only need to remove the topmost host child in each branch. But then we\n                // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n                // could split this into two separate traversals functions, where the second\n                // one doesn't include any removeChild logic. This is maybe the same\n                // function as \"disappearLayoutEffects\" (or whatever that turns into after\n                // the layout phase is refactored to use recursion).\n                // Before starting, find the nearest host parent on the stack so we know\n                // which instance/container to remove the children from.\n                // TODO: Instead of searching up the fiber return path on every deletion, we\n                // can track the nearest host component on the JS stack as we traverse the\n                // tree during the commit phase. This would make insertions faster, too.\n                var parent = returnFiber;\n                findParent: while(parent !== null){\n                    switch(parent.tag){\n                        case HostSingleton:\n                        case HostComponent:\n                            {\n                                hostParent = parent.stateNode;\n                                hostParentIsContainer = false;\n                                break findParent;\n                            }\n                        case HostRoot:\n                            {\n                                hostParent = parent.stateNode.containerInfo;\n                                hostParentIsContainer = true;\n                                break findParent;\n                            }\n                        case HostPortal:\n                            {\n                                hostParent = parent.stateNode.containerInfo;\n                                hostParentIsContainer = true;\n                                break findParent;\n                            }\n                    }\n                    parent = parent.return;\n                }\n                if (hostParent === null) {\n                    throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n                }\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = false;\n            } else {\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            }\n            detachFiberMutation(deletedFiber);\n        }\n        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n            // TODO: Use a static flag to skip trees that don't have unmount effects\n            var child = parent.child;\n            while(child !== null){\n                commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n                child = child.sibling;\n            }\n        }\n        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n            onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse\n            // into their subtree. There are simpler cases in the inner switch\n            // that don't modify the stack.\n            switch(deletedFiber.tag){\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            if (!offscreenSubtreeWasHidden) {\n                                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            }\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            if (deletedFiber.memoizedState) {\n                                releaseResource(deletedFiber.memoizedState);\n                            } else if (deletedFiber.stateNode) {\n                                unmountHoistable(deletedFiber.stateNode);\n                            }\n                            return;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            if (!offscreenSubtreeWasHidden) {\n                                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            }\n                            var prevHostParent = hostParent;\n                            var prevHostParentIsContainer = hostParentIsContainer;\n                            hostParent = deletedFiber.stateNode;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber); // Normally this is called in passive unmount effect phase however with\n                            // HostSingleton we warn if you acquire one that is already associated to\n                            // a different fiber. To increase our chances of avoiding this, specifically\n                            // if you keyed a HostSingleton so there will be a delete followed by a Placement\n                            // we treat detach eagerly here\n                            releaseSingletonInstance(deletedFiber.stateNode);\n                            hostParent = prevHostParent;\n                            hostParentIsContainer = prevHostParentIsContainer;\n                            return;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                        } // Intentional fallthrough to next branch\n                    }\n                case HostText:\n                    {\n                        // We only need to remove the nearest host child. Set the host parent\n                        // to `null` on the stack to indicate that nested children don't\n                        // need to be removed.\n                        if (supportsMutation) {\n                            var _prevHostParent = hostParent;\n                            var _prevHostParentIsContainer = hostParentIsContainer;\n                            hostParent = null;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            hostParent = _prevHostParent;\n                            hostParentIsContainer = _prevHostParentIsContainer;\n                            if (hostParent !== null) {\n                                // Now that all the child effects have unmounted, we can remove the\n                                // node from the tree.\n                                if (hostParentIsContainer) {\n                                    removeChildFromContainer(hostParent, deletedFiber.stateNode);\n                                } else {\n                                    removeChild(hostParent, deletedFiber.stateNode);\n                                }\n                            }\n                        } else {\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        }\n                        return;\n                    }\n                case DehydratedFragment:\n                    {\n                        // Delete the dehydrated suspense boundary and all of its content.\n                        if (supportsMutation) {\n                            if (hostParent !== null) {\n                                if (hostParentIsContainer) {\n                                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n                                } else {\n                                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        if (supportsMutation) {\n                            // When we go into a portal, it becomes the parent to remove from.\n                            var _prevHostParent2 = hostParent;\n                            var _prevHostParentIsContainer2 = hostParentIsContainer;\n                            hostParent = deletedFiber.stateNode.containerInfo;\n                            hostParentIsContainer = true;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            hostParent = _prevHostParent2;\n                            hostParentIsContainer = _prevHostParentIsContainer2;\n                        } else {\n                            emptyPortalContainer(deletedFiber);\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        }\n                        return;\n                    }\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            var updateQueue = deletedFiber.updateQueue;\n                            if (updateQueue !== null) {\n                                var lastEffect = updateQueue.lastEffect;\n                                if (lastEffect !== null) {\n                                    var firstEffect = lastEffect.next;\n                                    var effect = firstEffect;\n                                    do {\n                                        var tag = effect.tag;\n                                        var inst = effect.inst;\n                                        var destroy = inst.destroy;\n                                        if (destroy !== undefined) {\n                                            if ((tag & Insertion) !== NoFlags) {\n                                                inst.destroy = undefined;\n                                                safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                            } else if ((tag & Layout) !== NoFlags) {\n                                                {\n                                                    markComponentLayoutEffectUnmountStarted(deletedFiber);\n                                                }\n                                                if (shouldProfile(deletedFiber)) {\n                                                    startLayoutEffectTimer();\n                                                    inst.destroy = undefined;\n                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                                    recordLayoutEffectDuration(deletedFiber);\n                                                } else {\n                                                    inst.destroy = undefined;\n                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                                }\n                                                {\n                                                    markComponentLayoutEffectUnmountStopped();\n                                                }\n                                            }\n                                        }\n                                        effect = effect.next;\n                                    }while (effect !== firstEffect);\n                                }\n                            }\n                        }\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            var instance = deletedFiber.stateNode;\n                            if (typeof instance.componentWillUnmount === 'function') {\n                                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n                            }\n                        }\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case OffscreenComponent:\n                    {\n                        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                        {\n                            // If this offscreen component is hidden, we already unmounted it. Before\n                            // deleting the children, track that it's already unmounted so that we\n                            // don't attempt to unmount the effects again.\n                            // TODO: If the tree is hidden, in most cases we should be able to skip\n                            // over the nested children entirely. An exception is we haven't yet found\n                            // the topmost host node to delete, which we already track on the stack.\n                            // But the other case is portals, which need to be detached no matter how\n                            // deeply they are nested. We should use a subtree flag to track whether a\n                            // subtree includes a nested portal.\n                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n            }\n        }\n        function commitSuspenseCallback(finishedWork) {}\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n            if (!supportsHydration) {\n                return;\n            }\n            var newState = finishedWork.memoizedState;\n            if (newState === null) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        var suspenseInstance = prevState.dehydrated;\n                        if (suspenseInstance !== null) {\n                            try {\n                                commitHydratedSuspenseInstance(suspenseInstance);\n                                var hydrationCallbacks, onHydrated;\n                                if (enableSuspenseCallback) ;\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        function getRetryCache(finishedWork) {\n            // TODO: Unify the interface for the retry cache so we don't have to switch\n            // on the tag like this.\n            switch(finishedWork.tag){\n                case SuspenseComponent:\n                case SuspenseListComponent:\n                    {\n                        var retryCache = finishedWork.stateNode;\n                        if (retryCache === null) {\n                            retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n                        }\n                        return retryCache;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        var _retryCache = instance._retryCache;\n                        if (_retryCache === null) {\n                            _retryCache = instance._retryCache = new PossiblyWeakSet();\n                        }\n                        return _retryCache;\n                    }\n                default:\n                    {\n                        throw new Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a \" + 'bug in React.');\n                    }\n            }\n        }\n        function detachOffscreenInstance(instance) {\n            var fiber = instance._current;\n            if (fiber === null) {\n                throw new Error('Calling Offscreen.detach before instance handle has been set.');\n            }\n            if ((instance._pendingVisibility & OffscreenDetached) !== NoFlags$1) {\n                // The instance is already detached, this is a noop.\n                return;\n            } // TODO: There is an opportunity to optimise this by not entering commit phase\n            // and unmounting effects directly.\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                instance._pendingVisibility |= OffscreenDetached;\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function attachOffscreenInstance(instance) {\n            var fiber = instance._current;\n            if (fiber === null) {\n                throw new Error('Calling Offscreen.detach before instance handle has been set.');\n            }\n            if ((instance._pendingVisibility & OffscreenDetached) === NoFlags$1) {\n                // The instance is already attached, this is a noop.\n                return;\n            }\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                instance._pendingVisibility &= ~OffscreenDetached;\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function attachSuspenseRetryListeners(finishedWork, wakeables) {\n            // If this boundary just timed out, then it will have a set of wakeables.\n            // For each wakeable, attach a listener so that when it resolves, React\n            // attempts to re-render the boundary in the primary (pre-timeout) state.\n            var retryCache = getRetryCache(finishedWork);\n            wakeables.forEach(function(wakeable) {\n                // Memoize using the boundary fiber to prevent redundant listeners.\n                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n                if (!retryCache.has(wakeable)) {\n                    retryCache.add(wakeable);\n                    {\n                        if (isDevToolsPresent) {\n                            if (inProgressLanes !== null && inProgressRoot !== null) {\n                                // If we have pending work still, associate the original updaters with it.\n                                restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                            } else {\n                                throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n                            }\n                        }\n                    }\n                    wakeable.then(retry, retry);\n                }\n            });\n        } // This function detects when a Suspense boundary goes from visible to hidden.\n        function commitMutationEffects(root, finishedWork, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            {\n                runWithFiberInDEV(finishedWork, commitMutationEffectsOnFiber, finishedWork, root, committedLanes);\n            }\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function recursivelyTraverseMutationEffects(root, parentFiber, lanes) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects hae fired.\n            var deletions = parentFiber.deletions;\n            if (deletions !== null) {\n                for(var i = 0; i < deletions.length; i++){\n                    var childToDelete = deletions[i];\n                    try {\n                        commitDeletionEffects(root, parentFiber, childToDelete);\n                    } catch (error) {\n                        captureCommitPhaseError(childToDelete, parentFiber, error);\n                    }\n                }\n            }\n            if (parentFiber.subtreeFlags & MutationMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    {\n                        runWithFiberInDEV(child, commitMutationEffectsOnFiber, child, root, lanes);\n                    }\n                    child = child.sibling;\n                }\n            }\n        }\n        var currentHoistableRoot = null;\n        function commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,\n            // because the fiber tag is more specific. An exception is any flag related\n            // to reconciliation, because those can be set on all fiber types.\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            try {\n                                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                                commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            } // Layout effects are destroyed during the mutation phase so that all\n                            // destroy functions for all fibers are called before any create functions.\n                            // This prevents sibling component effects from interfering with each other,\n                            // e.g. a destroy function in one component should never override a ref set\n                            // by a create function in another component during the same commit.\n                            if (shouldProfile(finishedWork)) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                                recordLayoutEffectDuration(finishedWork);\n                            } else {\n                                try {\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        if (flags & Callback && offscreenSubtreeIsHidden) {\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                deferHiddenCallbacks(updateQueue);\n                            }\n                        }\n                        return;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            // We cast because we always set the root at the React root and so it cannot be\n                            // null while we are processing mutation effects\n                            var hoistableRoot = currentHoistableRoot;\n                            recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                            commitReconciliationEffects(finishedWork);\n                            if (flags & Ref) {\n                                if (current !== null) {\n                                    safelyDetachRef(current, current.return);\n                                }\n                            }\n                            if (flags & Update) {\n                                var currentResource = current !== null ? current.memoizedState : null;\n                                var newResource = finishedWork.memoizedState;\n                                if (current === null) {\n                                    // We are mounting a new HostHoistable Fiber. We fork the mount\n                                    // behavior based on whether this instance is a Hoistable Instance\n                                    // or a Hoistable Resource\n                                    if (newResource === null) {\n                                        if (finishedWork.stateNode === null) {\n                                            finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork);\n                                        } else {\n                                            mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);\n                                        }\n                                    } else {\n                                        finishedWork.stateNode = acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps);\n                                    }\n                                } else if (currentResource !== newResource) {\n                                    // We are moving to or from Hoistable Resource, or between different Hoistable Resources\n                                    if (currentResource === null) {\n                                        if (current.stateNode !== null) {\n                                            unmountHoistable(current.stateNode);\n                                        }\n                                    } else {\n                                        releaseResource(currentResource);\n                                    }\n                                    if (newResource === null) {\n                                        mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);\n                                    } else {\n                                        acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps);\n                                    }\n                                } else if (newResource === null && finishedWork.stateNode !== null) {\n                                    try {\n                                        commitUpdate(finishedWork.stateNode, finishedWork.type, current.memoizedProps, finishedWork.memoizedProps, finishedWork);\n                                    } catch (error) {\n                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                    }\n                                }\n                            }\n                            return;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            if (flags & Update) {\n                                var previousWork = finishedWork.alternate;\n                                if (previousWork === null) {\n                                    var singleton = finishedWork.stateNode;\n                                    var props = finishedWork.memoizedProps; // This was a new mount, we need to clear and set initial properties\n                                    clearSingleton(singleton);\n                                    acquireSingletonInstance(finishedWork.type, props, singleton, finishedWork);\n                                }\n                            }\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        if (supportsMutation) {\n                            // TODO: ContentReset gets cleared by the children during the commit\n                            // phase. This is a refactor hazard because it means we must read\n                            // flags the flags after `commitReconciliationEffects` has already run;\n                            // the order matters. We should refactor so that ContentReset does not\n                            // rely on mutating the flag during commit. Like by setting a flag\n                            // during the render phase instead.\n                            if (finishedWork.flags & ContentReset) {\n                                var instance = finishedWork.stateNode;\n                                try {\n                                    resetTextContent(instance);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                            if (flags & Update) {\n                                var _instance2 = finishedWork.stateNode;\n                                if (_instance2 != null) {\n                                    // Commit the work prepared earlier.\n                                    var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                                    // as the newProps. The updatePayload will contain the real change in\n                                    // this case.\n                                    var oldProps = current !== null ? current.memoizedProps : newProps;\n                                    var type = finishedWork.type;\n                                    try {\n                                        commitUpdate(_instance2, type, oldProps, newProps, finishedWork);\n                                    } catch (error) {\n                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                    }\n                                }\n                            }\n                            if (flags & FormReset) {\n                                needsFormReset = true;\n                                {\n                                    if (finishedWork.type !== 'form') {\n                                        // Paranoid coding. In case we accidentally start using the\n                                        // FormReset bit for something else.\n                                        error('Unexpected host component type. Expected a form. This is a ' + 'bug in React.');\n                                    }\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostText:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            if (supportsMutation) {\n                                if (finishedWork.stateNode === null) {\n                                    throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                }\n                                var textInstance = finishedWork.stateNode;\n                                var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                                // as the newProps. The updatePayload will contain the real change in\n                                // this case.\n                                var oldText = current !== null ? current.memoizedProps : newText;\n                                try {\n                                    commitTextUpdate(textInstance, oldText, newText);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostRoot:\n                    {\n                        if (supportsResources) {\n                            prepareToCommitHoistables();\n                            var previousHoistableRoot = currentHoistableRoot;\n                            currentHoistableRoot = getHoistableRoot(root.containerInfo);\n                            recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                            currentHoistableRoot = previousHoistableRoot;\n                            commitReconciliationEffects(finishedWork);\n                        } else {\n                            recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                            commitReconciliationEffects(finishedWork);\n                        }\n                        if (flags & Update) {\n                            if (supportsMutation && supportsHydration) {\n                                if (current !== null) {\n                                    var prevRootState = current.memoizedState;\n                                    if (prevRootState.isDehydrated) {\n                                        try {\n                                            commitHydratedContainer(root.containerInfo);\n                                        } catch (error) {\n                                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                        }\n                                    }\n                                }\n                            }\n                            if (supportsPersistence) {\n                                var containerInfo = root.containerInfo;\n                                var pendingChildren = root.pendingChildren;\n                                try {\n                                    replaceContainerChildren(containerInfo, pendingChildren);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        if (needsFormReset) {\n                            // A form component requested to be reset during this commit. We do this\n                            // after all mutations in the rest of the tree so that `defaultValue`\n                            // will already be updated. This way you can update `defaultValue` using\n                            // data sent by the server as a result of the form submission.\n                            //\n                            // Theoretically we could check finishedWork.subtreeFlags & FormReset,\n                            // but the FormReset bit is overloaded with other flags used by other\n                            // fiber types. So this extra variable lets us skip traversing the tree\n                            // except when a form was actually submitted.\n                            needsFormReset = false;\n                            recursivelyResetForms(finishedWork);\n                        }\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        if (supportsResources) {\n                            var _previousHoistableRoot = currentHoistableRoot;\n                            currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);\n                            recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                            commitReconciliationEffects(finishedWork);\n                            currentHoistableRoot = _previousHoistableRoot;\n                        } else {\n                            recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                            commitReconciliationEffects(finishedWork);\n                        }\n                        if (flags & Update) {\n                            if (supportsPersistence) {\n                                var portal = finishedWork.stateNode;\n                                var _containerInfo = portal.containerInfo;\n                                var _pendingChildren = portal.pendingChildren;\n                                try {\n                                    replaceContainerChildren(_containerInfo, _pendingChildren);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                        commitReconciliationEffects(finishedWork); // TODO: We should mark a flag on the Suspense fiber itself, rather than\n                        // relying on the Offscreen fiber having a flag also being marked. The\n                        // reason is that this offscreen fiber might not be part of the work-in-\n                        // progress tree! It could have been reused from a previous render. This\n                        // doesn't lead to incorrect behavior because we don't rely on the flag\n                        // check alone; we also compare the states explicitly below. But for\n                        // modeling purposes, we _should_ be able to rely on the flag check alone.\n                        // So this is a bit fragile.\n                        //\n                        // Also, all this logic could/should move to the passive phase so it\n                        // doesn't block paint.\n                        var offscreenFiber = finishedWork.child;\n                        if (offscreenFiber.flags & Visibility) {\n                            // Throttle the appearance and disappearance of Suspense fallbacks.\n                            var isShowingFallback = finishedWork.memoizedState !== null;\n                            var wasShowingFallback = current !== null && current.memoizedState !== null;\n                            {\n                                if (isShowingFallback !== wasShowingFallback) {\n                                    // A fallback is either appearing or disappearing.\n                                    markCommitTimeOfFallback();\n                                }\n                            }\n                        }\n                        if (flags & Update) {\n                            try {\n                                commitSuspenseCallback(finishedWork);\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                            var retryQueue = finishedWork.updateQueue;\n                            if (retryQueue !== null) {\n                                finishedWork.updateQueue = null;\n                                attachSuspenseRetryListeners(finishedWork, retryQueue);\n                            }\n                        }\n                        return;\n                    }\n                case OffscreenComponent:\n                    {\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        var newState = finishedWork.memoizedState;\n                        var isHidden = newState !== null;\n                        var wasHidden = current !== null && current.memoizedState !== null;\n                        {\n                            // Before committing the children, track on the stack whether this\n                            // offscreen subtree was already hidden, so that we don't unmount the\n                            // effects again.\n                            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                            recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                        }\n                        commitReconciliationEffects(finishedWork);\n                        var offscreenInstance = finishedWork.stateNode; // TODO: Add explicit effect flag to set _current.\n                        offscreenInstance._current = finishedWork; // Offscreen stores pending changes to visibility in `_pendingVisibility`. This is\n                        // to support batching of `attach` and `detach` calls.\n                        offscreenInstance._visibility &= ~OffscreenDetached;\n                        offscreenInstance._visibility |= offscreenInstance._pendingVisibility & OffscreenDetached;\n                        if (flags & Visibility) {\n                            // Track the current state on the Offscreen instance so we can\n                            // read it during an event\n                            if (isHidden) {\n                                offscreenInstance._visibility &= ~OffscreenVisible;\n                            } else {\n                                offscreenInstance._visibility |= OffscreenVisible;\n                            }\n                            if (isHidden) {\n                                var isUpdate = current !== null;\n                                var wasHiddenByAncestorOffscreen = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden; // Only trigger disapper layout effects if:\n                                //   - This is an update, not first mount.\n                                //   - This Offscreen was not hidden before.\n                                //   - Ancestor Offscreen was not hidden in previous commit.\n                                if (isUpdate && !wasHidden && !wasHiddenByAncestorOffscreen) {\n                                    {\n                                        // Disappear the layout effects of all the children\n                                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                                    }\n                                }\n                            } // Offscreen with manual mode manages visibility manually.\n                            if (supportsMutation && !isOffscreenManual(finishedWork)) {\n                                // TODO: This needs to run whenever there's an insertion or update\n                                // inside a hidden Offscreen tree.\n                                hideOrUnhideAllChildren(finishedWork, isHidden);\n                            }\n                        } // TODO: Move to passive phase\n                        if (flags & Update) {\n                            var offscreenQueue = finishedWork.updateQueue;\n                            if (offscreenQueue !== null) {\n                                var _retryQueue = offscreenQueue.retryQueue;\n                                if (_retryQueue !== null) {\n                                    offscreenQueue.retryQueue = null;\n                                    attachSuspenseRetryListeners(finishedWork, _retryQueue);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case SuspenseListComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            var _retryQueue2 = finishedWork.updateQueue;\n                            if (_retryQueue2 !== null) {\n                                finishedWork.updateQueue = null;\n                                attachSuspenseRetryListeners(finishedWork, _retryQueue2);\n                            }\n                        }\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        return;\n                    }\n                default:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n                        commitReconciliationEffects(finishedWork);\n                        return;\n                    }\n            }\n        }\n        function commitReconciliationEffects(finishedWork) {\n            // Placement effects (insertions, reorders) can be scheduled on any fiber\n            // type. They needs to happen after the children effects have fired, but\n            // before the effects on this fiber have fired.\n            var flags = finishedWork.flags;\n            if (flags & Placement) {\n                try {\n                    commitPlacement(finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                } // Clear the \"placement\" from effect tag so that we know that this is\n                // inserted, before any life-cycles like componentDidMount gets called.\n                // TODO: findDOMNode doesn't rely on this any more but isMounted does\n                // and isMounted is deprecated anyway so we should be able to kill this.\n                finishedWork.flags &= ~Placement;\n            }\n            if (flags & Hydrating) {\n                finishedWork.flags &= ~Hydrating;\n            }\n        }\n        function recursivelyResetForms(parentFiber) {\n            if (parentFiber.subtreeFlags & FormReset) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    resetFormOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n        }\n        function resetFormOnFiber(fiber) {\n            recursivelyResetForms(fiber);\n            if (fiber.tag === HostComponent && fiber.flags & FormReset) {\n                var formInstance = fiber.stateNode;\n                resetFormInstance(formInstance);\n            }\n        }\n        function commitLayoutEffects(finishedWork, root, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            var current = finishedWork.alternate;\n            {\n                runWithFiberInDEV(finishedWork, commitLayoutEffectOnFiber, root, current, finishedWork, committedLanes);\n            }\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function recursivelyTraverseLayoutEffects(root, parentFiber, lanes) {\n            if (parentFiber.subtreeFlags & LayoutMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    var current = child.alternate;\n                    {\n                        runWithFiberInDEV(child, commitLayoutEffectOnFiber, root, current, child, lanes);\n                    }\n                    child = child.sibling;\n                }\n            }\n        }\n        function disappearLayoutEffects(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & LayoutStatic\n                        if (shouldProfile(finishedWork)) {\n                            try {\n                                startLayoutEffectTimer();\n                                commitHookEffectListUnmount(Layout, finishedWork, finishedWork.return);\n                            } finally{\n                                recordLayoutEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListUnmount(Layout, finishedWork, finishedWork.return);\n                        }\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        var instance = finishedWork.stateNode;\n                        if (typeof instance.componentWillUnmount === 'function') {\n                            safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                        }\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        var isHidden = finishedWork.memoizedState !== null;\n                        if (isHidden) ;\n                        else {\n                            recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n            // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var child = parentFiber.child;\n            while(child !== null){\n                disappearLayoutEffects(child);\n                child = child.sibling;\n            }\n        }\n        function reappearLayoutEffects(finishedRoot, current, finishedWork, // from a previously committed tree. We cannot check non-static flags if the\n        // node was reused.\n        includeWorkInProgressEffects) {\n            // Turn on layout effects in a tree that previously disappeared.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check flags & LayoutStatic\n                        commitHookLayoutEffects(finishedWork, Layout);\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check for LayoutStatic flag\n                        var instance = finishedWork.stateNode;\n                        if (typeof instance.componentDidMount === 'function') {\n                            try {\n                                instance.componentDidMount();\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        } // Commit any callbacks that would have fired while the component\n                        // was hidden.\n                        var updateQueue = finishedWork.updateQueue;\n                        if (updateQueue !== null) {\n                            commitHiddenCallbacks(updateQueue, instance);\n                        } // If this is newly finished work, check for setState callbacks\n                        if (includeWorkInProgressEffects && flags & Callback) {\n                            commitClassCallbacks(finishedWork);\n                        } // TODO: Check flags & RefStatic\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                // Unlike commitLayoutEffectsOnFiber, we don't need to handle HostRoot\n                // because this function only visits nodes that are inside an\n                // Offscreen fiber.\n                // case HostRoot: {\n                //  ...\n                // }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // Renderers may schedule work to be done after host components are mounted\n                        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                        // These effects should only be committed when components are first mounted,\n                        // aka when there is no current/alternate.\n                        if (includeWorkInProgressEffects && current === null && flags & Update) {\n                            commitHostComponentMount(finishedWork);\n                        } // TODO: Check flags & Ref\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Profiler updates should work with Offscreen\n                        if (includeWorkInProgressEffects && flags & Update) {\n                            commitProfilerUpdate(finishedWork, current);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Suspense hydration callbacks should work\n                        // with Offscreen.\n                        if (includeWorkInProgressEffects && flags & Update) {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var offscreenState = finishedWork.memoizedState;\n                        var isHidden = offscreenState !== null;\n                        if (isHidden) ;\n                        else {\n                            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                        } // TODO: Check flags & Ref\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n            // This function visits both newly finished work and nodes that were re-used\n            // from a previously committed tree. We cannot check non-static flags if the\n            // node was reused.\n            var childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & LayoutMask) !== NoFlags$1; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var child = parentFiber.child;\n            while(child !== null){\n                var current = child.alternate;\n                {\n                    runWithFiberInDEV(child, reappearLayoutEffects, finishedRoot, current, child, childShouldIncludeWorkInProgressEffects);\n                }\n                child = child.sibling;\n            }\n        }\n        function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n            if (shouldProfile(finishedWork)) {\n                startPassiveEffectTimer();\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n                recordPassiveEffectDuration(finishedWork);\n            } else {\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitOffscreenPassiveMountEffects(current, finishedWork, instance) {\n            {\n                var previousCache = null;\n                if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                    previousCache = current.memoizedState.cachePool.pool;\n                }\n                var nextCache = null;\n                if (finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null) {\n                    nextCache = finishedWork.memoizedState.cachePool.pool;\n                } // Retain/release the cache used for pending (suspended) nodes.\n                // Note that this is only reached in the non-suspended/visible case:\n                // when the content is suspended/hidden, the retain/release occurs\n                // via the parent Suspense component (see case above).\n                if (nextCache !== previousCache) {\n                    if (nextCache != null) {\n                        retainCache(nextCache);\n                    }\n                    if (previousCache != null) {\n                        releaseCache(previousCache);\n                    }\n                }\n            }\n        }\n        function commitCachePassiveMountEffect(current, finishedWork) {\n            {\n                var previousCache = null;\n                if (finishedWork.alternate !== null) {\n                    previousCache = finishedWork.alternate.memoizedState.cache;\n                }\n                var nextCache = finishedWork.memoizedState.cache; // Retain/release the cache. In theory the cache component\n                // could be \"borrowing\" a cache instance owned by some parent,\n                // in which case we could avoid retaining/releasing. But it\n                // is non-trivial to determine when that is the case, so we\n                // always retain/release.\n                if (nextCache !== previousCache) {\n                    retainCache(nextCache);\n                    if (previousCache != null) {\n                        releaseCache(previousCache);\n                    }\n                }\n            }\n        }\n        function commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {\n            {\n                runWithFiberInDEV(finishedWork, commitPassiveMountOnFiber, root, finishedWork, committedLanes, committedTransitions);\n            }\n        }\n        function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    {\n                        runWithFiberInDEV(child, commitPassiveMountOnFiber, root, child, committedLanes, committedTransitions);\n                    }\n                    child = child.sibling;\n                }\n            }\n        }\n        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n            // When updating this function, also update reconnectPassiveEffects, which does\n            // most of the same things when an offscreen tree goes from hidden -> visible,\n            // or when toggling effects inside a hidden tree.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            {\n                                var previousCache = null;\n                                if (finishedWork.alternate !== null) {\n                                    previousCache = finishedWork.alternate.memoizedState.cache;\n                                }\n                                var nextCache = finishedWork.memoizedState.cache; // Retain/release the root cache.\n                                // Note that on initial mount, previousCache and nextCache will be the same\n                                // and this retain won't occur. To counter this, we instead retain the HostRoot's\n                                // initial cache when creating the root itself (see createFiberRoot() in\n                                // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\n                                // here, such that previous/next caches are retained correctly.\n                                if (nextCache !== previousCache) {\n                                    retainCache(nextCache);\n                                    if (previousCache != null) {\n                                        releaseCache(previousCache);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        // TODO: Pass `current` as argument to this function\n                        var _instance3 = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden) {\n                            if (_instance3._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                            } else {\n                                {\n                                    // The effects are currently disconnected. Since the tree is hidden,\n                                    // don't connect them. This also applies to the initial render.\n                                    {\n                                        // \"Atomic\" effects are ones that need to fire on every commit,\n                                        // even during pre-rendering. An example is updating the reference\n                                        // count on cache instances.\n                                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Tree is visible\n                            if (_instance3._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                            } else {\n                                // The effects are currently disconnected. Reconnect them, while also\n                                // firing effects inside newly mounted trees. This also applies to\n                                // the initial render.\n                                _instance3._visibility |= OffscreenPassiveEffectsConnected;\n                                var includeWorkInProgressEffects = (finishedWork.subtreeFlags & PassiveMask) !== NoFlags$1;\n                                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                            }\n                        }\n                        if (flags & Passive$1) {\n                            var _current = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(_current, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current2 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current2, finishedWork);\n                        }\n                        break;\n                    }\n                case TracingMarkerComponent:\n                default:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n            // This function visits both newly finished work and nodes that were re-used\n            // from a previously committed tree. We cannot check non-static flags if the\n            // node was reused.\n            var childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & PassiveMask) !== NoFlags$1; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var child = parentFiber.child;\n            while(child !== null){\n                {\n                    runWithFiberInDEV(child, reconnectPassiveEffects, finishedRoot, child, committedLanes, committedTransitions, childShouldIncludeWorkInProgressEffects);\n                }\n                child = child.sibling;\n            }\n        }\n        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, // from a previously committed tree. We cannot check non-static flags if the\n        // node was reused.\n        includeWorkInProgressEffects) {\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects); // TODO: Check for PassiveStatic flag\n                        commitHookPassiveMountEffects(finishedWork, Passive);\n                        break;\n                    }\n                // Unlike commitPassiveMountOnFiber, we don't need to handle HostRoot\n                // because this function only visits nodes that are inside an\n                // Offscreen fiber.\n                // case HostRoot: {\n                //  ...\n                // }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var _instance4 = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden) {\n                            if (_instance4._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                            } else {\n                                {\n                                    // The effects are currently disconnected. Since the tree is hidden,\n                                    // don't connect them. This also applies to the initial render.\n                                    {\n                                        // \"Atomic\" effects are ones that need to fire on every commit,\n                                        // even during pre-rendering. An example is updating the reference\n                                        // count on cache instances.\n                                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Tree is visible\n                            // Since we're already inside a reconnecting tree, it doesn't matter\n                            // whether the effects are currently connected. In either case, we'll\n                            // continue traversing the tree and firing all the effects.\n                            //\n                            // We do need to set the \"connected\" flag on the instance, though.\n                            _instance4._visibility |= OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        }\n                        if (includeWorkInProgressEffects && flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current3 = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(_current3, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        if (includeWorkInProgressEffects && flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current4 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current4, finishedWork);\n                        }\n                        break;\n                    }\n                case TracingMarkerComponent:\n                default:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseAtomicPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions) {\n            // \"Atomic\" effects are ones that need to fire on every commit, even during\n            // pre-rendering. We call this function when traversing a hidden tree whose\n            // regular effects are currently disconnected.\n            // TODO: Add special flag for atomic effects\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    {\n                        runWithFiberInDEV(child, commitAtomicPassiveEffects, finishedRoot, child, committedLanes, committedTransitions);\n                    }\n                    child = child.sibling;\n                }\n            }\n        }\n        function commitAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n            // \"Atomic\" effects are ones that need to fire on every commit, even during\n            // pre-rendering. We call this function when traversing a hidden tree whose\n            // regular effects are currently disconnected.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case OffscreenComponent:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var current = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(current, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current5 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current5, finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffects(finishedWork) {\n            {\n                runWithFiberInDEV(finishedWork, commitPassiveUnmountOnFiber, finishedWork);\n            }\n        } // If we're inside a brand new tree, or a tree that was already visible, then we\n        // should only suspend host components that have a ShouldSuspendCommit flag.\n        // Components without it haven't changed since the last commit, so we can skip\n        // over those.\n        //\n        // When we enter a tree that is being revealed (going from hidden -> visible),\n        // we need to suspend _any_ component that _may_ suspend. Even if they're\n        // already in the \"current\" tree. Because their visibility has changed, the\n        // browser may not have prerendered them yet. So we check the MaySuspendCommit\n        // flag instead.\n        var suspenseyCommitFlag = ShouldSuspendCommit;\n        function accumulateSuspenseyCommit(finishedWork) {\n            accumulateSuspenseyCommitOnFiber(finishedWork);\n        }\n        function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n            if (parentFiber.subtreeFlags & suspenseyCommitFlag) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    accumulateSuspenseyCommitOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n        }\n        function accumulateSuspenseyCommitOnFiber(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                        if (fiber.flags & suspenseyCommitFlag) {\n                            if (fiber.memoizedState !== null) {\n                                suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);\n                            } else {\n                                var type = fiber.type;\n                                var props = fiber.memoizedProps;\n                                suspendInstance(type, props);\n                            }\n                        }\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                        if (fiber.flags & suspenseyCommitFlag) {\n                            var _type = fiber.type;\n                            var _props = fiber.memoizedProps;\n                            suspendInstance(_type, _props);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        if (supportsResources) {\n                            var previousHoistableRoot = currentHoistableRoot;\n                            var container = fiber.stateNode.containerInfo;\n                            currentHoistableRoot = getHoistableRoot(container);\n                            recursivelyAccumulateSuspenseyCommit(fiber);\n                            currentHoistableRoot = previousHoistableRoot;\n                        } else {\n                            recursivelyAccumulateSuspenseyCommit(fiber);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var isHidden = fiber.memoizedState !== null;\n                        if (isHidden) ;\n                        else {\n                            var current = fiber.alternate;\n                            var wasHidden = current !== null && current.memoizedState !== null;\n                            if (wasHidden) {\n                                // This tree is being revealed. Visit all newly visible suspensey\n                                // instances, even if they're in the current tree.\n                                var prevFlags = suspenseyCommitFlag;\n                                suspenseyCommitFlag = MaySuspendCommit;\n                                recursivelyAccumulateSuspenseyCommit(fiber);\n                                suspenseyCommitFlag = prevFlags;\n                            } else {\n                                recursivelyAccumulateSuspenseyCommit(fiber);\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                    }\n            }\n        }\n        function detachAlternateSiblings(parentFiber) {\n            // A fiber was deleted from this parent fiber, but it's still part of the\n            // previous (alternate) parent fiber's list of children. Because children\n            // are a linked list, an earlier sibling that's still alive will be\n            // connected to the deleted fiber via its `alternate`:\n            //\n            //   live fiber --alternate--> previous live fiber --sibling--> deleted\n            //   fiber\n            //\n            // We can't disconnect `alternate` on nodes that haven't been deleted yet,\n            // but we can disconnect the `sibling` and `child` pointers.\n            var previousFiber = parentFiber.alternate;\n            if (previousFiber !== null) {\n                var detachedChild = previousFiber.child;\n                if (detachedChild !== null) {\n                    previousFiber.child = null;\n                    do {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var detachedSibling = detachedChild.sibling; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        detachedChild.sibling = null;\n                        detachedChild = detachedSibling;\n                    }while (detachedChild !== null);\n                }\n            }\n        }\n        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n            if (shouldProfile(finishedWork)) {\n                startPassiveEffectTimer();\n                commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n                recordPassiveEffectDuration(finishedWork);\n            } else {\n                commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n            }\n        }\n        function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects have fired.\n            var deletions = parentFiber.deletions;\n            if ((parentFiber.flags & ChildDeletion) !== NoFlags$1) {\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i]; // TODO: Convert this to use recursion\n                        nextEffect = childToDelete;\n                        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                    }\n                }\n                detachAlternateSiblings(parentFiber);\n            } // TODO: Split PassiveMask into separate masks for mount and unmount?\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    {\n                        runWithFiberInDEV(child, commitPassiveUnmountOnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n            }\n        }\n        function commitPassiveUnmountOnFiber(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        if (finishedWork.flags & Passive$1) {\n                            commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden && instance._visibility & OffscreenPassiveEffectsConnected && // the future we may change this to unmount after a delay.\n                        (finishedWork.return === null || finishedWork.return.tag !== SuspenseComponent)) {\n                            // The effects are currently connected. Disconnect them.\n                            // TODO: Add option or heuristic to delay before disconnecting the\n                            // effects. Then if the tree reappears before the delay has elapsed, we\n                            // can skip toggling the effects entirely.\n                            instance._visibility &= ~OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        } else {\n                            recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects have fired.\n            var deletions = parentFiber.deletions;\n            if ((parentFiber.flags & ChildDeletion) !== NoFlags$1) {\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i]; // TODO: Convert this to use recursion\n                        nextEffect = childToDelete;\n                        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                    }\n                }\n                detachAlternateSiblings(parentFiber);\n            } // TODO: Check PassiveStatic flag\n            var child = parentFiber.child;\n            while(child !== null){\n                {\n                    runWithFiberInDEV(child, disconnectPassiveEffect, child);\n                }\n                child = child.sibling;\n            }\n        }\n        function disconnectPassiveEffect(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        // TODO: Check PassiveStatic flag\n                        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive); // When disconnecting passive effects, we fire the effects in the same\n                        // order as during a deletiong: parent before child\n                        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        if (instance._visibility & OffscreenPassiveEffectsConnected) {\n                            instance._visibility &= ~OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // Deletion effects fire in parent -> child order\n                // TODO: Check if fiber has a PassiveStatic flag\n                {\n                    runWithFiberInDEV(fiber, commitPassiveUnmountInsideDeletedTreeOnFiber, fiber, nearestMountedAncestor);\n                }\n                var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag.\n                if (child !== null) {\n                    child.return = fiber;\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n                }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var sibling = fiber.sibling;\n                var returnFiber = fiber.return; // Recursively traverse the entire deleted tree and clean up fiber fields.\n                // This is more aggressive than ideal, and the long term goal is to only\n                // have to detach the deleted tree at the root.\n                detachFiberAfterEffects(fiber);\n                if (fiber === deletedSubtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                if (sibling !== null) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n        function commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                        break;\n                    }\n                // TODO: run passive unmount effects when unmounting a root.\n                // Because passive unmount effects are not currently run,\n                // the cache instance owned by the root will never be freed.\n                // When effects are run, the cache should be freed here:\n                // case HostRoot: {\n                //   if (enableCache) {\n                //     const cache = current.memoizedState.cache;\n                //     releaseCache(cache);\n                //   }\n                //   break;\n                // }\n                case LegacyHiddenComponent:\n                case OffscreenComponent:\n                    {\n                        {\n                            if (current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                                var cache = current.memoizedState.cachePool.pool; // Retain/release the cache used for pending (suspended) nodes.\n                                // Note that this is only reached in the non-suspended/visible case:\n                                // when the content is suspended/hidden, the retain/release occurs\n                                // via the parent Suspense component (see case above).\n                                if (cache != null) {\n                                    retainCache(cache);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _cache = current.memoizedState.cache;\n                            releaseCache(_cache);\n                        }\n                        break;\n                    }\n            }\n        }\n        function getCacheForType(resourceType) {\n            var cache = readContext(CacheContext);\n            var cacheForType = cache.data.get(resourceType);\n            if (cacheForType === undefined) {\n                cacheForType = resourceType();\n                cache.data.set(resourceType, cacheForType);\n            }\n            return cacheForType;\n        }\n        var DefaultAsyncDispatcher = {\n            getCacheForType: getCacheForType\n        };\n        {\n            DefaultAsyncDispatcher.getOwner = function() {\n                return current;\n            };\n        }\n        var COMPONENT_TYPE = 0;\n        var HAS_PSEUDO_CLASS_TYPE = 1;\n        var ROLE_TYPE = 2;\n        var TEST_NAME_TYPE = 3;\n        var TEXT_TYPE = 4;\n        if (typeof Symbol === 'function' && Symbol.for) {\n            var symbolFor = Symbol.for;\n            COMPONENT_TYPE = symbolFor('selector.component');\n            HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n            ROLE_TYPE = symbolFor('selector.role');\n            TEST_NAME_TYPE = symbolFor('selector.test_id');\n            TEXT_TYPE = symbolFor('selector.text');\n        }\n        function createComponentSelector(component) {\n            return {\n                $$typeof: COMPONENT_TYPE,\n                value: component\n            };\n        }\n        function createHasPseudoClassSelector(selectors) {\n            return {\n                $$typeof: HAS_PSEUDO_CLASS_TYPE,\n                value: selectors\n            };\n        }\n        function createRoleSelector(role) {\n            return {\n                $$typeof: ROLE_TYPE,\n                value: role\n            };\n        }\n        function createTextSelector(text) {\n            return {\n                $$typeof: TEXT_TYPE,\n                value: text\n            };\n        }\n        function createTestNameSelector(id) {\n            return {\n                $$typeof: TEST_NAME_TYPE,\n                value: id\n            };\n        }\n        function findFiberRootForHostRoot(hostRoot) {\n            var maybeFiber = getInstanceFromNode(hostRoot);\n            if (maybeFiber != null) {\n                if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n                    throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n                }\n                return maybeFiber;\n            } else {\n                var fiberRoot = findFiberRoot(hostRoot);\n                if (fiberRoot === null) {\n                    throw new Error('Could not find React container within specified host subtree.');\n                } // The Flow type for FiberRoot is a little funky.\n                // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n                return fiberRoot.stateNode.current;\n            }\n        }\n        function matchSelector(fiber, selector) {\n            var tag = fiber.tag;\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    if (fiber.type === selector.value) {\n                        return true;\n                    }\n                    break;\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return hasMatchingPaths(fiber, selector.value);\n                case ROLE_TYPE:\n                    if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                        var node = fiber.stateNode;\n                        if (matchAccessibilityRole(node, selector.value)) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEXT_TYPE:\n                    if (tag === HostComponent || tag === HostText || tag === HostHoistable || tag === HostSingleton) {\n                        var textContent = getTextContent(fiber);\n                        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEST_NAME_TYPE:\n                    if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                        var dataTestID = fiber.memoizedProps['data-testname'];\n                        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n                            return true;\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error('Invalid selector type specified.');\n            }\n            return false;\n        }\n        function selectorToString(selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    var displayName = getComponentNameFromType(selector.value) || 'Unknown';\n                    return \"<\" + displayName + \">\";\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return \":has(\" + (selectorToString(selector) || '') + \")\";\n                case ROLE_TYPE:\n                    return \"[role=\\\"\" + selector.value + \"\\\"]\";\n                case TEXT_TYPE:\n                    return \"\\\"\" + selector.value + \"\\\"\";\n                case TEST_NAME_TYPE:\n                    return \"[data-testname=\\\"\" + selector.value + \"\\\"]\";\n                default:\n                    throw new Error('Invalid selector type specified.');\n            }\n        }\n        function findPaths(root, selectors) {\n            var matchingFibers = [];\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    matchingFibers.push(fiber);\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return matchingFibers;\n        } // Same as findPaths but with eager bailout on first match\n        function hasMatchingPaths(root, selectors) {\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    return true;\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return false;\n        }\n        function findAllNodes(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var instanceRoots = [];\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var node = stack[index++];\n                var tag = node.tag;\n                if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                    if (isHiddenSubtree(node)) {\n                        continue;\n                    }\n                    instanceRoots.push(node.stateNode);\n                } else {\n                    var child = node.child;\n                    while(child !== null){\n                        stack.push(child);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return instanceRoots;\n        }\n        function getFindAllNodesFailureDescription(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var maxSelectorIndex = 0;\n            var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else if (matchSelector(fiber, selector)) {\n                    matchedNames.push(selectorToString(selector));\n                    selectorIndex++;\n                    if (selectorIndex > maxSelectorIndex) {\n                        maxSelectorIndex = selectorIndex;\n                    }\n                }\n                if (selectorIndex < selectors.length) {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            if (maxSelectorIndex < selectors.length) {\n                var unmatchedNames = [];\n                for(var i = maxSelectorIndex; i < selectors.length; i++){\n                    unmatchedNames.push(selectorToString(selectors[i]));\n                }\n                return 'findAllNodes was able to match part of the selector:\\n' + (\"  \" + matchedNames.join(' > ') + \"\\n\\n\") + 'No matching component was found for:\\n' + (\"  \" + unmatchedNames.join(' > '));\n            }\n            return null;\n        }\n        function findBoundingRects(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var boundingRects = [];\n            for(var i = 0; i < instanceRoots.length; i++){\n                boundingRects.push(getBoundingRect(instanceRoots[i]));\n            }\n            for(var _i = boundingRects.length - 1; _i > 0; _i--){\n                var targetRect = boundingRects[_i];\n                var targetLeft = targetRect.x;\n                var targetRight = targetLeft + targetRect.width;\n                var targetTop = targetRect.y;\n                var targetBottom = targetTop + targetRect.height;\n                for(var j = _i - 1; j >= 0; j--){\n                    if (_i !== j) {\n                        var otherRect = boundingRects[j];\n                        var otherLeft = otherRect.x;\n                        var otherRight = otherLeft + otherRect.width;\n                        var otherTop = otherRect.y;\n                        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n                        // but we can handle the most common cases:\n                        // 1. completely overlapping rects\n                        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n                        //\n                        // Even given the above constraints,\n                        // we still won't end up with the fewest possible rects without doing multiple passes,\n                        // but it's good enough for this purpose.\n                        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                            // Complete overlapping rects; remove the inner one.\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n                            // Adjacent vertical rects; merge them.\n                            if (otherTop > targetTop) {\n                                otherRect.height += otherTop - targetTop;\n                                otherRect.y = targetTop;\n                            }\n                            if (otherBottom < targetBottom) {\n                                otherRect.height = targetBottom - otherTop;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n                            // Adjacent horizontal rects; merge them.\n                            if (otherLeft > targetLeft) {\n                                otherRect.width += otherLeft - targetLeft;\n                                otherRect.x = targetLeft;\n                            }\n                            if (otherRight < targetRight) {\n                                otherRect.width = targetRight - otherLeft;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            return boundingRects;\n        }\n        function focusWithin(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                if (isHiddenSubtree(fiber)) {\n                    continue;\n                }\n                if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                    var node = fiber.stateNode;\n                    if (setFocusIfFocusable(node)) {\n                        return true;\n                    }\n                }\n                var child = fiber.child;\n                while(child !== null){\n                    stack.push(child);\n                    child = child.sibling;\n                }\n            }\n            return false;\n        }\n        var commitHooks = [];\n        function onCommitRoot() {\n            if (supportsTestSelectors) {\n                commitHooks.forEach(function(commitHook) {\n                    return commitHook();\n                });\n            }\n        }\n        function observeVisibleRects(hostRoot, selectors, callback, options) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n            var commitHook = function() {\n                var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n                instanceRoots.forEach(function(target) {\n                    if (nextInstanceRoots.indexOf(target) < 0) {\n                        unobserve(target);\n                    }\n                });\n                nextInstanceRoots.forEach(function(target) {\n                    if (instanceRoots.indexOf(target) < 0) {\n                        observe(target);\n                    }\n                });\n            };\n            commitHooks.push(commitHook);\n            return {\n                disconnect: function() {\n                    // Stop listening for React mutations:\n                    var index = commitHooks.indexOf(commitHook);\n                    if (index >= 0) {\n                        commitHooks.splice(index, 1);\n                    } // Disconnect the host observer:\n                    disconnect();\n                }\n            };\n        }\n        function isConcurrentActEnvironment() {\n            {\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;\n                if (!isReactActEnvironmentGlobal && ReactSharedInternals.actQueue !== null) {\n                    // TODO: Include link to relevant documentation page.\n                    error('The current testing environment is not configured to support ' + 'act(...)');\n                }\n                return isReactActEnvironmentGlobal;\n            }\n        }\n        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n        var NoContext = /*             */ 0;\n        var BatchedContext = /*               */ 1;\n        var RenderContext = /*         */ 2;\n        var CommitContext = /*         */ 4;\n        var RootInProgress = 0;\n        var RootFatalErrored = 1;\n        var RootErrored = 2;\n        var RootSuspended = 3;\n        var RootSuspendedWithDelay = 4;\n        var RootCompleted = 5;\n        var RootDidNotComplete = 6; // Describes where we are in the React execution stack\n        var executionContext = NoContext; // The root we're working on\n        var workInProgressRoot = null; // The fiber we're working on\n        var workInProgress = null; // The lanes we're rendering\n        var workInProgressRootRenderLanes = NoLanes;\n        var NotSuspended = 0;\n        var SuspendedOnError = 1;\n        var SuspendedOnData = 2;\n        var SuspendedOnImmediate = 3;\n        var SuspendedOnInstance = 4;\n        var SuspendedOnInstanceAndReadyToContinue = 5;\n        var SuspendedOnDeprecatedThrowPromise = 6;\n        var SuspendedAndReadyToContinue = 7;\n        var SuspendedOnHydration = 8; // When this is true, the work-in-progress fiber just suspended (or errored) and\n        // we've yet to unwind the stack. In some cases, we may yield to the main thread\n        // after this happens. If the fiber is pinged before we resume, we can retry\n        // immediately instead of unwinding the stack.\n        var workInProgressSuspendedReason = NotSuspended;\n        var workInProgressThrownValue = null; // Whether a ping listener was attached during this render. This is slightly\n        // different that whether something suspended, because we don't add multiple\n        // listeners to a promise we've already seen (per root and lane).\n        var workInProgressRootDidAttachPingListener = false; // A contextual version of workInProgressRootRenderLanes. It is a superset of\n        // the lanes that we started working on at the root. When we enter a subtree\n        // that is currently hidden, we add the lanes that would have committed if\n        // the hidden tree hadn't been deferred. This is modified by the\n        // HiddenContext module.\n        //\n        // Most things in the work loop should deal with workInProgressRootRenderLanes.\n        // Most things in begin/complete phases should deal with entangledRenderLanes.\n        var entangledRenderLanes = NoLanes; // Whether to root completed, errored, suspended, etc.\n        var workInProgressRootExitStatus = RootInProgress; // The work left over by components that were visited during this render. Only\n        // includes unprocessed updates, not work in bailed out children.\n        var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n        var workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n        var workInProgressRootPingedLanes = NoLanes; // If this lane scheduled deferred work, this is the lane of the deferred task.\n        var workInProgressDeferredLane = NoLane; // Errors that are thrown during the render phase.\n        var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n        // We will log them once the tree commits.\n        var workInProgressRootRecoverableErrors = null; // Tracks when an update occurs during the render phase.\n        var workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Thacks when an update occurs during the commit phase. It's a separate\n        // variable from the one for renders because the commit phase may run\n        // concurrently to a render phase.\n        var didIncludeCommitPhaseUpdate = false; // The most recent time we either committed a fallback, or when a fallback was\n        // filled in with the resolved UI. This lets us throttle the appearance of new\n        // content as it streams in, to minimize jank.\n        // TODO: Think of a better name for this variable?\n        var globalMostRecentFallbackTime = 0;\n        var FALLBACK_THROTTLE_MS = 300; // The absolute time for when we should start giving up on rendering\n        // more and prefer CPU suspense heuristics instead.\n        var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n        // suspense heuristics and opt out of rendering more content.\n        var RENDER_TIMEOUT_MS = 500;\n        var workInProgressTransitions = null;\n        function resetRenderTimer() {\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n        }\n        function getRenderTargetTime() {\n            return workInProgressRootRenderTargetTime;\n        }\n        var legacyErrorBoundariesThatAlreadyFailed = null;\n        var rootDoesHavePassiveEffects = false;\n        var rootWithPendingPassiveEffects = null;\n        var pendingPassiveEffectsLanes = NoLanes;\n        var pendingPassiveProfilerEffects = [];\n        var pendingPassiveEffectsRemainingLanes = NoLanes;\n        var pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates\n        var NESTED_UPDATE_LIMIT = 50;\n        var nestedUpdateCount = 0;\n        var rootWithNestedUpdates = null;\n        var isFlushingPassiveEffects = false;\n        var didScheduleUpdateDuringPassiveEffects = false;\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n        var nestedPassiveUpdateCount = 0;\n        var rootWithPassiveNestedUpdates = null;\n        var isRunningInsertionEffect = false;\n        function getWorkInProgressRoot() {\n            return workInProgressRoot;\n        }\n        function getWorkInProgressRootRenderLanes() {\n            return workInProgressRootRenderLanes;\n        }\n        function isWorkLoopSuspendedOnData() {\n            return workInProgressSuspendedReason === SuspendedOnData;\n        }\n        function requestUpdateLane(fiber) {\n            if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n                // This is a render phase update. These are not officially supported. The\n                // old behavior is to give this the same \"thread\" (lanes) as\n                // whatever is currently rendering. So if you call `setState` on a component\n                // that happens later in the same render, it will flush. Ideally, we want to\n                // remove the special case and treat them as if they came from an\n                // interleaved event. Regardless, this pattern is not officially supported.\n                // This behavior is only a fallback. The flag only exists until we can roll\n                // out the setState warning, since existing code might accidentally rely on\n                // the current behavior.\n                return pickArbitraryLane(workInProgressRootRenderLanes);\n            }\n            var transition = requestCurrentTransition();\n            if (transition !== null) {\n                {\n                    if (!transition._updatedFibers) {\n                        transition._updatedFibers = new Set();\n                    }\n                    transition._updatedFibers.add(fiber);\n                }\n                var actionScopeLane = peekEntangledActionLane();\n                return actionScopeLane !== NoLane ? actionScopeLane : // is the first update in that scope. Either way, we need to get a\n                // fresh transition lane.\n                requestTransitionLane();\n            }\n            return eventPriorityToLane(resolveUpdatePriority());\n        }\n        function requestRetryLane(fiber) {\n            return claimNextRetryLane();\n        }\n        function requestDeferredLane() {\n            if (workInProgressDeferredLane === NoLane) {\n                // If there are multiple useDeferredValue hooks in the same render, the\n                // tasks that they spawn should all be batched together, so they should all\n                // receive the same lane.\n                // Check the priority of the current render to decide the priority of the\n                // deferred task.\n                // OffscreenLane is used for prerendering, but we also use OffscreenLane\n                // for incremental hydration. It's given the lowest priority because the\n                // initial HTML is the same as the final UI. But useDeferredValue during\n                // hydration is an exception — we need to upgrade the UI to the final\n                // value. So if we're currently hydrating, we treat it like a transition.\n                var isPrerendering = includesSomeLane(workInProgressRootRenderLanes, OffscreenLane) && !getIsHydrating();\n                if (isPrerendering) {\n                    // There's only one OffscreenLane, so if it contains deferred work, we\n                    // should just reschedule using the same lane.\n                    workInProgressDeferredLane = OffscreenLane;\n                } else {\n                    // Everything else is spawned as a transition.\n                    workInProgressDeferredLane = claimNextTransitionLane();\n                }\n            } // Mark the parent Suspense boundary so it knows to spawn the deferred lane.\n            var suspenseHandler = getSuspenseHandler();\n            if (suspenseHandler !== null) {\n                // TODO: As an optimization, we shouldn't entangle the lanes at the root; we\n                // can entangle them using the baseLanes of the Suspense boundary instead.\n                // We only need to do something special if there's no Suspense boundary.\n                suspenseHandler.flags |= DidDefer;\n            }\n            return workInProgressDeferredLane;\n        }\n        function peekDeferredLane() {\n            return workInProgressDeferredLane;\n        }\n        function scheduleUpdateOnFiber(root, fiber, lane) {\n            {\n                if (isRunningInsertionEffect) {\n                    error('useInsertionEffect must not schedule updates.');\n                }\n            }\n            {\n                if (isFlushingPassiveEffects) {\n                    didScheduleUpdateDuringPassiveEffects = true;\n                }\n            }\n            // finish loading.\n            if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || // Suspended commit phase\n            root.cancelPendingCommit !== null) {\n                // The incoming update might unblock the current render. Interrupt the\n                // current attempt and restart from the top.\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane);\n            } // Mark that the root has a pending update.\n            markRootUpdated(root, lane);\n            if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n                // This update was dispatched during the render phase. This is a mistake\n                // if the update originates from user space (with the exception of local\n                // hook updates, which are handled differently and don't reach this\n                // function), but there are some internal React features that use this as\n                // an implementation detail, like selective hydration.\n                warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n            } else {\n                // This is a normal update, scheduled from outside the render phase. For\n                // example, during an input event.\n                {\n                    if (isDevToolsPresent) {\n                        addFiberToLanesMap(root, fiber, lane);\n                    }\n                }\n                warnIfUpdatesNotWrappedWithActDEV(fiber);\n                if (root === workInProgressRoot) {\n                    // Received an update to a tree that's in the middle of rendering. Mark\n                    // that there was an interleaved update work on this root.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n                    }\n                    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n                        // The root already suspended with a delay, which means this render\n                        // definitely won't finish. Since we have a new update, let's mark it as\n                        // suspended now, right before marking the incoming update. This has the\n                        // effect of interrupting the current render and switching to the update.\n                        // TODO: Make sure this doesn't override pings that happen while we've\n                        // already started rendering.\n                        markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane);\n                    }\n                }\n                ensureRootIsScheduled(root);\n                if (lane === SyncLane && executionContext === NoContext && !disableLegacyMode && (fiber.mode & ConcurrentMode) === NoMode) {\n                    if (ReactSharedInternals.isBatchingLegacy) ;\n                    else {\n                        // Flush the synchronous work now, unless we're already working or inside\n                        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n                        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n                        // without immediately flushing it. We only do this for user-initiated\n                        // updates, to preserve historical behavior of legacy mode.\n                        resetRenderTimer();\n                    }\n                }\n            }\n        }\n        function scheduleInitialHydrationOnRoot(root, lane) {\n            // This is a special fork of scheduleUpdateOnFiber that is only used to\n            // schedule the initial hydration of a root that has just been created. Most\n            // of the stuff in scheduleUpdateOnFiber can be skipped.\n            //\n            // The main reason for this separate path, though, is to distinguish the\n            // initial children from subsequent updates. In fully client-rendered roots\n            // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n            // updates, but hydration roots are special because the initial render must\n            // match what was rendered on the server.\n            var current = root.current;\n            current.lanes = lane;\n            markRootUpdated(root, lane);\n            ensureRootIsScheduled(root);\n        }\n        function isUnsafeClassRenderPhaseUpdate(fiber) {\n            // Check if this is a render phase update. Only called by class components,\n            // which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n            return (executionContext & RenderContext) !== NoContext;\n        } // This is the entry point for every concurrent task, i.e. anything that\n        // goes through Scheduler.\n        function performConcurrentWorkOnRoot(root, didTimeout) {\n            {\n                resetNestedUpdateFlag();\n            }\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            } // Flush any pending passive effects before deciding which lanes to work on,\n            // in case they schedule additional work.\n            var originalCallbackNode = root.callbackNode;\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // Something in the passive effect phase may have canceled the current task.\n                // Check if the task node for this root was changed.\n                if (root.callbackNode !== originalCallbackNode) {\n                    // The current task was canceled. Exit. We don't need to call\n                    // `ensureRootIsScheduled` because the check above implies either that\n                    // there's a new task, or that there's no remaining work on this root.\n                    return null;\n                }\n            } // Determine the next lanes to work on, using the fields stored\n            // on the root.\n            // TODO: This was already computed in the caller. Pass it as an argument.\n            var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (lanes === NoLanes) {\n                // Defensive coding. This is never expected to happen.\n                return null;\n            } // We disable time-slicing in some cases: if the work has been CPU-bound\n            // for too long (\"expired\" work, to prevent starvation), or we're in\n            // sync-updates-by-default mode.\n            // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n            // bug we're still investigating. Once the bug in Scheduler is fixed,\n            // we can remove this, since we track expiration ourselves.\n            var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout;\n            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n            if (exitStatus !== RootInProgress) {\n                var renderWasConcurrent = shouldTimeSlice;\n                do {\n                    if (exitStatus === RootDidNotComplete) {\n                        // The render unwound without completing the tree. This happens in special\n                        // cases where need to exit the current render without producing a\n                        // consistent tree or committing.\n                        markRootSuspended(root, lanes, NoLane);\n                    } else {\n                        // The render completed.\n                        // Check if this render may have yielded to a concurrent event, and if so,\n                        // confirm that any newly rendered stores are consistent.\n                        // TODO: It's possible that even a concurrent render may never have yielded\n                        // to the main thread, if it was fast enough, or if it expired. We could\n                        // skip the consistency check in that case, too.\n                        var finishedWork = root.current.alternate;\n                        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n                            // A store was mutated in an interleaved event. Render again,\n                            // synchronously, to block further mutations.\n                            exitStatus = renderRootSync(root, lanes); // We assume the tree is now consistent because we didn't yield to any\n                            // concurrent events.\n                            renderWasConcurrent = false; // Need to check the exit status again.\n                            continue;\n                        } // Check if something threw\n                        if (exitStatus === RootErrored) {\n                            var lanesThatJustErrored = lanes;\n                            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, lanesThatJustErrored);\n                            if (errorRetryLanes !== NoLanes) {\n                                lanes = errorRetryLanes;\n                                exitStatus = recoverFromConcurrentError(root, lanesThatJustErrored, errorRetryLanes);\n                                renderWasConcurrent = false; // Need to check the exit status again.\n                                if (exitStatus !== RootErrored) {\n                                    continue;\n                                }\n                            }\n                        }\n                        if (exitStatus === RootFatalErrored) {\n                            prepareFreshStack(root, NoLanes);\n                            markRootSuspended(root, lanes, NoLane);\n                            break;\n                        } // We now have a consistent tree. The next step is either to commit it,\n                        // or, if something suspended, wait to commit it after a timeout.\n                        root.finishedWork = finishedWork;\n                        root.finishedLanes = lanes;\n                        finishConcurrentRender(root, exitStatus, finishedWork, lanes);\n                    }\n                    break;\n                }while (true);\n            }\n            ensureRootIsScheduled(root);\n            return getContinuationForRoot(root, originalCallbackNode);\n        }\n        function recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes) {\n            // If an error occurred during hydration, discard server response and fall\n            // back to client side render.\n            // Before rendering again, save the errors from the previous attempt.\n            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n            var wasRootDehydrated = supportsHydration && isRootDehydrated(root);\n            if (wasRootDehydrated) {\n                // The shell failed to hydrate. Set a flag to force a client rendering\n                // during the next attempt. To do this, we call prepareFreshStack now\n                // to create the root work-in-progress fiber. This is a bit weird in terms\n                // of factoring, because it relies on renderRootSync not calling\n                // prepareFreshStack again in the call below, which happens because the\n                // root and lanes haven't changed.\n                //\n                // TODO: I think what we should do is set ForceClientRender inside\n                // throwException, like we do for nested Suspense boundaries. The reason\n                // it's here instead is so we can switch to the synchronous work loop, too.\n                // Something to consider for a future refactor.\n                var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n                rootWorkInProgress.flags |= ForceClientRender;\n            }\n            var exitStatus = renderRootSync(root, errorRetryLanes);\n            if (exitStatus !== RootErrored) {\n                // Successfully finished rendering on retry\n                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                    // During the synchronous render, we attached additional ping listeners.\n                    // This is highly suggestive of an uncached promise (though it's not the\n                    // only reason this would happen). If it was an uncached promise, then\n                    // it may have masked a downstream error from ocurring without actually\n                    // fixing it. Example:\n                    //\n                    //    use(Promise.resolve('uncached'))\n                    //    throw new Error('Oops!')\n                    //\n                    // When this happens, there's a conflict between blocking potential\n                    // concurrent data races and unwrapping uncached promise values. We\n                    // have to choose one or the other. Because the data race recovery is\n                    // a last ditch effort, we'll disable it.\n                    root.errorRecoveryDisabledLanes = mergeLanes(root.errorRecoveryDisabledLanes, originallyAttemptedLanes); // Mark the current render as suspended and force it to restart. Once\n                    // these lanes finish successfully, we'll re-enable the error recovery\n                    // mechanism for subsequent updates.\n                    workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes;\n                    return RootSuspendedWithDelay;\n                } // The errors from the failed first attempt have been recovered. Add\n                // them to the collection of recoverable errors. We'll log them in the\n                // commit phase.\n                var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n                workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n                // from the first attempt, to preserve the causal sequence.\n                if (errorsFromSecondAttempt !== null) {\n                    queueRecoverableErrors(errorsFromSecondAttempt);\n                }\n            }\n            return exitStatus;\n        }\n        function queueRecoverableErrors(errors) {\n            if (workInProgressRootRecoverableErrors === null) {\n                workInProgressRootRecoverableErrors = errors;\n            } else {\n                // $FlowFixMe[method-unbinding]\n                workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n            }\n        }\n        function finishConcurrentRender(root, exitStatus, finishedWork, lanes) {\n            // TODO: The fact that most of these branches are identical suggests that some\n            // of the exit statuses are not best modeled as exit statuses and should be\n            // tracked orthogonally.\n            switch(exitStatus){\n                case RootInProgress:\n                case RootFatalErrored:\n                    {\n                        throw new Error('Root did not complete. This is a bug in React.');\n                    }\n                case RootSuspendedWithDelay:\n                    {\n                        if (includesOnlyTransitions(lanes)) {\n                            // This is a transition, so we should exit without committing a\n                            // placeholder and without scheduling a timeout. Delay indefinitely\n                            // until we receive more data.\n                            markRootSuspended(root, lanes, workInProgressDeferredLane);\n                            return;\n                        } // Commit the placeholder.\n                        break;\n                    }\n                case RootErrored:\n                    {\n                        // This render errored. Ignore any recoverable errors because we weren't actually\n                        // able to recover. Instead, whatever the final errors were is the ones we log.\n                        // This ensures that we only log the actual client side error if it's just a plain\n                        // error thrown from a component on the server and the client.\n                        workInProgressRootRecoverableErrors = null;\n                        break;\n                    }\n                case RootSuspended:\n                case RootCompleted:\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        throw new Error('Unknown root exit status.');\n                    }\n            }\n            if (shouldForceFlushFallbacksInDEV()) {\n                // We're inside an `act` scope. Commit immediately.\n                commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane);\n            } else {\n                if (includesOnlyRetries(lanes) && alwaysThrottleRetries) {\n                    // This render only included retries, no updates. Throttle committing\n                    // retries so that we don't show too many loading states too quickly.\n                    var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(); // Don't bother with a very short suspense time.\n                    if (msUntilTimeout > 10) {\n                        markRootSuspended(root, lanes, workInProgressDeferredLane);\n                        var nextLanes = getNextLanes(root, NoLanes);\n                        if (nextLanes !== NoLanes) {\n                            // There's additional work we can do on this root. We might as well\n                            // attempt to work on that while we're suspended.\n                            return;\n                        } // The render is suspended, it hasn't timed out, and there's no\n                        // lower priority work to do. Instead of committing the fallback\n                        // immediately, wait for more data to arrive.\n                        // TODO: Combine retry throttling with Suspensey commits. Right now they\n                        // run one after the other.\n                        root.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, root, finishedWork, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane), msUntilTimeout);\n                        return;\n                    }\n                }\n                commitRootWhenReady(root, finishedWork, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane);\n            }\n        }\n        function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane) {\n            // TODO: Combine retry throttling with Suspensey commits. Right now they run\n            // one after the other.\n            var BothVisibilityAndMaySuspendCommit = Visibility | MaySuspendCommit;\n            var subtreeFlags = finishedWork.subtreeFlags;\n            if (subtreeFlags & ShouldSuspendCommit || (subtreeFlags & BothVisibilityAndMaySuspendCommit) === BothVisibilityAndMaySuspendCommit) {\n                // Before committing, ask the renderer whether the host tree is ready.\n                // If it's not, we'll wait until it notifies us.\n                startSuspendingCommit(); // This will walk the completed fiber tree and attach listeners to all\n                // the suspensey resources. The renderer is responsible for accumulating\n                // all the load events. This all happens in a single synchronous\n                // transaction, so it track state in its own module scope.\n                accumulateSuspenseyCommit(finishedWork); // At the end, ask the renderer if it's ready to commit, or if we should\n                // suspend. If it's not ready, it will return a callback to subscribe to\n                // a ready event.\n                var schedulePendingCommit = waitForCommitToBeReady();\n                if (schedulePendingCommit !== null) {\n                    // NOTE: waitForCommitToBeReady returns a subscribe function so that we\n                    // only allocate a function if the commit isn't ready yet. The other\n                    // pattern would be to always pass a callback to waitForCommitToBeReady.\n                    // Not yet ready to commit. Delay the commit until the renderer notifies\n                    // us that it's ready. This will be canceled if we start work on the\n                    // root again.\n                    root.cancelPendingCommit = schedulePendingCommit(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate));\n                    markRootSuspended(root, lanes, spawnedLane);\n                    return;\n                }\n            } // Otherwise, commit immediately.\n            commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane);\n        }\n        function isRenderConsistentWithExternalStores(finishedWork) {\n            // Search the rendered tree for external store reads, and check whether the\n            // stores were mutated in a concurrent event. Intentionally using an iterative\n            // loop instead of recursion so we can exit early.\n            var node = finishedWork;\n            while(true){\n                if (node.flags & StoreConsistency) {\n                    var updateQueue = node.updateQueue;\n                    if (updateQueue !== null) {\n                        var checks = updateQueue.stores;\n                        if (checks !== null) {\n                            for(var i = 0; i < checks.length; i++){\n                                var check = checks[i];\n                                var getSnapshot = check.getSnapshot;\n                                var renderedValue = check.value;\n                                try {\n                                    if (!objectIs(getSnapshot(), renderedValue)) {\n                                        // Found an inconsistent store.\n                                        return false;\n                                    }\n                                } catch (error) {\n                                    // If `getSnapshot` throws, return `false`. This will schedule\n                                    // a re-render, and the error will be rethrown during render.\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                }\n                var child = node.child;\n                if (node.subtreeFlags & StoreConsistency && child !== null) {\n                    child.return = node;\n                    node = child;\n                    continue;\n                }\n                if (node === finishedWork) {\n                    return true;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === finishedWork) {\n                        return true;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            } // Flow doesn't know this is unreachable, but eslint does\n            // eslint-disable-next-line no-unreachable\n            return true;\n        } // The extra indirections around markRootUpdated and markRootSuspended is\n        // needed to avoid a circular dependency between this module and\n        // ReactFiberLane. There's probably a better way to split up these modules and\n        // avoid this problem. Perhaps all the root-marking functions should move into\n        // the work loop.\n        function markRootUpdated(root, updatedLanes) {\n            markRootUpdated$1(root, updatedLanes);\n            {\n                // Check for recursive updates\n                if (executionContext & RenderContext) {\n                    workInProgressRootDidIncludeRecursiveRenderUpdate = true;\n                } else if (executionContext & CommitContext) {\n                    didIncludeCommitPhaseUpdate = true;\n                }\n                throwIfInfiniteUpdateLoopDetected();\n            }\n        }\n        function markRootPinged(root, pingedLanes) {\n            markRootPinged$1(root, pingedLanes);\n            {\n                // Check for recursive pings. Pings are conceptually different from updates in\n                // other contexts but we call it an \"update\" in this context because\n                // repeatedly pinging a suspended render can cause a recursive render loop.\n                // The relevant property is that it can result in a new render attempt\n                // being scheduled.\n                if (executionContext & RenderContext) {\n                    workInProgressRootDidIncludeRecursiveRenderUpdate = true;\n                } else if (executionContext & CommitContext) {\n                    didIncludeCommitPhaseUpdate = true;\n                }\n                throwIfInfiniteUpdateLoopDetected();\n            }\n        }\n        function markRootSuspended(root, suspendedLanes, spawnedLane) {\n            // When suspending, we should always exclude lanes that were pinged or (more\n            // rarely, since we try to avoid it) updated during the render phase.\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n            markRootSuspended$1(root, suspendedLanes, spawnedLane);\n        } // This is the entry point for synchronous tasks that don't go\n        // through Scheduler\n        function performSyncWorkOnRoot(root, lanes) {\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            }\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // If passive effects were flushed, exit to the outer work loop in the root\n                // scheduler, so we can recompute the priority.\n                // TODO: We don't actually need this `ensureRootIsScheduled` call because\n                // this path is only reachable if the root is already part of the schedule.\n                // I'm including it only for consistency with the other exit points from\n                // this function. Can address in a subsequent refactor.\n                ensureRootIsScheduled(root);\n                return null;\n            }\n            {\n                syncNestedUpdateFlag();\n            }\n            var exitStatus = renderRootSync(root, lanes);\n            if (exitStatus === RootErrored) {\n                // If something threw an error, try rendering one more time. We'll render\n                // synchronously to block concurrent data mutations, and we'll includes\n                // all pending updates are included. If it still fails after the second\n                // attempt, we'll give up and commit the resulting tree.\n                var originallyAttemptedLanes = lanes;\n                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes);\n                if (errorRetryLanes !== NoLanes) {\n                    lanes = errorRetryLanes;\n                    exitStatus = recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes);\n                }\n            }\n            if (exitStatus === RootFatalErrored) {\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended(root, lanes, NoLane);\n                ensureRootIsScheduled(root);\n                return null;\n            }\n            if (exitStatus === RootDidNotComplete) {\n                // The render unwound without completing the tree. This happens in special\n                // cases where need to exit the current render without producing a\n                // consistent tree or committing.\n                markRootSuspended(root, lanes, workInProgressDeferredLane);\n                ensureRootIsScheduled(root);\n                return null;\n            } // We now have a consistent tree. Because this is a sync render, we\n            // will commit it even if something suspended.\n            var finishedWork = root.current.alternate;\n            root.finishedWork = finishedWork;\n            root.finishedLanes = lanes;\n            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane); // Before exiting, make sure there's a callback scheduled for the next\n            // pending level.\n            ensureRootIsScheduled(root);\n            return null;\n        }\n        function flushRoot(root, lanes) {\n            if (lanes !== NoLanes) {\n                upgradePendingLanesToSync(root, lanes);\n                ensureRootIsScheduled(root);\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    resetRenderTimer(); // TODO: For historical reasons this flushes all sync work across all\n                    // roots. It shouldn't really matter either way, but we could change this\n                    // to only flush the given root.\n                    flushSyncWorkOnAllRoots();\n                }\n            }\n        }\n        function getExecutionContext() {\n            return executionContext;\n        }\n        function deferredUpdates(fn) {\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DefaultEventPriority);\n                ReactSharedInternals.T = null;\n                return fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n            }\n        }\n        function batchedUpdates(fn, a) {\n            {\n                // batchedUpdates is a no-op now, but there's still some internal react-dom\n                // code calling it, that we can't remove until we remove legacy mode.\n                return fn(a);\n            }\n        }\n        function discreteUpdates(fn, a, b, c, d) {\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                return fn(a, b, c, d);\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                if (executionContext === NoContext) {\n                    resetRenderTimer();\n                }\n            }\n        } // Overload the definition to the two valid signatures.\n        // Warning, this opts-out of checking the function body.\n        // eslint-disable-next-line no-unused-vars\n        // eslint-disable-next-line no-redeclare\n        // eslint-disable-next-line no-redeclare\n        function flushSyncFromReconciler(fn) {\n            // In legacy mode, we flush pending passive effects at the beginning of the\n            // next event, not at the end of the previous one.\n            if (rootWithPendingPassiveEffects !== null && !disableLegacyMode && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushPassiveEffects();\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                if (fn) {\n                    return fn();\n                } else {\n                    return undefined;\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n                // Note that this will happen even if batchedUpdates is higher up\n                // the stack.\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    flushSyncWorkOnAllRoots();\n                }\n            }\n        } // If called outside of a render or commit will flush all sync work on all roots\n        // Returns whether the the call was during a render or not\n        function flushSyncWork() {\n            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushSyncWorkOnAllRoots();\n                return false;\n            }\n            return true;\n        }\n        function isAlreadyRendering() {\n            // Used by the renderer to print a warning if certain APIs are called from\n            // the wrong context.\n            return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n        }\n        // hidden subtree. The stack logic is managed there because that's the only\n        // place that ever modifies it. Which module it lives in doesn't matter for\n        // performance because this function will get inlined regardless\n        function setEntangledRenderLanes(newEntangledRenderLanes) {\n            entangledRenderLanes = newEntangledRenderLanes;\n        }\n        function getEntangledRenderLanes() {\n            return entangledRenderLanes;\n        }\n        function resetWorkInProgressStack() {\n            if (workInProgress === null) return;\n            var interruptedWork;\n            if (workInProgressSuspendedReason === NotSuspended) {\n                // Normal case. Work-in-progress hasn't started yet. Unwind all\n                // its parents.\n                interruptedWork = workInProgress.return;\n            } else {\n                // Work-in-progress is in suspended state. Reset the work loop and unwind\n                // both the suspended fiber and all its parents.\n                resetSuspendedWorkLoopOnUnwind(workInProgress);\n                interruptedWork = workInProgress;\n            }\n            while(interruptedWork !== null){\n                var current = interruptedWork.alternate;\n                unwindInterruptedWork(current, interruptedWork);\n                interruptedWork = interruptedWork.return;\n            }\n            workInProgress = null;\n        }\n        function prepareFreshStack(root, lanes) {\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            var timeoutHandle = root.timeoutHandle;\n            if (timeoutHandle !== noTimeout) {\n                // The root previous suspended and scheduled a timeout to commit a fallback\n                // state. Now that we have additional work, cancel the timeout.\n                root.timeoutHandle = noTimeout; // $FlowFixMe[incompatible-call] Complains noTimeout is not a TimeoutID, despite the check above\n                cancelTimeout(timeoutHandle);\n            }\n            var cancelPendingCommit = root.cancelPendingCommit;\n            if (cancelPendingCommit !== null) {\n                root.cancelPendingCommit = null;\n                cancelPendingCommit();\n            }\n            resetWorkInProgressStack();\n            workInProgressRoot = root;\n            var rootWorkInProgress = createWorkInProgress(root.current, null);\n            workInProgress = rootWorkInProgress;\n            workInProgressRootRenderLanes = lanes;\n            workInProgressSuspendedReason = NotSuspended;\n            workInProgressThrownValue = null;\n            workInProgressRootDidAttachPingListener = false;\n            workInProgressRootExitStatus = RootInProgress;\n            workInProgressRootSkippedLanes = NoLanes;\n            workInProgressRootInterleavedUpdatedLanes = NoLanes;\n            workInProgressRootPingedLanes = NoLanes;\n            workInProgressDeferredLane = NoLane;\n            workInProgressRootConcurrentErrors = null;\n            workInProgressRootRecoverableErrors = null;\n            workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Get the lanes that are entangled with whatever we're about to render. We\n            // track these separately so we can distinguish the priority of the render\n            // task from the priority of the lanes it is entangled with. For example, a\n            // transition may not be allowed to finish unless it includes the Sync lane,\n            // which is currently suspended. We should be able to render the Transition\n            // and Sync lane in the same batch, but at Transition priority, because the\n            // Sync lane already suspended.\n            entangledRenderLanes = getEntangledLanes(root, lanes);\n            finishQueueingConcurrentUpdates();\n            {\n                ReactStrictModeWarnings.discardPendingWarnings();\n            }\n            return rootWorkInProgress;\n        }\n        function resetSuspendedWorkLoopOnUnwind(fiber) {\n            // Reset module-level state that was set during the render phase.\n            resetContextDependencies();\n            resetHooksOnUnwind(fiber);\n            resetChildReconcilerOnUnwind();\n        }\n        function handleThrow(root, thrownValue) {\n            // A component threw an exception. Usually this is because it suspended, but\n            // it also includes regular program errors.\n            //\n            // We're either going to unwind the stack to show a Suspense or error\n            // boundary, or we're going to replay the component again. Like after a\n            // promise resolves.\n            //\n            // Until we decide whether we're going to unwind or replay, we should preserve\n            // the current state of the work loop without resetting anything.\n            //\n            // If we do decide to unwind the stack, module-level variables will be reset\n            // in resetSuspendedWorkLoopOnUnwind.\n            // These should be reset immediately because they're only supposed to be set\n            // when React is executing user code.\n            resetHooksAfterThrow();\n            {\n                resetCurrentFiber();\n            }\n            if (thrownValue === SuspenseException) {\n                // This is a special type of exception used for Suspense. For historical\n                // reasons, the rest of the Suspense implementation expects the thrown value\n                // to be a thenable, because before `use` existed that was the (unstable)\n                // API for suspending. This implementation detail can change later, once we\n                // deprecate the old API in favor of `use`.\n                thrownValue = getSuspendedThenable();\n                workInProgressSuspendedReason = shouldRemainOnPreviousScreen() && // Check if there are other pending updates that might possibly unblock this\n                // component from suspending. This mirrors the check in\n                // renderDidSuspendDelayIfPossible. We should attempt to unify them somehow.\n                // TODO: Consider unwinding immediately, using the\n                // SuspendedOnHydration mechanism.\n                !includesNonIdleWork(workInProgressRootSkippedLanes) && !includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes) ? SuspendedOnData : // immediately resolved (i.e. in a microtask). Otherwise, trigger the\n                // nearest Suspense fallback.\n                SuspendedOnImmediate;\n            } else if (thrownValue === SuspenseyCommitException) {\n                thrownValue = getSuspendedThenable();\n                workInProgressSuspendedReason = SuspendedOnInstance;\n            } else if (thrownValue === SelectiveHydrationException) {\n                // An update flowed into a dehydrated boundary. Before we can apply the\n                // update, we need to finish hydrating. Interrupt the work-in-progress\n                // render so we can restart at the hydration lane.\n                //\n                // The ideal implementation would be able to switch contexts without\n                // unwinding the current stack.\n                //\n                // We could name this something more general but as of now it's the only\n                // case where we think this should happen.\n                workInProgressSuspendedReason = SuspendedOnHydration;\n            } else {\n                // This is a regular error.\n                var isWakeable = thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function';\n                workInProgressSuspendedReason = isWakeable ? // This has slightly different behavior than suspending with `use`.\n                SuspendedOnDeprecatedThrowPromise : // suspended, we must clear the thenable state to unblock the work loop.\n                SuspendedOnError;\n            }\n            workInProgressThrownValue = thrownValue;\n            var erroredWork = workInProgress;\n            if (erroredWork === null) {\n                // This is a fatal error\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                return;\n            }\n            if (erroredWork.mode & ProfileMode) {\n                // Record the time spent rendering before an error was thrown. This\n                // avoids inaccurate Profiler durations in the case of a\n                // suspended render.\n                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n            }\n            {\n                markComponentRenderStopped();\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnError:\n                        {\n                            markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                            break;\n                        }\n                    case SuspendedOnData:\n                    case SuspendedOnImmediate:\n                    case SuspendedOnDeprecatedThrowPromise:\n                    case SuspendedAndReadyToContinue:\n                        {\n                            var wakeable = thrownValue;\n                            markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n                            break;\n                        }\n                }\n            }\n        }\n        function shouldRemainOnPreviousScreen() {\n            // This is asking whether it's better to suspend the transition and remain\n            // on the previous screen, versus showing a fallback as soon as possible. It\n            // takes into account both the priority of render and also whether showing a\n            // fallback would produce a desirable user experience.\n            var handler = getSuspenseHandler();\n            if (handler === null) {\n                // There's no Suspense boundary that can provide a fallback. We have no\n                // choice but to remain on the previous screen.\n                // NOTE: We do this even for sync updates, for lack of any better option. In\n                // the future, we may change how we handle this, like by putting the whole\n                // root into a \"detached\" mode.\n                return true;\n            } // TODO: Once `use` has fully replaced the `throw promise` pattern, we should\n            // be able to remove the equivalent check in finishConcurrentRender, and rely\n            // just on this one.\n            if (includesOnlyTransitions(workInProgressRootRenderLanes)) {\n                if (getShellBoundary() === null) {\n                    // We're rendering inside the \"shell\" of the app. Activating the nearest\n                    // fallback would cause visible content to disappear. It's better to\n                    // suspend the transition and remain on the previous screen.\n                    return true;\n                } else {\n                    // We're rendering content that wasn't part of the previous screen.\n                    // Rather than block the transition, it's better to show a fallback as\n                    // soon as possible. The appearance of any nested fallbacks will be\n                    // throttled to avoid jank.\n                    return false;\n                }\n            }\n            if (includesOnlyRetries(workInProgressRootRenderLanes) || // In this context, an OffscreenLane counts as a Retry\n            // TODO: It's become increasingly clear that Retries and Offscreen are\n            // deeply connected. They probably can be unified further.\n            includesSomeLane(workInProgressRootRenderLanes, OffscreenLane)) {\n                // During a retry, we can suspend rendering if the nearest Suspense boundary\n                // is the boundary of the \"shell\", because we're guaranteed not to block\n                // any new content from appearing.\n                //\n                // The reason we must check if this is a retry is because it guarantees\n                // that suspending the work loop won't block an actual update, because\n                // retries don't \"update\" anything; they fill in fallbacks that were left\n                // behind by a previous transition.\n                return handler === getShellBoundary();\n            } // For all other Lanes besides Transitions and Retries, we should not wait\n            // for the data to load.\n            return false;\n        }\n        function pushDispatcher(container) {\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = ContextOnlyDispatcher;\n            if (prevDispatcher === null) {\n                // The React isomorphic package does not include a default dispatcher.\n                // Instead the first renderer will lazily attach one, in order to give\n                // nicer error messages.\n                return ContextOnlyDispatcher;\n            } else {\n                return prevDispatcher;\n            }\n        }\n        function popDispatcher(prevDispatcher) {\n            ReactSharedInternals.H = prevDispatcher;\n        }\n        function pushAsyncDispatcher() {\n            {\n                var prevAsyncDispatcher = ReactSharedInternals.A;\n                ReactSharedInternals.A = DefaultAsyncDispatcher;\n                return prevAsyncDispatcher;\n            }\n        }\n        function popAsyncDispatcher(prevAsyncDispatcher) {\n            {\n                ReactSharedInternals.A = prevAsyncDispatcher;\n            }\n        }\n        function markCommitTimeOfFallback() {\n            globalMostRecentFallbackTime = now$1();\n        }\n        function markSkippedUpdateLanes(lane) {\n            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n        }\n        function renderDidSuspend() {\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootSuspended;\n            }\n        }\n        function renderDidSuspendDelayIfPossible() {\n            workInProgressRootExitStatus = RootSuspendedWithDelay; // Check if there are updates that we skipped tree that might have unblocked\n            // this render.\n            if ((includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes)) && workInProgressRoot !== null) {\n                // Mark the current render as suspended so that we switch to working on\n                // the updates that were skipped. Usually we only suspend at the end of\n                // the render phase.\n                // TODO: We should probably always mark the root as suspended immediately\n                // (inside this function), since by suspending at the end of the render\n                // phase introduces a potential mistake where we suspend lanes that were\n                // pinged or updated while we were rendering.\n                // TODO: Consider unwinding immediately, using the\n                // SuspendedOnHydration mechanism.\n                markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane);\n            }\n        }\n        function renderDidError() {\n            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n                workInProgressRootExitStatus = RootErrored;\n            }\n        }\n        function queueConcurrentError(error) {\n            if (workInProgressRootConcurrentErrors === null) {\n                workInProgressRootConcurrentErrors = [\n                    error\n                ];\n            } else {\n                workInProgressRootConcurrentErrors.push(error);\n            }\n        } // Called during render to determine if anything has suspended.\n        // Returns false if we're not sure.\n        function renderHasNotSuspendedYet() {\n            // If something errored or completed, we can't really be sure,\n            // so those are false.\n            return workInProgressRootExitStatus === RootInProgress;\n        } // TODO: Over time, this function and renderRootConcurrent have become more\n        // and more similar. Not sure it makes sense to maintain forked paths. Consider\n        // unifying them again.\n        function renderRootSync(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher();\n            var prevAsyncDispatcher = pushAsyncDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                workInProgressTransitions = getTransitionsForLanes();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            var didSuspendInShell = false;\n            outer: do {\n                try {\n                    if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n                        // The work loop is suspended. During a synchronous render, we don't\n                        // yield to the main thread. Immediately unwind the stack. This will\n                        // trigger either a fallback or an error boundary.\n                        // TODO: For discrete and \"default\" updates (anything that's not\n                        // flushSync), we want to wait for the microtasks the flush before\n                        // unwinding. Will probably implement this using renderRootConcurrent,\n                        // or merge renderRootSync and renderRootConcurrent into the same\n                        // function and fork the behavior some other way.\n                        var unitOfWork = workInProgress;\n                        var thrownValue = workInProgressThrownValue;\n                        switch(workInProgressSuspendedReason){\n                            case SuspendedOnHydration:\n                                {\n                                    // Selective hydration. An update flowed into a dehydrated tree.\n                                    // Interrupt the current render so the work loop can switch to the\n                                    // hydration lane.\n                                    resetWorkInProgressStack();\n                                    workInProgressRootExitStatus = RootDidNotComplete;\n                                    break outer;\n                                }\n                            case SuspendedOnImmediate:\n                            case SuspendedOnData:\n                                {\n                                    if (!didSuspendInShell && getSuspenseHandler() === null) {\n                                        didSuspendInShell = true;\n                                    } // Intentional fallthrough\n                                }\n                            default:\n                                {\n                                    // Unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                        }\n                    }\n                    workLoopSync();\n                    break;\n                } catch (thrownValue) {\n                    handleThrow(root, thrownValue);\n                }\n            }while (true); // Check if something suspended in the shell. We use this to detect an\n            // infinite ping loop caused by an uncached promise.\n            //\n            // Only increment this counter once per synchronous render attempt across the\n            // whole tree. Even if there are many sibling components that suspend, this\n            // counter only gets incremented once.\n            if (didSuspendInShell) {\n                root.shellSuspendCounter++;\n            }\n            resetContextDependencies();\n            executionContext = prevExecutionContext;\n            popDispatcher(prevDispatcher);\n            popAsyncDispatcher(prevAsyncDispatcher);\n            if (workInProgress !== null) {\n                // This is a sync render, so we should have finished the whole tree.\n                throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n            }\n            {\n                markRenderStopped();\n            }\n            workInProgressRoot = null;\n            workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n            finishQueueingConcurrentUpdates();\n            return workInProgressRootExitStatus;\n        } // The work loop is an extremely hot path. Tell Closure not to inline it.\n        /** @noinline */ function workLoopSync() {\n            // Perform work without checking if we need to yield between fiber.\n            while(workInProgress !== null){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function renderRootConcurrent(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher();\n            var prevAsyncDispatcher = pushAsyncDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                workInProgressTransitions = getTransitionsForLanes();\n                resetRenderTimer();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            outer: do {\n                try {\n                    if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n                        // The work loop is suspended. We need to either unwind the stack or\n                        // replay the suspended component.\n                        var unitOfWork = workInProgress;\n                        var thrownValue = workInProgressThrownValue;\n                        resumeOrUnwind: switch(workInProgressSuspendedReason){\n                            case SuspendedOnError:\n                                {\n                                    // Unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnData:\n                                {\n                                    var thenable = thrownValue;\n                                    if (isThenableResolved(thenable)) {\n                                        // The data resolved. Try rendering the component again.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        replaySuspendedUnitOfWork(unitOfWork);\n                                        break;\n                                    } // The work loop is suspended on data. We should wait for it to\n                                    // resolve before continuing to render.\n                                    // TODO: Handle the case where the promise resolves synchronously.\n                                    // Usually this is handled when we instrument the promise to add a\n                                    // `status` field, but if the promise already has a status, we won't\n                                    // have added a listener until right here.\n                                    var onResolution = function() {\n                                        // Check if the root is still suspended on this promise.\n                                        if (workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root) {\n                                            // Mark the root as ready to continue rendering.\n                                            workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                                        } // Ensure the root is scheduled. We should do this even if we're\n                                        // currently working on a different root, so that we resume\n                                        // rendering later.\n                                        ensureRootIsScheduled(root);\n                                    };\n                                    thenable.then(onResolution, onResolution);\n                                    break outer;\n                                }\n                            case SuspendedOnImmediate:\n                                {\n                                    // If this fiber just suspended, it's possible the data is already\n                                    // cached. Yield to the main thread to give it a chance to ping. If\n                                    // it does, we can retry immediately without unwinding the stack.\n                                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                                    break outer;\n                                }\n                            case SuspendedOnInstance:\n                                {\n                                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                                    break outer;\n                                }\n                            case SuspendedAndReadyToContinue:\n                                {\n                                    var _thenable = thrownValue;\n                                    if (isThenableResolved(_thenable)) {\n                                        // The data resolved. Try rendering the component again.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        replaySuspendedUnitOfWork(unitOfWork);\n                                    } else {\n                                        // Otherwise, unwind then continue with the normal work loop.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    }\n                                    break;\n                                }\n                            case SuspendedOnInstanceAndReadyToContinue:\n                                {\n                                    var resource = null;\n                                    switch(workInProgress.tag){\n                                        case HostHoistable:\n                                            {\n                                                resource = workInProgress.memoizedState;\n                                            }\n                                        // intentional fallthrough\n                                        case HostComponent:\n                                        case HostSingleton:\n                                            {\n                                                // Before unwinding the stack, check one more time if the\n                                                // instance is ready. It may have loaded when React yielded to\n                                                // the main thread.\n                                                // Assigning this to a constant so Flow knows the binding won't\n                                                // be mutated by `preloadInstance`.\n                                                var hostFiber = workInProgress;\n                                                var type = hostFiber.type;\n                                                var props = hostFiber.pendingProps;\n                                                var isReady = resource ? preloadResource(resource) : preloadInstance(type, props);\n                                                if (isReady) {\n                                                    // The data resolved. Resume the work loop as if nothing\n                                                    // suspended. Unlike when a user component suspends, we don't\n                                                    // have to replay anything because the host fiber\n                                                    // already completed.\n                                                    workInProgressSuspendedReason = NotSuspended;\n                                                    workInProgressThrownValue = null;\n                                                    var sibling = hostFiber.sibling;\n                                                    if (sibling !== null) {\n                                                        workInProgress = sibling;\n                                                    } else {\n                                                        var returnFiber = hostFiber.return;\n                                                        if (returnFiber !== null) {\n                                                            workInProgress = returnFiber;\n                                                            completeUnitOfWork(returnFiber);\n                                                        } else {\n                                                            workInProgress = null;\n                                                        }\n                                                    }\n                                                    break resumeOrUnwind;\n                                                }\n                                                break;\n                                            }\n                                        default:\n                                            {\n                                                // This will fail gracefully but it's not correct, so log a\n                                                // warning in dev.\n                                                if (true) {\n                                                    error('Unexpected type of fiber triggered a suspensey commit. ' + 'This is a bug in React.');\n                                                }\n                                                break;\n                                            }\n                                    } // Otherwise, unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnDeprecatedThrowPromise:\n                                {\n                                    // Suspended by an old implementation that uses the `throw promise`\n                                    // pattern. The newer replaying behavior can cause subtle issues\n                                    // like infinite ping loops. So we maintain the old behavior and\n                                    // always unwind.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnHydration:\n                                {\n                                    // Selective hydration. An update flowed into a dehydrated tree.\n                                    // Interrupt the current render so the work loop can switch to the\n                                    // hydration lane.\n                                    resetWorkInProgressStack();\n                                    workInProgressRootExitStatus = RootDidNotComplete;\n                                    break outer;\n                                }\n                            default:\n                                {\n                                    throw new Error('Unexpected SuspendedReason. This is a bug in React.');\n                                }\n                        }\n                    }\n                    if ( true && ReactSharedInternals.actQueue !== null) {\n                        // `act` special case: If we're inside an `act` scope, don't consult\n                        // `shouldYield`. Always keep working until the render is complete.\n                        // This is not just an optimization: in a unit test environment, we\n                        // can't trust the result of `shouldYield`, because the host I/O is\n                        // likely mocked.\n                        workLoopSync();\n                    } else {\n                        workLoopConcurrent();\n                    }\n                    break;\n                } catch (thrownValue) {\n                    handleThrow(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            popDispatcher(prevDispatcher);\n            popAsyncDispatcher(prevAsyncDispatcher);\n            executionContext = prevExecutionContext;\n            if (workInProgress !== null) {\n                // Still work remaining.\n                {\n                    markRenderYielded();\n                }\n                return RootInProgress;\n            } else {\n                // Completed the tree.\n                {\n                    markRenderStopped();\n                }\n                workInProgressRoot = null;\n                workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n                finishQueueingConcurrentUpdates(); // Return the final exit status.\n                return workInProgressRootExitStatus;\n            }\n        }\n        /** @noinline */ function workLoopConcurrent() {\n            // Perform work until Scheduler asks us to yield\n            while(workInProgress !== null && !shouldYield()){\n                // $FlowFixMe[incompatible-call] found when upgrading Flow\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function performUnitOfWork(unitOfWork) {\n            // The current, flushed, state of this fiber is the alternate. Ideally\n            // nothing should rely on this, but relying on it here means that we don't\n            // need an additional field on the work in progress.\n            var current = unitOfWork.alternate;\n            var next;\n            if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n                startProfilerTimer(unitOfWork);\n                {\n                    next = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n                }\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } else {\n                {\n                    next = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n                }\n            }\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n        }\n        function replaySuspendedUnitOfWork(unitOfWork) {\n            // This is a fork of performUnitOfWork specifcally for replaying a fiber that\n            // just suspended.\n            var next;\n            {\n                next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);\n            }\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n        }\n        function replayBeginWork(unitOfWork) {\n            // This is a fork of beginWork specifcally for replaying a fiber that\n            // just suspended.\n            var current = unitOfWork.alternate;\n            var next;\n            var isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;\n            if (isProfilingMode) {\n                startProfilerTimer(unitOfWork);\n            }\n            switch(unitOfWork.tag){\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                    {\n                        // Resolve `defaultProps`. This logic is copied from `beginWork`.\n                        // TODO: Consider moving this switch statement into that module. Also,\n                        // could maybe use this as an opportunity to say `use` doesn't work with\n                        // `defaultProps` :)\n                        var Component = unitOfWork.type;\n                        var unresolvedProps = unitOfWork.pendingProps;\n                        var resolvedProps = unresolvedProps;\n                        var context;\n                        next = replayFunctionComponent(current, unitOfWork, resolvedProps, Component, context, workInProgressRootRenderLanes);\n                        break;\n                    }\n                case ForwardRef:\n                    {\n                        // Resolve `defaultProps`. This logic is copied from `beginWork`.\n                        // TODO: Consider moving this switch statement into that module. Also,\n                        // could maybe use this as an opportunity to say `use` doesn't work with\n                        // `defaultProps` :)\n                        var _Component = unitOfWork.type.render;\n                        var _unresolvedProps = unitOfWork.pendingProps;\n                        var _resolvedProps = _unresolvedProps;\n                        next = replayFunctionComponent(current, unitOfWork, _resolvedProps, _Component, unitOfWork.ref, workInProgressRootRenderLanes);\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        // Some host components are stateful (that's how we implement form\n                        // actions) but we don't bother to reuse the memoized state because it's\n                        // not worth the extra code. The main reason to reuse the previous hooks\n                        // is to reuse uncached promises, but we happen to know that the only\n                        // promises that a host component might suspend on are definitely cached\n                        // because they are controlled by us. So don't bother.\n                        resetHooksOnUnwind(unitOfWork); // Fallthrough to the next branch.\n                    }\n                default:\n                    {\n                        // Other types besides function components are reset completely before\n                        // being replayed. Currently this only happens when a Usable type is\n                        // reconciled — the reconciler will suspend.\n                        //\n                        // We reset the fiber back to its original state; however, this isn't\n                        // a full \"unwind\" because we're going to reuse the promises that were\n                        // reconciled previously. So it's intentional that we don't call\n                        // resetSuspendedWorkLoopOnUnwind here.\n                        unwindInterruptedWork(current, unitOfWork);\n                        unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes);\n                        next = beginWork(current, unitOfWork, entangledRenderLanes);\n                        break;\n                    }\n            }\n            if (isProfilingMode) {\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            }\n            return next;\n        }\n        function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {\n            // This is a fork of performUnitOfWork specifcally for unwinding a fiber\n            // that threw an exception.\n            //\n            // Return to the normal work loop. This will unwind the stack, and potentially\n            // result in showing a fallback.\n            resetSuspendedWorkLoopOnUnwind(unitOfWork);\n            var returnFiber = unitOfWork.return;\n            try {\n                // Find and mark the nearest Suspense or error boundary that can handle\n                // this \"exception\".\n                var didFatal = throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes);\n                if (didFatal) {\n                    panicOnRootError(root, thrownValue);\n                    return;\n                }\n            } catch (error) {\n                // We had trouble processing the error. An example of this happening is\n                // when accessing the `componentDidCatch` property of an error boundary\n                // throws an error. A weird edge case. There's a regression test for this.\n                // To prevent an infinite loop, bubble the error up to the next parent.\n                if (returnFiber !== null) {\n                    workInProgress = returnFiber;\n                    throw error;\n                } else {\n                    panicOnRootError(root, thrownValue);\n                    return;\n                }\n            }\n            if (unitOfWork.flags & Incomplete) {\n                // Unwind the stack until we reach the nearest boundary.\n                unwindUnitOfWork(unitOfWork);\n            } else {\n                // Although the fiber suspended, we're intentionally going to commit it in\n                // an inconsistent state. We can do this safely in cases where we know the\n                // inconsistent tree will be hidden.\n                //\n                // This currently only applies to Legacy Suspense implementation, but we may\n                // port a version of this to concurrent roots, too, when performing a\n                // synchronous render. Because that will allow us to mutate the tree as we\n                // go instead of buffering mutations until the end. Though it's unclear if\n                // this particular path is how that would be implemented.\n                completeUnitOfWork(unitOfWork);\n            }\n        }\n        function panicOnRootError(root, error) {\n            // There's no ancestor that can handle this exception. This should never\n            // happen because the root is supposed to capture all errors that weren't\n            // caught by an error boundary. This is a fatal error, or panic condition,\n            // because we've run out of ways to recover.\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(error, root.current)); // Set `workInProgress` to null. This represents advancing to the next\n            // sibling, or the parent if there are no siblings. But since the root\n            // has no siblings nor a parent, we set it to null. Usually this is\n            // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n            // intentionally not calling those, we need set it here.\n            // TODO: Consider calling `unwindWork` to pop the contexts.\n            workInProgress = null;\n        }\n        function completeUnitOfWork(unitOfWork) {\n            // Attempt to complete the current unit of work, then move to the next\n            // sibling. If there are no more siblings, return to the parent fiber.\n            var completedWork = unitOfWork;\n            do {\n                {\n                    if ((completedWork.flags & Incomplete) !== NoFlags$1) {\n                        // NOTE: If we re-enable sibling prerendering in some cases, this branch\n                        // is where we would switch to the unwinding path.\n                        error('Internal React error: Expected this fiber to be complete, but ' + \"it isn't. It should have been unwound. This is a bug in React.\");\n                    }\n                }\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = completedWork.alternate;\n                var returnFiber = completedWork.return;\n                var next = void 0;\n                if ((completedWork.mode & ProfileMode) === NoMode) {\n                    {\n                        next = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n                    }\n                } else {\n                    startProfilerTimer(completedWork);\n                    {\n                        next = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n                    }\n                    stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n                }\n                if (next !== null) {\n                    // Completing this fiber spawned new work. Work on that next.\n                    workInProgress = next;\n                    return;\n                }\n                var siblingFiber = completedWork.sibling;\n                if (siblingFiber !== null) {\n                    // If there is more work to do in this returnFiber, do that next.\n                    workInProgress = siblingFiber;\n                    return;\n                } // Otherwise, return to the parent\n                // $FlowFixMe[incompatible-type] we bail out when we get a null\n                completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = completedWork;\n            }while (completedWork !== null); // We've reached the root.\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootCompleted;\n            }\n        }\n        function unwindUnitOfWork(unitOfWork) {\n            var incompleteWork = unitOfWork;\n            do {\n                // The current, flushed, state of this fiber is the alternate. Ideally\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = incompleteWork.alternate; // This fiber did not complete because something threw. Pop values off\n                // the stack without entering the complete phase. If this is a boundary,\n                // capture values if possible.\n                var next = unwindWork(current, incompleteWork); // Because this fiber did not complete, don't reset its lanes.\n                if (next !== null) {\n                    // Found a boundary that can handle this exception. Re-renter the\n                    // begin phase. This branch will return us to the normal work loop.\n                    //\n                    // Since we're restarting, remove anything that is not a host effect\n                    // from the effect tag.\n                    next.flags &= HostEffectMask;\n                    workInProgress = next;\n                    return;\n                } // Keep unwinding until we reach either a boundary or the root.\n                if ((incompleteWork.mode & ProfileMode) !== NoMode) {\n                    // Record the render duration for the fiber that errored.\n                    stopProfilerTimerIfRunningAndRecordDelta(incompleteWork, false); // Include the time spent working on failed children before continuing.\n                    var actualDuration = incompleteWork.actualDuration;\n                    var child = incompleteWork.child;\n                    while(child !== null){\n                        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        actualDuration += child.actualDuration;\n                        child = child.sibling;\n                    }\n                    incompleteWork.actualDuration = actualDuration;\n                } // TODO: Once we stop prerendering siblings, instead of resetting the parent\n                // of the node being unwound, we should be able to reset node itself as we\n                // unwind the stack. Saves an additional null check.\n                var returnFiber = incompleteWork.return;\n                if (returnFiber !== null) {\n                    // Mark the parent fiber as incomplete and clear its subtree flags.\n                    // TODO: Once we stop prerendering siblings, we may be able to get rid of\n                    // the Incomplete flag because unwinding to the nearest boundary will\n                    // happen synchronously.\n                    returnFiber.flags |= Incomplete;\n                    returnFiber.subtreeFlags = NoFlags$1;\n                    returnFiber.deletions = null;\n                } // NOTE: If we re-enable sibling prerendering in some cases, here we\n                // would switch to the normal completion path: check if a sibling\n                // exists, and if so, begin work on it.\n                // Otherwise, return to the parent\n                // $FlowFixMe[incompatible-type] we bail out when we get a null\n                incompleteWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = incompleteWork;\n            }while (incompleteWork !== null); // We've unwound all the way to the root.\n            workInProgressRootExitStatus = RootDidNotComplete;\n            workInProgress = null;\n        }\n        function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane) {\n            // TODO: This no longer makes any sense. We already wrap the mutation and\n            // layout phases. Should be able to remove.\n            var prevTransition = ReactSharedInternals.T;\n            var previousUpdateLanePriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane);\n            } finally{\n                ReactSharedInternals.T = prevTransition;\n                setCurrentUpdatePriority(previousUpdateLanePriority);\n            }\n            return null;\n        }\n        function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane) {\n            do {\n                // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n                // means `flushPassiveEffects` will sometimes result in additional\n                // passive effects. So we need to keep flushing in a loop until there are\n                // no more pending effects.\n                // TODO: Might be better if `flushPassiveEffects` did not automatically\n                // flush synchronous work at the end, to avoid factoring hazards like this.\n                flushPassiveEffects();\n            }while (rootWithPendingPassiveEffects !== null);\n            flushRenderPhaseStrictModeWarningsInDEV();\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            }\n            var finishedWork = root.finishedWork;\n            var lanes = root.finishedLanes;\n            {\n                markCommitStarted(lanes);\n            }\n            if (finishedWork === null) {\n                {\n                    markCommitStopped();\n                }\n                return null;\n            } else {\n                {\n                    if (lanes === NoLanes) {\n                        error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n                    }\n                }\n            }\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            if (finishedWork === root.current) {\n                throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n            } // commitRoot never returns a continuation; it always finishes synchronously.\n            // So we can clear these now to allow a new callback to be scheduled.\n            root.callbackNode = null;\n            root.callbackPriority = NoLane;\n            root.cancelPendingCommit = null; // Check which lanes no longer have any work scheduled on them, and mark\n            // those as finished.\n            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes); // Make sure to account for lanes that were updated by a concurrent event\n            // during the render phase; don't mark them as finished.\n            var concurrentlyUpdatedLanes = getConcurrentlyUpdatedLanes();\n            remainingLanes = mergeLanes(remainingLanes, concurrentlyUpdatedLanes);\n            markRootFinished(root, remainingLanes, spawnedLane); // Reset this before firing side effects so we can detect recursive updates.\n            didIncludeCommitPhaseUpdate = false;\n            if (root === workInProgressRoot) {\n                // We can reset these now that they are finished.\n                workInProgressRoot = null;\n                workInProgress = null;\n                workInProgressRootRenderLanes = NoLanes;\n            } // If there are pending passive effects, schedule a callback to process them.\n            // Do this as early as possible, so it is queued before anything else that\n            // might get scheduled in the commit phase. (See #16714.)\n            // TODO: Delete all other places that schedule the passive effect callback\n            // They're redundant.\n            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags$1 || (finishedWork.flags & PassiveMask) !== NoFlags$1) {\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    pendingPassiveEffectsRemainingLanes = remainingLanes; // workInProgressTransitions might be overwritten, so we want\n                    // to store it in pendingPassiveTransitions until they get processed\n                    // We need to pass this through as an argument to commitRoot\n                    // because workInProgressTransitions might have changed between\n                    // the previous render and commit if we throttle the commit\n                    // with setTimeout\n                    pendingPassiveTransitions = transitions;\n                    scheduleCallback(NormalPriority$1, function() {\n                        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n                        // *after* passive effects fire to avoid freeing a cache pool that may\n                        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n                        return null;\n                    });\n                }\n            } // Check if there are any effects in the whole tree.\n            // TODO: This is left over from the effect list implementation, where we had\n            // to check for the existence of `firstEffect` to satisfy Flow. I think the\n            // only other reason this optimization exists is because it affects profiling.\n            // Reconsider whether this is necessary.\n            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags$1;\n            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags$1;\n            if (subtreeHasEffects || rootHasEffect) {\n                var prevTransition = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                var previousPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext; // The commit phase is broken into several sub-phases. We do a separate pass\n                // of the effect list for each phase: all mutation effects come before all\n                // layout effects, and so on.\n                // The first phase a \"before mutation\" phase. We use this phase to read the\n                // state of the host tree right before we mutate it. This is where\n                // getSnapshotBeforeUpdate is called.\n                commitBeforeMutationEffects(root, finishedWork);\n                {\n                    // Mark the current commit time to be shared by all Profilers in this\n                    // batch. This enables them to be grouped later.\n                    recordCommitTime();\n                }\n                commitMutationEffects(root, finishedWork, lanes);\n                resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n                // the mutation phase, so that the previous tree is still current during\n                // componentWillUnmount, but before the layout phase, so that the finished\n                // work is current during componentDidMount/Update.\n                root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n                {\n                    markLayoutEffectsStarted(lanes);\n                }\n                commitLayoutEffects(finishedWork, root, lanes);\n                {\n                    markLayoutEffectsStopped();\n                }\n                // opportunity to paint.\n                requestPaint();\n                executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n            } else {\n                // No effects.\n                root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n                // no effects.\n                // TODO: Maybe there's a better way to report this.\n                {\n                    recordCommitTime();\n                }\n            }\n            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n            if (rootDoesHavePassiveEffects) {\n                // This commit has passive effects. Stash a reference to them. But don't\n                // schedule a callback until after flushing layout work.\n                rootDoesHavePassiveEffects = false;\n                rootWithPendingPassiveEffects = root;\n                pendingPassiveEffectsLanes = lanes;\n            } else {\n                // There were no passive effects, so we can immediately release the cache\n                // pool for this render.\n                releaseRootPooledCache(root, remainingLanes);\n                {\n                    nestedPassiveUpdateCount = 0;\n                    rootWithPassiveNestedUpdates = null;\n                }\n            } // Read this again, since an effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n            // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n            // is to detect whether something might have called setState inside\n            // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n            // inside `componentDidCatch` is itself flawed — that's why we recommend\n            // `getDerivedStateFromError` instead. However, it could be improved by\n            // checking if remainingLanes includes Sync work, instead of whether there's\n            // any work remaining at all (which would also include stuff like Suspense\n            // retries or transitions). It's been like this for a while, though, so fixing\n            // it probably isn't that urgent.\n            if (remainingLanes === NoLanes) {\n                // If there's no remaining work, we can clear the set of already failed\n                // error boundaries.\n                legacyErrorBoundariesThatAlreadyFailed = null;\n            }\n            {\n                if (!rootDidHavePassiveEffects) {\n                    commitDoubleInvokeEffectsInDEV(root);\n                }\n            }\n            onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n            {\n                if (isDevToolsPresent) {\n                    root.memoizedUpdaters.clear();\n                }\n            }\n            {\n                onCommitRoot();\n            }\n            // additional work on this root is scheduled.\n            ensureRootIsScheduled(root);\n            if (recoverableErrors !== null) {\n                // There were errors during this render, but recovered from them without\n                // needing to surface it to the UI. We log them here.\n                var onRecoverableError = root.onRecoverableError;\n                for(var i = 0; i < recoverableErrors.length; i++){\n                    var recoverableError = recoverableErrors[i];\n                    var errorInfo = makeErrorInfo(recoverableError.stack);\n                    {\n                        runWithFiberInDEV(recoverableError.source, onRecoverableError, recoverableError.value, errorInfo);\n                    }\n                }\n            } // If the passive effects are the result of a discrete render, flush them\n            // synchronously at the end of the current task so that the result is\n            // immediately observable. Otherwise, we assume that they are not\n            // order-dependent and do not need to be observed by external systems, so we\n            // can wait until after paint.\n            // TODO: We can optimize this by not scheduling the callback earlier. Since we\n            // currently schedule the callback in multiple places, will wait until those\n            // are consolidated.\n            if (includesSyncLane(pendingPassiveEffectsLanes) && disableLegacyMode) {\n                flushPassiveEffects();\n            } // Read this again, since a passive effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if this render scheduled a cascading synchronous update. This is a\n            // heurstic to detect infinite update loops. We are intentionally excluding\n            // hydration lanes in this check, because render triggered by selective\n            // hydration is conceptually not an update.\n            if (// the render phase or the commit phase. We track these explicitly because\n            // we can't infer from the remaining lanes alone.\n            didIncludeRenderPhaseUpdate || didIncludeCommitPhaseUpdate || // Was the finished render the result of an update (not hydration)?\n            includesSomeLane(lanes, UpdateLanes) && // Did it schedule a sync update?\n            includesSomeLane(remainingLanes, SyncUpdateLanes)) {\n                {\n                    markNestedUpdateScheduled();\n                }\n                // finishing. If there are too many, it indicates an infinite update loop.\n                if (root === rootWithNestedUpdates) {\n                    nestedUpdateCount++;\n                } else {\n                    nestedUpdateCount = 0;\n                    rootWithNestedUpdates = root;\n                }\n            } else {\n                nestedUpdateCount = 0;\n            } // If layout work was scheduled, flush it now.\n            flushSyncWorkOnAllRoots();\n            {\n                markCommitStopped();\n            }\n            return null;\n        }\n        function makeErrorInfo(componentStack) {\n            var errorInfo = {\n                componentStack: componentStack\n            };\n            {\n                Object.defineProperty(errorInfo, 'digest', {\n                    get: function() {\n                        error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError.' + ' This property is no longer provided as part of errorInfo but can be accessed as a property' + ' of the Error instance itself.');\n                    }\n                });\n            }\n            return errorInfo;\n        }\n        function releaseRootPooledCache(root, remainingLanes) {\n            {\n                var pooledCacheLanes = root.pooledCacheLanes &= remainingLanes;\n                if (pooledCacheLanes === NoLanes) {\n                    // None of the remaining work relies on the cache pool. Clear it so\n                    // subsequent requests get a new cache\n                    var pooledCache = root.pooledCache;\n                    if (pooledCache != null) {\n                        root.pooledCache = null;\n                        releaseCache(pooledCache);\n                    }\n                }\n            }\n        }\n        function flushPassiveEffects() {\n            // Returns whether passive effects were flushed.\n            // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n            // probably just combine the two functions. I believe they were only separate\n            // in the first place because we used to wrap it with\n            // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n            // priority within React itself, so we can mutate the variable directly.\n            if (rootWithPendingPassiveEffects !== null) {\n                // Cache the root since rootWithPendingPassiveEffects is cleared in\n                // flushPassiveEffectsImpl\n                var root = rootWithPendingPassiveEffects; // Cache and clear the remaining lanes flag; it must be reset since this\n                // method can be called from various places, not always from commitRoot\n                // where the remaining lanes are known\n                var remainingLanes = pendingPassiveEffectsRemainingLanes;\n                pendingPassiveEffectsRemainingLanes = NoLanes;\n                var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n                var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n                var prevTransition = ReactSharedInternals.T;\n                var previousPriority = getCurrentUpdatePriority();\n                try {\n                    setCurrentUpdatePriority(priority);\n                    ReactSharedInternals.T = null;\n                    return flushPassiveEffectsImpl();\n                } finally{\n                    setCurrentUpdatePriority(previousPriority);\n                    ReactSharedInternals.T = prevTransition; // Once passive effects have run for the tree - giving components a\n                    // chance to retain cache instances they use - release the pooled\n                    // cache at the root (if there is one)\n                    releaseRootPooledCache(root, remainingLanes);\n                }\n            }\n            return false;\n        }\n        function enqueuePendingPassiveProfilerEffect(fiber) {\n            {\n                pendingPassiveProfilerEffects.push(fiber);\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback(NormalPriority$1, function() {\n                        flushPassiveEffects();\n                        return null;\n                    });\n                }\n            }\n        }\n        function flushPassiveEffectsImpl() {\n            if (rootWithPendingPassiveEffects === null) {\n                return false;\n            } // Cache and clear the transitions flag\n            var transitions = pendingPassiveTransitions;\n            pendingPassiveTransitions = null;\n            var root = rootWithPendingPassiveEffects;\n            var lanes = pendingPassiveEffectsLanes;\n            rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n            // Figure out why and fix it. It's not causing any known issues (probably\n            // because it's only used for profiling), but it's a refactor hazard.\n            pendingPassiveEffectsLanes = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Cannot flush passive effects while already rendering.');\n            }\n            {\n                isFlushingPassiveEffects = true;\n                didScheduleUpdateDuringPassiveEffects = false;\n            }\n            {\n                markPassiveEffectsStarted(lanes);\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            commitPassiveUnmountEffects(root.current);\n            commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects\n            {\n                var profilerEffects = pendingPassiveProfilerEffects;\n                pendingPassiveProfilerEffects = [];\n                for(var i = 0; i < profilerEffects.length; i++){\n                    var fiber = profilerEffects[i];\n                    commitPassiveEffectDurations(root, fiber);\n                }\n            }\n            {\n                markPassiveEffectsStopped();\n            }\n            {\n                commitDoubleInvokeEffectsInDEV(root);\n            }\n            executionContext = prevExecutionContext;\n            flushSyncWorkOnAllRoots();\n            {\n                // If additional passive effects were scheduled, increment a counter. If this\n                // exceeds the limit, we'll fire a warning.\n                if (didScheduleUpdateDuringPassiveEffects) {\n                    if (root === rootWithPassiveNestedUpdates) {\n                        nestedPassiveUpdateCount++;\n                    } else {\n                        nestedPassiveUpdateCount = 0;\n                        rootWithPassiveNestedUpdates = root;\n                    }\n                } else {\n                    nestedPassiveUpdateCount = 0;\n                }\n                isFlushingPassiveEffects = false;\n                didScheduleUpdateDuringPassiveEffects = false;\n            }\n            onPostCommitRoot(root);\n            {\n                var stateNode = root.current.stateNode;\n                stateNode.effectDuration = 0;\n                stateNode.passiveEffectDuration = 0;\n            }\n            return true;\n        }\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\n            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n        }\n        function markLegacyErrorBoundaryAsFailed(instance) {\n            if (legacyErrorBoundariesThatAlreadyFailed === null) {\n                legacyErrorBoundariesThatAlreadyFailed = new Set([\n                    instance\n                ]);\n            } else {\n                legacyErrorBoundariesThatAlreadyFailed.add(instance);\n            }\n        }\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n            var errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n            var update = createRootErrorUpdate(rootFiber.stateNode, errorInfo, SyncLane);\n            var root = enqueueUpdate(rootFiber, update, SyncLane);\n            if (root !== null) {\n                markRootUpdated(root, SyncLane);\n                ensureRootIsScheduled(root);\n            }\n        }\n        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n            {\n                setIsRunningInsertionEffect(false);\n            }\n            if (sourceFiber.tag === HostRoot) {\n                // Error was thrown at the root. There is no parent, so the root\n                // itself should capture it.\n                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n                return;\n            }\n            var fiber = nearestMountedAncestor;\n            while(fiber !== null){\n                if (fiber.tag === HostRoot) {\n                    captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n                    return;\n                } else if (fiber.tag === ClassComponent) {\n                    var ctor = fiber.type;\n                    var instance = fiber.stateNode;\n                    if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n                        var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n                        var update = createClassErrorUpdate(SyncLane);\n                        var root = enqueueUpdate(fiber, update, SyncLane);\n                        if (root !== null) {\n                            initializeClassErrorUpdate(update, root, fiber, errorInfo);\n                            markRootUpdated(root, SyncLane);\n                            ensureRootIsScheduled(root);\n                        }\n                        return;\n                    }\n                }\n                fiber = fiber.return;\n            }\n            {\n                error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Potential ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error$1);\n            }\n        }\n        function attachPingListener(root, wakeable, lanes) {\n            // Attach a ping listener\n            //\n            // The data might resolve before we have a chance to commit the fallback. Or,\n            // in the case of a refresh, we'll never commit a fallback. So we need to\n            // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n            // try rendering the tree again.\n            //\n            // Only attach a listener if one does not already exist for the lanes\n            // we're currently rendering (which acts like a \"thread ID\" here).\n            //\n            // We only need to do this in concurrent mode. Legacy Suspense always\n            // commits fallbacks synchronously, so there are no pings.\n            var pingCache = root.pingCache;\n            var threadIDs;\n            if (pingCache === null) {\n                pingCache = root.pingCache = new PossiblyWeakMap();\n                threadIDs = new Set();\n                pingCache.set(wakeable, threadIDs);\n            } else {\n                threadIDs = pingCache.get(wakeable);\n                if (threadIDs === undefined) {\n                    threadIDs = new Set();\n                    pingCache.set(wakeable, threadIDs);\n                }\n            }\n            if (!threadIDs.has(lanes)) {\n                workInProgressRootDidAttachPingListener = true; // Memoize using the thread ID to prevent redundant listeners.\n                threadIDs.add(lanes);\n                var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n                {\n                    if (isDevToolsPresent) {\n                        // If we have pending work still, restore the original updaters\n                        restorePendingUpdaters(root, lanes);\n                    }\n                }\n                wakeable.then(ping, ping);\n            }\n        }\n        function pingSuspendedRoot(root, wakeable, pingedLanes) {\n            var pingCache = root.pingCache;\n            if (pingCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                pingCache.delete(wakeable);\n            }\n            markRootPinged(root, pingedLanes);\n            warnIfSuspenseResolutionNotWrappedWithActDEV();\n            if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n                // Received a ping at the same priority level at which we're currently\n                // rendering. We might want to restart this render. This should mirror\n                // the logic of whether or not a root suspends once it completes.\n                // TODO: If we're rendering sync either due to Sync, Batched or expired,\n                // we should probably never restart.\n                // If we're suspended with delay, or if it's a retry, we'll always suspend\n                // so we can always restart.\n                if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n                    // Force a restart from the root by unwinding the stack. Unless this is\n                    // being called from the render phase, because that would cause a crash.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        prepareFreshStack(root, NoLanes);\n                    }\n                } else {\n                    // Even though we can't restart right now, we might get an\n                    // opportunity later. So we mark this render as having a ping.\n                    workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n                }\n            }\n            ensureRootIsScheduled(root);\n        }\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\n            // The boundary fiber (a Suspense component or SuspenseList component)\n            // previously was rendered in its fallback state. One of the promises that\n            // suspended it has resolved, which means at least part of the tree was\n            // likely unblocked. Try rendering again, at a new lanes.\n            if (retryLane === NoLane) {\n                // TODO: Assign this to `suspenseState.retryLane`? to avoid\n                // unnecessary entanglement?\n                retryLane = requestRetryLane();\n            } // TODO: Special case idle priority?\n            var root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n            if (root !== null) {\n                markRootUpdated(root, retryLane);\n                ensureRootIsScheduled(root);\n            }\n        }\n        function retryDehydratedSuspenseBoundary(boundaryFiber) {\n            var suspenseState = boundaryFiber.memoizedState;\n            var retryLane = NoLane;\n            if (suspenseState !== null) {\n                retryLane = suspenseState.retryLane;\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\n            var retryLane = NoLane; // Default\n            var retryCache;\n            switch(boundaryFiber.tag){\n                case SuspenseComponent:\n                    retryCache = boundaryFiber.stateNode;\n                    var suspenseState = boundaryFiber.memoizedState;\n                    if (suspenseState !== null) {\n                        retryLane = suspenseState.retryLane;\n                    }\n                    break;\n                case SuspenseListComponent:\n                    retryCache = boundaryFiber.stateNode;\n                    break;\n                case OffscreenComponent:\n                    {\n                        var instance = boundaryFiber.stateNode;\n                        retryCache = instance._retryCache;\n                        break;\n                    }\n                default:\n                    throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n            }\n            if (retryCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                retryCache.delete(wakeable);\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function throwIfInfiniteUpdateLoopDetected() {\n            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n                nestedUpdateCount = 0;\n                nestedPassiveUpdateCount = 0;\n                rootWithNestedUpdates = null;\n                rootWithPassiveNestedUpdates = null;\n                {\n                    if (executionContext & RenderContext && workInProgressRoot !== null) {\n                        // We're in the render phase. Disable the concurrent error recovery\n                        // mechanism to ensure that the error we're about to throw gets handled.\n                        // We need it to trigger the nearest error boundary so that the infinite\n                        // update loop is broken.\n                        workInProgressRoot.errorRecoveryDisabledLanes = mergeLanes(workInProgressRoot.errorRecoveryDisabledLanes, workInProgressRootRenderLanes);\n                    }\n                }\n                throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n            }\n            {\n                if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n                    nestedPassiveUpdateCount = 0;\n                    rootWithPassiveNestedUpdates = null;\n                    error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n                }\n            }\n        }\n        function flushRenderPhaseStrictModeWarningsInDEV() {\n            {\n                ReactStrictModeWarnings.flushLegacyContextWarning();\n                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n            }\n        }\n        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, parentFiber, isInStrictMode) {\n            if ((parentFiber.subtreeFlags & (PlacementDEV | Visibility)) === NoFlags$1) {\n                // Parent's descendants have already had effects double invoked.\n                // Early exit to avoid unnecessary tree traversal.\n                return;\n            }\n            var child = parentFiber.child;\n            while(child !== null){\n                doubleInvokeEffectsInDEVIfNecessary(root, child, isInStrictMode);\n                child = child.sibling;\n            }\n        } // Unconditionally disconnects and connects passive and layout effects.\n        function doubleInvokeEffectsOnFiber(root, fiber) {\n            var shouldDoubleInvokePassiveEffects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            setIsStrictModeForDevtools(true);\n            disappearLayoutEffects(fiber);\n            if (shouldDoubleInvokePassiveEffects) {\n                disconnectPassiveEffect(fiber);\n            }\n            reappearLayoutEffects(root, fiber.alternate, fiber, false);\n            if (shouldDoubleInvokePassiveEffects) {\n                reconnectPassiveEffects(root, fiber, NoLanes, null, false);\n            }\n            setIsStrictModeForDevtools(false);\n        }\n        function doubleInvokeEffectsInDEVIfNecessary(root, fiber, parentIsInStrictMode) {\n            var isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            var isInStrictMode = parentIsInStrictMode || isStrictModeFiber; // First case: the fiber **is not** of type OffscreenComponent. No\n            // special rules apply to double invoking effects.\n            if (fiber.tag !== OffscreenComponent) {\n                if (fiber.flags & PlacementDEV) {\n                    if (isInStrictMode) {\n                        runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode);\n                    }\n                } else {\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isInStrictMode);\n                }\n                return;\n            } // Second case: the fiber **is** of type OffscreenComponent.\n            // This branch contains cases specific to Offscreen.\n            if (fiber.memoizedState === null) {\n                // Only consider Offscreen that is visible.\n                // TODO (Offscreen) Handle manual mode.\n                if (isInStrictMode && fiber.flags & Visibility) {\n                    // Double invoke effects on Offscreen's subtree only\n                    // if it is visible and its visibility has changed.\n                    runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber);\n                } else if (fiber.subtreeFlags & PlacementDEV) {\n                    // Something in the subtree could have been suspended.\n                    // We need to continue traversal and find newly inserted fibers.\n                    runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isInStrictMode);\n                }\n            }\n        }\n        function commitDoubleInvokeEffectsInDEV(root, hasPassiveEffects) {\n            {\n                {\n                    var doubleInvokeEffects = true;\n                    if (!(root.current.mode & (StrictLegacyMode | StrictEffectsMode))) {\n                        doubleInvokeEffects = false;\n                    }\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n                }\n            }\n        }\n        var didWarnStateUpdateForNotYetMountedComponent = null;\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n            {\n                if ((executionContext & RenderContext) !== NoContext) {\n                    // We let the other warning about render phase updates deal with this one.\n                    return;\n                }\n                var tag = fiber.tag;\n                if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n                    // Only warn for user-defined components, not internal ones like Suspense.\n                    return;\n                } // We show the whole stack but dedupe on the top component's name because\n                // the problematic code almost always lies inside that component.\n                var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n                if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n                } else {\n                    didWarnStateUpdateForNotYetMountedComponent = new Set([\n                        componentName\n                    ]);\n                }\n                runWithFiberInDEV(fiber, function() {\n                    error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n                });\n            }\n        }\n        var didWarnAboutUpdateInRender = false;\n        var didWarnAboutUpdateInRenderForAnotherComponent;\n        {\n            didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n        }\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n            {\n                if (isRendering) {\n                    switch(fiber.tag){\n                        case FunctionComponent:\n                        case ForwardRef:\n                        case SimpleMemoComponent:\n                            {\n                                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n                                var dedupeKey = renderingComponentName;\n                                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                                    var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n                                    error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://react.dev/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n                                }\n                                break;\n                            }\n                        case ClassComponent:\n                            {\n                                if (!didWarnAboutUpdateInRender) {\n                                    error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n                                    didWarnAboutUpdateInRender = true;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function restorePendingUpdaters(root, lanes) {\n            {\n                if (isDevToolsPresent) {\n                    var memoizedUpdaters = root.memoizedUpdaters;\n                    memoizedUpdaters.forEach(function(schedulingFiber) {\n                        addFiberToLanesMap(root, schedulingFiber, lanes);\n                    }); // This function intentionally does not clear memoized updaters.\n                // Those may still be relevant to the current commit\n                // and a future one (e.g. Suspense).\n                }\n            }\n        }\n        var fakeActCallbackNode = {}; // $FlowFixMe[missing-local-annot]\n        function scheduleCallback(priorityLevel, callback) {\n            {\n                // If we're currently inside an `act` scope, bypass Scheduler and push to\n                // the `act` queue instead.\n                var actQueue = ReactSharedInternals.actQueue;\n                if (actQueue !== null) {\n                    actQueue.push(callback);\n                    return fakeActCallbackNode;\n                } else {\n                    return scheduleCallback$3(priorityLevel, callback);\n                }\n            }\n        }\n        function shouldForceFlushFallbacksInDEV() {\n            // Never force flush in production. This function should get stripped out.\n            return ReactSharedInternals.actQueue !== null;\n        }\n        function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n            {\n                {\n                    if (!isConcurrentActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                }\n                if (ReactSharedInternals.actQueue === null) {\n                    runWithFiberInDEV(fiber, function() {\n                        error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://react.dev/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n                    });\n                }\n            }\n        }\n        function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n            {\n                if (isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null) {\n                    error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://react.dev/link/wrap-tests-with-act');\n                }\n            }\n        }\n        function setIsRunningInsertionEffect(isRunning) {\n            {\n                isRunningInsertionEffect = isRunning;\n            }\n        }\n        /* eslint-disable react-internal/prod-error-codes */ // Used by React Refresh runtime through DevTools Global Hook.\n        var resolveFamily = null;\n        var failedBoundaries = null;\n        var setRefreshHandler = function(handler) {\n            {\n                resolveFamily = handler;\n            }\n        };\n        function resolveFunctionForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function resolveClassForHotReloading(type) {\n            // No implementation differences.\n            return resolveFunctionForHotReloading(type);\n        }\n        function resolveForwardRefForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    // Check if we're dealing with a real forwardRef. Don't want to crash early.\n                    if (type !== null && type !== undefined && typeof type.render === 'function') {\n                        // ForwardRef is special because its resolved .type is an object,\n                        // but it's possible that we only have its inner render function in the map.\n                        // If that inner render function is different, we'll build a new forwardRef type.\n                        var currentRender = resolveFunctionForHotReloading(type.render);\n                        if (type.render !== currentRender) {\n                            var syntheticType = {\n                                $$typeof: REACT_FORWARD_REF_TYPE,\n                                render: currentRender\n                            };\n                            if (type.displayName !== undefined) {\n                                syntheticType.displayName = type.displayName;\n                            }\n                            return syntheticType;\n                        }\n                    }\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function isCompatibleFamilyForHotReloading(fiber, element) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return false;\n                }\n                var prevType = fiber.elementType;\n                var nextType = element.type; // If we got here, we know types aren't === equal.\n                var needsCompareFamilies = false;\n                var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n                switch(fiber.tag){\n                    case ClassComponent:\n                        {\n                            if (typeof nextType === 'function') {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case FunctionComponent:\n                        {\n                            if (typeof nextType === 'function') {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                // We don't know the inner type yet.\n                                // We're going to assume that the lazy inner type is stable,\n                                // and so it is sufficient to avoid reconciling it away.\n                                // We're not going to unwrap or actually use the new lazy type.\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case ForwardRef:\n                        {\n                            if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if ($$typeofNextType === REACT_MEMO_TYPE) {\n                                // TODO: if it was but can no longer be simple,\n                                // we shouldn't set this.\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    default:\n                        return false;\n                } // Check if both types have a family and it's the same one.\n                if (needsCompareFamilies) {\n                    // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n                    // This means both of them need to be registered to preserve state.\n                    // If we unwrapped and compared the inner types for wrappers instead,\n                    // then we would risk falsely saying two separate memo(Foo)\n                    // calls are equivalent because they wrap the same Foo function.\n                    var prevFamily = resolveFamily(prevType); // $FlowFixMe[not-a-function] found when upgrading Flow\n                    if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        function markFailedErrorBoundaryForHotReloading(fiber) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                if (typeof WeakSet !== 'function') {\n                    return;\n                }\n                if (failedBoundaries === null) {\n                    failedBoundaries = new WeakSet();\n                }\n                failedBoundaries.add(fiber);\n            }\n        }\n        var scheduleRefresh = function(root, update) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\n                flushPassiveEffects();\n                scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n                flushSyncWork();\n            }\n        };\n        var scheduleRoot = function(root, element) {\n            {\n                if (root.context !== emptyContextObject) {\n                    // Super edge case: root has a legacy _renderSubtree context\n                    // but we don't know the parentComponent so we can't pass it.\n                    // Just ignore. We'll delete this with _renderSubtree code path later.\n                    return;\n                }\n                updateContainerSync(element, root, null, null);\n                flushSyncWork();\n            }\n        };\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n            {\n                var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                if (resolveFamily === null) {\n                    throw new Error('Expected resolveFamily to be set during hot reload.');\n                }\n                var needsRender = false;\n                var needsRemount = false;\n                if (candidateType !== null) {\n                    var family = resolveFamily(candidateType);\n                    if (family !== undefined) {\n                        if (staleFamilies.has(family)) {\n                            needsRemount = true;\n                        } else if (updatedFamilies.has(family)) {\n                            if (tag === ClassComponent) {\n                                needsRemount = true;\n                            } else {\n                                needsRender = true;\n                            }\n                        }\n                    }\n                }\n                if (failedBoundaries !== null) {\n                    if (failedBoundaries.has(fiber) || // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    alternate !== null && failedBoundaries.has(alternate)) {\n                        needsRemount = true;\n                    }\n                }\n                if (needsRemount) {\n                    fiber._debugNeedsRemount = true;\n                }\n                if (needsRemount || needsRender) {\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n                if (child !== null && !needsRemount) {\n                    scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n                }\n                if (sibling !== null) {\n                    scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n                }\n            }\n        }\n        var findHostInstancesForRefresh = function(root, families) {\n            {\n                var hostInstances = new Set();\n                var types = new Set(families.map(function(family) {\n                    return family.current;\n                }));\n                findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n                return hostInstances;\n            }\n        };\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n            {\n                var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                var didMatch = false;\n                if (candidateType !== null) {\n                    if (types.has(candidateType)) {\n                        didMatch = true;\n                    }\n                }\n                if (didMatch) {\n                    // We have a match. This only drills down to the closest host components.\n                    // There's no need to search deeper because for the purpose of giving\n                    // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n                    findHostInstancesForFiberShallowly(fiber, hostInstances);\n                } else {\n                    // If there's no match, maybe there will be one further down in the child tree.\n                    if (child !== null) {\n                        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n                    }\n                }\n                if (sibling !== null) {\n                    findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n                }\n            }\n        }\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n                if (foundHostInstances) {\n                    return;\n                } // If we didn't find any host children, fallback to closest host parent.\n                var node = fiber;\n                while(true){\n                    switch(node.tag){\n                        case HostSingleton:\n                        case HostComponent:\n                            hostInstances.add(node.stateNode);\n                            return;\n                        case HostPortal:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                        case HostRoot:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                    }\n                    if (node.return === null) {\n                        throw new Error('Expected to reach root first.');\n                    }\n                    node = node.return;\n                }\n            }\n        }\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var node = fiber;\n                var foundHostInstances = false;\n                while(true){\n                    if (node.tag === HostComponent || node.tag === HostHoistable || (supportsSingletons ? node.tag === HostSingleton : false)) {\n                        // We got a match.\n                        foundHostInstances = true;\n                        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === fiber) {\n                        return foundHostInstances;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === fiber) {\n                            return foundHostInstances;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n            return false;\n        }\n        var hasBadMapPolyfill;\n        {\n            hasBadMapPolyfill = false;\n            try {\n                var nonExtensibleObject = Object.preventExtensions({});\n                /* eslint-disable no-new */ new Map([\n                    [\n                        nonExtensibleObject,\n                        null\n                    ]\n                ]);\n                new Set([\n                    nonExtensibleObject\n                ]);\n            /* eslint-enable no-new */ } catch (e) {\n                // TODO: Consider warning about bad polyfills\n                hasBadMapPolyfill = true;\n            }\n        }\n        function FiberNode(tag, pendingProps, key, mode) {\n            // Instance\n            this.tag = tag;\n            this.key = key;\n            this.elementType = null;\n            this.type = null;\n            this.stateNode = null; // Fiber\n            this.return = null;\n            this.child = null;\n            this.sibling = null;\n            this.index = 0;\n            this.ref = null;\n            this.refCleanup = null;\n            this.pendingProps = pendingProps;\n            this.memoizedProps = null;\n            this.updateQueue = null;\n            this.memoizedState = null;\n            this.dependencies = null;\n            this.mode = mode; // Effects\n            this.flags = NoFlags$1;\n            this.subtreeFlags = NoFlags$1;\n            this.deletions = null;\n            this.lanes = NoLanes;\n            this.childLanes = NoLanes;\n            this.alternate = null;\n            {\n                // Note: The following is done to avoid a v8 performance cliff.\n                //\n                // Initializing the fields below to smis and later updating them with\n                // double values will cause Fibers to end up having separate shapes.\n                // This behavior/bug has something to do with Object.preventExtension().\n                // Fortunately this only impacts DEV builds.\n                // Unfortunately it makes React unusably slow for some applications.\n                // To work around this, initialize the fields below with doubles.\n                //\n                // Learn more about this here:\n                // https://github.com/facebook/react/issues/14365\n                // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n                this.actualDuration = Number.NaN;\n                this.actualStartTime = Number.NaN;\n                this.selfBaseDuration = Number.NaN;\n                this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n                // This won't trigger the performance cliff mentioned above,\n                // and it simplifies other profiler code (including DevTools).\n                this.actualDuration = 0;\n                this.actualStartTime = -1;\n                this.selfBaseDuration = 0;\n                this.treeBaseDuration = 0;\n            }\n            {\n                // This isn't directly used but is handy for debugging internals:\n                this._debugInfo = null;\n                this._debugOwner = null;\n                this._debugNeedsRemount = false;\n                this._debugHookTypes = null;\n                if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n                    Object.preventExtensions(this);\n                }\n            }\n        } // This is a constructor function, rather than a POJO constructor, still\n        // please ensure we do the following:\n        // 1) Nobody should add any instance methods on this. Instance methods can be\n        //    more difficult to predict when they get optimized and they are almost\n        //    never inlined properly in static compilers.\n        // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n        //    always know when it is a fiber.\n        // 3) We might want to experiment with using numeric keys since they are easier\n        //    to optimize in a non-JIT environment.\n        // 4) We can easily go from a constructor to a createFiber object literal if that\n        //    is faster.\n        // 5) It should be easy to port this to a C struct and keep a C implementation\n        //    compatible.\n        function createFiber(tag, pendingProps, key, mode) {\n            // $FlowFixMe[invalid-constructor]: the shapes are exact here but Flow doesn't like constructors\n            return new FiberNode(tag, pendingProps, key, mode);\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function isSimpleFunctionComponent(type) {\n            return typeof type === 'function' && !shouldConstruct(type) && type.defaultProps === undefined;\n        }\n        function isFunctionClassComponent(type) {\n            return shouldConstruct(type);\n        } // This is used to create an alternate fiber to do work on.\n        function createWorkInProgress(current, pendingProps) {\n            var workInProgress = current.alternate;\n            if (workInProgress === null) {\n                // We use a double buffering pooling technique because we know that we'll\n                // only ever need at most two versions of a tree. We pool the \"other\" unused\n                // node that we're free to reuse. This is lazily created to avoid allocating\n                // extra objects for things that are never updated. It also allow us to\n                // reclaim the extra memory if needed.\n                workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n                workInProgress.elementType = current.elementType;\n                workInProgress.type = current.type;\n                workInProgress.stateNode = current.stateNode;\n                {\n                    // DEV-only fields\n                    workInProgress._debugOwner = current._debugOwner;\n                    workInProgress._debugHookTypes = current._debugHookTypes;\n                }\n                workInProgress.alternate = current;\n                current.alternate = workInProgress;\n            } else {\n                workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // We already have an alternate.\n                // Reset the effect tag.\n                workInProgress.flags = NoFlags$1; // The effects are no longer valid.\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.deletions = null;\n                {\n                    // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n                    // This prevents time from endlessly accumulating in new commits.\n                    // This has the downside of resetting values for different priority renders,\n                    // But works for yielding (the common case) and should support resuming.\n                    workInProgress.actualDuration = 0;\n                    workInProgress.actualStartTime = -1;\n                }\n            } // Reset all effects except static ones.\n            // Static effects are not specific to a render.\n            workInProgress.flags = current.flags & StaticMask;\n            workInProgress.childLanes = current.childLanes;\n            workInProgress.lanes = current.lanes;\n            workInProgress.child = current.child;\n            workInProgress.memoizedProps = current.memoizedProps;\n            workInProgress.memoizedState = current.memoizedState;\n            workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n            // it cannot be shared with the current fiber.\n            var currentDependencies = current.dependencies;\n            workInProgress.dependencies = currentDependencies === null ? null : {\n                lanes: currentDependencies.lanes,\n                firstContext: currentDependencies.firstContext\n            }; // These will be overridden during the parent's reconciliation\n            workInProgress.sibling = current.sibling;\n            workInProgress.index = current.index;\n            workInProgress.ref = current.ref;\n            workInProgress.refCleanup = current.refCleanup;\n            {\n                workInProgress.selfBaseDuration = current.selfBaseDuration;\n                workInProgress.treeBaseDuration = current.treeBaseDuration;\n            }\n            {\n                workInProgress._debugInfo = current._debugInfo;\n                workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n                switch(workInProgress.tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                        workInProgress.type = resolveFunctionForHotReloading(current.type);\n                        break;\n                    case ClassComponent:\n                        workInProgress.type = resolveClassForHotReloading(current.type);\n                        break;\n                    case ForwardRef:\n                        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n                        break;\n                }\n            }\n            return workInProgress;\n        } // Used to reuse a Fiber for a second pass.\n        function resetWorkInProgress(workInProgress, renderLanes) {\n            // This resets the Fiber to what createFiber or createWorkInProgress would\n            // have set the values to before during the first pass. Ideally this wouldn't\n            // be necessary but unfortunately many code paths reads from the workInProgress\n            // when they should be reading from current and writing to workInProgress.\n            // We assume pendingProps, index, key, ref, return are still untouched to\n            // avoid doing another reconciliation.\n            // Reset the effect flags but keep any Placement tags, since that's something\n            // that child fiber is setting, not the reconciliation.\n            workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n            var current = workInProgress.alternate;\n            if (current === null) {\n                // Reset to createFiber's initial values.\n                workInProgress.childLanes = NoLanes;\n                workInProgress.lanes = renderLanes;\n                workInProgress.child = null;\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.memoizedProps = null;\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null;\n                workInProgress.dependencies = null;\n                workInProgress.stateNode = null;\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = 0;\n                    workInProgress.treeBaseDuration = 0;\n                }\n            } else {\n                // Reset to the cloned values that createWorkInProgress would've.\n                workInProgress.childLanes = current.childLanes;\n                workInProgress.lanes = current.lanes;\n                workInProgress.child = current.child;\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.deletions = null;\n                workInProgress.memoizedProps = current.memoizedProps;\n                workInProgress.memoizedState = current.memoizedState;\n                workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n                // it cannot be shared with the current fiber.\n                var currentDependencies = current.dependencies;\n                workInProgress.dependencies = currentDependencies === null ? null : {\n                    lanes: currentDependencies.lanes,\n                    firstContext: currentDependencies.firstContext\n                };\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = current.selfBaseDuration;\n                    workInProgress.treeBaseDuration = current.treeBaseDuration;\n                }\n            }\n            return workInProgress;\n        }\n        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n            var mode;\n            {\n                mode = ConcurrentMode;\n                if (isStrictMode === true) {\n                    mode |= StrictLegacyMode | StrictEffectsMode;\n                }\n            }\n            if (isDevToolsPresent) {\n                // Always collect profile timings when DevTools are present.\n                // This enables DevTools to start capturing timing at any point–\n                // Without some nodes in the tree having empty base times.\n                mode |= ProfileMode;\n            }\n            return createFiber(HostRoot, null, null, mode);\n        }\n        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n            var fiberTag = FunctionComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n            var resolvedType = type;\n            if (typeof type === 'function') {\n                if (shouldConstruct(type)) {\n                    fiberTag = ClassComponent;\n                    {\n                        resolvedType = resolveClassForHotReloading(resolvedType);\n                    }\n                } else {\n                    {\n                        resolvedType = resolveFunctionForHotReloading(resolvedType);\n                    }\n                }\n            } else if (typeof type === 'string') {\n                if (supportsResources && supportsSingletons) {\n                    var hostContext = getHostContext();\n                    fiberTag = isHostHoistableType(type, pendingProps, hostContext) ? HostHoistable : isHostSingletonType(type) ? HostSingleton : HostComponent;\n                } else if (supportsResources) {\n                    var _hostContext = getHostContext();\n                    fiberTag = isHostHoistableType(type, pendingProps, _hostContext) ? HostHoistable : HostComponent;\n                } else if (supportsSingletons) {\n                    fiberTag = isHostSingletonType(type) ? HostSingleton : HostComponent;\n                } else {\n                    fiberTag = HostComponent;\n                }\n            } else {\n                getTag: switch(type){\n                    case REACT_FRAGMENT_TYPE:\n                        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n                    case REACT_STRICT_MODE_TYPE:\n                        fiberTag = Mode;\n                        mode |= StrictLegacyMode;\n                        {\n                            // Strict effects should never run on legacy roots\n                            mode |= StrictEffectsMode;\n                        }\n                        break;\n                    case REACT_PROFILER_TYPE:\n                        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_TYPE:\n                        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n                    case REACT_OFFSCREEN_TYPE:\n                        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n                    case REACT_LEGACY_HIDDEN_TYPE:\n                    // Fall through\n                    case REACT_SCOPE_TYPE:\n                    // Fall through\n                    case REACT_TRACING_MARKER_TYPE:\n                    // Fall through\n                    case REACT_DEBUG_TRACING_MODE_TYPE:\n                    // Fall through\n                    default:\n                        {\n                            if (typeof type === 'object' && type !== null) {\n                                switch(type.$$typeof){\n                                    case REACT_PROVIDER_TYPE:\n                                    // Fall through\n                                    case REACT_CONTEXT_TYPE:\n                                        {\n                                            fiberTag = ContextProvider;\n                                            break getTag;\n                                        }\n                                    case REACT_CONSUMER_TYPE:\n                                        {\n                                            fiberTag = ContextConsumer;\n                                            break getTag;\n                                        }\n                                    // Fall through\n                                    case REACT_FORWARD_REF_TYPE:\n                                        fiberTag = ForwardRef;\n                                        {\n                                            resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                                        }\n                                        break getTag;\n                                    case REACT_MEMO_TYPE:\n                                        fiberTag = MemoComponent;\n                                        break getTag;\n                                    case REACT_LAZY_TYPE:\n                                        fiberTag = LazyComponent;\n                                        resolvedType = null;\n                                        break getTag;\n                                }\n                            }\n                            var info = '';\n                            var typeString;\n                            {\n                                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n                                    info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n                                }\n                                if (type === null) {\n                                    typeString = 'null';\n                                } else if (isArray(type)) {\n                                    typeString = 'array';\n                                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                                    typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n                                    info = ' Did you accidentally export a JSX literal instead of a component?';\n                                } else {\n                                    typeString = typeof type;\n                                }\n                                var ownerName = owner ? getComponentNameFromOwner(owner) : null;\n                                if (ownerName) {\n                                    info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n                                }\n                            }\n                            throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + typeString + \".\" + info));\n                        }\n                }\n            }\n            var fiber = createFiber(fiberTag, pendingProps, key, mode);\n            fiber.elementType = type;\n            fiber.type = resolvedType;\n            fiber.lanes = lanes;\n            {\n                fiber._debugOwner = owner;\n            }\n            return fiber;\n        }\n        function createFiberFromElement(element, mode, lanes) {\n            var owner = null;\n            {\n                owner = element._owner;\n            }\n            var type = element.type;\n            var key = element.key;\n            var pendingProps = element.props;\n            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n            {\n                fiber._debugOwner = element._owner;\n            }\n            return fiber;\n        }\n        function createFiberFromFragment(elements, mode, lanes, key) {\n            var fiber = createFiber(Fragment, elements, key, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n            {\n                if (typeof pendingProps.id !== 'string') {\n                    error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n                }\n            }\n            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n            fiber.elementType = REACT_PROFILER_TYPE;\n            fiber.lanes = lanes;\n            {\n                fiber.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                };\n            }\n            return fiber;\n        }\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_OFFSCREEN_TYPE;\n            fiber.lanes = lanes;\n            var primaryChildInstance = {\n                _visibility: OffscreenVisible,\n                _pendingVisibility: OffscreenVisible,\n                _pendingMarkers: null,\n                _retryCache: null,\n                _transitions: null,\n                _current: null,\n                detach: function() {\n                    return detachOffscreenInstance(primaryChildInstance);\n                },\n                attach: function() {\n                    return attachOffscreenInstance(primaryChildInstance);\n                }\n            };\n            fiber.stateNode = primaryChildInstance;\n            return fiber;\n        }\n        function createFiberFromText(content, mode, lanes) {\n            var fiber = createFiber(HostText, content, null, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromDehydratedFragment(dehydratedNode) {\n            var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n            fiber.stateNode = dehydratedNode;\n            return fiber;\n        }\n        function createFiberFromPortal(portal, mode, lanes) {\n            var pendingProps = portal.children !== null ? portal.children : [];\n            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n            fiber.lanes = lanes;\n            fiber.stateNode = {\n                containerInfo: portal.containerInfo,\n                pendingChildren: null,\n                // Used by persistent updates\n                implementation: portal.implementation\n            };\n            return fiber;\n        }\n        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n            this.tag = ConcurrentRoot;\n            this.containerInfo = containerInfo;\n            this.pendingChildren = null;\n            this.current = null;\n            this.pingCache = null;\n            this.finishedWork = null;\n            this.timeoutHandle = noTimeout;\n            this.cancelPendingCommit = null;\n            this.context = null;\n            this.pendingContext = null;\n            this.next = null;\n            this.callbackNode = null;\n            this.callbackPriority = NoLane;\n            this.expirationTimes = createLaneMap(NoTimestamp);\n            this.pendingLanes = NoLanes;\n            this.suspendedLanes = NoLanes;\n            this.pingedLanes = NoLanes;\n            this.expiredLanes = NoLanes;\n            this.finishedLanes = NoLanes;\n            this.errorRecoveryDisabledLanes = NoLanes;\n            this.shellSuspendCounter = 0;\n            this.entangledLanes = NoLanes;\n            this.entanglements = createLaneMap(NoLanes);\n            this.hiddenUpdates = createLaneMap(null);\n            this.identifierPrefix = identifierPrefix;\n            this.onUncaughtError = onUncaughtError;\n            this.onCaughtError = onCaughtError;\n            this.onRecoverableError = onRecoverableError;\n            {\n                this.pooledCache = null;\n                this.pooledCacheLanes = NoLanes;\n            }\n            this.formState = formState;\n            this.incompleteTransitions = new Map();\n            {\n                this.effectDuration = 0;\n                this.passiveEffectDuration = 0;\n            }\n            {\n                this.memoizedUpdaters = new Set();\n                var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n                for(var _i = 0; _i < TotalLanes; _i++){\n                    pendingUpdatersLaneMap.push(new Set());\n                }\n            }\n            {\n                {\n                    // TODO: This varies by each renderer.\n                    this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n                }\n            }\n        }\n        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // host config, but because they are passed in at runtime, we have to thread\n        // them through the root constructor. Perhaps we should put them all into a\n        // single type, like a DynamicHostConfig that is defined by the renderer.\n        identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n            // stateNode is any.\n            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n            root.current = uninitializedFiber;\n            uninitializedFiber.stateNode = root;\n            {\n                var initialCache = createCache();\n                retainCache(initialCache); // The pooledCache is a fresh cache instance that is used temporarily\n                // for newly mounted boundaries during a render. In general, the\n                // pooledCache is always cleared from the root at the end of a render:\n                // it is either released when render commits, or moved to an Offscreen\n                // component if rendering suspends. Because the lifetime of the pooled\n                // cache is distinct from the main memoizedState.cache, it must be\n                // retained separately.\n                root.pooledCache = initialCache;\n                retainCache(initialCache);\n                var initialState = {\n                    element: initialChildren,\n                    isDehydrated: hydrate,\n                    cache: initialCache\n                };\n                uninitializedFiber.memoizedState = initialState;\n            }\n            initializeUpdateQueue(uninitializedFiber);\n            return root;\n        }\n        var ReactVersion = '19.0.0';\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return '' + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function createPortal(children, containerInfo, implementation) {\n            var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n            {\n                checkKeyStringCoercion(key);\n            }\n            return {\n                // This tag allow us to uniquely identify this as a React Portal\n                $$typeof: REACT_PORTAL_TYPE,\n                key: key == null ? null : '' + key,\n                children: children,\n                containerInfo: containerInfo,\n                implementation: implementation\n            };\n        }\n        // Might add PROFILE later.\n        var didWarnAboutNestedUpdates;\n        var didWarnAboutFindNodeInStrictMode;\n        {\n            didWarnAboutNestedUpdates = false;\n            didWarnAboutFindNodeInStrictMode = {};\n        }\n        function getContextForSubtree(parentComponent) {\n            if (!parentComponent) {\n                return emptyContextObject;\n            }\n            var fiber = get(parentComponent);\n            var parentContext = findCurrentUnmaskedContext();\n            if (fiber.tag === ClassComponent) {\n                var Component = fiber.type;\n                if (isContextProvider()) {\n                    return processChildContext(fiber, Component, parentContext);\n                }\n            }\n            return parentContext;\n        }\n        function findHostInstance(component) {\n            var fiber = get(component);\n            if (fiber === undefined) {\n                if (typeof component.render === 'function') {\n                    throw new Error('Unable to find node on an unmounted component.');\n                } else {\n                    var keys = Object.keys(component).join(',');\n                    throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                }\n            }\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return getPublicInstance(hostFiber.stateNode);\n        }\n        function findHostInstanceWithWarning(component, methodName) {\n            {\n                var fiber = get(component);\n                if (fiber === undefined) {\n                    if (typeof component.render === 'function') {\n                        throw new Error('Unable to find node on an unmounted component.');\n                    } else {\n                        var keys = Object.keys(component).join(',');\n                        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                    }\n                }\n                var hostFiber = findCurrentHostFiber(fiber);\n                if (hostFiber === null) {\n                    return null;\n                }\n                if (hostFiber.mode & StrictLegacyMode) {\n                    var componentName = getComponentNameFromFiber(fiber) || 'Component';\n                    if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n                        didWarnAboutFindNodeInStrictMode[componentName] = true;\n                        runWithFiberInDEV(hostFiber, function() {\n                            if (fiber.mode & StrictLegacyMode) {\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://react.dev/link/strict-mode-find-node', methodName, methodName, componentName);\n                            } else {\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://react.dev/link/strict-mode-find-node', methodName, methodName, componentName);\n                            }\n                        });\n                    }\n                }\n                return getPublicInstance(hostFiber.stateNode);\n            }\n        }\n        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n            var hydrate = false;\n            var initialChildren = null;\n            return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n        }\n        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n            var hydrate = true;\n            var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState); // TODO: Move this to FiberRoot constructor\n            root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n            // a regular update because the initial render must match was was rendered\n            // on the server.\n            // NOTE: This update intentionally doesn't have a payload. We're only using\n            // the update to schedule work on the root fiber (and, for legacy roots, to\n            // enqueue the callback if one is provided).\n            var current = root.current;\n            var lane = requestUpdateLane(current);\n            var update = createUpdate(lane);\n            update.callback = callback !== undefined && callback !== null ? callback : null;\n            enqueueUpdate(current, update, lane);\n            scheduleInitialHydrationOnRoot(root, lane);\n            return root;\n        }\n        function updateContainer(element, container, parentComponent, callback) {\n            var current = container.current;\n            var lane = requestUpdateLane(current);\n            updateContainerImpl(current, lane, element, container, parentComponent, callback);\n            return lane;\n        }\n        function updateContainerSync(element, container, parentComponent, callback) {\n            if (container.tag === LegacyRoot) {\n                flushPassiveEffects();\n            }\n            var current = container.current;\n            updateContainerImpl(current, SyncLane, element, container, parentComponent, callback);\n            return SyncLane;\n        }\n        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n            {\n                onScheduleRoot(container, element);\n            }\n            {\n                markRenderScheduled(lane);\n            }\n            var context = getContextForSubtree(parentComponent);\n            if (container.context === null) {\n                container.context = context;\n            } else {\n                container.pendingContext = context;\n            }\n            {\n                if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n                    didWarnAboutNestedUpdates = true;\n                    error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');\n                }\n            }\n            var update = createUpdate(lane); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: element\n            };\n            callback = callback === undefined ? null : callback;\n            if (callback !== null) {\n                {\n                    if (typeof callback !== 'function') {\n                        error('Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n                    }\n                }\n                update.callback = callback;\n            }\n            var root = enqueueUpdate(rootFiber, update, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, rootFiber, lane);\n                entangleTransitions(root, rootFiber, lane);\n            }\n        }\n        function getPublicRootInstance(container) {\n            var containerFiber = container.current;\n            if (!containerFiber.child) {\n                return null;\n            }\n            switch(containerFiber.child.tag){\n                case HostSingleton:\n                case HostComponent:\n                    return getPublicInstance(containerFiber.child.stateNode);\n                default:\n                    return containerFiber.child.stateNode;\n            }\n        }\n        function attemptSynchronousHydration(fiber) {\n            switch(fiber.tag){\n                case HostRoot:\n                    {\n                        var root = fiber.stateNode;\n                        if (isRootDehydrated(root)) {\n                            // Flush the first scheduled \"update\".\n                            var lanes = getHighestPriorityPendingLanes(root);\n                            flushRoot(root, lanes);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                        if (_root !== null) {\n                            scheduleUpdateOnFiber(_root, fiber, SyncLane);\n                        }\n                        flushSyncWork(); // If we're still blocked after this, we need to increase\n                        // the priority of any promises resolving within this\n                        // boundary so that they next attempt also has higher pri.\n                        var retryLane = SyncLane;\n                        markRetryLaneIfNotHydrated(fiber, retryLane);\n                        break;\n                    }\n            }\n        }\n        function markRetryLaneImpl(fiber, retryLane) {\n            var suspenseState = fiber.memoizedState;\n            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n            }\n        } // Increases the priority of thenables when they resolve within this boundary.\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\n            markRetryLaneImpl(fiber, retryLane);\n            var alternate = fiber.alternate;\n            if (alternate) {\n                markRetryLaneImpl(alternate, retryLane);\n            }\n        }\n        function attemptContinuousHydration(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority and they should not suspend on I/O,\n                // since you have to wrap anything that might suspend in\n                // Suspense.\n                return;\n            }\n            var lane = SelectiveHydrationLane;\n            var root = enqueueConcurrentRenderForLane(fiber, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, lane);\n            }\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function attemptHydrationAtCurrentPriority(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority other than synchronously flush it.\n                return;\n            }\n            var lane = requestUpdateLane(fiber);\n            var root = enqueueConcurrentRenderForLane(fiber, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, lane);\n            }\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function findHostInstanceWithNoPortals(fiber) {\n            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return getPublicInstance(hostFiber.stateNode);\n        }\n        var shouldErrorImpl = function(fiber) {\n            return null;\n        };\n        function shouldError(fiber) {\n            return shouldErrorImpl(fiber);\n        }\n        var shouldSuspendImpl = function(fiber) {\n            return false;\n        };\n        function shouldSuspend(fiber) {\n            return shouldSuspendImpl(fiber);\n        }\n        var overrideHookState = null;\n        var overrideHookStateDeletePath = null;\n        var overrideHookStateRenamePath = null;\n        var overrideProps = null;\n        var overridePropsDeletePath = null;\n        var overridePropsRenamePath = null;\n        var scheduleUpdate = null;\n        var setErrorHandler = null;\n        var setSuspenseHandler = null;\n        {\n            var copyWithDeleteImpl = function(obj, path, index) {\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === path.length) {\n                    if (isArray(updated)) {\n                        updated.splice(key, 1);\n                    } else {\n                        delete updated[key];\n                    }\n                    return updated;\n                } // $FlowFixMe[incompatible-use] number or string is fine here\n                updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n                return updated;\n            };\n            var copyWithDelete = function(obj, path) {\n                return copyWithDeleteImpl(obj, path, 0);\n            };\n            var copyWithRenameImpl = function(obj, oldPath, newPath, index) {\n                var oldKey = oldPath[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === oldPath.length) {\n                    var newKey = newPath[index]; // $FlowFixMe[incompatible-use] number or string is fine here\n                    updated[newKey] = updated[oldKey];\n                    if (isArray(updated)) {\n                        updated.splice(oldKey, 1);\n                    } else {\n                        delete updated[oldKey];\n                    }\n                } else {\n                    // $FlowFixMe[incompatible-use] number or string is fine here\n                    updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n                }\n                return updated;\n            };\n            var copyWithRename = function(obj, oldPath, newPath) {\n                if (oldPath.length !== newPath.length) {\n                    warn('copyWithRename() expects paths of the same length');\n                    return;\n                } else {\n                    for(var i = 0; i < newPath.length - 1; i++){\n                        if (oldPath[i] !== newPath[i]) {\n                            warn('copyWithRename() expects paths to be the same except for the deepest key');\n                            return;\n                        }\n                    }\n                }\n                return copyWithRenameImpl(obj, oldPath, newPath, 0);\n            };\n            var copyWithSetImpl = function(obj, path, index, value) {\n                if (index >= path.length) {\n                    return value;\n                }\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe[incompatible-use] number or string is fine here\n                updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n                return updated;\n            };\n            var copyWithSet = function(obj, path, value) {\n                return copyWithSetImpl(obj, path, 0, value);\n            };\n            var findHook = function(fiber, id) {\n                // For now, the \"id\" of stateful hooks is just the stateful hook index.\n                // This may change in the future with e.g. nested hooks.\n                var currentHook = fiber.memoizedState;\n                while(currentHook !== null && id > 0){\n                    currentHook = currentHook.next;\n                    id--;\n                }\n                return currentHook;\n            }; // Support DevTools editable values for useState and useReducer.\n            overrideHookState = function(fiber, id, path, value) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithSet(hook.memoizedState, path, value);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            };\n            overrideHookStateDeletePath = function(fiber, id, path) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithDelete(hook.memoizedState, path);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            };\n            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n            overrideProps = function(fiber, path, value) {\n                fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            overridePropsDeletePath = function(fiber, path) {\n                fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            overridePropsRenamePath = function(fiber, oldPath, newPath) {\n                fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            scheduleUpdate = function(fiber) {\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            setErrorHandler = function(newShouldErrorImpl) {\n                shouldErrorImpl = newShouldErrorImpl;\n            };\n            setSuspenseHandler = function(newShouldSuspendImpl) {\n                shouldSuspendImpl = newShouldSuspendImpl;\n            };\n        }\n        function findHostInstanceByFiber(fiber) {\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function emptyFindFiberByHostInstance(instance) {\n            return null;\n        }\n        function getCurrentFiberForDevTools() {\n            return current;\n        }\n        function injectIntoDevTools(devToolsConfig) {\n            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n            return injectInternals({\n                bundleType: devToolsConfig.bundleType,\n                version: devToolsConfig.version,\n                rendererPackageName: devToolsConfig.rendererPackageName,\n                rendererConfig: devToolsConfig.rendererConfig,\n                overrideHookState: overrideHookState,\n                overrideHookStateDeletePath: overrideHookStateDeletePath,\n                overrideHookStateRenamePath: overrideHookStateRenamePath,\n                overrideProps: overrideProps,\n                overridePropsDeletePath: overridePropsDeletePath,\n                overridePropsRenamePath: overridePropsRenamePath,\n                setErrorHandler: setErrorHandler,\n                setSuspenseHandler: setSuspenseHandler,\n                scheduleUpdate: scheduleUpdate,\n                currentDispatcherRef: ReactSharedInternals,\n                findHostInstanceByFiber: findHostInstanceByFiber,\n                findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n                // React Refresh\n                findHostInstancesForRefresh: findHostInstancesForRefresh,\n                scheduleRefresh: scheduleRefresh,\n                scheduleRoot: scheduleRoot,\n                setRefreshHandler: setRefreshHandler,\n                // Enables DevTools to append owner stacks to error messages in DEV mode.\n                getCurrentFiber: getCurrentFiberForDevTools,\n                // Enables DevTools to detect reconciler version rather than renderer version\n                // which may not match for third party renderers.\n                reconcilerVersion: ReactVersion\n            });\n        }\n        exports.attemptContinuousHydration = attemptContinuousHydration;\n        exports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\n        exports.attemptSynchronousHydration = attemptSynchronousHydration;\n        exports.batchedUpdates = batchedUpdates;\n        exports.createComponentSelector = createComponentSelector;\n        exports.createContainer = createContainer;\n        exports.createHasPseudoClassSelector = createHasPseudoClassSelector;\n        exports.createHydrationContainer = createHydrationContainer;\n        exports.createPortal = createPortal;\n        exports.createRoleSelector = createRoleSelector;\n        exports.createTestNameSelector = createTestNameSelector;\n        exports.createTextSelector = createTextSelector;\n        exports.defaultOnCaughtError = defaultOnCaughtError;\n        exports.defaultOnRecoverableError = defaultOnRecoverableError;\n        exports.defaultOnUncaughtError = defaultOnUncaughtError;\n        exports.deferredUpdates = deferredUpdates;\n        exports.discreteUpdates = discreteUpdates;\n        exports.findAllNodes = findAllNodes;\n        exports.findBoundingRects = findBoundingRects;\n        exports.findHostInstance = findHostInstance;\n        exports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\n        exports.findHostInstanceWithWarning = findHostInstanceWithWarning;\n        exports.flushPassiveEffects = flushPassiveEffects;\n        exports.flushSyncFromReconciler = flushSyncFromReconciler;\n        exports.flushSyncWork = flushSyncWork;\n        exports.focusWithin = focusWithin;\n        exports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\n        exports.getPublicRootInstance = getPublicRootInstance;\n        exports.injectIntoDevTools = injectIntoDevTools;\n        exports.isAlreadyRendering = isAlreadyRendering;\n        exports.observeVisibleRects = observeVisibleRects;\n        exports.shouldError = shouldError;\n        exports.shouldSuspend = shouldSuspend;\n        exports.startHostTransition = startHostTransition;\n        exports.updateContainer = updateContainer;\n        exports.updateContainerSync = updateContainerSync;\n        return exports;\n    };\n    module.exports[\"default\"] = module.exports;\n    Object.defineProperty(module.exports, \"__esModule\", ({\n        value: true\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBRWIsSUFBSUEsSUFBcUMsRUFBRTtJQUN6Q0MsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGNBQWNDLFNBQVM7UUFDL0MsSUFBSUYsVUFBVSxDQUFDO1FBQ25CO1FBRUEsSUFBSUcsUUFBUUMsbUJBQU9BLENBQUMsaUdBQU87UUFDM0IsSUFBSUMsWUFBWUQsbUJBQU9BLENBQUMsMERBQVc7UUFFbkMsSUFBSUUsdUJBQXVCSCxNQUFNSSwrREFBK0Q7UUFFaEcsZ0ZBQWdGO1FBQ2hGLGFBQWE7UUFDYixFQUFFO1FBQ0YsOEVBQThFO1FBQzlFLHlFQUF5RTtRQUN6RSxnRkFBZ0Y7UUFDaEYsZ0ZBQWdGO1FBQ2hGLG1DQUFtQztRQUNuQyxFQUFFO1FBQ0YsK0VBQStFO1FBQy9FLDBEQUEwRDtRQUMxRCxnRkFBZ0Y7UUFDaEYsa0NBQWtDO1FBRWxDLElBQUlDLCtCQUErQjtRQUNuQyxJQUFJQyxxQkFBcUIsTUFBTSxtRUFBbUU7UUFFbEcsSUFBSUMsc0NBQXNDLE1BQU0sZ0ZBQWdGO1FBQ2hJLHdEQUF3RDtRQUN4RCxFQUFFO1FBQ0YsOEVBQThFO1FBQzlFLDhEQUE4RDtRQUM5RCxnRkFBZ0Y7UUFDaEYsNkVBQTZFO1FBQzdFLDRFQUE0RTtRQUM1RSxtQ0FBbUM7UUFDbkMsRUFBRTtRQUNGLDBFQUEwRTtRQUMxRSx1QkFBdUI7UUFDdkIsRUFBRTtRQUNGLHVFQUF1RTtRQUV2RSxJQUFJQyx5QkFBeUIsT0FBTyw4QkFBOEI7UUFDbEUsSUFBSUMsOEJBQThCO1FBRWxDLElBQUlDLCtCQUErQixPQUFPLHNEQUFzRDtRQUVoRyxJQUFJQyxxQkFBcUIsT0FBTyxzREFBc0Q7UUFDdEYsSUFBSUMsd0JBQXdCO1FBQzVCLElBQUlDLHdDQUF3QztRQUM1QyxJQUFJQyxvQkFBb0I7UUFDeEIs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ZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAkJCRyZWNvbmNpbGVyKCQkJGNvbmZpZykge1xuICAgIHZhciBleHBvcnRzID0ge307XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgU2NoZWR1bGVyID0gcmVxdWlyZSgnc2NoZWR1bGVyJyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEtpbGxzd2l0Y2hcbi8vXG4vLyBGbGFncyB0aGF0IGV4aXN0IHNvbGVseSB0byB0dXJuIG9mZiBhIGNoYW5nZSBpbiBjYXNlIGl0IGNhdXNlcyBhIHJlZ3Jlc3Npb25cbi8vIHdoZW4gaXQgcm9sbHMgb3V0IHRvIHByb2QuIFdlIHNob3VsZCByZW1vdmUgdGhlc2UgYXMgc29vbiBhcyBwb3NzaWJsZS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGFuZCBvciByZW1vdmUgKG1vZGVyYXRlIGVmZm9ydClcbi8vXG4vLyBGbGFncyB0aGF0IGNhbiBiZSBwcm9iYWJseSBkZWxldGVkIG9yIGxhbmRlZCwgYnV0IG1pZ2h0IHJlcXVpcmUgZXh0cmEgZWZmb3J0XG4vLyBsaWtlIG1pZ3JhdGluZyBpbnRlcm5hbCBjYWxsZXJzIG9yIHBlcmZvcm1hbmNlIHRlc3RpbmcuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVE9ETzogRmluaXNoIHJvbGxpbmcgb3V0IGluIHd3d1xuXG52YXIgZmF2b3JTYWZldHlPdmVySHlkcmF0aW9uUGVyZiA9IHRydWU7XG52YXIgZW5hYmxlQXN5bmNBY3Rpb25zID0gdHJ1ZTsgLy8gTmVlZCB0byByZW1vdmUgZGlkVGltZW91dCBhcmd1bWVudCBmcm9tIFNjaGVkdWxlciBiZWZvcmUgbGFuZGluZ1xuXG52YXIgZGlzYWJsZURlZmF1bHRQcm9wc0V4Y2VwdEZvckNsYXNzZXMgPSB0cnVlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2xhdGVkIGZvciByZW1vdmFsIGluIHRoZSBmdXR1cmUgKHNpZ25pZmljYW50IGVmZm9ydClcbi8vXG4vLyBUaGVzZSBhcmUgZXhwZXJpbWVudHMgdGhhdCBkaWRuJ3Qgd29yayBvdXQsIGFuZCBuZXZlciBzaGlwcGVkLCBidXQgd2UgY2FuJ3Rcbi8vIGRlbGV0ZSBmcm9tIHRoZSBjb2RlYmFzZSB1bnRpbCB3ZSBtaWdyYXRlIGludGVybmFsIGNhbGxlcnMuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQWRkIGEgY2FsbGJhY2sgcHJvcGVydHkgdG8gc3VzcGVuc2UgdG8gbm90aWZ5IHdoaWNoIHByb21pc2VzIGFyZSBjdXJyZW50bHlcbi8vIGluIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgYWxsb3dzIHJlcG9ydGluZyBhbmQgdHJhY2luZyBvZiB3aGF0IGlzIGNhdXNpbmdcbi8vIHRoZSB1c2VyIHRvIHNlZSBhIGxvYWRpbmcgc3RhdGUuXG4vL1xuLy8gQWxzbyBhbGxvd3MgaHlkcmF0aW9uIGNhbGxiYWNrcyB0byBmaXJlIHdoZW4gYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGdldHNcbi8vIGh5ZHJhdGVkIG9yIGRlbGV0ZWQuXG4vL1xuLy8gVGhpcyB3aWxsIGV2ZW50dWFsbHkgYmUgcmVwbGFjZWQgYnkgdGhlIFRyYW5zaXRpb24gVHJhY2luZyBwcm9wb3NhbC5cblxudmFyIGVuYWJsZVN1c3BlbnNlQ2FsbGJhY2sgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIFNjb3BlIHN1cHBvcnQuXG52YXIgZW5hYmxlQXN5bmNJdGVyYWJsZUNoaWxkcmVuID0gZmFsc2U7XG5cbnZhciBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uID0gZmFsc2U7IC8vIEZCLW9ubHkgdXNhZ2UuIFRoZSBuZXcgQVBJIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzLlxuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxudmFyIGFsd2F5c1Rocm90dGxlUmV0cmllcyA9IHRydWU7XG52YXIgcGFzc0NoaWxkcmVuV2hlbkNsb25pbmdQZXJzaXN0ZWROb2RlcyA9IGZhbHNlO1xudmFyIGVuYWJsZU93bmVyU3RhY2tzID0gZmFsc2U7XG52YXIgc3luY0xhbmVFeHBpcmF0aW9uTXMgPSAyNTA7XG52YXIgdHJhbnNpdGlvbkxhbmVFeHBpcmF0aW9uTXMgPSA1MDAwOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhpcyBhbGxvd3MgdXMgdG8gbGFuZCBicmVha2luZyBjaGFuZ2VzIHRvIHJlbW92ZSBsZWdhY3kgbW9kZSBBUElzIGluIGV4cGVyaW1lbnRhbCBidWlsZHNcbi8vIGJlZm9yZSByZW1vdmluZyB0aGVtIGluIHN0YWJsZSBpbiB0aGUgbmV4dCBNYWpvclxuXG52YXIgZGlzYWJsZUxlZ2FjeU1vZGUgPSB0cnVlOyAvLyBNYWtlIDxDb250ZXh0PiBlcXVpdmFsZW50IHRvIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkIG9mIDxDb250ZXh0LkNvbnN1bWVyPlxuLy8gRGVidWdnaW5nIGFuZCBEZXZUb29sc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEFkZHMgdXNlciB0aW1pbmcgbWFya3MgZm9yIGUuZy4gc3RhdGUgdXBkYXRlcywgc3VzcGVuc2UsIGFuZCB3b3JrIGxvb3Agc3R1ZmYsXG4vLyBmb3IgYW4gZXhwZXJpbWVudGFsIHRpbWVsaW5lIHRvb2wuXG5cbnZhciBlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIgPSB0cnVlOyAvLyBIZWxwcyBpZGVudGlmeSBzaWRlIGVmZmVjdHMgaW4gcmVuZGVyLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGVcblxudmFyIGVuYWJsZVByb2ZpbGVyVGltZXIgPSB0cnVlOyAvLyBSZWNvcmQgZHVyYXRpb25zIGZvciBjb21taXQgYW5kIHBhc3NpdmUgZWZmZWN0cyBwaGFzZXMuXG5cbnZhciBlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzID0gdHJ1ZTsgLy8gUGhhc2UgcGFyYW0gcGFzc2VkIHRvIG9uUmVuZGVyIGNhbGxiYWNrIGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYW4gXCJ1cGRhdGVcIiBhbmQgYSBcImNhc2NhZGluZy11cGRhdGVcIi5cblxudmFyIGVuYWJsZVByb2ZpbGVyTmVzdGVkVXBkYXRlUGhhc2UgPSB0cnVlOyAvLyBBZGRzIHZlcmJvc2UgY29uc29sZSBsb2dnaW5nIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wXG5cbnZhciBzdXBwcmVzc1dhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldFN1cHByZXNzV2FybmluZyhuZXdTdXBwcmVzc1dhcm5pbmcpIHtcbiAge1xuICAgIHN1cHByZXNzV2FybmluZyA9IG5ld1N1cHByZXNzV2FybmluZztcbiAgfVxufSAvLyBJbiBERVYsIGNhbGxzIHRvIGNvbnNvbGUud2FybiBhbmQgY29uc29sZS5lcnJvciBnZXQgcmVwbGFjZWRcbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGlmICghc3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIGlzRXJyb3JMb2dnZXIgPSBmb3JtYXQgPT09ICclc1xcblxcbiVzXFxuJyB8fCBmb3JtYXQgPT09ICclb1xcblxcbiVzXFxuXFxuJXNcXG4nO1xuXG4gICAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjaykge1xuICAgICAgLy8gV2Ugb25seSBhZGQgdGhlIGN1cnJlbnQgc3RhY2sgdG8gdGhlIGNvbnNvbGUgd2hlbiBjcmVhdGVUYXNrIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAvLyBTaW5jZSBjcmVhdGVUYXNrIHJlcXVpcmVzIERldlRvb2xzIHRvIGJlIG9wZW4gdG8gd29yaywgdGhpcyBtZWFucyB0aGF0IHN0YWNrc1xuICAgICAgLy8gY2FuIGJlIGxvc3Qgd2hpbGUgRGV2VG9vbHMgaXNuJ3Qgb3BlbiBidXQgd2UgY2FuJ3QgZGV0ZWN0IHRoaXMuXG4gICAgICB2YXIgc3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2soKTtcblxuICAgICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0Vycm9yTG9nZ2VyKSB7XG4gICAgICAvLyBEb24ndCBwcmVmaXggb3VyIGRlZmF1bHQgbG9nZ2luZyBmb3JtYXR0aW5nIGluIFJlYWN0RmliZXJFcnJvckxvZ2dnZXIuXG4gICAgICAvLyBEb24ndCB0b1N0cmluZyB0aGUgYXJndW1lbnRzLlxuICAgICAgYXJncy51bnNoaWZ0KGZvcm1hdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHByZWZpeCBhbmQgc3RvcCB0b1N0cmluZ2luZyBpbiB0aGUgd3JhcHBlciBhbmRcbiAgICAgIC8vIGluc3RlYWQgZG8gaXQgYXQgZWFjaCBjYWxsc2l0ZSBhcyBuZWVkZWQuXG4gICAgICAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICAgIH0pO1xuICAgICAgYXJncy51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTtcbiAgICB9IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG52YXIgTGVnYWN5Um9vdCA9IDA7XG52YXIgQ29uY3VycmVudFJvb3QgPSAxO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG59XG5cbnZhciBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAxO1xudmFyIEhvc3RSb290ID0gMzsgLy8gUm9vdCBvZiBhIGhvc3QgdHJlZS4gQ291bGQgYmUgbmVzdGVkIGluc2lkZSBhbm90aGVyIG5vZGUuXG5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cblxudmFyIEhvc3RDb21wb25lbnQgPSA1O1xudmFyIEhvc3RUZXh0ID0gNjtcbnZhciBGcmFnbWVudCA9IDc7XG52YXIgTW9kZSA9IDg7XG52YXIgQ29udGV4dENvbnN1bWVyID0gOTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSAxMDtcbnZhciBGb3J3YXJkUmVmID0gMTE7XG52YXIgUHJvZmlsZXIgPSAxMjtcbnZhciBTdXNwZW5zZUNvbXBvbmVudCA9IDEzO1xudmFyIE1lbW9Db21wb25lbnQgPSAxNDtcbnZhciBTaW1wbGVNZW1vQ29tcG9uZW50ID0gMTU7XG52YXIgTGF6eUNvbXBvbmVudCA9IDE2O1xudmFyIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCA9IDE3O1xudmFyIERlaHlkcmF0ZWRGcmFnbWVudCA9IDE4O1xudmFyIFN1c3BlbnNlTGlzdENvbXBvbmVudCA9IDE5O1xudmFyIFNjb3BlQ29tcG9uZW50ID0gMjE7XG52YXIgT2Zmc2NyZWVuQ29tcG9uZW50ID0gMjI7XG52YXIgTGVnYWN5SGlkZGVuQ29tcG9uZW50ID0gMjM7XG52YXIgQ2FjaGVDb21wb25lbnQgPSAyNDtcbnZhciBUcmFjaW5nTWFya2VyQ29tcG9uZW50ID0gMjU7XG52YXIgSG9zdEhvaXN0YWJsZSA9IDI2O1xudmFyIEhvc3RTaW5nbGV0b24gPSAyNztcbnZhciBJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQgPSAyODtcblxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG5cbnZhciBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50JykgO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7IC8vIFRPRE86IERlbGV0ZSB3aXRoIGVuYWJsZVJlbmRlcmFibGVDb250ZXh0XG5cbnZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29uc3VtZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG52YXIgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnRyYWNpbmdfbWFya2VyJyk7XG52YXIgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWwnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUkMShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lJDEodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpOyAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICAvLyBUT0RPOiBDcmVhdGUgYSBjb252ZW50aW9uIGZvciBuYW1pbmcgY2xpZW50IHJlZmVyZW5jZXMgd2l0aCBkZWJ1ZyBpbmZvLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG5cbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZSQxKGNvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnN1bWVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShjb25zdW1lci5fY29udGV4dCkgKyAnLkNvbnN1bWVyJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSQxKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHNoYXJlZC9nZXRDb21wb25lbnROYW1lRnJvbVR5cGVcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21Pd25lcihvd25lcikge1xuICBpZiAodHlwZW9mIG93bmVyLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcik7XG4gIH1cblxuICBpZiAodHlwZW9mIG93bmVyLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG93bmVyLm5hbWU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcbiAgdmFyIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnQ2FjaGUnO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICB7XG4gICAgICAgIHZhciBjb25zdW1lciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb25zdW1lci5fY29udGV4dCkgKyAnLkNvbnN1bWVyJztcbiAgICAgIH1cblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAge1xuICAgICAgICB2YXIgX2NvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICB9XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRGVoeWRyYXRlZEZyYWdtZW50JztcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgLy8gSG9zdCBjb21wb25lbnQgdHlwZSBpcyB0aGUgZGlzcGxheSBuYW1lIChlLmcuIFwiZGl2XCIsIFwiVmlld1wiKVxuICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuICdSb290JztcblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICByZXR1cm4gJ1RleHQnO1xuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgLy8gTmFtZSBjb21lcyBmcm9tIHRoZSB0eXBlIGluIHRoaXMgY2FzZTsgd2UgZG9uJ3QgaGF2ZSBhIHRhZy5cbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICBjYXNlIE1vZGU6XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSkge1xuICAgICAgICAvLyBEb24ndCBiZSBsZXNzIHNwZWNpZmljIHRoYW4gc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuICAgICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ01vZGUnO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTY29wZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnVHJhY2luZ01hcmtlcic7XG4gICAgLy8gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhlc2UgdGFncyBjb21lIGZyb20gdGhlIHVzZXItcHJvdmlkZWQgdHlwZTpcblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIEZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgTm9GbGFncyQxID1cbi8qICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIFBlcmZvcm1lZFdvcmsgPVxuLyogICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUGxhY2VtZW50ID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBEaWRDYXB0dXJlID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4xMjg7XG52YXIgSHlkcmF0aW5nID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuNDA5NjsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBVcGRhdGUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG40O1xuLyogU2tpcHBlZCB2YWx1ZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDA7ICovXG5cbnZhciBDaGlsZERlbGV0aW9uID1cbi8qICAgICAgICAgICAgICAgICovXG4xNjtcbnZhciBDb250ZW50UmVzZXQgPVxuLyogICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBDYWxsYmFjayA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG42NDtcbi8qIFVzZWQgYnkgRGlkQ2FwdHVyZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwOyAqL1xuXG52YXIgRm9yY2VDbGllbnRSZW5kZXIgPVxuLyogICAgICAgICAgICAqL1xuMjU2O1xudmFyIFJlZiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUxMjtcbnZhciBTbmFwc2hvdCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4xMDI0O1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbi8qIFVzZWQgYnkgSHlkcmF0aW5nOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMGIwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwOyAqL1xuXG52YXIgVmlzaWJpbGl0eSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBTdG9yZUNvbnNpc3RlbmN5ID1cbi8qICAgICAgICAgICAgICovXG4xNjM4NDsgLy8gSXQncyBPSyB0byByZXVzZSB0aGVzZSBiaXRzIGJlY2F1c2UgdGhlc2UgZmxhZ3MgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBmb3Jcbi8vIGRpZmZlcmVudCBmaWJlciB0eXBlcy4gV2Ugc2hvdWxkIHJlYWxseSBiZSBkb2luZyB0aGlzIGZvciBhcyBtYW55IGZsYWdzIGFzXG4vLyBwb3NzaWJsZSwgYmVjYXVzZSB3ZSdyZSBhYm91dCB0byBydW4gb3V0IG9mIGJpdHMuXG5cbnZhciBTY2hlZHVsZVJldHJ5ID0gU3RvcmVDb25zaXN0ZW5jeTtcbnZhciBTaG91bGRTdXNwZW5kQ29tbWl0ID0gVmlzaWJpbGl0eTtcbnZhciBEaWREZWZlciA9IENvbnRlbnRSZXNldDtcbnZhciBGb3JtUmVzZXQgPSBTbmFwc2hvdDtcblxudmFyIEhvc3RFZmZlY3RNYXNrID1cbi8qICAgICAgICAgICAgICAgKi9cbjMyNzY3OyAvLyBUaGVzZSBhcmUgbm90IHJlYWxseSBzaWRlIGVmZmVjdHMsIGJ1dCB3ZSBzdGlsbCByZXVzZSB0aGlzIGZpZWxkLlxuXG52YXIgSW5jb21wbGV0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMzI3Njg7XG52YXIgU2hvdWxkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAqL1xuNjU1MzY7XG52YXIgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSA9XG4vKiAqL1xuMTMxMDcyO1xudmFyIEZvcmtlZCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEwNDg1NzY7IC8vIFN0YXRpYyB0YWdzIGRlc2NyaWJlIGFzcGVjdHMgb2YgYSBmaWJlciB0aGF0IGFyZSBub3Qgc3BlY2lmaWMgdG8gYSByZW5kZXIsXG4vLyBlLmcuIGEgZmliZXIgdXNlcyBhIHBhc3NpdmUgZWZmZWN0IChldmVuIGlmIHRoZXJlIGFyZSBubyB1cGRhdGVzIG9uIHRoaXMgcGFydGljdWxhciByZW5kZXIpLlxuLy8gVGhpcyBlbmFibGVzIHVzIHRvIGRlZmVyIG1vcmUgd29yayBpbiB0aGUgdW5tb3VudCBjYXNlLFxuLy8gc2luY2Ugd2UgY2FuIGRlZmVyIHRyYXZlcnNpbmcgdGhlIHRyZWUgZHVyaW5nIGxheW91dCB0byBsb29rIGZvciBQYXNzaXZlIGVmZmVjdHMsXG4vLyBhbmQgaW5zdGVhZCByZWx5IG9uIHRoZSBzdGF0aWMgZmxhZyBhcyBhIHNpZ25hbCB0aGF0IHRoZXJlIG1heSBiZSBjbGVhbnVwIHdvcmsuXG5cbnZhciBSZWZTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yMDk3MTUyO1xudmFyIExheW91dFN0YXRpYyA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjQxOTQzMDQ7XG52YXIgUGFzc2l2ZVN0YXRpYyA9XG4vKiAgICAgICAgICAgICAgICAqL1xuODM4ODYwODtcbnZhciBNYXlTdXNwZW5kQ29tbWl0ID1cbi8qICAgICAgICAgICAgICovXG4xNjc3NzIxNjsgLy8gRmxhZyB1c2VkIHRvIGlkZW50aWZ5IG5ld2x5IGluc2VydGVkIGZpYmVycy4gSXQgaXNuJ3QgcmVzZXQgYWZ0ZXIgY29tbWl0IHVubGlrZSBgUGxhY2VtZW50YC5cblxudmFyIFBsYWNlbWVudERFViA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjMzNTU0NDMyO1xudmFyIE1vdW50TGF5b3V0RGV2ID1cbi8qICAgICAgICAgICAgICAgKi9cbjY3MTA4ODY0O1xudmFyIE1vdW50UGFzc2l2ZURldiA9XG4vKiAgICAgICAgICAgICAgKi9cbjEzNDIxNzcyODsgLy8gR3JvdXBzIG9mIGZsYWdzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIGNvbW1pdCBwaGFzZSB0byBza2lwIG92ZXIgdHJlZXMgdGhhdFxuLy8gZG9uJ3QgY29udGFpbiBlZmZlY3RzLCBieSBjaGVja2luZyBzdWJ0cmVlRmxhZ3MuXG5cbnZhciBCZWZvcmVNdXRhdGlvbk1hc2sgPSAvLyBUT0RPOiBSZW1vdmUgVXBkYXRlIGZsYWcgZnJvbSBiZWZvcmUgbXV0YXRpb24gcGhhc2UgYnkgcmUtbGFuZGluZyBWaXNpYmlsaXR5XG4vLyBmbGFnIGxvZ2ljIChzZWUgIzIwMDQzKVxuVXBkYXRlIHwgU25hcHNob3QgfCAoMCk7XG52YXIgTXV0YXRpb25NYXNrID0gUGxhY2VtZW50IHwgVXBkYXRlIHwgQ2hpbGREZWxldGlvbiB8IENvbnRlbnRSZXNldCB8IFJlZiB8IEh5ZHJhdGluZyB8IFZpc2liaWxpdHkgfCBGb3JtUmVzZXQ7XG52YXIgTGF5b3V0TWFzayA9IFVwZGF0ZSB8IENhbGxiYWNrIHwgUmVmIHwgVmlzaWJpbGl0eTsgLy8gVE9ETzogU3BsaXQgaW50byBQYXNzaXZlTW91bnRNYXNrIGFuZCBQYXNzaXZlVW5tb3VudE1hc2tcblxudmFyIFBhc3NpdmVNYXNrID0gUGFzc2l2ZSQxIHwgVmlzaWJpbGl0eSB8IENoaWxkRGVsZXRpb247IC8vIFVuaW9uIG9mIHRhZ3MgdGhhdCBkb24ndCBnZXQgcmVzZXQgb24gY2xvbmVzLlxuLy8gVGhpcyBhbGxvd3MgY2VydGFpbiBjb25jZXB0cyB0byBwZXJzaXN0IHdpdGhvdXQgcmVjYWxjdWxhdGluZyB0aGVtLFxuLy8gZS5nLiB3aGV0aGVyIGEgc3VidHJlZSBjb250YWlucyBwYXNzaXZlIGVmZmVjdHMgb3IgcG9ydGFscy5cblxudmFyIFN0YXRpY01hc2sgPSBMYXlvdXRTdGF0aWMgfCBQYXNzaXZlU3RhdGljIHwgUmVmU3RhdGljIHwgTWF5U3VzcGVuZENvbW1pdDtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVEZWJ1Z0luZm9GcmFtZShuYW1lLCBlbnYpIHtcbiAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUgKyAoZW52ID8gJyAoJyArIGVudiArICcpJyA6ICcnKSk7XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCQxID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCQxKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IOyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvcikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoY3RvciwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBDb25zaWRlciBtYXJraW5nIHRoZSB3aG9sZSBidW5kbGUgaW5zdGVhZCBvZiB0aGVzZSBib3VuZGFyaWVzLlxuXG4vKiogQG5vaW5saW5lICovXG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRJbkRFVihDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gIHZhciByZXN1bHQgPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAbm9pbmxpbmUgKi9cblxuZnVuY3Rpb24gY2FsbFJlbmRlckluREVWKGluc3RhbmNlKSB7XG4gIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICB2YXIgcmVzdWx0ID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAbm9pbmxpbmUgKi9cblxuZnVuY3Rpb24gY2FsbExhenlJbml0SW5ERVYobGF6eSkge1xuICB2YXIgcGF5bG9hZCA9IGxhenkuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eS5faW5pdDtcbiAgcmV0dXJuIGluaXQocGF5bG9hZCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZS5yZW5kZXIpO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIGRvIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcblxuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgLy8gQWRkIGFueSBTZXJ2ZXIgQ29tcG9uZW50IHN0YWNrIGZyYW1lcyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgICB2YXIgZGVidWdJbmZvID0gbm9kZS5fZGVidWdJbmZvO1xuXG4gICAgICAgIGlmIChkZWJ1Z0luZm8pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBkZWJ1Z0luZm9baV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSBkZXNjcmliZURlYnVnSW5mb0ZyYW1lKGVudHJ5Lm5hbWUsIGVudHJ5LmVudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG5cbnZhciBjdXJyZW50ID0gbnVsbDtcbnZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuXG4gICAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgY2FsbGJhY2ssIGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAge1xuICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcbiAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChlbmFibGVPd25lclN0YWNrcykgO1xuXG4gICAgICByZXR1cm4gY2FsbGJhY2soYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnQgPSBwcmV2aW91c0ZpYmVyO1xuICAgIH1cbiAgfSAvLyBUaGVzZSBlcnJvcnMgc2hvdWxkIG5ldmVyIG1ha2UgaXQgaW50byBhIGJ1aWxkIHNvIHdlIGRvbid0IG5lZWQgdG8gZW5jb2RlIHRoZW0gaW4gY29kZXMuanNvblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdydW5XaXRoRmliZXJJbkRFViBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGluIHByb2R1Y3Rpb24uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG59XG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGN1cnJlbnQgPSBudWxsO1xufVxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBmaWJlciA9PT0gbnVsbCA/IG51bGwgOiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50ID0gZmliZXI7XG59XG5mdW5jdGlvbiBzZXRJc1JlbmRlcmluZyhyZW5kZXJpbmcpIHtcbiAge1xuICAgIGlzUmVuZGVyaW5nID0gcmVuZGVyaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgdmFyIG5leHROb2RlID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcblxuICAgICAgaWYgKChub2RlLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24gb3IgaW4tcHJvZ3Jlc3MgaHlkcmF0aW9uLiBUaGUgbmVhcmVzdCBwb3NzaWJsZVxuICAgICAgICAvLyBtb3VudGVkIGZpYmVyIGlzIHRoZSBwYXJlbnQgYnV0IHdlIG5lZWQgdG8gY29udGludWUgdG8gZmlndXJlIG91dFxuICAgICAgICAvLyBpZiB0aGF0IG9uZSBpcyBzdGlsbCBtb3VudGVkLlxuICAgICAgICBuZWFyZXN0TW91bnRlZCA9IG5vZGUucmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICBuZXh0Tm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH0gd2hpbGUgKG5leHROb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZS5yZXR1cm4pIHtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAvLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbiAgICByZXR1cm4gbmVhcmVzdE1vdW50ZWQ7XG4gIH0gLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBjdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIGlzUmVuZGVyaW5nICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKCFpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIpIHtcbiAgICAgICAgZXJyb3IoJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXJGaWJlcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICBpZiAoZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgIT09IGZpYmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkICE9PSBmaWJlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG5cblxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG5cbiAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKHBhcmVudEIgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgLy8gaGFwcGVucyB3aGVuIGEgU3VzcGVuc2UgY29tcG9uZW50IGlzIGhpZGRlbi4gQW4gZXh0cmEgZnJhZ21lbnQgZmliZXJcbiAgICAgIC8vIGlzIGluc2VydGVkIGluIGJldHdlZW4gdGhlIFN1c3BlbnNlIGZpYmVyIGFuZCBpdHMgY2hpbGRyZW4uIFNraXBcbiAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICB2YXIgbmV4dFBhcmVudCA9IHBhcmVudEEucmV0dXJuO1xuXG4gICAgICBpZiAobmV4dFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgYXQgdGhlIHJvb3QuXG5cblxuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9IC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGEucmV0dXJuICE9PSBiLnJldHVybikge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuXG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgJyArICdpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gXCIgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH0gLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuXG5cbiAgaWYgKGEudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICB9XG5cbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cblxuXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICByZXR1cm4gY3VycmVudFBhcmVudCAhPT0gbnVsbCA/IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChjdXJyZW50UGFyZW50KSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKSB7XG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciB0YWcgPSBub2RlLnRhZztcblxuICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24gfHwgdGFnID09PSBIb3N0VGV4dCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwoY2hpbGQpO1xuXG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICByZXR1cm4gY3VycmVudFBhcmVudCAhPT0gbnVsbCA/IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY3VycmVudFBhcmVudCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpIHtcbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuXG4gIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbiB8fCB0YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmIChjaGlsZC50YWcgIT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY2hpbGQpO1xuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8vIFRoaXMgaXMgYSBob3N0IGNvbmZpZyB0aGF0J3MgdXNlZCBmb3IgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCBwYWNrYWdlIG9uIG5wbS5cbi8vIEl0IGlzIG9ubHkgdXNlZCBieSB0aGlyZC1wYXJ0eSByZW5kZXJlcnMuXG4vL1xuLy8gSXRzIEFQSSBsZXRzIHlvdSBwYXNzIHRoZSBob3N0IGNvbmZpZyBhcyBhbiBhcmd1bWVudC5cbi8vIEhvd2V2ZXIsIGluc2lkZSB0aGUgYHJlYWN0LXJlY29uY2lsZXJgIHdlIHRyZWF0IGhvc3QgY29uZmlnIGFzIGEgbW9kdWxlLlxuLy8gVGhpcyBmaWxlIGlzIGEgc2hpbSBiZXR3ZWVuIHR3byB3b3JsZHMuXG4vL1xuLy8gSXQgd29ya3MgYmVjYXVzZSB0aGUgYHJlYWN0LXJlY29uY2lsZXJgIGJ1bmRsZSBpcyB3cmFwcGVkIGluIHNvbWV0aGluZyBsaWtlOlxuLy9cbi8vIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCQkJGNvbmZpZykge1xuLy8gICAvKiByZWNvbmNpbGVyIGNvZGUgKi9cbi8vIH1cbi8vXG4vLyBTbyBgJCQkY29uZmlnYCBsb29rcyBsaWtlIGEgZ2xvYmFsIHZhcmlhYmxlLCBidXQgaXQnc1xuLy8gcmVhbGx5IGFuIGFyZ3VtZW50IHRvIGEgdG9wLWxldmVsIHdyYXBwaW5nIGZ1bmN0aW9uLlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxudmFyIGdldFB1YmxpY0luc3RhbmNlID0gJCQkY29uZmlnLmdldFB1YmxpY0luc3RhbmNlO1xudmFyIGdldFJvb3RIb3N0Q29udGV4dCA9ICQkJGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG52YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9ICQkJGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0O1xudmFyIHByZXBhcmVGb3JDb21taXQgPSAkJCRjb25maWcucHJlcGFyZUZvckNvbW1pdDtcbnZhciByZXNldEFmdGVyQ29tbWl0ID0gJCQkY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG52YXIgY3JlYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSW5zdGFuY2U7XG52YXIgYXBwZW5kSW5pdGlhbENoaWxkID0gJCQkY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZDtcbnZhciBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiA9ICQkJGNvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbjtcbnZhciBzaG91bGRTZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudDtcbnZhciBjcmVhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlO1xudmFyIHNjaGVkdWxlVGltZW91dCA9ICQkJGNvbmZpZy5zY2hlZHVsZVRpbWVvdXQ7XG52YXIgY2FuY2VsVGltZW91dCA9ICQkJGNvbmZpZy5jYW5jZWxUaW1lb3V0O1xudmFyIG5vVGltZW91dCA9ICQkJGNvbmZpZy5ub1RpbWVvdXQ7XG52YXIgaXNQcmltYXJ5UmVuZGVyZXIgPSAkJCRjb25maWcuaXNQcmltYXJ5UmVuZGVyZXI7XG4kJCRjb25maWcud2FybnNJZk5vdEFjdGluZztcbnZhciBzdXBwb3J0c011dGF0aW9uID0gJCQkY29uZmlnLnN1cHBvcnRzTXV0YXRpb247XG52YXIgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9ICQkJGNvbmZpZy5zdXBwb3J0c1BlcnNpc3RlbmNlO1xudmFyIHN1cHBvcnRzSHlkcmF0aW9uID0gJCQkY29uZmlnLnN1cHBvcnRzSHlkcmF0aW9uO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSAkJCRjb25maWcuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcbiQkJGNvbmZpZy5iZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI7XG4kJCRjb25maWcuYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG52YXIgcHJlcGFyZVBvcnRhbE1vdW50ID0gJCQkY29uZmlnLnByZXBhcmVQb3J0YWxNb3VudDtcbiQkJGNvbmZpZy5wcmVwYXJlU2NvcGVVcGRhdGU7XG4kJCRjb25maWcuZ2V0SW5zdGFuY2VGcm9tU2NvcGU7XG52YXIgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLnNldEN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbnZhciBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcuZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5O1xudmFyIHJlc29sdmVVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5yZXNvbHZlVXBkYXRlUHJpb3JpdHk7XG52YXIgc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbiA9ICQkJGNvbmZpZy5zaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uO1xudmFyIGRldGFjaERlbGV0ZWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5kZXRhY2hEZWxldGVkSW5zdGFuY2U7XG4kJCRjb25maWcucmVxdWVzdFBvc3RQYWludENhbGxiYWNrO1xudmFyIG1heVN1c3BlbmRDb21taXQgPSAkJCRjb25maWcubWF5U3VzcGVuZENvbW1pdDtcbnZhciBwcmVsb2FkSW5zdGFuY2UgPSAkJCRjb25maWcucHJlbG9hZEluc3RhbmNlO1xudmFyIHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCA9ICQkJGNvbmZpZy5zdGFydFN1c3BlbmRpbmdDb21taXQ7XG52YXIgc3VzcGVuZEluc3RhbmNlID0gJCQkY29uZmlnLnN1c3BlbmRJbnN0YW5jZTtcbnZhciB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5ID0gJCQkY29uZmlnLndhaXRGb3JDb21taXRUb0JlUmVhZHk7XG52YXIgTm90UGVuZGluZ1RyYW5zaXRpb24gPSAkJCRjb25maWcuTm90UGVuZGluZ1RyYW5zaXRpb247XG52YXIgcmVzZXRGb3JtSW5zdGFuY2UgPSAkJCRjb25maWcucmVzZXRGb3JtSW5zdGFuY2U7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgTWljcm90YXNrc1xuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHN1cHBvcnRzTWljcm90YXNrcyA9ICQkJGNvbmZpZy5zdXBwb3J0c01pY3JvdGFza3M7XG52YXIgc2NoZWR1bGVNaWNyb3Rhc2sgPSAkJCRjb25maWcuc2NoZWR1bGVNaWNyb3Rhc2s7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgVGVzdCBzZWxlY3RvcnNcbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBzdXBwb3J0c1Rlc3RTZWxlY3RvcnMgPSAkJCRjb25maWcuc3VwcG9ydHNUZXN0U2VsZWN0b3JzO1xudmFyIGZpbmRGaWJlclJvb3QgPSAkJCRjb25maWcuZmluZEZpYmVyUm9vdDtcbnZhciBnZXRCb3VuZGluZ1JlY3QgPSAkJCRjb25maWcuZ2V0Qm91bmRpbmdSZWN0O1xudmFyIGdldFRleHRDb250ZW50ID0gJCQkY29uZmlnLmdldFRleHRDb250ZW50O1xudmFyIGlzSGlkZGVuU3VidHJlZSA9ICQkJGNvbmZpZy5pc0hpZGRlblN1YnRyZWU7XG52YXIgbWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSA9ICQkJGNvbmZpZy5tYXRjaEFjY2Vzc2liaWxpdHlSb2xlO1xudmFyIHNldEZvY3VzSWZGb2N1c2FibGUgPSAkJCRjb25maWcuc2V0Rm9jdXNJZkZvY3VzYWJsZTtcbnZhciBzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyID0gJCQkY29uZmlnLnNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgTXV0YXRpb25cbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBhcHBlbmRDaGlsZCA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZDtcbnZhciBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gJCQkY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXI7XG52YXIgY29tbWl0VGV4dFVwZGF0ZSA9ICQkJGNvbmZpZy5jb21taXRUZXh0VXBkYXRlO1xudmFyIGNvbW1pdE1vdW50ID0gJCQkY29uZmlnLmNvbW1pdE1vdW50O1xudmFyIGNvbW1pdFVwZGF0ZSA9ICQkJGNvbmZpZy5jb21taXRVcGRhdGU7XG52YXIgaW5zZXJ0QmVmb3JlID0gJCQkY29uZmlnLmluc2VydEJlZm9yZTtcbnZhciBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9ICQkJGNvbmZpZy5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZTtcbnZhciByZW1vdmVDaGlsZCA9ICQkJGNvbmZpZy5yZW1vdmVDaGlsZDtcbnZhciByZW1vdmVDaGlsZEZyb21Db250YWluZXIgPSAkJCRjb25maWcucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xudmFyIHJlc2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcucmVzZXRUZXh0Q29udGVudDtcbnZhciBoaWRlSW5zdGFuY2UgPSAkJCRjb25maWcuaGlkZUluc3RhbmNlO1xudmFyIGhpZGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaGlkZVRleHRJbnN0YW5jZTtcbnZhciB1bmhpZGVJbnN0YW5jZSA9ICQkJGNvbmZpZy51bmhpZGVJbnN0YW5jZTtcbnZhciB1bmhpZGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcudW5oaWRlVGV4dEluc3RhbmNlO1xudmFyIGNsZWFyQ29udGFpbmVyID0gJCQkY29uZmlnLmNsZWFyQ29udGFpbmVyOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgUGVyc2lzdGVuY2Vcbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBjbG9uZUluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSW5zdGFuY2U7XG52YXIgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRjb25maWcuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQ7XG52YXIgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0ID0gJCQkY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldDtcbnZhciBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkY29uZmlnLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG52YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkY29uZmlnLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbjtcbnZhciBjbG9uZUhpZGRlbkluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSGlkZGVuSW5zdGFuY2U7XG52YXIgY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2U7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICBIeWRyYXRpb25cbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nID0gJCQkY29uZmlnLmlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmc7XG52YXIgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sgPSAkJCRjb25maWcuaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2s7XG52YXIgZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzID0gJCQkY29uZmlnLmdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscztcbnZhciByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSA9ICQkJGNvbmZpZy5yZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeTtcbnZhciBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXI7XG52YXIgaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyA9ICQkJGNvbmZpZy5pc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nO1xudmFyIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9ICQkJGNvbmZpZy5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc7XG52YXIgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQ7XG52YXIgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIgPSAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXI7XG52YXIgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBjYW5IeWRyYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZUluc3RhbmNlO1xudmFyIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBoeWRyYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZUluc3RhbmNlO1xudmFyIGh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5oeWRyYXRlU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2U7XG52YXIgY29tbWl0SHlkcmF0ZWRDb250YWluZXIgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRDb250YWluZXI7XG52YXIgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBjbGVhclN1c3BlbnNlQm91bmRhcnkgPSAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5O1xudmFyIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIgPSAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcjtcbnZhciBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyA9ICQkJGNvbmZpZy5zaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcztcbnZhciBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzID0gJCQkY29uZmlnLmRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3M7XG52YXIgZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzID0gJCQkY29uZmlnLmRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncztcbnZhciBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzID0gJCQkY29uZmlnLmRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3M7XG52YXIgdmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UgPSAkJCRjb25maWcudmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2U7XG52YXIgdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLnZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIFJlc291cmNlc1xuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxudmFyIHN1cHBvcnRzUmVzb3VyY2VzID0gJCQkY29uZmlnLnN1cHBvcnRzUmVzb3VyY2VzO1xudmFyIGlzSG9zdEhvaXN0YWJsZVR5cGUgPSAkJCRjb25maWcuaXNIb3N0SG9pc3RhYmxlVHlwZTtcbnZhciBnZXRIb2lzdGFibGVSb290ID0gJCQkY29uZmlnLmdldEhvaXN0YWJsZVJvb3Q7XG52YXIgZ2V0UmVzb3VyY2UgPSAkJCRjb25maWcuZ2V0UmVzb3VyY2U7XG52YXIgYWNxdWlyZVJlc291cmNlID0gJCQkY29uZmlnLmFjcXVpcmVSZXNvdXJjZTtcbnZhciByZWxlYXNlUmVzb3VyY2UgPSAkJCRjb25maWcucmVsZWFzZVJlc291cmNlO1xudmFyIGh5ZHJhdGVIb2lzdGFibGUgPSAkJCRjb25maWcuaHlkcmF0ZUhvaXN0YWJsZTtcbnZhciBtb3VudEhvaXN0YWJsZSA9ICQkJGNvbmZpZy5tb3VudEhvaXN0YWJsZTtcbnZhciB1bm1vdW50SG9pc3RhYmxlID0gJCQkY29uZmlnLnVubW91bnRIb2lzdGFibGU7XG52YXIgY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2U7XG52YXIgcHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyA9ICQkJGNvbmZpZy5wcmVwYXJlVG9Db21taXRIb2lzdGFibGVzO1xudmFyIG1heVJlc291cmNlU3VzcGVuZENvbW1pdCA9ICQkJGNvbmZpZy5tYXlSZXNvdXJjZVN1c3BlbmRDb21taXQ7XG52YXIgcHJlbG9hZFJlc291cmNlID0gJCQkY29uZmlnLnByZWxvYWRSZXNvdXJjZTtcbnZhciBzdXNwZW5kUmVzb3VyY2UgPSAkJCRjb25maWcuc3VzcGVuZFJlc291cmNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgU2luZ2xldG9uc1xuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHN1cHBvcnRzU2luZ2xldG9ucyA9ICQkJGNvbmZpZy5zdXBwb3J0c1NpbmdsZXRvbnM7XG52YXIgcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLnJlc29sdmVTaW5nbGV0b25JbnN0YW5jZTtcbnZhciBjbGVhclNpbmdsZXRvbiA9ICQkJGNvbmZpZy5jbGVhclNpbmdsZXRvbjtcbnZhciBhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcuYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlO1xudmFyIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZWxlYXNlU2luZ2xldG9uSW5zdGFuY2U7XG52YXIgaXNIb3N0U2luZ2xldG9uVHlwZSA9ICQkJGNvbmZpZy5pc0hvc3RTaW5nbGV0b25UeXBlO1xuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xudmFyIGZpYmVyU3RhY2s7XG5cbntcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICBlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufSAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcih0eXBlKSB7XG4gIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgdHlwZSwgcGFyZW50Q29udGV4dCkge1xuICB7XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAge1xuICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cbn1cblxuLy8gV2UgdXNlIHRoZSBleGlzdGVuY2Ugb2YgdGhlIHN0YXRlIG9iamVjdCBhcyBhbiBpbmRpY2F0b3IgdGhhdCB0aGUgY29tcG9uZW50XG4vLyBpcyBoaWRkZW4uXG52YXIgT2Zmc2NyZWVuVmlzaWJsZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4xO1xudmFyIE9mZnNjcmVlbkRldGFjaGVkID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCA9XG4vKiAgICAgKi9cbjQ7XG5mdW5jdGlvbiBpc09mZnNjcmVlbk1hbnVhbChvZmZzY3JlZW5GaWJlcikge1xuICByZXR1cm4gb2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRQcm9wcyAhPT0gbnVsbCAmJiBvZmZzY3JlZW5GaWJlci5tZW1vaXplZFByb3BzLm1vZGUgPT09ICdtYW51YWwnO1xufVxuXG52YXIgTm9Nb2RlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wOyAvLyBUT0RPOiBSZW1vdmUgQ29uY3VycmVudE1vZGUgYnkgcmVhZGluZyBmcm9tIHRoZSByb290IHRhZyBpbnN0ZWFkXG5cbnZhciBDb25jdXJyZW50TW9kZSA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUHJvZmlsZU1vZGUgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFN0cmljdExlZ2FjeU1vZGUgPVxuLyogICAgICAgICAgICAgICAqL1xuODtcbnZhciBTdHJpY3RFZmZlY3RzTW9kZSA9XG4vKiAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIE5vU3RyaWN0UGFzc2l2ZUVmZmVjdHNNb2RlID1cbi8qICAgICAqL1xuNjQ7XG5cbi8vIFRPRE86IFRoaXMgaXMgcHJldHR5IHdlbGwgc3VwcG9ydGVkIGJ5IGJyb3dzZXJzLiBNYXliZSB3ZSBjYW4gZHJvcCBpdC5cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjazsgLy8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxuXG52YXIgbG9nJDEgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gIHZhciBhc1VpbnQgPSB4ID4+PiAwO1xuXG4gIGlmIChhc1VpbnQgPT09IDApIHtcbiAgICByZXR1cm4gMzI7XG4gIH1cblxuICByZXR1cm4gMzEgLSAobG9nJDEoYXNVaW50KSAvIExOMiB8IDApIHwgMDtcbn1cblxuLy8gSWYgdGhvc2UgdmFsdWVzIGFyZSBjaGFuZ2VkIHRoYXQgcGFja2FnZSBzaG91bGQgYmUgcmVidWlsdCBhbmQgcmVkZXBsb3llZC5cblxudmFyIFRvdGFsTGFuZXMgPSAzMTtcbnZhciBOb0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgTm9MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBTeW5jSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICAgICovXG4xO1xudmFyIFN5bmNMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgU3luY0xhbmVJbmRleCA9IDE7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAqL1xuNDtcbnZhciBJbnB1dENvbnRpbnVvdXNMYW5lID1cbi8qICAgICAgICAgICAgICovXG44O1xudmFyIERlZmF1bHRIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgKi9cbjE2O1xudmFyIERlZmF1bHRMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIFN5bmNVcGRhdGVMYW5lcyA9IFN5bmNMYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRMYW5lIDtcbnZhciBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAqL1xuNjQ7XG52YXIgVHJhbnNpdGlvbkxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDE5NDE3NjtcbnZhciBUcmFuc2l0aW9uTGFuZTEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIFRyYW5zaXRpb25MYW5lMiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgVHJhbnNpdGlvbkxhbmUzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUxMjtcbnZhciBUcmFuc2l0aW9uTGFuZTQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBUcmFuc2l0aW9uTGFuZTUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBUcmFuc2l0aW9uTGFuZTYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBUcmFuc2l0aW9uTGFuZTcgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBUcmFuc2l0aW9uTGFuZTggPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTYzODQ7XG52YXIgVHJhbnNpdGlvbkxhbmU5ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFRyYW5zaXRpb25MYW5lMTAgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBUcmFuc2l0aW9uTGFuZTExID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTMxMDcyO1xudmFyIFRyYW5zaXRpb25MYW5lMTIgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4yNjIxNDQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUyNDI4ODtcbnZhciBUcmFuc2l0aW9uTGFuZTE0ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjtcbnZhciBUcmFuc2l0aW9uTGFuZTE1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBSZXRyeUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG42MjkxNDU2MDtcbnZhciBSZXRyeUxhbmUxID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDE5NDMwNDtcbnZhciBSZXRyeUxhbmUyID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuODM4ODYwODtcbnZhciBSZXRyeUxhbmUzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTY3NzcyMTY7XG52YXIgUmV0cnlMYW5lNCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjMzNTU0NDMyO1xudmFyIFNvbWVSZXRyeUxhbmUgPSBSZXRyeUxhbmUxO1xudmFyIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgKi9cbjY3MTA4ODY0O1xudmFyIE5vbklkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEzNDIxNzcyNztcbnZhciBJZGxlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICAgICovXG4xMzQyMTc3Mjg7XG52YXIgSWRsZUxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjY4NDM1NDU2O1xudmFyIE9mZnNjcmVlbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjUzNjg3MDkxMjtcbnZhciBEZWZlcnJlZExhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4xMDczNzQxODI0OyAvLyBBbnkgbGFuZSB0aGF0IG1pZ2h0IHNjaGVkdWxlIGFuIHVwZGF0ZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVjdCBpbmZpbml0ZVxuLy8gdXBkYXRlIGxvb3BzLCBzbyBpdCBkb2Vzbid0IGluY2x1ZGUgaHlkcmF0aW9uIGxhbmVzIG9yIHJldHJpZXMuXG5cbnZhciBVcGRhdGVMYW5lcyA9IFN5bmNMYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRMYW5lIHwgVHJhbnNpdGlvbkxhbmVzOyAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIHRoZSBleHBlcmltZW50YWwgdGltZWxpbmUgKHJlYWN0LWRldnRvb2xzLXRpbWVsaW5lKVxuLy8gSXQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBMYW5lcyB2YWx1ZXMgYWJvdmUuXG5cbmZ1bmN0aW9uIGdldExhYmVsRm9yTGFuZShsYW5lKSB7XG4gIHtcbiAgICBpZiAobGFuZSAmIFN5bmNIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ1N5bmNIeWRyYXRpb25MYW5lJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFN5bmNMYW5lKSB7XG4gICAgICByZXR1cm4gJ1N5bmMnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdJbnB1dENvbnRpbnVvdXNIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSW5wdXRDb250aW51b3VzTGFuZSkge1xuICAgICAgcmV0dXJuICdJbnB1dENvbnRpbnVvdXMnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgRGVmYXVsdEh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnRGVmYXVsdEh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBEZWZhdWx0TGFuZSkge1xuICAgICAgcmV0dXJuICdEZWZhdWx0JztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ1RyYW5zaXRpb25IeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgVHJhbnNpdGlvbkxhbmVzKSB7XG4gICAgICByZXR1cm4gJ1RyYW5zaXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgUmV0cnlMYW5lcykge1xuICAgICAgcmV0dXJuICdSZXRyeSc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBTZWxlY3RpdmVIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ1NlbGVjdGl2ZUh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJZGxlSHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdJZGxlSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElkbGVMYW5lKSB7XG4gICAgICByZXR1cm4gJ0lkbGUnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgT2Zmc2NyZWVuTGFuZSkge1xuICAgICAgcmV0dXJuICdPZmZzY3JlZW4nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgRGVmZXJyZWRMYW5lKSB7XG4gICAgICByZXR1cm4gJ0RlZmVycmVkJztcbiAgICB9XG4gIH1cbn1cbnZhciBOb1RpbWVzdGFtcCA9IC0xO1xudmFyIG5leHRUcmFuc2l0aW9uTGFuZSA9IFRyYW5zaXRpb25MYW5lMTtcbnZhciBuZXh0UmV0cnlMYW5lID0gUmV0cnlMYW5lMTtcblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobGFuZXMpIHtcbiAge1xuICAgIHZhciBwZW5kaW5nU3luY0xhbmVzID0gbGFuZXMgJiBTeW5jVXBkYXRlTGFuZXM7XG5cbiAgICBpZiAocGVuZGluZ1N5bmNMYW5lcyAhPT0gMCkge1xuICAgICAgcmV0dXJuIHBlbmRpbmdTeW5jTGFuZXM7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSkge1xuICAgIGNhc2UgU3luY0h5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gU3luY0h5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIFN5bmNMYW5lOlxuICAgICAgcmV0dXJuIFN5bmNMYW5lO1xuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgcmV0dXJuIERlZmF1bHRMYW5lO1xuXG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgICAgcmV0dXJuIGxhbmVzICYgVHJhbnNpdGlvbkxhbmVzO1xuXG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgICAgcmV0dXJuIGxhbmVzICYgUmV0cnlMYW5lcztcblxuICAgIGNhc2UgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBTZWxlY3RpdmVIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBJZGxlSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBJZGxlSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgSWRsZUxhbmU6XG4gICAgICByZXR1cm4gSWRsZUxhbmU7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkxhbmU6XG4gICAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcblxuICAgIGNhc2UgRGVmZXJyZWRMYW5lOlxuICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgcmVhY2hhYmxlIGJlY2F1c2UgZGVmZXJyZWQgd29yayBpcyBhbHdheXMgZW50YW5nbGVkXG4gICAgICAvLyB3aXRoIHNvbWV0aGluZyBlbHNlLlxuICAgICAgcmV0dXJuIE5vTGFuZXM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9IC8vIFRoaXMgc2hvdWxkbid0IGJlIHJlYWNoYWJsZSwgYnV0IGFzIGEgZmFsbGJhY2ssIHJldHVybiB0aGUgZW50aXJlIGJpdG1hc2suXG5cblxuICAgICAgcmV0dXJuIGxhbmVzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5leHRMYW5lcyhyb290LCB3aXBMYW5lcykge1xuICAvLyBFYXJseSBiYWlsb3V0IGlmIHRoZXJlJ3Mgbm8gcGVuZGluZyB3b3JrIGxlZnQuXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcblxuICBpZiAocGVuZGluZ0xhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH1cblxuICB2YXIgbmV4dExhbmVzID0gTm9MYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lczsgLy8gRG8gbm90IHdvcmsgb24gYW55IGlkbGUgd29yayB1bnRpbCBhbGwgdGhlIG5vbi1pZGxlIHdvcmsgaGFzIGZpbmlzaGVkLFxuICAvLyBldmVuIGlmIHRoZSB3b3JrIGlzIHN1c3BlbmRlZC5cblxuICB2YXIgbm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIE5vbklkbGVMYW5lcztcblxuICBpZiAobm9uSWRsZVBlbmRpbmdMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHZhciBub25JZGxlVW5ibG9ja2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzO1xuXG4gICAgaWYgKG5vbklkbGVVbmJsb2NrZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVVuYmxvY2tlZExhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vbklkbGVQaW5nZWRMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiBwaW5nZWRMYW5lcztcblxuICAgICAgaWYgKG5vbklkbGVQaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGluZ2VkTGFuZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgb25seSByZW1haW5pbmcgd29yayBpcyBJZGxlLlxuICAgIHZhciB1bmJsb2NrZWRMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgIGlmICh1bmJsb2NrZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXModW5ibG9ja2VkTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGluZ2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHJlYWNoYWJsZSBpZiB3ZSdyZSBzdXNwZW5kZWRcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGluIHRoaXMgcGF0aCBpZiBhIGZhbGxiYWNrIHRpbWVyIGlzIG5vdCBzY2hlZHVsZWQuXG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH0gLy8gSWYgd2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVuZGVyLCBzd2l0Y2hpbmcgbGFuZXMgd2lsbCBpbnRlcnJ1cHRcbiAgLy8gaXQgYW5kIHdlJ2xsIGxvc2Ugb3VyIHByb2dyZXNzLiBXZSBzaG91bGQgb25seSBkbyB0aGlzIGlmIHRoZSBuZXcgbGFuZXMgYXJlXG4gIC8vIGhpZ2hlciBwcmlvcml0eS5cblxuXG4gIGlmICh3aXBMYW5lcyAhPT0gTm9MYW5lcyAmJiB3aXBMYW5lcyAhPT0gbmV4dExhbmVzICYmIC8vIElmIHdlIGFscmVhZHkgc3VzcGVuZGVkIHdpdGggYSBkZWxheSwgdGhlbiBpbnRlcnJ1cHRpbmcgaXMgZmluZS4gRG9uJ3RcbiAgLy8gYm90aGVyIHdhaXRpbmcgdW50aWwgdGhlIHJvb3QgaXMgY29tcGxldGUuXG4gICh3aXBMYW5lcyAmIHN1c3BlbmRlZExhbmVzKSA9PT0gTm9MYW5lcykge1xuICAgIHZhciBuZXh0TGFuZSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTtcbiAgICB2YXIgd2lwTGFuZSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUod2lwTGFuZXMpO1xuXG4gICAgaWYgKCAvLyBUZXN0cyB3aGV0aGVyIHRoZSBuZXh0IGxhbmUgaXMgZXF1YWwgb3IgbG93ZXIgcHJpb3JpdHkgdGhhbiB0aGUgd2lwXG4gICAgLy8gb25lLiBUaGlzIHdvcmtzIGJlY2F1c2UgdGhlIGJpdHMgZGVjcmVhc2UgaW4gcHJpb3JpdHkgYXMgeW91IGdvIGxlZnQuXG4gICAgbmV4dExhbmUgPj0gd2lwTGFuZSB8fCAvLyBEZWZhdWx0IHByaW9yaXR5IHVwZGF0ZXMgc2hvdWxkIG5vdCBpbnRlcnJ1cHQgdHJhbnNpdGlvbiB1cGRhdGVzLiBUaGVcbiAgICAvLyBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiBkZWZhdWx0IHVwZGF0ZXMgYW5kIHRyYW5zaXRpb24gdXBkYXRlcyBpcyB0aGF0XG4gICAgLy8gZGVmYXVsdCB1cGRhdGVzIGRvIG5vdCBzdXBwb3J0IHJlZnJlc2ggdHJhbnNpdGlvbnMuXG4gICAgbmV4dExhbmUgPT09IERlZmF1bHRMYW5lICYmICh3aXBMYW5lICYgVHJhbnNpdGlvbkxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgICAgLy8gS2VlcCB3b3JraW5nIG9uIHRoZSBleGlzdGluZyBpbi1wcm9ncmVzcyB0cmVlLiBEbyBub3QgaW50ZXJydXB0LlxuICAgICAgcmV0dXJuIHdpcExhbmVzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBnZXRFbnRhbmdsZWRMYW5lcyhyb290LCByZW5kZXJMYW5lcykge1xuICB2YXIgZW50YW5nbGVkTGFuZXMgPSByZW5kZXJMYW5lcztcblxuICBpZiAoKGVudGFuZ2xlZExhbmVzICYgSW5wdXRDb250aW51b3VzTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICAvLyBXaGVuIHVwZGF0ZXMgYXJlIHN5bmMgYnkgZGVmYXVsdCwgd2UgZW50YW5nbGUgY29udGludW91cyBwcmlvcml0eSB1cGRhdGVzXG4gICAgLy8gYW5kIGRlZmF1bHQgdXBkYXRlcywgc28gdGhleSByZW5kZXIgaW4gdGhlIHNhbWUgYmF0Y2guIFRoZSBvbmx5IHJlYXNvblxuICAgIC8vIHRoZXkgdXNlIHNlcGFyYXRlIGxhbmVzIGlzIGJlY2F1c2UgY29udGludW91cyB1cGRhdGVzIHNob3VsZCBpbnRlcnJ1cHRcbiAgICAvLyB0cmFuc2l0aW9ucywgYnV0IGRlZmF1bHQgdXBkYXRlcyBzaG91bGQgbm90LlxuICAgIGVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzICYgRGVmYXVsdExhbmU7XG4gIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuICAvL1xuICAvLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbiAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbiAgLy8gd2hlbiBtdWx0aXBsZSB1cGRhdGVzIGhhdmUgdGhlIHNhbWUgc291cmNlLCBhbmQgd2Ugb25seSB3YW50IHRvIHJlc3BvbmQgdG9cbiAgLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBhcHBseSBlbnRhbmdsZW1lbnRzICphZnRlciogY2hlY2tpbmcgZm9yIHBhcnRpYWwgd29yayBhYm92ZS5cbiAgLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4gIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2VcbiAgLy8gZW50YW5nbGVtZW50IGlzIHVzdWFsbHkgXCJiZXN0IGVmZm9ydFwiOiB3ZSdsbCB0cnkgb3VyIGJlc3QgdG8gcmVuZGVyIHRoZVxuICAvLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbiAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4gIC8vIFRPRE86IFJlY29uc2lkZXIgdGhpcy4gVGhlIGNvdW50ZXItYXJndW1lbnQgaXMgdGhhdCB0aGUgcGFydGlhbCB3b3JrXG4gIC8vIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIHN0YXRlLCB3aGljaCB3ZSBkb24ndCB3YW50IHRvIHNob3cgdG8gdGhlIHVzZXIuXG4gIC8vIEFuZCBieSBzcGVuZGluZyBleHRyYSB0aW1lIGZpbmlzaGluZyBpdCwgd2UncmUgaW5jcmVhc2luZyB0aGUgYW1vdW50IG9mXG4gIC8vIHRpbWUgaXQgdGFrZXMgdG8gc2hvdyB0aGUgZmluYWwgc3RhdGUsIHdoaWNoIGlzIHdoYXQgdGhleSBhcmUgYWN0dWFsbHlcbiAgLy8gd2FpdGluZyBmb3IuXG4gIC8vXG4gIC8vIEZvciB0aG9zZSBleGNlcHRpb25zIHdoZXJlIGVudGFuZ2xlbWVudCBpcyBzZW1hbnRpY2FsbHkgaW1wb3J0YW50LFxuICAvLyB3ZSBzaG91bGQgZW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gcGFydGlhbCB3b3JrIGF0IHRoZVxuICAvLyB0aW1lIHdlIGFwcGx5IHRoZSBlbnRhbmdsZW1lbnQuXG5cblxuICB2YXIgYWxsRW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzO1xuXG4gIGlmIChhbGxFbnRhbmdsZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICAgIHZhciBsYW5lcyA9IGVudGFuZ2xlZExhbmVzICYgYWxsRW50YW5nbGVkTGFuZXM7XG5cbiAgICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgIGVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlbWVudHNbaW5kZXhdO1xuICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVudGFuZ2xlZExhbmVzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpIHtcbiAgc3dpdGNoIChsYW5lKSB7XG4gICAgY2FzZSBTeW5jSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIFN5bmNMYW5lOlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICAvLyBVc2VyIGludGVyYWN0aW9ucyBzaG91bGQgZXhwaXJlIHNsaWdodGx5IG1vcmUgcXVpY2tseS5cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBUaGlzIGlzIHNldCB0byB0aGUgY29ycmVzcG9uZGluZyBjb25zdGFudCBhcyBpbiBTY2hlZHVsZXIuanMuXG4gICAgICAvLyBXaGVuIHdlIG1hZGUgaXQgbGFyZ2VyLCBhIHByb2R1Y3QgbWV0cmljIGluIHd3dyByZWdyZXNzZWQsIHN1Z2dlc3RpbmdcbiAgICAgIC8vIHRoZXJlJ3MgYSB1c2VyIGludGVyYWN0aW9uIHRoYXQncyBiZWluZyBzdGFydmVkIGJ5IGEgc2VyaWVzIG9mXG4gICAgICAvLyBzeW5jaHJvbm91cyB1cGRhdGVzLiBJZiB0aGF0IHRoZW9yeSBpcyBjb3JyZWN0LCB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzXG4gICAgICAvLyB0byBmaXggdGhlIHN0YXJ2YXRpb24uIEhvd2V2ZXIsIHRoaXMgc2NlbmFyaW8gc3VwcG9ydHMgdGhlIGlkZWEgdGhhdFxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcyBhcmUgYW4gaW1wb3J0YW50IHNhZmVndWFyZCB3aGVuIHN0YXJ2YXRpb25cbiAgICAgIC8vIGRvZXMgaGFwcGVuLlxuICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgc3luY0xhbmVFeHBpcmF0aW9uTXM7XG5cbiAgICBjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICAgIHJldHVybiBjdXJyZW50VGltZSArIHRyYW5zaXRpb25MYW5lRXhwaXJhdGlvbk1zO1xuXG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgICAgLy8gVE9ETzogUmV0cmllcyBzaG91bGQgYmUgYWxsb3dlZCB0byBleHBpcmUgaWYgdGhleSBhcmUgQ1BVIGJvdW5kIGZvclxuICAgICAgLy8gdG9vIGxvbmcsIGJ1dCB3aGVuIEkgbWFkZSB0aGlzIGNoYW5nZSBpdCBjYXVzZWQgYSBzcGlrZSBpbiBicm93c2VyXG4gICAgICAvLyBjcmFzaGVzLiBUaGVyZSBtdXN0IGJlIHNvbWUgb3RoZXIgdW5kZXJseWluZyBidWc7IG5vdCBzdXBlciB1cmdlbnQgYnV0XG4gICAgICAvLyBpZGVhbGx5IHNob3VsZCBmaWd1cmUgb3V0IHdoeSBhbmQgZml4IGl0LiBVbmZvcnR1bmF0ZWx5IHdlIGRvbid0IGhhdmVcbiAgICAgIC8vIGEgcmVwcm8gZm9yIHRoZSBjcmFzaGVzLCBvbmx5IGRldGVjdGVkIHZpYSBwcm9kdWN0aW9uIG1ldHJpY3MuXG4gICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG5cbiAgICBjYXNlIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBJZGxlSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIElkbGVMYW5lOlxuICAgIGNhc2UgT2Zmc2NyZWVuTGFuZTpcbiAgICBjYXNlIERlZmVycmVkTGFuZTpcbiAgICAgIC8vIEFueXRoaW5nIGlkbGUgcHJpb3JpdHkgb3IgbG93ZXIgc2hvdWxkIG5ldmVyIGV4cGlyZS5cbiAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGVycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE5vVGltZXN0YW1wO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQocm9vdCwgY3VycmVudFRpbWUpIHtcbiAgLy8gVE9ETzogVGhpcyBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHdlIHlpZWxkLiBXZSBjYW4gb3B0aW1pemUgYnkgc3RvcmluZ1xuICAvLyB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lIG9uIHRoZSByb290LiBUaGVuIHVzZSB0aGF0IHRvIHF1aWNrbHkgYmFpbCBvdXRcbiAgLy8gb2YgdGhpcyBmdW5jdGlvbi5cbiAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuICB2YXIgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzO1xuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7IC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGVuZGluZyBsYW5lcyBhbmQgY2hlY2sgaWYgd2UndmUgcmVhY2hlZCB0aGVpclxuICAvLyBleHBpcmF0aW9uIHRpbWUuIElmIHNvLCB3ZSdsbCBhc3N1bWUgdGhlIHVwZGF0ZSBpcyBiZWluZyBzdGFydmVkIGFuZCBtYXJrXG4gIC8vIGl0IGFzIGV4cGlyZWQgdG8gZm9yY2UgaXQgdG8gZmluaXNoLlxuICAvLyBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byByZXBsYWNlIHRoaXMgd2l0aCB1cGdyYWRlUGVuZGluZ0xhbmVzVG9TeW5jXG4gIC8vXG4gIC8vIFdlIGV4Y2x1ZGUgcmV0cnkgbGFuZXMgYmVjYXVzZSB0aG9zZSBtdXN0IGFsd2F5cyBiZSB0aW1lIHNsaWNlZCwgaW4gb3JkZXJcbiAgLy8gdG8gdW53cmFwIHVuY2FjaGVkIHByb21pc2VzLlxuICAvLyBUT0RPOiBXcml0ZSBhIHRlc3QgZm9yIHRoaXNcblxuICB2YXIgbGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+UmV0cnlMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lc1tpbmRleF07XG5cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPT09IE5vVGltZXN0YW1wKSB7XG4gICAgICAvLyBGb3VuZCBhIHBlbmRpbmcgbGFuZSB3aXRoIG5vIGV4cGlyYXRpb24gdGltZS4gSWYgaXQncyBub3Qgc3VzcGVuZGVkLCBvclxuICAgICAgLy8gaWYgaXQncyBwaW5nZWQsIGFzc3VtZSBpdCdzIENQVS1ib3VuZC4gQ29tcHV0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWVcbiAgICAgIC8vIHVzaW5nIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICBpZiAoKGxhbmUgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMgfHwgKGxhbmUgJiBwaW5nZWRMYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgLy8gQXNzdW1lcyB0aW1lc3RhbXBzIGFyZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRoaXMgbGFuZSBleHBpcmVkXG4gICAgICByb290LmV4cGlyZWRMYW5lcyB8PSBsYW5lO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59IC8vIFRoaXMgcmV0dXJucyB0aGUgaGlnaGVzdCBwcmlvcml0eSBwZW5kaW5nIGxhbmVzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGV5XG4vLyBhcmUgc3VzcGVuZGVkLlxuXG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMocm9vdCkge1xuICByZXR1cm4gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocm9vdC5wZW5kaW5nTGFuZXMpO1xufVxuZnVuY3Rpb24gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCwgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzKSB7XG4gIGlmIChyb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICYgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzKSB7XG4gICAgLy8gVGhlIGVycm9yIHJlY292ZXJ5IG1lY2hhbmlzbSBpcyBkaXNhYmxlZCB1bnRpbCB0aGVzZSBsYW5lcyBhcmUgY2xlYXJlZC5cbiAgICByZXR1cm4gTm9MYW5lcztcbiAgfVxuXG4gIHZhciBldmVyeXRoaW5nQnV0T2Zmc2NyZWVuID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+T2Zmc2NyZWVuTGFuZTtcblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybiBldmVyeXRoaW5nQnV0T2Zmc2NyZWVuO1xuICB9XG5cbiAgaWYgKGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gJiBPZmZzY3JlZW5MYW5lKSB7XG4gICAgcmV0dXJuIE9mZnNjcmVlbkxhbmU7XG4gIH1cblxuICByZXR1cm4gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzU3luY0xhbmUobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIChTeW5jTGFuZSB8IFN5bmNIeWRyYXRpb25MYW5lKSkgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc05vbklkbGVXb3JrKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBOb25JZGxlTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNPbmx5UmV0cmllcyhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgUmV0cnlMYW5lcykgPT09IGxhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNPbmx5Tm9uVXJnZW50TGFuZXMobGFuZXMpIHtcbiAgLy8gVE9ETzogU2hvdWxkIGh5ZHJhdGlvbiBsYW5lcyBiZSBpbmNsdWRlZCBoZXJlPyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHlcbiAgLy8gdXNlZCBpbiBgdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGxgLlxuICB2YXIgVXJnZW50TGFuZXMgPSBTeW5jTGFuZSB8IElucHV0Q29udGludW91c0xhbmUgfCBEZWZhdWx0TGFuZTtcbiAgcmV0dXJuIChsYW5lcyAmIFVyZ2VudExhbmVzKSA9PT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSB7XG5cbiAgdmFyIFN5bmNEZWZhdWx0TGFuZXMgPSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRIeWRyYXRpb25MYW5lIHwgRGVmYXVsdExhbmU7XG4gIHJldHVybiAobGFuZXMgJiBTeW5jRGVmYXVsdExhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCwgbGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhIHNlcGFyYXRlIGNoZWNrIGZyb20gaW5jbHVkZXNCbG9ja2luZ0xhbmUgYmVjYXVzZSBhIGxhbmUgY2FuXG4gIC8vIGV4cGlyZSBhZnRlciBhIHJlbmRlciBoYXMgYWxyZWFkeSBzdGFydGVkLlxuICByZXR1cm4gKGxhbmVzICYgcm9vdC5leHBpcmVkTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uTGFuZShsYW5lKSB7XG4gIHJldHVybiAobGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpIHtcbiAgLy8gQ3ljbGUgdGhyb3VnaCB0aGUgbGFuZXMsIGFzc2lnbmluZyBlYWNoIG5ldyB0cmFuc2l0aW9uIHRvIHRoZSBuZXh0IGxhbmUuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgbWVhbnMgZXZlcnkgdHJhbnNpdGlvbiBnZXRzIGl0cyBvd24gbGFuZSwgdW50aWwgd2VcbiAgLy8gcnVuIG91dCBvZiBsYW5lcyBhbmQgY3ljbGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLlxuICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuXG4gIGlmICgobmV4dFRyYW5zaXRpb25MYW5lICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gTm9MYW5lcykge1xuICAgIG5leHRUcmFuc2l0aW9uTGFuZSA9IFRyYW5zaXRpb25MYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gIG5leHRSZXRyeUxhbmUgPDw9IDE7XG5cbiAgaWYgKChuZXh0UmV0cnlMYW5lICYgUmV0cnlMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICBuZXh0UmV0cnlMYW5lID0gUmV0cnlMYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykge1xuICByZXR1cm4gbGFuZXMgJiAtbGFuZXM7XG59XG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcykge1xuICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGJpdCBpcyBzZWxlY3RlZDsgeW91IGNhbiBwaWNrIGFueSBiaXQgd2l0aG91dFxuICAvLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4gIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuICByZXR1cm4gMzEgLSBjbHozMihsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcbiAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZSk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuICByZXR1cm4gKGEgJiBiKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gKHNldCAmIHN1YnNldCkgPT09IHN1YnNldDtcbn1cbmZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuICByZXR1cm4gYSB8IGI7XG59XG5mdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gc2V0ICYgfnN1YnNldDtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdExhbmVzKGEsIGIpIHtcbiAgcmV0dXJuIGEgJiBiO1xufSAvLyBTZWVtcyByZWR1bmRhbnQsIGJ1dCBpdCBjaGFuZ2VzIHRoZSB0eXBlIGZyb20gYSBzaW5nbGUgbGFuZSAodXNlZCBmb3Jcbi8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuXG5mdW5jdGlvbiBsYW5lVG9MYW5lcyhsYW5lKSB7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gaGlnaGVyUHJpb3JpdHlMYW5lKGEsIGIpIHtcbiAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXQgcmFuZ2VzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICByZXR1cm4gYSAhPT0gTm9MYW5lICYmIGEgPCBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgLy8gSW50ZW50aW9uYWxseSBwdXNoaW5nIG9uZSBieSBvbmUuXG4gIC8vIGh0dHBzOi8vdjguZGV2L2Jsb2cvZWxlbWVudHMta2luZHMjYXZvaWQtY3JlYXRpbmctaG9sZXNcbiAgdmFyIGxhbmVNYXAgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFRvdGFsTGFuZXM7IGkrKykge1xuICAgIGxhbmVNYXAucHVzaChpbml0aWFsKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lTWFwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlTGFuZSkge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lOyAvLyBJZiB0aGVyZSBhcmUgYW55IHN1c3BlbmRlZCB0cmFuc2l0aW9ucywgaXQncyBwb3NzaWJsZSB0aGlzIG5ldyB1cGRhdGVcbiAgLy8gY291bGQgdW5ibG9jayB0aGVtLiBDbGVhciB0aGUgc3VzcGVuZGVkIGxhbmVzIHNvIHRoYXQgd2UgY2FuIHRyeSByZW5kZXJpbmdcbiAgLy8gdGhlbSBhZ2Fpbi5cbiAgLy9cbiAgLy8gVE9ETzogV2UgcmVhbGx5IG9ubHkgbmVlZCB0byB1bnN1c3BlbmQgb25seSBsYW5lcyB0aGF0IGFyZSBpbiB0aGVcbiAgLy8gYHN1YnRyZWVMYW5lc2Agb2YgdGhlIHVwZGF0ZWQgZmliZXIsIG9yIHRoZSB1cGRhdGUgbGFuZXMgb2YgdGhlIHJldHVyblxuICAvLyBwYXRoLiBUaGlzIHdvdWxkIGV4Y2x1ZGUgc3VzcGVuZGVkIHVwZGF0ZXMgaW4gYW4gdW5yZWxhdGVkIHNpYmxpbmcgdHJlZSxcbiAgLy8gc2luY2UgdGhlcmUncyBubyB3YXkgZm9yIHRoaXMgdXBkYXRlIHRvIHVuYmxvY2sgaXQuXG4gIC8vXG4gIC8vIFdlIGRvbid0IGRvIHRoaXMgaWYgdGhlIGluY29taW5nIHVwZGF0ZSBpcyBpZGxlLCBiZWNhdXNlIHdlIG5ldmVyIHByb2Nlc3NcbiAgLy8gaWRsZSB1cGRhdGVzIHVudGlsIGFmdGVyIGFsbCB0aGUgcmVndWxhciB1cGRhdGVzIGhhdmUgZmluaXNoZWQ7IHRoZXJlJ3Mgbm9cbiAgLy8gd2F5IGl0IGNvdWxkIHVuYmxvY2sgYSB0cmFuc2l0aW9uLlxuXG4gIGlmICh1cGRhdGVMYW5lICE9PSBJZGxlTGFuZSkge1xuICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHJvb3QucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzLCBzcGF3bmVkTGFuZSkge1xuICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lczsgLy8gVGhlIHN1c3BlbmRlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIENQVS1ib3VuZC4gQ2xlYXIgdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cblxuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gIHZhciBsYW5lcyA9IHN1c3BlbmRlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG5cbiAgaWYgKHNwYXduZWRMYW5lICE9PSBOb0xhbmUpIHtcbiAgICBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgc3VzcGVuZGVkTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZCQxKHJvb3QsIHBpbmdlZExhbmVzKSB7XG4gIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcywgc3Bhd25lZExhbmUpIHtcbiAgdmFyIG5vTG9uZ2VyUGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7IC8vIExldCdzIHRyeSBldmVyeXRoaW5nIGFnYWluXG5cbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHJvb3QucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICByb290LmV4cGlyZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5zaGVsbFN1c3BlbmRDb3VudGVyID0gMDtcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lcztcbiAgdmFyIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7IC8vIENsZWFyIHRoZSBsYW5lcyB0aGF0IG5vIGxvbmdlciBoYXZlIHBlbmRpbmcgd29ya1xuXG4gIHZhciBsYW5lcyA9IG5vTG9uZ2VyUGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gPSBOb0xhbmVzO1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICB2YXIgaGlkZGVuVXBkYXRlc0ZvckxhbmUgPSBoaWRkZW5VcGRhdGVzW2luZGV4XTtcblxuICAgIGlmIChoaWRkZW5VcGRhdGVzRm9yTGFuZSAhPT0gbnVsbCkge1xuICAgICAgaGlkZGVuVXBkYXRlc1tpbmRleF0gPSBudWxsOyAvLyBcIkhpZGRlblwiIHVwZGF0ZXMgYXJlIHVwZGF0ZXMgdGhhdCB3ZXJlIG1hZGUgdG8gYSBoaWRkZW4gY29tcG9uZW50LiBUaGV5XG4gICAgICAvLyBoYXZlIHNwZWNpYWwgbG9naWMgYXNzb2NpYXRlZCB3aXRoIHRoZW0gYmVjYXVzZSB0aGV5IG1heSBiZSBlbnRhbmdsZWRcbiAgICAgIC8vIHdpdGggdXBkYXRlcyB0aGF0IG9jY3VyIG91dHNpZGUgdGhhdCB0cmVlLiBCdXQgb25jZSB0aGUgb3V0ZXIgdHJlZVxuICAgICAgLy8gY29tbWl0cywgdGhleSBiZWhhdmUgbGlrZSByZWd1bGFyIHVwZGF0ZXMuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuVXBkYXRlc0ZvckxhbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGhpZGRlblVwZGF0ZXNGb3JMYW5lW2ldO1xuXG4gICAgICAgIGlmICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGUubGFuZSAmPSB+T2Zmc2NyZWVuTGFuZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG5cbiAgaWYgKHNwYXduZWRMYW5lICE9PSBOb0xhbmUpIHtcbiAgICBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgLy8gVGhpcyByZW5kZXIgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5IHdpdGhvdXQgc3VzcGVuZGluZywgc28gd2UgZG9uJ3QgbmVlZFxuICAgIC8vIHRvIGVudGFuZ2xlIHRoZSBzcGF3bmVkIHRhc2sgd2l0aCB0aGUgcGFyZW50IHRhc2suXG4gICAgTm9MYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIGVudGFuZ2xlZExhbmVzKSB7XG4gIC8vIFRoaXMgcmVuZGVyIHNwYXduZWQgYSBkZWZlcnJlZCB0YXNrLiBNYXJrIGl0IGFzIHBlbmRpbmcuXG4gIHJvb3QucGVuZGluZ0xhbmVzIHw9IHNwYXduZWRMYW5lO1xuICByb290LnN1c3BlbmRlZExhbmVzICY9IH5zcGF3bmVkTGFuZTsgLy8gRW50YW5nbGUgdGhlIHNwYXduZWQgbGFuZSB3aXRoIHRoZSBEZWZlcnJlZExhbmUgYml0IHNvIHRoYXQgd2Uga25vdyBpdFxuICAvLyB3YXMgdGhlIHJlc3VsdCBvZiBhbm90aGVyIHJlbmRlci4gVGhpcyBsZXRzIHVzIGF2b2lkIGEgdXNlRGVmZXJyZWRWYWx1ZVxuICAvLyB3YXRlcmZhbGwg4oCUIG9ubHkgdGhlIGZpcnN0IGxldmVsIHdpbGwgZGVmZXIuXG5cbiAgdmFyIHNwYXduZWRMYW5lSW5kZXggPSBsYW5lVG9JbmRleChzcGF3bmVkTGFuZSk7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gc3Bhd25lZExhbmU7XG4gIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSB8PSBEZWZlcnJlZExhbmUgfCAvLyBJZiB0aGUgcGFyZW50IHJlbmRlciB0YXNrIHN1c3BlbmRlZCwgd2UgbXVzdCBhbHNvIGVudGFuZ2xlIHRob3NlIGxhbmVzXG4gIC8vIHdpdGggdGhlIHNwYXduZWQgdGFzaywgc28gdGhhdCB0aGUgZGVmZXJyZWQgdGFzayBpbmNsdWRlcyBhbGwgdGhlIHNhbWVcbiAgLy8gdXBkYXRlcyB0aGF0IHRoZSBwYXJlbnQgdGFzayBkaWQuIFdlIGNhbiBleGNsdWRlIGFueSBsYW5lIHRoYXQgaXMgbm90XG4gIC8vIHVzZWQgZm9yIHVwZGF0ZXMgKGUuZy4gT2Zmc2NyZWVuKS5cbiAgZW50YW5nbGVkTGFuZXMgJiBVcGRhdGVMYW5lcztcbn1cblxuZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgLy8gSW4gYWRkaXRpb24gdG8gZW50YW5nbGluZyBlYWNoIG9mIHRoZSBnaXZlbiBsYW5lcyB3aXRoIGVhY2ggb3RoZXIsIHdlIGFsc29cbiAgLy8gaGF2ZSB0byBjb25zaWRlciBfdHJhbnNpdGl2ZV8gZW50YW5nbGVtZW50cy4gRm9yIGVhY2ggbGFuZSB0aGF0IGlzIGFscmVhZHlcbiAgLy8gZW50YW5nbGVkIHdpdGggKmFueSogb2YgdGhlIGdpdmVuIGxhbmVzLCB0aGF0IGxhbmUgaXMgbm93IHRyYW5zaXRpdmVseVxuICAvLyBlbnRhbmdsZWQgd2l0aCAqYWxsKiB0aGUgZ2l2ZW4gbGFuZXMuXG4gIC8vXG4gIC8vIFRyYW5zbGF0ZWQ6IElmIEMgaXMgZW50YW5nbGVkIHdpdGggQSwgdGhlbiBlbnRhbmdsaW5nIEEgd2l0aCBCIGFsc29cbiAgLy8gZW50YW5nbGVzIEMgd2l0aCBCLlxuICAvL1xuICAvLyBJZiB0aGlzIGlzIGhhcmQgdG8gZ3Jhc3AsIGl0IG1pZ2h0IGhlbHAgdG8gaW50ZW50aW9uYWxseSBicmVhayB0aGlzXG4gIC8vIGZ1bmN0aW9uIGFuZCBsb29rIGF0IHRoZSB0ZXN0cyB0aGF0IGZhaWwgaW4gUmVhY3RUcmFuc2l0aW9uLXRlc3QuanMuIFRyeVxuICAvLyBjb21tZW50aW5nIG91dCBvbmUgb2YgdGhlIGNvbmRpdGlvbnMgYmVsb3cuXG4gIHZhciByb290RW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGxhbmVzID0gcm9vdEVudGFuZ2xlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcykge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcblxuICAgIGlmICggLy8gSXMgdGhpcyBvbmUgb2YgdGhlIG5ld2x5IGVudGFuZ2xlZCBsYW5lcz9cbiAgICBsYW5lICYgZW50YW5nbGVkTGFuZXMgfCAvLyBJcyB0aGlzIGxhbmUgdHJhbnNpdGl2ZWx5IGVudGFuZ2xlZCB3aXRoIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gJiBlbnRhbmdsZWRMYW5lcykge1xuICAgICAgZW50YW5nbGVtZW50c1tpbmRleF0gfD0gZW50YW5nbGVkTGFuZXM7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZ3JhZGVQZW5kaW5nTGFuZVRvU3luYyhyb290LCBsYW5lKSB7XG4gIC8vIFNpbmNlIHdlJ3JlIHVwZ3JhZGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGdpdmVuIGxhbmUsIHRoZXJlIGlzIG5vdyBwZW5kaW5nXG4gIC8vIHN5bmMgd29yay5cbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gU3luY0xhbmU7IC8vIEVudGFuZ2xlIHRoZSBzeW5jIGxhbmUgd2l0aCB0aGUgbGFuZSB3ZSdyZSB1cGdyYWRpbmcuIFRoaXMgbWVhbnMgU3luY0xhbmVcbiAgLy8gd2lsbCBub3QgYmUgYWxsb3dlZCB0byBmaW5pc2ggd2l0aG91dCBhbHNvIGZpbmlzaGluZyB0aGUgZ2l2ZW4gbGFuZS5cblxuICByb290LmVudGFuZ2xlZExhbmVzIHw9IFN5bmNMYW5lO1xuICByb290LmVudGFuZ2xlbWVudHNbU3luY0xhbmVJbmRleF0gfD0gbGFuZTtcbn1cbmZ1bmN0aW9uIHVwZ3JhZGVQZW5kaW5nTGFuZXNUb1N5bmMocm9vdCwgbGFuZXNUb1VwZ3JhZGUpIHtcbiAgLy8gU2FtZSBhcyB1cGdyYWRlUGVuZGluZ0xhbmVUb1N5bmMgYnV0IGFjY2VwdHMgbXVsdGlwbGUgbGFuZXMsIHNvIGl0J3MgYVxuICAvLyBiaXQgc2xvd2VyLlxuICByb290LnBlbmRpbmdMYW5lcyB8PSBTeW5jTGFuZTtcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBTeW5jTGFuZTtcbiAgdmFyIGxhbmVzID0gbGFuZXNUb1VwZ3JhZGU7XG5cbiAgd2hpbGUgKGxhbmVzKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHJvb3QuZW50YW5nbGVtZW50c1tTeW5jTGFuZUluZGV4XSB8PSBsYW5lO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrSGlkZGVuVXBkYXRlKHJvb3QsIHVwZGF0ZSwgbGFuZSkge1xuICB2YXIgaW5kZXggPSBsYW5lVG9JbmRleChsYW5lKTtcbiAgdmFyIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7XG4gIHZhciBoaWRkZW5VcGRhdGVzRm9yTGFuZSA9IGhpZGRlblVwZGF0ZXNbaW5kZXhdO1xuXG4gIGlmIChoaWRkZW5VcGRhdGVzRm9yTGFuZSA9PT0gbnVsbCkge1xuICAgIGhpZGRlblVwZGF0ZXNbaW5kZXhdID0gW3VwZGF0ZV07XG4gIH0gZWxzZSB7XG4gICAgaGlkZGVuVXBkYXRlc0ZvckxhbmUucHVzaCh1cGRhdGUpO1xuICB9XG5cbiAgdXBkYXRlLmxhbmUgPSBsYW5lIHwgT2Zmc2NyZWVuTGFuZTtcbn1cbmZ1bmN0aW9uIGdldEJ1bXBlZExhbmVGb3JIeWRyYXRpb24ocm9vdCwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHJlbmRlckxhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHJlbmRlckxhbmVzKTtcbiAgdmFyIGxhbmU7XG5cbiAgaWYgKChyZW5kZXJMYW5lICYgU3luY1VwZGF0ZUxhbmVzKSAhPT0gTm9MYW5lKSB7XG4gICAgbGFuZSA9IFN5bmNIeWRyYXRpb25MYW5lO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAocmVuZGVyTGFuZSkge1xuICAgICAgY2FzZSBTeW5jTGFuZTpcbiAgICAgICAgbGFuZSA9IFN5bmNIeWRyYXRpb25MYW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lOlxuICAgICAgICBsYW5lID0gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgICAgIGxhbmUgPSBEZWZhdWx0SHlkcmF0aW9uTGFuZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTI6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTU6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTg6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMTpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNDpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICAgIGNhc2UgUmV0cnlMYW5lMTpcbiAgICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICAgIGNhc2UgUmV0cnlMYW5lMzpcbiAgICAgIGNhc2UgUmV0cnlMYW5lNDpcbiAgICAgICAgbGFuZSA9IFRyYW5zaXRpb25IeWRyYXRpb25MYW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgICAgbGFuZSA9IElkbGVIeWRyYXRpb25MYW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIGFscmVhZHkgZWl0aGVyIGEgaHlkcmF0aW9uIGxhbmUsIG9yIHNob3VsZG4ndFxuICAgICAgICAvLyBiZSByZXRyaWVkIGF0IGEgaHlkcmF0aW9uIGxhbmUuXG4gICAgICAgIGxhbmUgPSBOb0xhbmU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyBDaGVjayBpZiB0aGUgbGFuZSB3ZSBjaG9zZSBpcyBzdXNwZW5kZWQuIElmIHNvLCB0aGF0IGluZGljYXRlcyB0aGF0IHdlXG4gIC8vIGFscmVhZHkgYXR0ZW1wdGVkIGFuZCBmYWlsZWQgdG8gaHlkcmF0ZSBhdCB0aGF0IGxldmVsLiBBbHNvIGNoZWNrIGlmIHdlJ3JlXG4gIC8vIGFscmVhZHkgcmVuZGVyaW5nIHRoYXQgbGFuZSwgd2hpY2ggaXMgcmFyZSBidXQgY291bGQgaGFwcGVuLlxuXG5cbiAgaWYgKChsYW5lICYgKHJvb3Quc3VzcGVuZGVkTGFuZXMgfCByZW5kZXJMYW5lcykpICE9PSBOb0xhbmUpIHtcbiAgICAvLyBHaXZlIHVwIHRyeWluZyB0byBoeWRyYXRlIGFuZCBmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlci5cbiAgICByZXR1cm4gTm9MYW5lO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmVzKSB7XG5cbiAgaWYgKCFpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBsYW5lVG9JbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciB1cGRhdGVycyA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuICAgIHVwZGF0ZXJzLmFkZChmaWJlcik7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcykge1xuXG4gIGlmICghaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDtcbiAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIHVwZGF0ZXJzID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG5cbiAgICBpZiAodXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgIHVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCAhbWVtb2l6ZWRVcGRhdGVycy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1cGRhdGVycy5jbGVhcigpO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uc0ZvckxhbmVzKHJvb3QsIGxhbmVzKSB7XG4gIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgRGlzY3JldGVFdmVudFByaW9yaXR5ID0gU3luY0xhbmU7XG52YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lO1xudmFyIERlZmF1bHRFdmVudFByaW9yaXR5ID0gRGVmYXVsdExhbmU7XG52YXIgSWRsZUV2ZW50UHJpb3JpdHkgPSBJZGxlTGFuZTtcbmZ1bmN0aW9uIGhpZ2hlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuICByZXR1cm4gYSAhPT0gMCAmJiBhIDwgYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gbG93ZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IDAgfHwgYSA+IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGlzSGlnaGVyRXZlbnRQcmlvcml0eShhLCBiKSB7XG4gIHJldHVybiBhICE9PSAwICYmIGEgPCBiO1xufVxuZnVuY3Rpb24gZXZlbnRQcmlvcml0eVRvTGFuZSh1cGRhdGVQcmlvcml0eSkge1xuICByZXR1cm4gdXBkYXRlUHJpb3JpdHk7XG59XG5mdW5jdGlvbiBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcykge1xuICB2YXIgbGFuZSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO1xuXG4gIGlmICghaXNIaWdoZXJFdmVudFByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSwgbGFuZSkpIHtcbiAgICByZXR1cm4gRGlzY3JldGVFdmVudFByaW9yaXR5O1xuICB9XG5cbiAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoQ29udGludW91c0V2ZW50UHJpb3JpdHksIGxhbmUpKSB7XG4gICAgcmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuICB9XG5cbiAgaWYgKGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZSkpIHtcbiAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gIH1cblxuICByZXR1cm4gSWRsZUV2ZW50UHJpb3JpdHk7XG59XG5cbi8vIFRoaXMgbW9kdWxlIG9ubHkgZXhpc3RzIGFzIGFuIEVTTSB3cmFwcGVyIGFyb3VuZCB0aGUgZXh0ZXJuYWwgQ29tbW9uSlNcbnZhciBzY2hlZHVsZUNhbGxiYWNrJDMgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaztcbnZhciBjYW5jZWxDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xudmFyIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkO1xudmFyIHJlcXVlc3RQYWludCA9IFNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG52YXIgbm93JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93O1xudmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5O1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5O1xudmFyIE5vcm1hbFByaW9yaXR5JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHk7XG52YXIgSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eTsgLy8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IG9uIHRoZSBzY2hlZHVsZXIsIGJ1dCBpdCAqZG9lcypcbi8vIG9uIHNjaGVkdWxlci91bnN0YWJsZV9tb2NrLCB3aGljaCB3ZSdsbCBuZWVkIGZvciBpbnRlcm5hbCB0ZXN0aW5nXG5cbnZhciBsb2cgPSBTY2hlZHVsZXIubG9nO1xudmFyIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgfSAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cblxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIpIHtcbiAgICAgIC8vIENvbmRpdGlvbmFsbHkgaW5qZWN0IHRoZXNlIGhvb2tzIG9ubHkgaWYgVGltZWxpbmUgcHJvZmlsZXIgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgYnVpbGQuXG4gICAgICAvLyBUaGlzIGdpdmVzIERldlRvb2xzIGEgd2F5IHRvIGZlYXR1cmUgZGV0ZWN0IHRoYXQgaXNuJ3QgdGllZCB0byB2ZXJzaW9uIG51bWJlclxuICAgICAgLy8gKHNpbmNlIHByb2ZpbGluZyBhbmQgdGltZWxpbmUgYXJlIGNvbnRyb2xsZWQgYnkgZGlmZmVyZW50IGZlYXR1cmUgZmxhZ3MpLlxuICAgICAgaW50ZXJuYWxzID0gYXNzaWduKHt9LCBpbnRlcm5hbHMsIHtcbiAgICAgICAgZ2V0TGFuZUxhYmVsTWFwOiBnZXRMYW5lTGFiZWxNYXAsXG4gICAgICAgIGluamVjdFByb2ZpbGluZ0hvb2tzOiBpbmplY3RQcm9maWxpbmdIb29rc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7IC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG5cbiAgICBpbmplY3RlZEhvb2sgPSBob29rO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy4nLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChob29rLmNoZWNrRENFKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgcmVhbCBEZXZUb29scy5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGxpa2VseSBhIGhvb2sgaW5zdGFsbGVkIGJ5IEZhc3QgUmVmcmVzaCBydW50aW1lLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gb25TY2hlZHVsZVJvb3Qocm9vdCwgY2hpbGRyZW4pIHtcbiAge1xuICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBjaGlsZHJlbik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRSb290JDEocm9vdCwgZXZlbnRQcmlvcml0eSkge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGRpZEVycm9yID0gKHJvb3QuY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpID09PSBEaWRDYXB0dXJlO1xuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHk7XG5cbiAgICAgICAgc3dpdGNoIChldmVudFByaW9yaXR5KSB7XG4gICAgICAgICAgY2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBEZWZhdWx0RXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBJZGxlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgc2NoZWR1bGVyUHJpb3JpdHksIGRpZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Qb3N0Q29tbWl0Um9vdChyb290KSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhuZXdJc1N0cmljdE1vZGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgbG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBXZSdyZSBpbiBhIHRlc3QgYmVjYXVzZSBTY2hlZHVsZXIubG9nIG9ubHkgZXhpc3RzXG4gICAgICAvLyBpbiBTY2hlZHVsZXJNb2NrLiBUbyByZWR1Y2UgdGhlIG5vaXNlIGluIHN0cmljdCBtb2RlIHRlc3RzLFxuICAgICAgLy8gc3VwcHJlc3Mgd2FybmluZ3MgYW5kIGRpc2FibGUgc2NoZWR1bGVyIHlpZWxkaW5nIGR1cmluZyB0aGUgZG91YmxlIHJlbmRlclxuICAgICAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUobmV3SXNTdHJpY3RNb2RlKTtcbiAgICAgIHNldFN1cHByZXNzV2FybmluZyhuZXdJc1N0cmljdE1vZGUpO1xuICAgIH1cblxuICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbmplY3RlZEhvb2suc2V0U3RyaWN0TW9kZShyZW5kZXJlcklELCBuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gUHJvZmlsZXIgQVBJIGhvb2tzXG5cbmZ1bmN0aW9uIGluamVjdFByb2ZpbGluZ0hvb2tzKHByb2ZpbGluZ0hvb2tzKSB7XG4gIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBwcm9maWxpbmdIb29rcztcbn1cblxuZnVuY3Rpb24gZ2V0TGFuZUxhYmVsTWFwKCkge1xuICB7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgbGFuZSA9IDE7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgVG90YWxMYW5lczsgaW5kZXgrKykge1xuICAgICAgdmFyIGxhYmVsID0gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpO1xuICAgICAgbWFwLnNldChsYW5lLCBsYWJlbCk7XG4gICAgICBsYW5lICo9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQ29tbWl0U3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbW1pdFN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50RXJyb3JlZChmaWJlciwgdGhyb3duVmFsdWUsIGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50RXJyb3JlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50RXJyb3JlZChmaWJlciwgdGhyb3duVmFsdWUsIGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkKGZpYmVyLCB3YWtlYWJsZSwgbGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1JlbmRlcllpZWxkZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1JlbmRlclN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1JlbmRlclNjaGVkdWxlZChsYW5lKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxuLy8gVGhpcyBpcyBpbXBvcnRlZCBieSB0aGUgZXZlbnQgcmVwbGF5aW5nIGltcGxlbWVudGF0aW9uIGluIFJlYWN0IERPTS4gSXQnc1xuLy8gaW4gYSBzZXBhcmF0ZSBmaWxlIHRvIGJyZWFrIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSByZW5kZXJlciBhbmRcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gaXNSb290RGVoeWRyYXRlZChyb290KSB7XG4gIHZhciBjdXJyZW50U3RhdGUgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG59XG5cbnZhciBDYXB0dXJlZFN0YWNrcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlKSB7XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciwgY2FsbCB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIHRocm93blxuICAvLyBzbyB0aGUgc3RhY2sgaXMgYWNjdXJhdGUuXG4gIHZhciBzdGFjaztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHZhciBjYXB0dXJlZFN0YWNrID0gQ2FwdHVyZWRTdGFja3MuZ2V0KHZhbHVlKTtcblxuICAgIGlmICh0eXBlb2YgY2FwdHVyZWRTdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN0YWNrID0gY2FwdHVyZWRTdGFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKTtcbiAgICAgIENhcHR1cmVkU3RhY2tzLnNldCh2YWx1ZSwgc3RhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IHN0YWNrXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlRnJvbUVycm9yKHZhbHVlLCBzdGFjaykge1xuICBpZiAodHlwZW9mIHN0YWNrID09PSAnc3RyaW5nJykge1xuICAgIENhcHR1cmVkU3RhY2tzLnNldCh2YWx1ZSwgc3RhY2spO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBudWxsLFxuICAgIHN0YWNrOiBzdGFja1xuICB9O1xufVxuXG4vLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBpdCB5ZXQgdG8gZGVyaXNrIHRoZSBpbml0aWFsIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlXG4vLyB0aGUgd2F5IHdlIHB1c2gvcG9wIHRoZXNlIHZhbHVlcyBpcyBhIGJpdCB1bnVzdWFsLiBJZiB0aGVyZSdzIGEgbWlzdGFrZSwgSSdkXG4vLyByYXRoZXIgdGhlIGlkcyBiZSB3cm9uZyB0aGFuIGNyYXNoIHRoZSB3aG9sZSByZWNvbmNpbGVyLlxuXG52YXIgZm9ya1N0YWNrID0gW107XG52YXIgZm9ya1N0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVGb3JrQ291bnQgPSAwO1xudmFyIGlkU3RhY2sgPSBbXTtcbnZhciBpZFN0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVDb250ZXh0SWQgPSAxO1xudmFyIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSAnJztcbmZ1bmN0aW9uIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JrZWQpICE9PSBOb0ZsYWdzJDE7XG59XG5mdW5jdGlvbiBnZXRGb3Jrc0F0TGV2ZWwod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIHJldHVybiB0cmVlRm9ya0NvdW50O1xufVxuZnVuY3Rpb24gZ2V0VHJlZUlkKCkge1xuICB2YXIgb3ZlcmZsb3cgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICB2YXIgaWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gIHZhciBpZCA9IGlkV2l0aExlYWRpbmdCaXQgJiB+Z2V0TGVhZGluZ0JpdChpZFdpdGhMZWFkaW5nQml0KTtcbiAgcmV0dXJuIGlkLnRvU3RyaW5nKDMyKSArIG92ZXJmbG93O1xufVxuZnVuY3Rpb24gcHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHdlIHJlY29uY2lsZSBhbiBhcnJheSAob3IgaXRlcmF0b3IpIG9mIGNoaWxkXG4gIC8vIGZpYmVycywgYmVjYXVzZSB0aGF0J3MgdGhlIG9ubHkgcGxhY2Ugd2hlcmUgd2Uga25vdyBob3cgbWFueSBjaGlsZHJlbiBpblxuICAvLyB0aGUgd2hvbGUgc2V0IHdpdGhvdXQgZG9pbmcgZXh0cmEgd29yayBsYXRlciwgb3Igc3RvcmluZyBhZGR0aW9uYWxcbiAgLy8gaW5mb3JtYXRpb24gb24gdGhlIGZpYmVyLlxuICAvL1xuICAvLyBUaGF0J3Mgd2h5IHRoaXMgZnVuY3Rpb24gaXMgc2VwYXJhdGUgZnJvbSBwdXNoVHJlZUlkIOKAlCBpdCdzIGNhbGxlZCBkdXJpbmdcbiAgLy8gdGhlIHJlbmRlciBwaGFzZSBvZiB0aGUgZm9yayBwYXJlbnQsIG5vdCB0aGUgY2hpbGQsIHdoaWNoIGlzIHdoZXJlIHdlIHB1c2hcbiAgLy8gdGhlIG90aGVyIGNvbnRleHQgdmFsdWVzLlxuICAvL1xuICAvLyBJbiB0aGUgRml6eiBpbXBsZW1lbnRhdGlvbiB0aGlzIGlzIG11Y2ggc2ltcGxlciBiZWNhdXNlIHRoZSBjaGlsZCBpc1xuICAvLyByZW5kZXJlZCBpbiB0aGUgc2FtZSBjYWxsc3RhY2sgYXMgdGhlIHBhcmVudC5cbiAgLy9cbiAgLy8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgYWRkIGEgYGZvcmtzYCBmaWVsZCB0byB0aGUgRmliZXIgdHlwZS4gSXQgd291bGRcbiAgLy8gbWFrZSB0aGlzIG1vZHVsZSBzaW1wbGVyLlxuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtDb3VudDtcbiAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtQcm92aWRlcjtcbiAgdHJlZUZvcmtQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICB0cmVlRm9ya0NvdW50ID0gdG90YWxDaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQ7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyO1xuICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBiYXNlSWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gIHZhciBiYXNlT3ZlcmZsb3cgPSB0cmVlQ29udGV4dE92ZXJmbG93OyAvLyBUaGUgbGVmdG1vc3QgMSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgbm9uLWluY2x1c2l2ZS4gSXQncyBub3QgcGFydFxuICAvLyBvZiB0aGUgaWQ7IHdlIHVzZSBpdCB0byBhY2NvdW50IGZvciBsZWFkaW5nIDBzLlxuXG4gIHZhciBiYXNlTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gIHZhciBiYXNlSWQgPSBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmIH4oMSA8PCBiYXNlTGVuZ3RoKTtcbiAgdmFyIHNsb3QgPSBpbmRleCArIDE7XG4gIHZhciBsZW5ndGggPSBnZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoOyAvLyAzMCBpcyB0aGUgbWF4IGxlbmd0aCB3ZSBjYW4gc3RvcmUgd2l0aG91dCBvdmVyZmxvd2luZywgdGFraW5nIGludG9cbiAgLy8gY29uc2lkZXJhdGlvbiB0aGUgbGVhZGluZyAxIHdlIHVzZSB0byBtYXJrIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuXG4gIGlmIChsZW5ndGggPiAzMCkge1xuICAgIC8vIFdlIG92ZXJmbG93ZWQgdGhlIGJpdHdpc2Utc2FmZSByYW5nZS4gRmFsbCBiYWNrIHRvIHNsb3dlciBhbGdvcml0aG0uXG4gICAgLy8gVGhpcyBicmFuY2ggYXNzdW1lcyB0aGUgbGVuZ3RoIG9mIHRoZSBiYXNlIGlkIGlzIGdyZWF0ZXIgdGhhbiA1OyBpdCB3b24ndFxuICAgIC8vIHdvcmsgZm9yIHNtYWxsZXIgaWRzLCBiZWNhdXNlIHlvdSBuZWVkIDUgYml0cyBwZXIgY2hhcmFjdGVyLlxuICAgIC8vXG4gICAgLy8gV2UgZW5jb2RlIHRoZSBpZCBpbiBtdWx0aXBsZSBzdGVwczogZmlyc3QgdGhlIGJhc2UgaWQsIHRoZW4gdGhlXG4gICAgLy8gcmVtYWluaW5nIGRpZ2l0cy5cbiAgICAvL1xuICAgIC8vIEVhY2ggNSBiaXQgc2VxdWVuY2UgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgYmFzZSAzMiBjaGFyYWN0ZXIuIFNvIGZvclxuICAgIC8vIGV4YW1wbGUsIGlmIHRoZSBjdXJyZW50IGlkIGlzIDIzIGJpdHMgbG9uZywgd2UgY2FuIGNvbnZlcnQgMjAgb2YgdGhvc2VcbiAgICAvLyBiaXRzIGludG8gYSBzdHJpbmcgb2YgNCBjaGFyYWN0ZXJzLCB3aXRoIDMgYml0cyBsZWZ0IG92ZXIuXG4gICAgLy9cbiAgICAvLyBGaXJzdCBjYWxjdWxhdGUgaG93IG1hbnkgYml0cyBpbiB0aGUgYmFzZSBpZCByZXByZXNlbnQgYSBjb21wbGV0ZVxuICAgIC8vIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMuXG4gICAgdmFyIG51bWJlck9mT3ZlcmZsb3dCaXRzID0gYmFzZUxlbmd0aCAtIGJhc2VMZW5ndGggJSA1OyAvLyBUaGVuIGNyZWF0ZSBhIGJpdG1hc2sgdGhhdCBzZWxlY3RzIG9ubHkgdGhvc2UgYml0cy5cblxuICAgIHZhciBuZXdPdmVyZmxvd0JpdHMgPSAoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxOyAvLyBTZWxlY3QgdGhlIGJpdHMsIGFuZCBjb252ZXJ0IHRoZW0gdG8gYSBiYXNlIDMyIHN0cmluZy5cblxuICAgIHZhciBuZXdPdmVyZmxvdyA9IChiYXNlSWQgJiBuZXdPdmVyZmxvd0JpdHMpLnRvU3RyaW5nKDMyKTsgLy8gTm93IHdlIGNhbiByZW1vdmUgdGhvc2UgYml0cyBmcm9tIHRoZSBiYXNlIGlkLlxuXG4gICAgdmFyIHJlc3RPZkJhc2VJZCA9IGJhc2VJZCA+PiBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICB2YXIgcmVzdE9mQmFzZUxlbmd0aCA9IGJhc2VMZW5ndGggLSBudW1iZXJPZk92ZXJmbG93Qml0czsgLy8gRmluYWxseSwgZW5jb2RlIHRoZSByZXN0IG9mIHRoZSBiaXRzIHVzaW5nIHRoZSBub3JtYWwgYWxnb3JpdGhtLiBCZWNhdXNlXG4gICAgLy8gd2UgbWFkZSBtb3JlIHJvb20sIHRoaXMgdGltZSBpdCB3b24ndCBvdmVyZmxvdy5cblxuICAgIHZhciByZXN0T2ZMZW5ndGggPSBnZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikgKyByZXN0T2ZCYXNlTGVuZ3RoO1xuICAgIHZhciByZXN0T2ZOZXdCaXRzID0gc2xvdCA8PCByZXN0T2ZCYXNlTGVuZ3RoO1xuICAgIHZhciBpZCA9IHJlc3RPZk5ld0JpdHMgfCByZXN0T2ZCYXNlSWQ7XG4gICAgdmFyIG92ZXJmbG93ID0gbmV3T3ZlcmZsb3cgKyBiYXNlT3ZlcmZsb3c7XG4gICAgdHJlZUNvbnRleHRJZCA9IDEgPDwgcmVzdE9mTGVuZ3RoIHwgaWQ7XG4gICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IG92ZXJmbG93O1xuICB9IGVsc2Uge1xuICAgIC8vIE5vcm1hbCBwYXRoXG4gICAgdmFyIG5ld0JpdHMgPSBzbG90IDw8IGJhc2VMZW5ndGg7XG5cbiAgICB2YXIgX2lkID0gbmV3Qml0cyB8IGJhc2VJZDtcblxuICAgIHZhciBfb3ZlcmZsb3cgPSBiYXNlT3ZlcmZsb3c7XG4gICAgdHJlZUNvbnRleHRJZCA9IDEgPDwgbGVuZ3RoIHwgX2lkO1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBfb3ZlcmZsb3c7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7IC8vIFRoaXMgY29tcG9uZW50IG1hdGVyaWFsaXplZCBhbiBpZC4gVGhpcyB3aWxsIGFmZmVjdCBhbnkgaWRzIHRoYXQgYXBwZWFyXG4gIC8vIGluIGl0cyBjaGlsZHJlbi5cblxuICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgdmFyIG51bWJlck9mRm9ya3MgPSAxO1xuICAgIHZhciBzbG90SW5kZXggPSAwO1xuICAgIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgbnVtYmVyT2ZGb3Jrcywgc2xvdEluZGV4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaXRMZW5ndGgobnVtYmVyKSB7XG4gIHJldHVybiAzMiAtIGNsejMyKG51bWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldExlYWRpbmdCaXQoaWQpIHtcbiAgcmV0dXJuIDEgPDwgZ2V0Qml0TGVuZ3RoKGlkKSAtIDE7XG59XG5cbmZ1bmN0aW9uIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHZhbHVlcy5cbiAgLy8gVGhpcyBpcyBhIGJpdCBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gb3RoZXIgY29udGV4dC1saWtlIG1vZHVsZXMgaW4gRmliZXJcbiAgLy8gYmVjYXVzZSB0aGUgc2FtZSBGaWJlciBtYXkgYXBwZWFyIG9uIHRoZSBzdGFjayBtdWx0aXBsZSB0aW1lcyBhbmQgZm9yXG4gIC8vIGRpZmZlcmVudCByZWFzb25zLiBXZSBoYXZlIHRvIGtlZXAgcG9wcGluZyB1bnRpbCB0aGUgd29yay1pbi1wcm9ncmVzcyBpc1xuICAvLyBubyBsb25nZXIgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2suXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUZvcmtQcm92aWRlcikge1xuICAgIHRyZWVGb3JrUHJvdmlkZXIgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07XG4gICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGw7XG4gICAgdHJlZUZvcmtDb3VudCA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XTtcbiAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUNvbnRleHRQcm92aWRlcikge1xuICAgIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XTtcbiAgICBpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsO1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XTtcbiAgICBpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsO1xuICAgIHRyZWVDb250ZXh0SWQgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XTtcbiAgICBpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCgpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG5cbiAgaWYgKHRyZWVDb250ZXh0UHJvdmlkZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRyZWVDb250ZXh0SWQsXG4gICAgICBvdmVyZmxvdzogdHJlZUNvbnRleHRPdmVyZmxvd1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuZGVkQ29udGV4dCkge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgdHJlZUNvbnRleHRJZCA9IHN1c3BlbmRlZENvbnRleHQuaWQ7XG4gIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBzdXNwZW5kZWRDb250ZXh0Lm92ZXJmbG93O1xuICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZk5vdEh5ZHJhdGluZygpIHtcbiAge1xuICAgIGlmICghZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGJlIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgJyArICdhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTsgLy8gUmVwcmVzZW50cyB0aGUgbmVhcmVzdCBob3N0IHRyYW5zaXRpb24gcHJvdmlkZXIgKGluIFJlYWN0IERPTSwgYSA8Zm9ybSAvPilcbi8vIE5PVEU6IFNpbmNlIGZvcm1zIGNhbm5vdCBiZSBuZXN0ZWQsIGFuZCB0aGlzIGZlYXR1cmUgaXMgb25seSBpbXBsZW1lbnRlZCBieVxuLy8gUmVhY3QgRE9NLCB3ZSBkb24ndCB0ZWNobmljYWxseSBuZWVkIHRoaXMgdG8gYmUgYSBzdGFjay4gSXQgY291bGQgYmUgYSBzaW5nbGVcbi8vIG1vZHVsZSB2YXJpYWJsZSBpbnN0ZWFkLlxuXG52YXIgaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTsgLy8gVE9ETzogVGhpcyBzaG91bGQgaW5pdGlhbGl6ZSB0byBOb3RQZW5kaW5nVHJhbnNpdGlvbiwgYSBjb25zdGFudFxuLy8gaW1wb3J0ZWQgZnJvbSB0aGUgZmliZXIgY29uZmlnLiBIb3dldmVyLCBiZWNhdXNlIG9mIGEgY3ljbGUgaW4gdGhlIG1vZHVsZVxuLy8gZ3JhcGgsIHRoYXQgdmFsdWUgaXNuJ3QgZGVmaW5lZCBkdXJpbmcgdGhpcyBtb2R1bGUncyBpbml0aWFsaXphdGlvbi4gSSBjYW4ndFxuLy8gdGhpbmsgb2YgYSB3YXkgdG8gd29yayBhcm91bmQgdGhpcyB3aXRob3V0IG1vdmluZyB0aGF0IHZhbHVlIG91dCBvZiB0aGVcbi8vIGZpYmVyIGNvbmZpZy4gRm9yIG5vdywgdGhlIFwibm8gcHJvdmlkZXJcIiBjYXNlIGlzIGhhbmRsZWQgd2hlbiByZWFkaW5nLFxuLy8gaW5zaWRlIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzLlxuXG52YXIgSG9zdFRyYW5zaXRpb25Db250ZXh0ID0ge1xuICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICBQcm92aWRlcjogbnVsbCxcbiAgQ29uc3VtZXI6IG51bGwsXG4gIF9jdXJyZW50VmFsdWU6IG51bGwsXG4gIF9jdXJyZW50VmFsdWUyOiBudWxsLFxuICBfdGhyZWFkQ291bnQ6IDBcbn07XG5cbmZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gIHtcbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTsgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5cbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTsgLy8gRmluYWxseSwgd2UgbmVlZCB0byBwdXNoIHRoZSBob3N0IGNvbnRleHQgdG8gdGhlIHN0YWNrLlxuICAvLyBIb3dldmVyLCB3ZSBjYW4ndCBqdXN0IGNhbGwgZ2V0Um9vdEhvc3RDb250ZXh0KCkgYW5kIHB1c2ggaXQgYmVjYXVzZVxuICAvLyB3ZSdkIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudHJpZXMgb24gdGhlIHN0YWNrIGRlcGVuZGluZyBvblxuICAvLyB3aGV0aGVyIGdldFJvb3RIb3N0Q29udGV4dCgpIHRocm93cyBzb21ld2hlcmUgaW4gcmVuZGVyZXIgY29kZSBvciBub3QuXG4gIC8vIFNvIHdlIHB1c2ggYW4gZW1wdHkgdmFsdWUgZmlyc3QuIFRoaXMgbGV0cyB1cyBzYWZlbHkgdW53aW5kIG9uIGVycm9ycy5cblxuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbnVsbCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOyAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICB7XG4gICAgdmFyIHN0YXRlSG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3RhdGVIb29rICE9PSBudWxsKSB7XG4gICAgICAvLyBPbmx5IHByb3ZpZGUgY29udGV4dCBpZiB0aGlzIGZpYmVyIGhhcyBiZWVuIHVwZ3JhZGVkIGJ5IGEgaG9zdFxuICAgICAgLy8gdHJhbnNpdGlvbi4gV2UgdXNlIHRoZSBzYW1lIG9wdGltaXphdGlvbiBmb3IgcmVndWxhciBob3N0IGNvbnRleHQgYmVsb3cuXG4gICAgICBwdXNoKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUpOyAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cblxuICBpZiAoY29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRDb250ZXh0LCBmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyKSB7XG4gICAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgIC8vIHB1c2hIb3N0Q29udGV4dCgpIG9ubHkgcHVzaGVzIEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50ID09PSBmaWJlcikge1xuICAgICAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LiBUaGlzIGlzIG1vc3RseVxuICAgICAgLy8gYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIGJ1dCBjb252ZW5pZW50bHkgaXQgYWxzbyBwcmV2ZW50cyBhIHBvdGVudGlhbFxuICAgICAgLy8gZGF0YSByYWNlIHdoZXJlIGEgaG9zdCBwcm92aWRlciBpcyB1cGdyYWRlZCAoaS5lLiBtZW1vaXplZFN0YXRlIGJlY29tZXNcbiAgICAgIC8vIG5vbi1udWxsKSBkdXJpbmcgYSBjb25jdXJyZW50IGV2ZW50LiBUaGlzIGlzIGEgYml0IG9mIGEgZmxhdyBpbiB0aGUgd2F5XG4gICAgICAvLyB3ZSB1cGdyYWRlIGhvc3QgY29tcG9uZW50cywgYnV0IGJlY2F1c2Ugd2UncmUgYWNjb3VudGluZyBmb3IgaXQgaGVyZSwgaXRcbiAgICAgIC8vIHNob3VsZCBiZSBmaW5lLlxuICAgICAgcG9wKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyKTsgLy8gV2hlbiBwb3BwaW5nIHRoZSB0cmFuc2l0aW9uIHByb3ZpZGVyLCB3ZSByZXNldCB0aGUgY29udGV4dCB2YWx1ZSBiYWNrXG4gICAgICAvLyB0byBgbnVsbGAuIFdlIGNhbiBkbyB0aGlzIGJlY2F1c2UgeW91J3JlIG5vdCBhbGxvd2QgdG8gbmVzdCBmb3Jtcy4gSWZcbiAgICAgIC8vIHdlIGFsbG93ZWQgZm9yIG11bHRpcGxlIG5lc3RlZCBob3N0IHRyYW5zaXRpb24gcHJvdmlkZXJzLCB0aGVuIHdlJ2RcbiAgICAgIC8vIG5lZWQgdG8gcmVzZXQgdGhpcyB0byB0aGUgcGFyZW50IHByb3ZpZGVyJ3Mgc3RhdHVzLlxuXG4gICAgICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIG1heFJvd0xlbmd0aCA9IDEyMDtcbnZhciBpZGVhbERlcHRoID0gMTU7XG5cbmZ1bmN0aW9uIGZpbmROb3RhYmxlTm9kZShub2RlLCBpbmRlbnQpIHtcbiAgaWYgKG5vZGUuc2VydmVyUHJvcHMgPT09IHVuZGVmaW5lZCAmJiBub2RlLnNlcnZlclRhaWwubGVuZ3RoID09PSAwICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuZGlzdGFuY2VGcm9tTGVhZiA+IDMgJiYgbm9kZS5kaXN0YW5jZUZyb21MZWFmID4gaWRlYWxEZXB0aCAtIGluZGVudCkge1xuICAgIC8vIFRoaXMgaXMgbm90IGFuIGludGVyZXN0aW5nIG5vZGUgZm9yIGNvbnRleHR1YWwgcHVycG9zZXMgc28gd2UgY2FuIHNraXAgaXQuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gZmluZE5vdGFibGVOb2RlKGNoaWxkLCBpbmRlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGluZGVudGF0aW9uKGluZGVudCkge1xuICByZXR1cm4gJyAgJyArICcgICcucmVwZWF0KGluZGVudCk7XG59XG5cbmZ1bmN0aW9uIGFkZGVkKGluZGVudCkge1xuICByZXR1cm4gJysgJyArICcgICcucmVwZWF0KGluZGVudCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZWQoaW5kZW50KSB7XG4gIHJldHVybiAnLSAnICsgJyAgJy5yZXBlYXQoaW5kZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBmaWJlci50eXBlO1xuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgcmV0dXJuICdMYXp5JztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB2YXIgZm4gPSBmaWJlci50eXBlO1xuICAgICAgcmV0dXJuIGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgfHwgbnVsbDtcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHZhciByZW5kZXIgPSBmaWJlci50eXBlLnJlbmRlcjtcbiAgICAgIHJldHVybiByZW5kZXIuZGlzcGxheU5hbWUgfHwgcmVuZGVyLm5hbWUgfHwgbnVsbDtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB2YXIgY3RyID0gZmliZXIudHlwZTtcbiAgICAgIHJldHVybiBjdHIuZGlzcGxheU5hbWUgfHwgY3RyLm5hbWUgfHwgbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBTa2lwXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgbmVlZHNFc2NhcGluZyA9IC9bXCInJjw+XFxuXFx0XS87XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVGV4dE5vZGUoY29udGVudCwgbWF4TGVuZ3RoKSB7XG4gIGlmIChuZWVkc0VzY2FwaW5nLnRlc3QoY29udGVudCkpIHtcbiAgICB2YXIgZW5jb2RlZCA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpO1xuXG4gICAgaWYgKGVuY29kZWQubGVuZ3RoID4gbWF4TGVuZ3RoIC0gMikge1xuICAgICAgaWYgKG1heExlbmd0aCA8IDgpIHtcbiAgICAgICAgcmV0dXJuICd7XCIuLi5cIn0nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ3snICsgZW5jb2RlZC5zbGljZSgwLCBtYXhMZW5ndGggLSA3KSArICcuLi5cIn0nO1xuICAgIH1cblxuICAgIHJldHVybiAneycgKyBlbmNvZGVkICsgJ30nO1xuICB9IGVsc2Uge1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgaWYgKG1heExlbmd0aCA8IDUpIHtcbiAgICAgICAgcmV0dXJuICd7XCIuLi5cIn0nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudC5zbGljZSgwLCBtYXhMZW5ndGggLSAzKSArICcuLi4nO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVGV4dERpZmYoY2xpZW50VGV4dCwgc2VydmVyUHJvcHMsIGluZGVudCkge1xuICB2YXIgbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gaW5kZW50ICogMjtcblxuICBpZiAoc2VydmVyUHJvcHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYWRkZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArICdcXG4nO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXJ2ZXJQcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VydmVyVGV4dCA9IHNlcnZlclByb3BzO1xuICAgIHZhciBmaXJzdERpZmYgPSAwO1xuXG4gICAgZm9yICg7IGZpcnN0RGlmZiA8IHNlcnZlclRleHQubGVuZ3RoICYmIGZpcnN0RGlmZiA8IGNsaWVudFRleHQubGVuZ3RoOyBmaXJzdERpZmYrKykge1xuICAgICAgaWYgKHNlcnZlclRleHQuY2hhckNvZGVBdChmaXJzdERpZmYpICE9PSBjbGllbnRUZXh0LmNoYXJDb2RlQXQoZmlyc3REaWZmKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlyc3REaWZmID4gbWF4TGVuZ3RoIC0gOCAmJiBmaXJzdERpZmYgPiAxMCkge1xuICAgICAgLy8gVGhlIGZpcnN0IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIHN0cmluZ3Mgd291bGQgYmUgY3V0IG9mZiwgc28gY3V0IG9mZiBpblxuICAgICAgLy8gdGhlIGJlZ2lubmluZyBpbnN0ZWFkLlxuICAgICAgY2xpZW50VGV4dCA9ICcuLi4nICsgY2xpZW50VGV4dC5zbGljZShmaXJzdERpZmYgLSA4KTtcbiAgICAgIHNlcnZlclRleHQgPSAnLi4uJyArIHNlcnZlclRleHQuc2xpY2UoZmlyc3REaWZmIC0gOCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyAnXFxuJyArIHJlbW92ZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoc2VydmVyVGV4dCwgbWF4TGVuZ3RoKSArICdcXG4nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbmRlbnRhdGlvbihpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICsgJ1xcbic7XG4gIH1cbn1cblxuZnVuY3Rpb24gb2JqZWN0TmFtZShvYmplY3QpIHtcbiAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICB2YXIgbmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKilcXF0kLywgZnVuY3Rpb24gKG0sIHAwKSB7XG4gICAgcmV0dXJuIHAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGVuY29kZWQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGVuY29kZWQubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG1heExlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCIuLi5cIic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVuY29kZWQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNCkgKyAnLi4uXCInO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVuY29kZWQ7XG4gICAgICB9XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdbLi4uXSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICAgIHZhciB0eXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHZhbHVlLnR5cGUpO1xuICAgICAgICAgIHJldHVybiB0eXBlID8gJzwnICsgdHlwZSArICc+JyA6ICc8Li4uPic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChuYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gJyc7XG4gICAgICAgICAgbWF4TGVuZ3RoIC09IDI7XG5cbiAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBqc29uUHJvcE5hbWUgPSBKU09OLnN0cmluZ2lmeShwcm9wTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChqc29uUHJvcE5hbWUgIT09ICdcIicgKyBwcm9wTmFtZSArICdcIicpIHtcbiAgICAgICAgICAgICAgcHJvcE5hbWUgPSBqc29uUHJvcE5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggLSAyO1xuICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlVmFsdWUodmFsdWVbcHJvcE5hbWVdLCBtYXhMZW5ndGggPCAxNSA/IG1heExlbmd0aCA6IDE1KTtcbiAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAobWF4TGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzICs9IHByb3BlcnRpZXMgPT09ICcnID8gJy4uLicgOiAnLCAuLi4nO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydGllcyArPSAocHJvcGVydGllcyA9PT0gJycgPyAnJyA6ICcsJykgKyBwcm9wTmFtZSArICc6JyArIHByb3BWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJ3snICsgcHJvcGVydGllcyArICd9JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICB2YXIgX25hbWUgPSB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lO1xuXG4gICAgICAgIHJldHVybiBfbmFtZSA/ICdmdW5jdGlvbiAnICsgX25hbWUgOiAnZnVuY3Rpb24nO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVQcm9wVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhbmVlZHNFc2NhcGluZy50ZXN0KHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGggLSAyKSB7XG4gICAgICBpZiAobWF4TGVuZ3RoIDwgNSkge1xuICAgICAgICByZXR1cm4gJ1wiLi4uXCInO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1wiJyArIHZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCAtIDUpICsgJy4uLlwiJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiAneycgKyBkZXNjcmliZVZhbHVlKHZhbHVlLCBtYXhMZW5ndGggLSAyKSArICd9Jztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDb2xsYXBzZWRFbGVtZW50KHR5cGUsIHByb3BzLCBpbmRlbnQpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBmaXQgdGhlIHByb3BzIGludG8gYSBzaW5nbGUgbGluZSBmb3Igbm9uLWVzc2VudGlhbCBlbGVtZW50cy5cbiAgLy8gV2UgYWxzbyBpZ25vcmUgY2hpbGRyZW4gYmVjYXVzZSB3ZSdyZSBub3QgZ29pbmcgZGVlcGVyLlxuICB2YXIgbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gaW5kZW50ICogMiAtIHR5cGUubGVuZ3RoIC0gMjtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcE5hbWUgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgIC8vIElnbm9yZWQuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUocHJvcHNbcHJvcE5hbWVdLCAxNSk7XG4gICAgbWF4TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCArIHByb3BWYWx1ZS5sZW5ndGggKyAyO1xuXG4gICAgaWYgKG1heExlbmd0aCA8IDApIHtcbiAgICAgIGNvbnRlbnQgKz0gJyAuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29udGVudCArPSAnICcgKyBwcm9wTmFtZSArICc9JyArIHByb3BWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBpbmRlbnRhdGlvbihpbmRlbnQpICsgJzwnICsgdHlwZSArIGNvbnRlbnQgKyAnPlxcbic7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KHR5cGUsIHByb3BzLCByb3dQcmVmaXgpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBmaXQgdGhlIHByb3BzIGludG8gYSBzaW5nbGUgbGluZSBmb3Igbm9uLWVzc2VudGlhbCBlbGVtZW50cy5cbiAgLy8gV2UgYWxzbyBpZ25vcmUgY2hpbGRyZW4gYmVjYXVzZSB3ZSdyZSBub3QgZ29pbmcgZGVlcGVyLlxuICB2YXIgcmVtYWluaW5nUm93TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gcm93UHJlZml4Lmxlbmd0aCAtIHR5cGUubGVuZ3RoOyAvLyBXZSBhZGQgdGhlIHByb3BlcnRpZXMgdG8gYSBzZXQgc28gd2UgY2FuIGNob29zZSBsYXRlciB3aGV0aGVyIHdlJ2xsIHB1dCBpdCBvbiBvbmVcbiAgLy8gbGluZSBvciBtdWx0aXBsZSBsaW5lcy5cblxuICB2YXIgcHJvcGVydGllcyA9IFtdO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wTmFtZSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgLy8gSWdub3JlZC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBtYXhMZW5ndGggPSBtYXhSb3dMZW5ndGggLSByb3dQcmVmaXgubGVuZ3RoIC0gcHJvcE5hbWUubGVuZ3RoIC0gMTtcbiAgICB2YXIgcHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUocHJvcHNbcHJvcE5hbWVdLCBtYXhMZW5ndGgpO1xuICAgIHJlbWFpbmluZ1Jvd0xlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggKyBwcm9wVmFsdWUubGVuZ3RoICsgMjtcbiAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcE5hbWUgKyAnPScgKyBwcm9wVmFsdWUpO1xuICB9XG5cbiAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJvd1ByZWZpeCArICc8JyArIHR5cGUgKyAnPlxcbic7XG4gIH0gZWxzZSBpZiAocmVtYWluaW5nUm93TGVuZ3RoID4gMCkge1xuICAgIC8vIFdlIGNhbiBmaXQgYWxsIG9uIG9uZSByb3cuXG4gICAgcmV0dXJuIHJvd1ByZWZpeCArICc8JyArIHR5cGUgKyAnICcgKyBwcm9wZXJ0aWVzLmpvaW4oJyAnKSArICc+XFxuJztcbiAgfSBlbHNlIHtcbiAgICAvLyBTcGxpdCBpbnRvIG9uZSByb3cgcGVyIHByb3BlcnR5OlxuICAgIHJldHVybiByb3dQcmVmaXggKyAnPCcgKyB0eXBlICsgJ1xcbicgKyByb3dQcmVmaXggKyAnICAnICsgcHJvcGVydGllcy5qb2luKCdcXG4nICsgcm93UHJlZml4ICsgJyAgJykgKyAnXFxuJyArIHJvd1ByZWZpeCArICc+XFxuJztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZVByb3BlcnRpZXNEaWZmKGNsaWVudE9iamVjdCwgc2VydmVyT2JqZWN0LCBpbmRlbnQpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSAnJztcbiAgdmFyIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMgPSBhc3NpZ24oe30sIHNlcnZlck9iamVjdCk7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY2xpZW50T2JqZWN0KSB7XG4gICAgaWYgKCFjbGllbnRPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBkZWxldGUgcmVtYWluaW5nU2VydmVyUHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgdmFyIG1heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIGluZGVudCAqIDIgLSBwcm9wTmFtZS5sZW5ndGggLSAyO1xuICAgIHZhciBjbGllbnRWYWx1ZSA9IGNsaWVudE9iamVjdFtwcm9wTmFtZV07XG4gICAgdmFyIGNsaWVudFByb3BWYWx1ZSA9IGRlc2NyaWJlVmFsdWUoY2xpZW50VmFsdWUsIG1heExlbmd0aCk7XG5cbiAgICBpZiAoc2VydmVyT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgdmFyIHNlcnZlclZhbHVlID0gc2VydmVyT2JqZWN0W3Byb3BOYW1lXTtcbiAgICAgIHZhciBzZXJ2ZXJQcm9wVmFsdWUgPSBkZXNjcmliZVZhbHVlKHNlcnZlclZhbHVlLCBtYXhMZW5ndGgpO1xuICAgICAgcHJvcGVydGllcyArPSBhZGRlZChpbmRlbnQpICsgcHJvcE5hbWUgKyAnOiAnICsgY2xpZW50UHJvcFZhbHVlICsgJ1xcbic7XG4gICAgICBwcm9wZXJ0aWVzICs9IHJlbW92ZWQoaW5kZW50KSArIHByb3BOYW1lICsgJzogJyArIHNlcnZlclByb3BWYWx1ZSArICdcXG4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wZXJ0aWVzICs9IGFkZGVkKGluZGVudCkgKyBwcm9wTmFtZSArICc6ICcgKyBjbGllbnRQcm9wVmFsdWUgKyAnXFxuJztcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gcmVtYWluaW5nU2VydmVyUHJvcGVydGllcykge1xuICAgIGlmICghcmVtYWluaW5nU2VydmVyUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgX21heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIGluZGVudCAqIDIgLSBfcHJvcE5hbWUubGVuZ3RoIC0gMjtcblxuICAgIHZhciBfc2VydmVyVmFsdWUgPSByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW19wcm9wTmFtZV07XG5cbiAgICB2YXIgX3NlcnZlclByb3BWYWx1ZSA9IGRlc2NyaWJlVmFsdWUoX3NlcnZlclZhbHVlLCBfbWF4TGVuZ3RoKTtcblxuICAgIHByb3BlcnRpZXMgKz0gcmVtb3ZlZChpbmRlbnQpICsgX3Byb3BOYW1lICsgJzogJyArIF9zZXJ2ZXJQcm9wVmFsdWUgKyAnXFxuJztcbiAgfVxuXG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUVsZW1lbnREaWZmKHR5cGUsIGNsaWVudFByb3BzLCBzZXJ2ZXJQcm9wcywgaW5kZW50KSB7XG4gIHZhciBjb250ZW50ID0gJyc7IC8vIE1hcHMgYW55IHByZXZpb3VzbHkgdW5tYXRjaGVkIGxvd2VyIGNhc2Ugc2VydmVyIHByb3AgbmFtZSB0byBpdHMgZnVsbCBwcm9wIG5hbWVcblxuICB2YXIgc2VydmVyUHJvcE5hbWVzID0gbmV3IE1hcCgpO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIHNlcnZlclByb3BzKSB7XG4gICAgaWYgKCFzZXJ2ZXJQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHNlcnZlclByb3BOYW1lcy5zZXQocHJvcE5hbWUudG9Mb3dlckNhc2UoKSwgcHJvcE5hbWUpO1xuICB9XG5cbiAgaWYgKHNlcnZlclByb3BOYW1lcy5zaXplID09PSAxICYmIHNlcnZlclByb3BOYW1lcy5oYXMoJ2NoaWxkcmVuJykpIHtcbiAgICBjb250ZW50ICs9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KHR5cGUsIGNsaWVudFByb3BzLCBpbmRlbnRhdGlvbihpbmRlbnQpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBfcHJvcE5hbWUyIGluIGNsaWVudFByb3BzKSB7XG4gICAgICBpZiAoIWNsaWVudFByb3BzLmhhc093blByb3BlcnR5KF9wcm9wTmFtZTIpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3Byb3BOYW1lMiA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICAvLyBIYW5kbGVkIGJlbG93LlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIChpbmRlbnQgKyAxKSAqIDIgLSBfcHJvcE5hbWUyLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgc2VydmVyUHJvcE5hbWUgPSBzZXJ2ZXJQcm9wTmFtZXMuZ2V0KF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgIGlmIChzZXJ2ZXJQcm9wTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlcnZlclByb3BOYW1lcy5kZWxldGUoX3Byb3BOYW1lMi50b0xvd2VyQ2FzZSgpKTsgLy8gVGhlcmUncyBhIGRpZmYgaGVyZS5cblxuICAgICAgICB2YXIgY2xpZW50VmFsdWUgPSBjbGllbnRQcm9wc1tfcHJvcE5hbWUyXTtcbiAgICAgICAgdmFyIHNlcnZlclZhbHVlID0gc2VydmVyUHJvcHNbc2VydmVyUHJvcE5hbWVdO1xuICAgICAgICB2YXIgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoY2xpZW50VmFsdWUsIG1heExlbmd0aCk7XG4gICAgICAgIHZhciBzZXJ2ZXJQcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShzZXJ2ZXJWYWx1ZSwgbWF4TGVuZ3RoKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNsaWVudFZhbHVlID09PSAnb2JqZWN0JyAmJiBjbGllbnRWYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygc2VydmVyVmFsdWUgPT09ICdvYmplY3QnICYmIHNlcnZlclZhbHVlICE9PSBudWxsICYmIG9iamVjdE5hbWUoY2xpZW50VmFsdWUpID09PSAnT2JqZWN0JyAmJiBvYmplY3ROYW1lKHNlcnZlclZhbHVlKSA9PT0gJ09iamVjdCcgJiYgKCAvLyBPbmx5IGRvIHRoZSBkaWZmIGlmIHRoZSBvYmplY3QgaGFzIGEgbG90IG9mIGtleXMgb3Igd2FzIHNob3J0ZW5lZC5cbiAgICAgICAgT2JqZWN0LmtleXMoY2xpZW50VmFsdWUpLmxlbmd0aCA+IDIgfHwgT2JqZWN0LmtleXMoc2VydmVyVmFsdWUpLmxlbmd0aCA+IDIgfHwgY2xpZW50UHJvcFZhbHVlLmluZGV4T2YoJy4uLicpID4gLTEgfHwgc2VydmVyUHJvcFZhbHVlLmluZGV4T2YoJy4uLicpID4gLTEpKSB7XG4gICAgICAgICAgLy8gV2UncmUgY29tcGFyaW5nIHR3byBwbGFpbiBvYmplY3RzLiBXZSBjYW4gZGlmZiB0aGUgbmVzdGVkIG9iamVjdHMgaW5zdGVhZC5cbiAgICAgICAgICBjb250ZW50ICs9IGluZGVudGF0aW9uKGluZGVudCArIDEpICsgX3Byb3BOYW1lMiArICc9e3tcXG4nICsgZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZihjbGllbnRWYWx1ZSwgc2VydmVyVmFsdWUsIGluZGVudCArIDIpICsgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgKyAnfX1cXG4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgKz0gYWRkZWQoaW5kZW50ICsgMSkgKyBfcHJvcE5hbWUyICsgJz0nICsgY2xpZW50UHJvcFZhbHVlICsgJ1xcbic7XG4gICAgICAgICAgY29udGVudCArPSByZW1vdmVkKGluZGVudCArIDEpICsgX3Byb3BOYW1lMiArICc9JyArIHNlcnZlclByb3BWYWx1ZSArICdcXG4nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb25zaWRlcmVkIGVxdWFsLlxuICAgICAgICBjb250ZW50ICs9IGluZGVudGF0aW9uKGluZGVudCArIDEpICsgX3Byb3BOYW1lMiArICc9JyArIGRlc2NyaWJlUHJvcFZhbHVlKGNsaWVudFByb3BzW19wcm9wTmFtZTJdLCBtYXhMZW5ndGgpICsgJ1xcbic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VydmVyUHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgLy8gSGFuZGxlZCBiZWxvdy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gKGluZGVudCArIDEpICogMiAtIHByb3BOYW1lLmxlbmd0aCAtIDE7XG4gICAgICBjb250ZW50ICs9IHJlbW92ZWQoaW5kZW50ICsgMSkgKyBwcm9wTmFtZSArICc9JyArIGRlc2NyaWJlUHJvcFZhbHVlKHNlcnZlclByb3BzW3Byb3BOYW1lXSwgbWF4TGVuZ3RoKSArICdcXG4nO1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbnRlbnQgPT09ICcnKSB7XG4gICAgICAvLyBObyBwcm9wZXJ0aWVzXG4gICAgICBjb250ZW50ID0gaW5kZW50YXRpb24oaW5kZW50KSArICc8JyArIHR5cGUgKyAnPlxcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhhZCBwcm9wZXJ0aWVzXG4gICAgICBjb250ZW50ID0gaW5kZW50YXRpb24oaW5kZW50KSArICc8JyArIHR5cGUgKyAnXFxuJyArIGNvbnRlbnQgKyBpbmRlbnRhdGlvbihpbmRlbnQpICsgJz5cXG4nO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzZXJ2ZXJDaGlsZHJlbiA9IHNlcnZlclByb3BzLmNoaWxkcmVuO1xuICB2YXIgY2xpZW50Q2hpbGRyZW4gPSBjbGllbnRQcm9wcy5jaGlsZHJlbjtcblxuICBpZiAodHlwZW9mIHNlcnZlckNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc2VydmVyQ2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBzZXJ2ZXJDaGlsZHJlbiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAvLyBUaGVyZSdzIGEgZGlmZiBvZiB0aGUgY2hpbGRyZW4uXG4gICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dXG4gICAgdmFyIHNlcnZlclRleHQgPSAnJyArIHNlcnZlckNoaWxkcmVuO1xuICAgIHZhciBjbGllbnRUZXh0ID0gJyc7XG5cbiAgICBpZiAodHlwZW9mIGNsaWVudENoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2xpZW50Q2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBjbGllbnRDaGlsZHJlbiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXVxuICAgICAgY2xpZW50VGV4dCA9ICcnICsgY2xpZW50Q2hpbGRyZW47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBkZXNjcmliZVRleHREaWZmKGNsaWVudFRleHQsIHNlcnZlclRleHQsIGluZGVudCArIDEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjbGllbnRDaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNsaWVudENoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY2xpZW50Q2hpbGRyZW4gPT09ICdiaWdpbnQnKSB7XG4gICAgLy8gVGhlIGNsaWVudCBoYXMgY2hpbGRyZW4gYnV0IGl0J3Mgbm90IGNvbnNpZGVyZWQgYSBkaWZmZXJlbmNlIGZyb20gdGhlIHNlcnZlci5cbiAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl1cbiAgICBjb250ZW50ICs9IGRlc2NyaWJlVGV4dERpZmYoJycgKyBjbGllbnRDaGlsZHJlbiwgdW5kZWZpbmVkLCBpbmRlbnQgKyAxKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVNpYmxpbmdGaWJlcihmaWJlciwgaW5kZW50KSB7XG4gIHZhciB0eXBlID0gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpO1xuXG4gIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgLy8gU2tpcCB0aGlzIHR5cGUgb2YgZmliZXIuIFdlIGN1cnJlbnRseSB0cmVhdCB0aGlzIGFzIGEgZnJhZ21lbnRcbiAgICAvLyBzbyBpdCdzIGp1c3QgcGFydCBvZiB0aGUgcGFyZW50J3MgY2hpbGRyZW4uXG4gICAgdmFyIGZsYXRDb250ZW50ID0gJyc7XG4gICAgdmFyIGNoaWxkRmliZXIgPSBmaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZEZpYmVyKSB7XG4gICAgICBmbGF0Q29udGVudCArPSBkZXNjcmliZVNpYmxpbmdGaWJlcihjaGlsZEZpYmVyLCBpbmRlbnQpO1xuICAgICAgY2hpbGRGaWJlciA9IGNoaWxkRmliZXIuc2libGluZztcbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdENvbnRlbnQ7XG4gIH1cblxuICByZXR1cm4gaW5kZW50YXRpb24oaW5kZW50KSArICc8JyArIHR5cGUgKyAnPicgKyAnXFxuJztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOb2RlKG5vZGUsIGluZGVudCkge1xuICB2YXIgc2tpcFRvTm9kZSA9IGZpbmROb3RhYmxlTm9kZShub2RlLCBpbmRlbnQpO1xuXG4gIGlmIChza2lwVG9Ob2RlICE9PSBub2RlICYmIChub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBub2RlLmNoaWxkcmVuWzBdICE9PSBza2lwVG9Ob2RlKSkge1xuICAgIHJldHVybiBpbmRlbnRhdGlvbihpbmRlbnQpICsgJy4uLlxcbicgKyBkZXNjcmliZU5vZGUoc2tpcFRvTm9kZSwgaW5kZW50ICsgMSk7XG4gIH0gLy8gUHJlZml4IHdpdGggYW55IHNlcnZlciBjb21wb25lbnRzIGZvciBjb250ZXh0XG5cblxuICB2YXIgcGFyZW50Q29udGVudCA9ICcnO1xuICB2YXIgZGVidWdJbmZvID0gbm9kZS5maWJlci5fZGVidWdJbmZvO1xuXG4gIGlmIChkZWJ1Z0luZm8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlYnVnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlcnZlckNvbXBvbmVudE5hbWUgPSBkZWJ1Z0luZm9baV0ubmFtZTtcblxuICAgICAgaWYgKHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJlbnRDb250ZW50ICs9IGluZGVudGF0aW9uKGluZGVudCkgKyAnPCcgKyBzZXJ2ZXJDb21wb25lbnROYW1lICsgJz4nICsgJ1xcbic7XG4gICAgICAgIGluZGVudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTZWxmXG5cblxuICB2YXIgc2VsZkNvbnRlbnQgPSAnJzsgLy8gV2UgdXNlIHRoZSBwZW5kaW5nIHByb3BzIHNpbmNlIHdlIG1pZ2h0IGJlIGdlbmVyYXRpbmcgYSBkaWZmIGJlZm9yZSB0aGUgY29tcGxldGUgcGhhc2VcbiAgLy8gd2hlbiBzb21ldGhpbmcgdGhyb3dzLlxuXG4gIHZhciBjbGllbnRQcm9wcyA9IG5vZGUuZmliZXIucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChub2RlLmZpYmVyLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBUZXh0IE5vZGVcbiAgICBzZWxmQ29udGVudCA9IGRlc2NyaWJlVGV4dERpZmYoY2xpZW50UHJvcHMsIG5vZGUuc2VydmVyUHJvcHMsIGluZGVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBkZXNjcmliZUZpYmVyVHlwZShub2RlLmZpYmVyKTtcblxuICAgIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgICAvLyBFbGVtZW50IE5vZGVcbiAgICAgIGlmIChub2RlLnNlcnZlclByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSnVzdCBhIHJlZmVyZW5jZSBub2RlIGZvciBjb250ZXh0LlxuICAgICAgICBzZWxmQ29udGVudCA9IGRlc2NyaWJlQ29sbGFwc2VkRWxlbWVudCh0eXBlLCBjbGllbnRQcm9wcywgaW5kZW50KTtcbiAgICAgICAgaW5kZW50Kys7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuc2VydmVyUHJvcHMgPT09IG51bGwpIHtcbiAgICAgICAgc2VsZkNvbnRlbnQgPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudCh0eXBlLCBjbGllbnRQcm9wcywgYWRkZWQoaW5kZW50KSk7IC8vIElmIHRoaXMgd2FzIGFuIGluc2VydGlvbiB3ZSB3b24ndCBzdGVwIGRvd24gZnVydGhlci4gQW55IHRhaWxcbiAgICAgICAgLy8gYXJlIGNvbnNpZGVyZWQgc2libGluZ3Mgc28gd2UgZG9uJ3QgaW5kZW50LlxuICAgICAgICAvLyBUT0RPOiBNb2RlbCB0aGlzIGEgbGl0dGxlIGJldHRlci5cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUuc2VydmVyUHJvcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvcignU2hvdWxkIG5vdCBoYXZlIG1hdGNoZWQgYSBub24gSG9zdFRleHQgZmliZXIgdG8gYSBUZXh0IG5vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGZDb250ZW50ID0gZGVzY3JpYmVFbGVtZW50RGlmZih0eXBlLCBjbGllbnRQcm9wcywgbm9kZS5zZXJ2ZXJQcm9wcywgaW5kZW50KTtcbiAgICAgICAgaW5kZW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENvbXB1dGUgY2hpbGRyZW5cblxuXG4gIHZhciBjaGlsZENvbnRlbnQgPSAnJztcbiAgdmFyIGNoaWxkRmliZXIgPSBub2RlLmZpYmVyLmNoaWxkO1xuICB2YXIgZGlmZklkeCA9IDA7XG5cbiAgd2hpbGUgKGNoaWxkRmliZXIgJiYgZGlmZklkeCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuY2hpbGRyZW5bZGlmZklkeF07XG5cbiAgICBpZiAoY2hpbGROb2RlLmZpYmVyID09PSBjaGlsZEZpYmVyKSB7XG4gICAgICAvLyBUaGlzIHdhcyBhIG1hdGNoIGluIHRoZSBkaWZmLlxuICAgICAgY2hpbGRDb250ZW50ICs9IGRlc2NyaWJlTm9kZShjaGlsZE5vZGUsIGluZGVudCk7XG4gICAgICBkaWZmSWR4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gdW5yZWxhdGVkIHByZXZpb3VzIHNpYmxpbmcuXG4gICAgICBjaGlsZENvbnRlbnQgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoY2hpbGRGaWJlciwgaW5kZW50KTtcbiAgICB9XG5cbiAgICBjaGlsZEZpYmVyID0gY2hpbGRGaWJlci5zaWJsaW5nO1xuICB9XG5cbiAgaWYgKGNoaWxkRmliZXIgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgLy8gSWYgd2UgaGFkIGFueSBmdXJ0aGVyIHNpYmxpbmdzIGFmdGVyIHRoZSBsYXN0IG1pc21hdGNoLCB3ZSBjYW4ndCBiZSBzdXJlIGlmIGl0J3NcbiAgICAvLyBhY3R1YWxseSBhIHZhbGlkIG1hdGNoIHNpbmNlIGl0IG1pZ2h0IG5vdCBoYXZlIGZvdW5kIGEgbWF0Y2guIFNvIHdlIGV4Y2x1ZGUgbmV4dFxuICAgIC8vIHNpYmxpbmdzIHRvIGF2b2lkIGNvbmZ1c2lvbi5cbiAgICBjaGlsZENvbnRlbnQgKz0gaW5kZW50YXRpb24oaW5kZW50KSArICcuLi4nICsgJ1xcbic7XG4gIH0gLy8gRGVsZXRlZCB0YWlsIG5vZGVzXG5cblxuICB2YXIgc2VydmVyVGFpbCA9IG5vZGUuc2VydmVyVGFpbDtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc2VydmVyVGFpbC5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgdGFpbE5vZGUgPSBzZXJ2ZXJUYWlsW19pXTtcblxuICAgIGlmICh0eXBlb2YgdGFpbE5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBSZW1vdmVkIHRleHQgbm9kZVxuICAgICAgY2hpbGRDb250ZW50ICs9IHJlbW92ZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUodGFpbE5vZGUsIG1heFJvd0xlbmd0aCAtIGluZGVudCAqIDIpICsgJ1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZWQgZWxlbWVudFxuICAgICAgY2hpbGRDb250ZW50ICs9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KHRhaWxOb2RlLnR5cGUsIHRhaWxOb2RlLnByb3BzLCByZW1vdmVkKGluZGVudCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZW50ICsgc2VsZkNvbnRlbnQgKyBjaGlsZENvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZihyb290Tm9kZSkge1xuICB0cnkge1xuICAgIHJldHVybiAnXFxuXFxuJyArIGRlc2NyaWJlTm9kZShyb290Tm9kZSwgMCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBtYXkgaGF2ZSBiZWVuIGFuIGluc2VydGlvbiBvciBhIGh5ZHJhdGlvbi5cblxudmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbnZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc0h5ZHJhdGluZyA9IGZhbHNlOyAvLyBUaGlzIGZsYWcgYWxsb3dzIGZvciB3YXJuaW5nIHN1cHJlc3Npb24gd2hlbiB3ZSBleHBlY3QgdGhlcmUgdG8gYmUgbWlzbWF0Y2hlc1xuLy8gZHVlIHRvIGVhcmxpZXIgbWlzbWF0Y2hlcyBvciBhIHN1c3BlbmRlZCBmaWJlci5cblxudmFyIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7IC8vIEh5ZHJhdGlvbiBkaWZmZXJlbmNlcyBmb3VuZCB0aGF0IGhhdmVuJ3QgeWV0IGJlZW4gbG9nZ2VkLlxuXG52YXIgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsOyAvLyBIeWRyYXRpb24gZXJyb3JzIHRoYXQgd2VyZSB0aHJvd24gaW5zaWRlIHRoaXMgYm91bmRhcnlcblxudmFyIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG52YXIgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IGZhbHNlOyAvLyBCdWlsZHMgYSBjb21tb24gYW5jZXN0b3IgdHJlZSBmcm9tIHRoZSByb290IGRvd24gZm9yIGNvbGxlY3RpbmcgZGlmZnMuXG5cbmZ1bmN0aW9uIGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIGRpc3RhbmNlRnJvbUxlYWYpIHtcbiAgaWYgKGZpYmVyLnJldHVybiA9PT0gbnVsbCkge1xuICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgIGlmIChoeWRyYXRpb25EaWZmUm9vdERFViA9PT0gbnVsbCkge1xuICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSB7XG4gICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBzZXJ2ZXJQcm9wczogdW5kZWZpbmVkLFxuICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWLmZpYmVyICE9PSBmaWJlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYXcgbXVsdGlwbGUgaHlkcmF0aW9uIGRpZmYgcm9vdHMgaW4gYSBwYXNzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH0gZWxzZSBpZiAoaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYpIHtcbiAgICAgIGh5ZHJhdGlvbkRpZmZSb290REVWLmRpc3RhbmNlRnJvbUxlYWYgPSBkaXN0YW5jZUZyb21MZWFmO1xuICAgIH1cblxuICAgIHJldHVybiBoeWRyYXRpb25EaWZmUm9vdERFVjtcbiAgfVxuXG4gIHZhciBzaWJsaW5ncyA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIucmV0dXJuLCBkaXN0YW5jZUZyb21MZWFmICsgMSkuY2hpbGRyZW47IC8vIFRoZSBzYW1lIG5vZGUgbWF5IGFscmVhZHkgZXhpc3QgaW4gdGhlIHBhcmVudC4gU2luY2Ugd2UgY3VycmVudGx5IGFsd2F5cyByZW5kZXIgZGVwdGggZmlyc3RcbiAgLy8gYW5kIHJlcmVuZGVyIGlmIHdlIHN1c3BlbmQgb3IgdGVybWluYXRlIGVhcmx5LCBpZiBhIHNoYXJlZCBhbmNlc3RvciB3YXMgYWRkZWQgd2Ugc2hvdWxkIHN0aWxsXG4gIC8vIGJlIGluc2lkZSBvZiB0aGF0IHNoYXJlZCBhbmNlc3RvciB3aGljaCBtZWFucyBpdCB3YXMgdGhlIGxhc3Qgb25lIHRvIGJlIGFkZGVkLiBJZiB0aGlzIGNoYW5nZXNcbiAgLy8gd2UgbWF5IGhhdmUgdG8gc2NhbiB0aGUgd2hvbGUgc2V0LlxuXG4gIGlmIChzaWJsaW5ncy5sZW5ndGggPiAwICYmIHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdLmZpYmVyID09PSBmaWJlcikge1xuICAgIHZhciBleGlzdGluZyA9IHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGV4aXN0aW5nLmRpc3RhbmNlRnJvbUxlYWYgPiBkaXN0YW5jZUZyb21MZWFmKSB7XG4gICAgICBleGlzdGluZy5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZjtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICB2YXIgbmV3Tm9kZSA9IHtcbiAgICBmaWJlcjogZmliZXIsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIHNlcnZlclByb3BzOiB1bmRlZmluZWQsXG4gICAgc2VydmVyVGFpbDogW10sXG4gICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICB9O1xuICBzaWJsaW5ncy5wdXNoKG5ld05vZGUpO1xuICByZXR1cm4gbmV3Tm9kZTtcbn1cblxuZnVuY3Rpb24gd2FybklmSHlkcmF0aW5nKCkge1xuICB7XG4gICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICBlcnJvcignV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWKCkge1xuICB7XG4gICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIocGFyZW50SW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7XG4gIGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbDtcbiAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIsIHN1c3BlbnNlSW5zdGFuY2UsIHRyZWVDb250ZXh0KSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7XG4gIGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbDtcbiAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IGZhbHNlO1xuXG4gIGlmICh0cmVlQ29udGV4dCAhPT0gbnVsbCkge1xuICAgIHJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dChmaWJlciwgdHJlZUNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKGZpYmVyLCByZWplY3RlZENhbmRpZGF0ZSkge1xuICB7XG4gICAgaWYgKGRpZFN1c3BlbmRPckVycm9yREVWKSB7XG4gICAgICAvLyBJbnNpZGUgYSBib3VuZGFyeSB0aGF0IGFscmVhZHkgc3VzcGVuZGVkLiBXZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHRoZVxuICAgICAgLy8gc2libGluZ3Mgb2YgYSBzdXNwZW5kZWQgbm9kZS4gVGhlIG1pc21hdGNoIG1heSBiZSBkdWUgdG8gdGhlIG1pc3NpbmdcbiAgICAgIC8vIGRhdGEsIHNvIGl0J3MgcHJvYmFibHkgYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEFkZCB0aGlzIGZpYmVyIHRvIHRoZSBkaWZmIHRyZWUuXG5cblxuICAgIHZhciBkaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApOyAvLyBXZSB1c2UgbnVsbCBhcyBhIHNpZ25hbCB0aGF0IHRoZXJlIHdhcyBubyBub2RlIHRvIG1hdGNoLlxuXG4gICAgZGlmZk5vZGUuc2VydmVyUHJvcHMgPSBudWxsO1xuXG4gICAgaWYgKHJlamVjdGVkQ2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzKHJlamVjdGVkQ2FuZGlkYXRlKTtcbiAgICAgIGRpZmZOb2RlLnNlcnZlclRhaWwucHVzaChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUh5ZHJhdGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAvLyBmaWJlciBpcyBhIEhvc3RDb21wb25lbnQgRmliZXJcbiAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIucGVuZGluZ1Byb3BzLCByb290T3JTaW5nbGV0b25Db250ZXh0KTtcblxuICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICBmaWJlci5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkU3VzcGVuZE9yRXJyb3JERVYpIHtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2VzID0gZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyhpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIucGVuZGluZ1Byb3BzLCBob3N0Q29udGV4dCk7XG5cbiAgICAgICAgaWYgKGRpZmZlcmVuY2VzICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7XG4gICAgICAgICAgZGlmZk5vZGUuc2VydmVyUHJvcHMgPSBkaWZmZXJlbmNlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKGluc3RhbmNlKTtcbiAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRyeUh5ZHJhdGVUZXh0KGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgLy8gZmliZXIgaXMgYSBIb3N0VGV4dCBGaWJlclxuICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0LCByb290T3JTaW5nbGV0b25Db250ZXh0KTtcblxuICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7IC8vIFRleHQgSW5zdGFuY2VzIGRvbid0IGhhdmUgY2hpbGRyZW4gc28gdGhlcmUncyBub3RoaW5nIHRvIGh5ZHJhdGUuXG5cbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZVN1c3BlbnNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgLy8gZmliZXIgaXMgYSBTdXNwZW5zZUNvbXBvbmVudCBGaWJlclxuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgcm9vdE9yU2luZ2xldG9uQ29udGV4dCk7XG5cbiAgaWYgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHtcbiAgICAgIGRlaHlkcmF0ZWQ6IHN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICB0cmVlQ29udGV4dDogZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSxcbiAgICAgIHJldHJ5TGFuZTogT2Zmc2NyZWVuTGFuZVxuICAgIH07XG4gICAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IHN1c3BlbnNlU3RhdGU7IC8vIFN0b3JlIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50IGFzIGEgY2hpbGQgZmliZXIuXG4gICAgLy8gVGhpcyBzaW1wbGlmaWVzIHRoZSBjb2RlIGZvciBnZXRIb3N0U2libGluZyBhbmQgZGVsZXRpbmcgbm9kZXMsXG4gICAgLy8gc2luY2UgaXQgZG9lc24ndCBoYXZlIHRvIGNvbnNpZGVyIGFsbCBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAgIC8vIGNoZWNrIGlmIHRoZXkncmUgZGVoeWRyYXRlZCBvbmVzIG9yIG5vdC5cblxuICAgIHZhciBkZWh5ZHJhdGVkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgZGVoeWRyYXRlZEZyYWdtZW50LnJldHVybiA9IGZpYmVyO1xuICAgIGZpYmVyLmNoaWxkID0gZGVoeWRyYXRlZEZyYWdtZW50O1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7IC8vIFdoaWxlIGEgU3VzcGVuc2UgSW5zdGFuY2UgZG9lcyBoYXZlIGNoaWxkcmVuLCB3ZSB3b24ndCBzdGVwIGludG9cbiAgICAvLyBpdCBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIEluc3RlYWQsIHdlJ2xsIHJlZW50ZXIgaXQgbGF0ZXIuXG5cbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uID0gbmV3IEVycm9yKCdIeWRyYXRpb24gTWlzbWF0Y2ggRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byAnICsgXCJ1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCIpO1xuXG5mdW5jdGlvbiB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpIHtcbiAgdmFyIGRpZmYgPSAnJztcblxuICB7XG4gICAgLy8gQ29uc3VtZSB0aGUgZGlmZiByb290IGZvciB0aGlzIG1pc21hdGNoLlxuICAgIC8vIEFueSBvdGhlciBlcnJvcnMgd2lsbCBnZXQgdGhlaXIgb3duIGRpZmZzLlxuICAgIHZhciBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuXG4gICAgaWYgKGRpZmZSb290ICE9PSBudWxsKSB7XG4gICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGw7XG4gICAgICBkaWZmID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KTtcbiAgICB9XG4gIH1cblxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50LiBBcyBhIHJlc3VsdCB0aGlzIHRyZWUgd2lsbCBiZSByZWdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblwiICsgJ1xcbicgKyBcIi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuXCIgKyBcIi0gVmFyaWFibGUgaW5wdXQgc3VjaCBhcyBgRGF0ZS5ub3coKWAgb3IgYE1hdGgucmFuZG9tKClgIHdoaWNoIGNoYW5nZXMgZWFjaCB0aW1lIGl0J3MgY2FsbGVkLlxcblwiICsgXCItIERhdGUgZm9ybWF0dGluZyBpbiBhIHVzZXIncyBsb2NhbGUgd2hpY2ggZG9lc24ndCBtYXRjaCB0aGUgc2VydmVyLlxcblwiICsgJy0gRXh0ZXJuYWwgY2hhbmdpbmcgZGF0YSB3aXRob3V0IHNlbmRpbmcgYSBzbmFwc2hvdCBvZiBpdCBhbG9uZyB3aXRoIHRoZSBIVE1MLlxcbicgKyAnLSBJbnZhbGlkIEhUTUwgdGFnIG5lc3RpbmcuXFxuJyArICdcXG4nICsgJ0l0IGNhbiBhbHNvIGhhcHBlbiBpZiB0aGUgY2xpZW50IGhhcyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGluc3RhbGxlZCB3aGljaCBtZXNzZXMgd2l0aCB0aGUgSFRNTCBiZWZvcmUgUmVhY3QgbG9hZGVkLlxcbicgKyAnXFxuJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaCcgKyBkaWZmKTtcbiAgcXVldWVIeWRyYXRpb25FcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgZmliZXIpKTtcbiAgdGhyb3cgSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb247XG59XG5cbmZ1bmN0aW9uIGNsYWltSHlkcmF0YWJsZVNpbmdsZXRvbihmaWJlcikge1xuICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50Um9vdENvbnRhaW5lciA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlID0gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKGZpYmVyLnR5cGUsIGZpYmVyLnBlbmRpbmdQcm9wcywgY3VycmVudFJvb3RDb250YWluZXIsIGN1cnJlbnRIb3N0Q29udGV4dCwgZmFsc2UpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRTdXNwZW5kT3JFcnJvckRFVikge1xuICAgICAgICB2YXIgZGlmZmVyZW5jZXMgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5wZW5kaW5nUHJvcHMsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG5cbiAgICAgICAgaWYgKGRpZmZlcmVuY2VzICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7XG4gICAgICAgICAgZGlmZk5vZGUuc2VydmVyUHJvcHMgPSBkaWZmZXJlbmNlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IHRydWU7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFZhbGlkYXRlIHRoYXQgdGhpcyBpcyBvayB0byByZW5kZXIgaGVyZSBiZWZvcmUgYW55IG1pc21hdGNoZXMuXG5cblxuICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgdmFyIHNob3VsZEtlZXBXYXJuaW5nID0gdmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIudHlwZSwgZmliZXIucGVuZGluZ1Byb3BzLCBjdXJyZW50SG9zdENvbnRleHQpO1xuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICBpZiAoc2hvdWxkS2VlcFdhcm5pbmcpIHtcbiAgICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgdmFyIHNob3VsZEtlZXBXYXJuaW5nID0gdHJ1ZTsgLy8gVmFsaWRhdGUgdGhhdCB0aGlzIGlzIG9rIHRvIHJlbmRlciBoZXJlIGJlZm9yZSBhbnkgbWlzbWF0Y2hlcy5cblxuICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgc2hvdWxkS2VlcFdhcm5pbmcgPSB2YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UodGV4dCwgY3VycmVudEhvc3RDb250ZXh0KTtcbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGVUZXh0KGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgaWYgKHNob3VsZEtlZXBXYXJuaW5nKSB7XG4gICAgICB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlU3VzcGVuc2UoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUZvcm1NYXJrZXJJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpIHtcbiAgICB2YXIgbWFya2VySW5zdGFuY2UgPSBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UsIHJvb3RPclNpbmdsZXRvbkNvbnRleHQpO1xuXG4gICAgaWYgKG1hcmtlckluc3RhbmNlKSB7XG4gICAgICAvLyBGb3VuZCB0aGUgbWFya2VyIGluc3RhbmNlLlxuICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhtYXJrZXJJbnN0YW5jZSk7IC8vIFJldHVybiB0cnVlIGlmIHRoaXMgbWFya2VyIGluc3RhbmNlIHNob3VsZCB1c2UgdGhlIHN0YXRlIHBhc3NlZFxuICAgICAgLy8gdG8gaHlkcmF0ZVJvb3QuXG4gICAgICAvLyBUT0RPOiBBcyBhbiBvcHRpbWl6YXRpb24sIEZpenogc2hvdWxkIG9ubHkgZW1pdCB0aGVzZSBtYXJrZXJzIGlmIGZvcm1cbiAgICAgIC8vIHN0YXRlIGlzIHBhc3NlZCBhdCB0aGUgcm9vdC5cblxuICAgICAgcmV0dXJuIGlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcobWFya2VySW5zdGFuY2UpO1xuICAgIH1cbiAgfSAvLyBTaG91bGQgaGF2ZSBmb3VuZCBhIG1hcmtlciBpbnN0YW5jZS4gVGhyb3cgYW4gZXJyb3IgdG8gdHJpZ2dlciBjbGllbnRcbiAgLy8gcmVuZGVyaW5nLiBXZSBkb24ndCBib3RoZXIgdG8gY2hlY2sgaWYgd2UncmUgaW4gYSBjb25jdXJyZW50IHJvb3QgYmVjYXVzZVxuICAvLyB1c2VBY3Rpb25TdGF0ZSBpcyBhIG5ldyBBUEksIHNvIGJhY2t3YXJkcyBjb21wYXQgaXMgbm90IGFuIGlzc3VlLlxuXG5cbiAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCBob3N0Q29udGV4dCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciBkaWRIeWRyYXRlID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCBob3N0Q29udGV4dCwgZmliZXIpO1xuXG4gIGlmICghZGlkSHlkcmF0ZSAmJiBmYXZvclNhZmV0eU92ZXJIeWRyYXRpb25QZXJmKSB7XG4gICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgdmFyIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2ID0gIWRpZFN1c3BlbmRPckVycm9yREVWO1xuICB2YXIgcGFyZW50UHJvcHMgPSBudWxsOyAvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG5cbiAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYpIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3ModGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgcGFyZW50UHJvcHMpO1xuXG4gICAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7XG4gICAgICAgICAgICAgICAgZGlmZk5vZGUuc2VydmVyUHJvcHMgPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KSB7XG4gICAgICAgICAgICAgIHZhciBfZGlmZmVyZW5jZSA9IGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyh0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCBwYXJlbnRQcm9wcyk7XG5cbiAgICAgICAgICAgICAgaWYgKF9kaWZmZXJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApO1xuXG4gICAgICAgICAgICAgICAgX2RpZmZOb2RlLnNlcnZlclByb3BzID0gX2RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gLy8gVE9ETzogV2hhdCBpZiBpdCdzIGEgU3VzcGVuc2VJbnN0YW5jZT9cblxuICB9XG5cbiAgdmFyIGRpZEh5ZHJhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyLCBwYXJlbnRQcm9wcyk7XG5cbiAgaWYgKCFkaWRIeWRyYXRlICYmIGZhdm9yU2FmZXR5T3Zlckh5ZHJhdGlvblBlcmYpIHtcbiAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlICE9PSBudWxsID8gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkIDogbnVsbDtcblxuICBpZiAoIXN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlICE9PSBudWxsID8gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkIDogbnVsbDtcblxuICBpZiAoIXN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgc3dpdGNoIChoeWRyYXRpb25QYXJlbnRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgLy8gdHJlZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgIC8vIHNpYmxpbmdzLlxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc2hvdWxkQ2xlYXIgPSBmYWxzZTtcblxuICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgLy8gV2l0aCBmbG9hdCB3ZSBuZXZlciBjbGVhciB0aGUgUm9vdCwgb3IgU2luZ2xldG9uIGluc3RhbmNlcy4gV2UgYWxzbyBkbyBub3QgY2xlYXIgSW5zdGFuY2VzXG4gICAgLy8gdGhhdCBoYXZlIHNpbmdsZXRvbiB0ZXh0IGNvbnRlbnRcbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Um9vdCAmJiBmaWJlci50YWcgIT09IEhvc3RTaW5nbGV0b24gJiYgIShmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgJiYgKCFzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSB8fCBzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpKSB7XG4gICAgICBzaG91bGRDbGVhciA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uIFdlIGFsc28gZG9uJ3QgZGVsZXRlIGFueXRoaW5nIGluc2lkZSB0aGUgcm9vdCBjb250YWluZXIuXG4gICAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QgJiYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpKSB7XG4gICAgICBzaG91bGRDbGVhciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNob3VsZENsZWFyKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgICBpZiAobmV4dEluc3RhbmNlKSB7XG4gICAgICB3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzKGZpYmVyKTtcbiAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7XG4gIH0gZWxzZSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpIHtcbiAge1xuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzKG5leHRJbnN0YW5jZSk7XG4gICAgICBkaWZmTm9kZS5zZXJ2ZXJUYWlsLnB1c2goZGVzY3JpcHRpb24pO1xuXG4gICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ1N1c3BlbnNlJykge1xuICAgICAgICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IG5leHRJbnN0YW5jZTtcbiAgICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKSB7XG4gIGlmIChoeWRyYXRpb25FcnJvcnMgIT09IG51bGwpIHtcbiAgICAvLyBTdWNjZXNzZnVsbHkgY29tcGxldGVkIGEgZm9yY2VkIGNsaWVudCByZW5kZXIuIFRoZSBlcnJvcnMgdGhhdCBvY2N1cnJlZFxuICAgIC8vIGR1cmluZyB0aGUgaHlkcmF0aW9uIGF0dGVtcHQgYXJlIG5vdyByZWNvdmVyZWQuIFdlIHdpbGwgbG9nIHRoZW0gaW5cbiAgICAvLyBjb21taXQgcGhhc2UsIG9uY2UgdGhlIGVudGlyZSB0cmVlIGhhcyBmaW5pc2hlZC5cbiAgICBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGh5ZHJhdGlvbkVycm9ycyk7XG4gICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRJc0h5ZHJhdGluZygpIHtcbiAgcmV0dXJuIGlzSHlkcmF0aW5nO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKSB7XG4gIGlmIChoeWRyYXRpb25FcnJvcnMgPT09IG51bGwpIHtcbiAgICBoeWRyYXRpb25FcnJvcnMgPSBbZXJyb3JdO1xuICB9IGVsc2Uge1xuICAgIGh5ZHJhdGlvbkVycm9ycy5wdXNoKGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpIHtcbiAge1xuICAgIC8vIElmIHdlIGhhdmVuJ3QgeWV0IHRocm93biBhbnkgaHlkcmF0aW9uIGVycm9ycyBieSB0aGUgdGltZSB3ZSByZWFjaCB0aGUgZW5kIHdlJ3ZlIHN1Y2Nlc3NmdWxseVxuICAgIC8vIGh5ZHJhdGVkLCBob3dldmVyLCB3ZSBtaWdodCBzdGlsbCBoYXZlIERFVi1vbmx5IG1pc21hdGNoZXMgdGhhdCB3ZSBsb2cgbm93LlxuICAgIHZhciBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuXG4gICAgaWYgKGRpZmZSb290ICE9PSBudWxsKSB7XG4gICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGw7XG4gICAgICB2YXIgZGlmZiA9IGRlc2NyaWJlRGlmZihkaWZmUm9vdCk7XG5cbiAgICAgIGVycm9yKFwiQSB0cmVlIGh5ZHJhdGVkIGJ1dCBzb21lIGF0dHJpYnV0ZXMgb2YgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50IHByb3BlcnRpZXMuIFRoaXMgd29uJ3QgYmUgcGF0Y2hlZCB1cC4gXCIgKyAnVGhpcyBjYW4gaGFwcGVuIGlmIGEgU1NSLWVkIENsaWVudCBDb21wb25lbnQgdXNlZDpcXG4nICsgJ1xcbicgKyBcIi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuXCIgKyBcIi0gVmFyaWFibGUgaW5wdXQgc3VjaCBhcyBgRGF0ZS5ub3coKWAgb3IgYE1hdGgucmFuZG9tKClgIHdoaWNoIGNoYW5nZXMgZWFjaCB0aW1lIGl0J3MgY2FsbGVkLlxcblwiICsgXCItIERhdGUgZm9ybWF0dGluZyBpbiBhIHVzZXIncyBsb2NhbGUgd2hpY2ggZG9lc24ndCBtYXRjaCB0aGUgc2VydmVyLlxcblwiICsgJy0gRXh0ZXJuYWwgY2hhbmdpbmcgZGF0YSB3aXRob3V0IHNlbmRpbmcgYSBzbmFwc2hvdCBvZiBpdCBhbG9uZyB3aXRoIHRoZSBIVE1MLlxcbicgKyAnLSBJbnZhbGlkIEhUTUwgdGFnIG5lc3RpbmcuXFxuJyArICdcXG4nICsgJ0l0IGNhbiBhbHNvIGhhcHBlbiBpZiB0aGUgY2xpZW50IGhhcyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGluc3RhbGxlZCB3aGljaCBtZXNzZXMgd2l0aCB0aGUgSFRNTCBiZWZvcmUgUmVhY3QgbG9hZGVkLlxcbicgKyAnXFxuJyArICclcyVzJywgJ2h0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaHlkcmF0aW9uLW1pc21hdGNoJywgZGlmZik7XG4gICAgfVxuICB9XG59XG5cbi8vIHdlIHdhaXQgdW50aWwgdGhlIGN1cnJlbnQgcmVuZGVyIGlzIG92ZXIgKGVpdGhlciBmaW5pc2hlZCBvciBpbnRlcnJ1cHRlZClcbi8vIGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIGZpYmVyL2hvb2sgcXVldWUuIFB1c2ggdG8gdGhpcyBhcnJheSBzbyB3ZSBjYW5cbi8vIGFjY2VzcyB0aGUgcXVldWUsIGZpYmVyLCB1cGRhdGUsIGV0IGFsIGxhdGVyLlxuXG52YXIgY29uY3VycmVudFF1ZXVlcyA9IFtdO1xudmFyIGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDA7XG52YXIgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gTm9MYW5lcztcbmZ1bmN0aW9uIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSB7XG4gIHZhciBlbmRJbmRleCA9IGNvbmN1cnJlbnRRdWV1ZXNJbmRleDtcbiAgY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMDtcbiAgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gTm9MYW5lcztcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgZW5kSW5kZXgpIHtcbiAgICB2YXIgZmliZXIgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgdmFyIHF1ZXVlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgdmFyIGxhbmUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG5cbiAgICBpZiAocXVldWUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgICAgIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgIH1cblxuICAgIGlmIChsYW5lICE9PSBOb0xhbmUpIHtcbiAgICAgIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29uY3VycmVudGx5VXBkYXRlZExhbmVzKCkge1xuICByZXR1cm4gY29uY3VycmVudGx5VXBkYXRlZExhbmVzO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgLy8gRG9uJ3QgdXBkYXRlIHRoZSBgY2hpbGRMYW5lc2Agb24gdGhlIHJldHVybiBwYXRoIHlldC4gSWYgd2UgYWxyZWFkeSBpblxuICAvLyB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZywgd2FpdCB1bnRpbCBhZnRlciBpdCBoYXMgY29tcGxldGVkLlxuICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IGZpYmVyO1xuICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHF1ZXVlO1xuICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHVwZGF0ZTtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBsYW5lO1xuICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBtZXJnZUxhbmVzKGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcywgbGFuZSk7IC8vIFRoZSBmaWJlcidzIGBsYW5lYCBmaWVsZCBpcyB1c2VkIGluIHNvbWUgcGxhY2VzIHRvIGNoZWNrIGlmIGFueSB3b3JrIGlzXG4gIC8vIHNjaGVkdWxlZCwgdG8gcGVyZm9ybSBhbiBlYWdlciBiYWlsb3V0LCBzbyB3ZSBuZWVkIHRvIHVwZGF0ZSBpdCBpbW1lZGlhdGVseS5cbiAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IG1vdmUgdGhpcyB0byB0aGUgXCJzaGFyZWRcIiBxdWV1ZSBpbnN0ZWFkLlxuXG4gIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgbGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCBsYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgdmFyIGNvbmN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICB2YXIgY29uY3VycmVudFVwZGF0ZSA9IHVwZGF0ZTtcbiAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBjb25jdXJyZW50UXVldWUsIGNvbmN1cnJlbnRVcGRhdGUsIGxhbmUpO1xuICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGVBbmRFYWdlcmx5QmFpbG91dChmaWJlciwgcXVldWUsIHVwZGF0ZSkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcXVldWUgYW4gdXBkYXRlIHRoYXQgZG9lc24ndCBuZWVkIGEgcmVyZW5kZXIuIFRoZVxuICAvLyBvbmx5IHJlYXNvbiB3ZSBxdWV1ZSBpdCBpcyBpbiBjYXNlIHRoZXJlJ3MgYSBzdWJzZXF1ZW50IGhpZ2hlciBwcmlvcml0eVxuICAvLyB1cGRhdGUgdGhhdCBjYXVzZXMgaXQgdG8gYmUgcmViYXNlZC5cbiAgdmFyIGxhbmUgPSBOb0xhbmU7XG4gIHZhciBjb25jdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgdmFyIGNvbmN1cnJlbnRVcGRhdGUgPSB1cGRhdGU7XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgY29uY3VycmVudFF1ZXVlLCBjb25jdXJyZW50VXBkYXRlLCBsYW5lKTsgLy8gVXN1YWxseSB3ZSBjYW4gcmVseSBvbiB0aGUgdXBjb21pbmcgcmVuZGVyIHBoYXNlIHRvIHByb2Nlc3MgdGhlIGNvbmN1cnJlbnRcbiAgLy8gcXVldWUuIEhvd2V2ZXIsIHNpbmNlIHRoaXMgaXMgYSBiYWlsIG91dCwgd2UncmUgbm90IHNjaGVkdWxpbmcgYW55IHdvcmtcbiAgLy8gaGVyZS4gU28gdGhlIHVwZGF0ZSB3ZSBqdXN0IHF1ZXVlZCB3aWxsIGxlYWsgdW50aWwgc29tZXRoaW5nIGVsc2UgaGFwcGVuc1xuICAvLyB0byBzY2hlZHVsZSB3b3JrIChpZiBldmVyKS5cbiAgLy9cbiAgLy8gQ2hlY2sgaWYgd2UncmUgY3VycmVudGx5IGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nIGEgdHJlZSwgYW5kIGlmIG5vdCxcbiAgLy8gcHJvY2VzcyB0aGUgcXVldWUgaW1tZWRpYXRlbHkgdG8gcHJldmVudCBhIGxlYWsuXG5cbiAgdmFyIGlzQ29uY3VycmVudGx5UmVuZGVyaW5nID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCkgIT09IG51bGw7XG5cbiAgaWYgKCFpc0NvbmN1cnJlbnRseVJlbmRlcmluZykge1xuICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRDbGFzc1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICB2YXIgY29uY3VycmVudFF1ZXVlID0gcXVldWU7XG4gIHZhciBjb25jdXJyZW50VXBkYXRlID0gdXBkYXRlO1xuICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIGNvbmN1cnJlbnRRdWV1ZSwgY29uY3VycmVudFVwZGF0ZSwgbGFuZSk7XG4gIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSkge1xuICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIG51bGwsIG51bGwsIGxhbmUpO1xuICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG59IC8vIENhbGxpbmcgdGhpcyBmdW5jdGlvbiBvdXRzaWRlIHRoaXMgbW9kdWxlIHNob3VsZCBvbmx5IGJlIGRvbmUgZm9yIGJhY2t3YXJkc1xuLy8gY29tcGF0aWJpbGl0eSBhbmQgc2hvdWxkIGFsd2F5cyBiZSBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcuXG5cbmZ1bmN0aW9uIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgbGFuZSkge1xuICAvLyBOT1RFOiBGb3IgSHlydW0ncyBMYXcgcmVhc29ucywgaWYgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgaXMgZGV0ZWN0ZWQsIGl0XG4gIC8vIHNob3VsZCB0aHJvdyBiZWZvcmUgYG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290YCBpcyBjYWxsZWQuIEJ1dCB0aGlzIGlzXG4gIC8vIHVuZGVmaW5lZCBiZWhhdmlvciBhbmQgd2UgY2FuIGNoYW5nZSBpdCBpZiB3ZSBuZWVkIHRvOyBpdCBqdXN0IHNvIGhhcHBlbnNcbiAgLy8gdGhhdCwgYXQgdGhlIHRpbWUgb2YgdGhpcyB3cml0aW5nLCB0aGVyZSdzIGFuIGludGVybmFsIHByb2R1Y3QgdGVzdCB0aGF0XG4gIC8vIGhhcHBlbnMgdG8gcmVseSBvbiB0aGlzLlxuICB2YXIgcm9vdCA9IGdldFJvb3RGb3JVcGRhdGVkRmliZXIoc291cmNlRmliZXIpO1xuICBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgbnVsbCwgbGFuZSk7XG4gIHJldHVybiByb290O1xufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgbGFuZXNcbiAgc291cmNlRmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLCBsYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIGxhbmUpO1xuICB9IC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGxhbmVzLlxuXG5cbiAgdmFyIGlzSGlkZGVuID0gZmFsc2U7XG4gIHZhciBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gIHZhciBub2RlID0gc291cmNlRmliZXI7XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudC5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnQuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudC50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBvZmZzY3JlZW4gYm91bmRhcnkgaXMgY3VycmVudGx5IGhpZGRlbi5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgaW5zdGFuY2UgbWF5IGJlIG51bGwgaWYgdGhlIE9mZnNjcmVlbiBwYXJlbnQgd2FzIHVubW91bnRlZC4gVXN1YWxseVxuICAgICAgLy8gdGhlIHBhcmVudCB3b3VsZG4ndCBiZSByZWFjaGFibGUgaW4gdGhhdCBjYXNlIGJlY2F1c2Ugd2UgZGlzY29ubmVjdFxuICAgICAgLy8gZmliZXJzIGZyb20gdGhlIHRyZWUgd2hlbiB0aGV5IGFyZSBkZWxldGVkLiBIb3dldmVyLCB0aGVyZSdzIGEgd2VpcmRcbiAgICAgIC8vIGVkZ2UgY2FzZSB3aGVyZSBzZXRTdGF0ZSBpcyBjYWxsZWQgb24gYSBmaWJlciB0aGF0IHdhcyBpbnRlcnJ1cHRlZFxuICAgICAgLy8gYmVmb3JlIGl0IGV2ZXIgbW91bnRlZC4gQmVjYXVzZSBpdCBuZXZlciBtb3VudHMsIGl0IGFsc28gbmV2ZXIgZ2V0c1xuICAgICAgLy8gZGVsZXRlZC4gQmVjYXVzZSBpdCBuZXZlciBnZXRzIGRlbGV0ZWQsIGl0cyByZXR1cm4gcG9pbnRlciBuZXZlciBnZXRzXG4gICAgICAvLyBkaXNjb25uZWN0ZWQuIFdoaWNoIG1lYW5zIGl0IG1heSBiZSBhdHRhY2hlZCB0byBhIGRlbGV0ZWQgT2Zmc2NyZWVuXG4gICAgICAvLyBwYXJlbnQgbm9kZS4gKFRoaXMgZGlzY292ZXJ5IHN1Z2dlc3RzIGl0IG1heSBiZSBiZXR0ZXIgZm9yIG1lbW9yeSB1c2FnZVxuICAgICAgLy8gaWYgd2UgZG9uJ3QgYXR0YWNoIHRoZSBgcmV0dXJuYCBwb2ludGVyIHVudGlsIHRoZSBjb21taXQgcGhhc2UsIHRob3VnaFxuICAgICAgLy8gaW4gb3JkZXIgdG8gZG8gdGhhdCB3ZSdkIG5lZWQgc29tZSBvdGhlciB3YXkgdG8gdHJhY2sgdGhlIHJldHVyblxuICAgICAgLy8gcG9pbnRlciBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyLCBsaWtlIG9uIHRoZSBzdGFjay4pXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBjYXNlIGlzIGFsd2F5cyBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcsIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvXG4gICAgICAvLyBhY2NvdW50IGZvciBpdC4gKFRoZXJlIG1heSBiZSBvdGhlciBjYXNlcyB0aGF0IHdlIGhhdmVuJ3QgZGlzY292ZXJlZCxcbiAgICAgIC8vIHRvby4pXG4gICAgICB2YXIgb2Zmc2NyZWVuSW5zdGFuY2UgPSBwYXJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAob2Zmc2NyZWVuSW5zdGFuY2UgIT09IG51bGwgJiYgIShvZmZzY3JlZW5JbnN0YW5jZS5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblZpc2libGUpKSB7XG4gICAgICAgIGlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gcGFyZW50O1xuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cblxuICBpZiAoaXNIaWRkZW4gJiYgdXBkYXRlICE9PSBudWxsICYmIG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgbWFya0hpZGRlblVwZGF0ZShyb290LCB1cGRhdGUsIGxhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoc291cmNlRmliZXIpIHtcbiAgLy8gVE9ETzogV2Ugd2lsbCBkZXRlY3QgYW5kIGluZmluaXRlIHVwZGF0ZSBsb29wIGFuZCB0aHJvdyBldmVuIGlmIHRoaXMgZmliZXJcbiAgLy8gaGFzIGFscmVhZHkgdW5tb3VudGVkLiBUaGlzIGlzbid0IHJlYWxseSBuZWNlc3NhcnkgYnV0IGl0IGhhcHBlbnMgdG8gYmUgdGhlXG4gIC8vIGN1cnJlbnQgYmVoYXZpb3Igd2UndmUgdXNlZCBmb3Igc2V2ZXJhbCByZWxlYXNlIGN5Y2xlcy4gQ29uc2lkZXIgbm90XG4gIC8vIHBlcmZvcm1pbmcgdGhpcyBjaGVjayBpZiB0aGUgdXBkYXRlZCBmaWJlciBhbHJlYWR5IHVubW91bnRlZCwgc2luY2UgaXQnc1xuICAvLyBub3QgcG9zc2libGUgZm9yIHRoYXQgdG8gY2F1c2UgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AuXG4gIHRocm93SWZJbmZpbml0ZVVwZGF0ZUxvb3BEZXRlY3RlZCgpOyAvLyBXaGVuIGEgc2V0U3RhdGUgaGFwcGVucywgd2UgbXVzdCBlbnN1cmUgdGhlIHJvb3QgaXMgc2NoZWR1bGVkLiBCZWNhdXNlXG4gIC8vIHVwZGF0ZSBxdWV1ZXMgZG8gbm90IGhhdmUgYSBiYWNrcG9pbnRlciB0byB0aGUgcm9vdCwgdGhlIG9ubHkgd2F5IHRvIGRvXG4gIC8vIHRoaXMgY3VycmVudGx5IGlzIHRvIHdhbGsgdXAgdGhlIHJldHVybiBwYXRoLiBUaGlzIHVzZWQgdG8gbm90IGJlIGEgYmlnXG4gIC8vIGRlYWwgYmVjYXVzZSB3ZSB3b3VsZCBoYXZlIHRvIHdhbGsgdXAgdGhlIHJldHVybiBwYXRoIHRvIHNldFxuICAvLyB0aGUgYGNoaWxkTGFuZXNgLCBhbnl3YXksIGJ1dCBub3cgdGhvc2UgdHdvIHRyYXZlcnNhbHMgaGFwcGVuIGF0XG4gIC8vIGRpZmZlcmVudCB0aW1lcy5cbiAgLy8gVE9ETzogQ29uc2lkZXIgYWRkaW5nIGEgYHJvb3RgIGJhY2twb2ludGVyIG9uIHRoZSB1cGRhdGUgcXVldWUuXG5cbiAgZGV0ZWN0VXBkYXRlT25Vbm1vdW50ZWRGaWJlcihzb3VyY2VGaWJlciwgc291cmNlRmliZXIpO1xuICB2YXIgbm9kZSA9IHNvdXJjZUZpYmVyO1xuICB2YXIgcGFyZW50ID0gbm9kZS5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGRldGVjdFVwZGF0ZU9uVW5tb3VudGVkRmliZXIoc291cmNlRmliZXIsIG5vZGUpO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gbm9kZS5yZXR1cm47XG4gIH1cblxuICByZXR1cm4gbm9kZS50YWcgPT09IEhvc3RSb290ID8gbm9kZS5zdGF0ZU5vZGUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RVcGRhdGVPblVubW91bnRlZEZpYmVyKHNvdXJjZUZpYmVyLCBwYXJlbnQpIHtcbiAge1xuICAgIHZhciBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCAmJiAocGFyZW50LmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO1xuICAgIH1cbiAgfVxufVxuXG4vLyB0aGVyZSdzIG9ubHkgYSBzaW5nbGUgcm9vdCwgYnV0IHdlIGRvIHN1cHBvcnQgbXVsdGkgcm9vdCBhcHBzLCBoZW5jZSB0aGlzXG4vLyBleHRyYSBjb21wbGV4aXR5LiBCdXQgdGhpcyBtb2R1bGUgaXMgb3B0aW1pemVkIGZvciB0aGUgc2luZ2xlIHJvb3QgY2FzZS5cblxudmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG52YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsOyAvLyBVc2VkIHRvIHByZXZlbnQgcmVkdW5kYW50IG1pcmNvdGFza3MgZnJvbSBiZWluZyBzY2hlZHVsZWQuXG5cbnZhciBkaWRTY2hlZHVsZU1pY3JvdGFzayA9IGZhbHNlOyAvLyBgYWN0YCBcIm1pY3JvdGFza3NcIiBhcmUgc2NoZWR1bGVkIG9uIHRoZSBgYWN0YCBxdWV1ZSBpbnN0ZWFkIG9mIGFuIGFjdHVhbFxuLy8gbWljcm90YXNrLCBzbyB3ZSBoYXZlIHRvIGRlZHVwZSB0aG9zZSBzZXBhcmF0ZWx5LiBUaGlzIHdvdWxkbid0IGJlIGFuIGlzc3VlXG4vLyBpZiB3ZSByZXF1aXJlZCBhbGwgYGFjdGAgY2FsbHMgdG8gYmUgYXdhaXRlZCwgd2hpY2ggd2UgbWlnaHQgaW4gdGhlIGZ1dHVyZS5cblxudmFyIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9IGZhbHNlOyAvLyBVc2VkIHRvIHF1aWNrbHkgYmFpbCBvdXQgb2YgZmx1c2hTeW5jIGlmIHRoZXJlJ3Mgbm8gc3luYyB3b3JrIHRvIGRvLlxuXG52YXIgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gZmFsc2U7XG52YXIgaXNGbHVzaGluZ1dvcmsgPSBmYWxzZTtcbnZhciBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IE5vTGFuZTtcbmZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIGEgcm9vdCByZWNlaXZlcyBhbiB1cGRhdGUuIEl0IGRvZXMgdHdvXG4gIC8vIHRoaW5ncyAxKSBpdCBlbnN1cmVzIHRoZSByb290IGlzIGluIHRoZSByb290IHNjaGVkdWxlLCBhbmQgMikgaXQgZW5zdXJlc1xuICAvLyB0aGVyZSdzIGEgcGVuZGluZyBtaWNyb3Rhc2sgdG8gcHJvY2VzcyB0aGUgcm9vdCBzY2hlZHVsZS5cbiAgLy9cbiAgLy8gTW9zdCBvZiB0aGUgYWN0dWFsIHNjaGVkdWxpbmcgbG9naWMgZG9lcyBub3QgaGFwcGVuIHVudGlsXG4gIC8vIGBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrYCBydW5zLlxuICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlXG4gIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCB8fCByb290Lm5leHQgIT09IG51bGwpIDsgZWxzZSB7XG4gICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHQgPSByb290O1xuICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgIH1cbiAgfSAvLyBBbnkgdGltZSBhIHJvb3QgcmVjZWl2ZWQgYW4gdXBkYXRlLCB3ZSBzZXQgdGhpcyB0byB0cnVlIHVudGlsIHRoZSBuZXh0IHRpbWVcbiAgLy8gd2UgcHJvY2VzcyB0aGUgc2NoZWR1bGUuIElmIGl0J3MgZmFsc2UsIHRoZW4gd2UgY2FuIHF1aWNrbHkgZXhpdCBmbHVzaFN5bmNcbiAgLy8gd2l0aG91dCBjb25zdWx0aW5nIHRoZSBzY2hlZHVsZS5cblxuXG4gIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9IHRydWU7IC8vIEF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZXZlbnQsIGdvIHRocm91Z2ggZWFjaCBvZiB0aGUgcm9vdHMgYW5kIGVuc3VyZVxuICAvLyB0aGVyZSdzIGEgdGFzayBzY2hlZHVsZWQgZm9yIGVhY2ggb25lIGF0IHRoZSBjb3JyZWN0IHByaW9yaXR5LlxuXG4gIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFdlJ3JlIGluc2lkZSBhbiBgYWN0YCBzY29wZS5cbiAgICBpZiAoIWRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCkge1xuICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWRpZFNjaGVkdWxlTWljcm90YXNrKSB7XG4gICAgICBkaWRTY2hlZHVsZU1pY3JvdGFzayA9IHRydWU7XG4gICAgICBzY2hlZHVsZUltbWVkaWF0ZVRhc2socHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCkge1xuICAvLyBUaGlzIGlzIGFsbG93ZWQgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHksIGJ1dCB0aGUgY2FsbGVyIHNob3VsZCBjaGVja1xuICAvLyB0aGUgZXhlY3V0aW9uIGNvbnRleHQgZmlyc3QuXG4gIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwob25seUxlZ2FjeSkge1xuICBpZiAoaXNGbHVzaGluZ1dvcmspIHtcbiAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuXG4gICAgLy8gVE9ETzogSXMgdGhpcyBvdmVybHkgZGVmZW5zaXZlPyBUaGUgY2FsbGVycyBtdXN0IGNoZWNrIHRoZSBleGVjdXRpb25cbiAgICAvLyBjb250ZXh0IGZpcnN0IHJlZ2FyZGxlc3MuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFtaWdodEhhdmVQZW5kaW5nU3luY1dvcmspIHtcbiAgICAvLyBGYXN0IHBhdGguIFRoZXJlJ3Mgbm8gc3luYyB3b3JrIHRvIGRvLlxuICAgIHJldHVybjtcbiAgfSAvLyBUaGVyZSBtYXkgb3IgbWF5IG5vdCBiZSBzeW5jaHJvbm91cyB3b3JrIHNjaGVkdWxlZC4gTGV0J3MgY2hlY2suXG5cblxuICB2YXIgZGlkUGVyZm9ybVNvbWVXb3JrO1xuICBpc0ZsdXNoaW5nV29yayA9IHRydWU7XG5cbiAgZG8ge1xuICAgIGRpZFBlcmZvcm1Tb21lV29yayA9IGZhbHNlO1xuICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuXG4gICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGlmIChvbmx5TGVnYWN5ICYmIChkaXNhYmxlTGVnYWN5TW9kZSApKSA7IGVsc2Uge1xuICAgICAgICB2YXIgd29ya0luUHJvZ3Jlc3NSb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG4gICAgICAgIHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IGdldFdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKCk7XG4gICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICAgICAgICBpZiAoaW5jbHVkZXNTeW5jTGFuZShuZXh0TGFuZXMpKSB7XG4gICAgICAgICAgLy8gVGhpcyByb290IGhhcyBwZW5kaW5nIHN5bmMgd29yay4gRmx1c2ggaXQgbm93LlxuICAgICAgICAgIGRpZFBlcmZvcm1Tb21lV29yayA9IHRydWU7XG4gICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIG5leHRMYW5lcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcm9vdCA9IHJvb3QubmV4dDtcbiAgICB9XG4gIH0gd2hpbGUgKGRpZFBlcmZvcm1Tb21lV29yayk7XG5cbiAgaXNGbHVzaGluZ1dvcmsgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGFsd2F5cyBjYWxsZWQgaW5zaWRlIGEgbWljcm90YXNrLiBJdCBzaG91bGQgbmV2ZXIgYmVcbiAgLy8gY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gIGRpZFNjaGVkdWxlTWljcm90YXNrID0gZmFsc2U7XG5cbiAge1xuICAgIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9IGZhbHNlO1xuICB9IC8vIFdlJ2xsIHJlY29tcHV0ZSB0aGlzIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCBhbGwgdGhlIHJvb3RzIGFuZCBzY2hlZHVsZSB0aGVtLlxuXG5cbiAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gZmFsc2U7XG4gIHZhciBjdXJyZW50VGltZSA9IG5vdyQxKCk7XG4gIHZhciBwcmV2ID0gbnVsbDtcbiAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG5cbiAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dCA9IHJvb3QubmV4dDtcblxuICAgIGlmIChjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAhPT0gTm9MYW5lICYmIHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24oKSkge1xuICAgICAgLy8gQSB0cmFuc2l0aW9uIHdhcyBzY2hlZHVsZWQgZHVyaW5nIGFuIGV2ZW50LCBidXQgd2UncmUgZ29pbmcgdG8gdHJ5IHRvXG4gICAgICAvLyByZW5kZXIgaXQgc3luY2hyb25vdXNseSBhbnl3YXkuIFdlIGRvIHRoaXMgZHVyaW5nIGEgcG9wc3RhdGUgZXZlbnQgdG9cbiAgICAgIC8vIHByZXNlcnZlIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAgICB1cGdyYWRlUGVuZGluZ0xhbmVUb1N5bmMocm9vdCwgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUpO1xuICAgIH1cblxuICAgIHZhciBuZXh0TGFuZXMgPSBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKTtcblxuICAgIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZSkge1xuICAgICAgLy8gVGhpcyByb290IGhhcyBubyBtb3JlIHBlbmRpbmcgd29yay4gUmVtb3ZlIGl0IGZyb20gdGhlIHNjaGVkdWxlLiBUb1xuICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWJ0bGUgcmVlbnRyYW5jeSBidWdzLCB0aGlzIG1pY3JvdGFzayBpcyB0aGUgb25seSBwbGFjZVxuICAgICAgLy8gd2UgZG8gdGhpcyDigJQgeW91IGNhbiBhZGQgcm9vdHMgdG8gdGhlIHNjaGVkdWxlIHdoZW5ldmVyLCBidXQgeW91IGNhblxuICAgICAgLy8gb25seSByZW1vdmUgdGhlbSBoZXJlLlxuICAgICAgLy8gTnVsbCB0aGlzIG91dCBzbyB3ZSBrbm93IGl0J3MgYmVlbiByZW1vdmVkIGZyb20gdGhlIHNjaGVkdWxlLlxuICAgICAgcm9vdC5uZXh0ID0gbnVsbDtcblxuICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbmV3IGhlYWQgb2YgdGhlIGxpc3RcbiAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG5ldyB0YWlsIG9mIHRoZSBsaXN0XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyByb290IHN0aWxsIGhhcyB3b3JrLiBLZWVwIGl0IGluIHRoZSBsaXN0LlxuICAgICAgcHJldiA9IHJvb3Q7XG5cbiAgICAgIGlmIChpbmNsdWRlc1N5bmNMYW5lKG5leHRMYW5lcykpIHtcbiAgICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByb290ID0gbmV4dDtcbiAgfVxuXG4gIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gTm9MYW5lOyAvLyBBdCB0aGUgZW5kIG9mIHRoZSBtaWNyb3Rhc2ssIGZsdXNoIGFueSBwZW5kaW5nIHN5bmNocm9ub3VzIHdvcmsuIFRoaXMgaGFzXG4gIC8vIHRvIGNvbWUgYXQgdGhlIGVuZCwgYmVjYXVzZSBpdCBkb2VzIGFjdHVhbCByZW5kZXJpbmcgd29yayB0aGF0IG1pZ2h0IHRocm93LlxuXG4gIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBhbHdheXMgY2FsbGVkIGluc2lkZSBhIG1pY3JvdGFzaywgb3IgYXQgdGhlIHZlcnkgZW5kIG9mIGFcbiAgLy8gcmVuZGVyaW5nIHRhc2sgcmlnaHQgYmVmb3JlIHdlIHlpZWxkIHRvIHRoZSBtYWluIHRocmVhZC4gSXQgc2hvdWxkIG5ldmVyIGJlXG4gIC8vIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICAvL1xuICAvLyBUT0RPOiBVbmxlc3MgZW5hYmxlRGVmZXJSb290U2NoZWR1bGluZ1RvTWljcm90YXNrIGlzIG9mZi4gV2UgbmVlZCB0byBsYW5kXG4gIC8vIHRoYXQgQVNBUCB0byB1bmJsb2NrIGFkZGl0aW9uYWwgZmVhdHVyZXMgd2UgaGF2ZSBwbGFubmVkLlxuICAvL1xuICAvLyBUaGlzIGZ1bmN0aW9uIGFsc28gbmV2ZXIgcGVyZm9ybXMgUmVhY3Qgd29yayBzeW5jaHJvbm91c2x5OyBpdCBzaG91bGRcbiAgLy8gb25seSBzY2hlZHVsZSB3b3JrIHRvIGJlIHBlcmZvcm1lZCBsYXRlciwgaW4gYSBzZXBhcmF0ZSB0YXNrIG9yIG1pY3JvdGFzay5cbiAgLy8gQ2hlY2sgaWYgYW55IGxhbmVzIGFyZSBiZWluZyBzdGFydmVkIGJ5IG90aGVyIHdvcmsuIElmIHNvLCBtYXJrIHRoZW0gYXNcbiAgLy8gZXhwaXJlZCBzbyB3ZSBrbm93IHRvIHdvcmsgb24gdGhvc2UgbmV4dC5cbiAgbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSk7IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCBhbmQgdGhlaXIgcHJpb3JpdHkuXG5cbiAgdmFyIHdvcmtJblByb2dyZXNzUm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuICB2YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcygpO1xuICB2YXIgbmV4dExhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIDogTm9MYW5lcyk7XG4gIHZhciBleGlzdGluZ0NhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuXG4gIGlmICggLy8gQ2hlY2sgaWYgdGhlcmUncyBub3RoaW5nIHRvIHdvcmsgb25cbiAgbmV4dExhbmVzID09PSBOb0xhbmVzIHx8IC8vIElmIHRoaXMgcm9vdCBpcyBjdXJyZW50bHkgc3VzcGVuZGVkIGFuZCB3YWl0aW5nIGZvciBkYXRhIHRvIHJlc29sdmUsIGRvbid0XG4gIC8vIHNjaGVkdWxlIGEgdGFzayB0byByZW5kZXIgaXQuIFdlJ2xsIGVpdGhlciB3YWl0IGZvciBhIHBpbmcsIG9yIHdhaXQgdG9cbiAgLy8gcmVjZWl2ZSBhbiB1cGRhdGUuXG4gIC8vXG4gIC8vIFN1c3BlbmRlZCByZW5kZXIgcGhhc2VcbiAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmIGlzV29ya0xvb3BTdXNwZW5kZWRPbkRhdGEoKSB8fCAvLyBTdXNwZW5kZWQgY29tbWl0IHBoYXNlXG4gIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCAhPT0gbnVsbCkge1xuICAgIC8vIEZhc3QgcGF0aDogVGhlcmUncyBub3RoaW5nIHRvIHdvcmsgb24uXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxDYWxsYmFjayhleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgfVxuXG4gICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcbiAgICByZXR1cm4gTm9MYW5lO1xuICB9IC8vIFNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrIGluIHRoZSBob3N0IGVudmlyb25tZW50LlxuXG5cbiAgaWYgKGluY2x1ZGVzU3luY0xhbmUobmV4dExhbmVzKSkge1xuICAgIC8vIFN5bmNocm9ub3VzIHdvcmsgaXMgYWx3YXlzIGZsdXNoZWQgYXQgdGhlIGVuZCBvZiB0aGUgbWljcm90YXNrLCBzbyB3ZVxuICAgIC8vIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgYW4gYWRkaXRpb25hbCB0YXNrLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICAgIH1cblxuICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IFN5bmNMYW5lO1xuICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgdXNlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGxhbmUgdG8gcmVwcmVzZW50IHRoZSBwcmlvcml0eSBvZiB0aGUgY2FsbGJhY2suXG4gICAgdmFyIGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSA9IHJvb3QuY2FsbGJhY2tQcmlvcml0eTtcbiAgICB2YXIgbmV3Q2FsbGJhY2tQcmlvcml0eSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTtcblxuICAgIGlmIChuZXdDYWxsYmFja1ByaW9yaXR5ID09PSBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgJiYgLy8gU3BlY2lhbCBjYXNlIHJlbGF0ZWQgdG8gYGFjdGAuIElmIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkIHRhc2sgaXMgYVxuICAgIC8vIFNjaGVkdWxlciB0YXNrLCByYXRoZXIgdGhhbiBhbiBgYWN0YCB0YXNrLCBjYW5jZWwgaXQgYW5kIHJlLXNjaGVkdWxlXG4gICAgLy8gb24gdGhlIGBhY3RgIHF1ZXVlLlxuICAgICEoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwgJiYgZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IGZha2VBY3RDYWxsYmFja05vZGUkMSkpIHtcbiAgICAgIC8vIFRoZSBwcmlvcml0eSBoYXNuJ3QgY2hhbmdlZC4gV2UgY2FuIHJldXNlIHRoZSBleGlzdGluZyB0YXNrLlxuICAgICAgcmV0dXJuIG5ld0NhbGxiYWNrUHJpb3JpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbmNlbCB0aGUgZXhpc3RpbmcgY2FsbGJhY2suIFdlJ2xsIHNjaGVkdWxlIGEgbmV3IG9uZSBiZWxvdy5cbiAgICAgIGNhbmNlbENhbGxiYWNrKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbDtcblxuICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkobmV4dExhbmVzKSkge1xuICAgICAgY2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBJZGxlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbmV3Q2FsbGJhY2tOb2RlID0gc2NoZWR1bGVDYWxsYmFjayQyKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwsIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbmV3Q2FsbGJhY2tOb2RlO1xuICAgIHJldHVybiBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbnRpbnVhdGlvbkZvclJvb3Qocm9vdCwgb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgYXQgdGhlIGVuZCBvZiBgcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290YCB0byBkZXRlcm1pbmVcbiAgLy8gaWYgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNvbnRpbnVhdGlvbiB0YXNrLlxuICAvL1xuICAvLyBVc3VhbGx5IGBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrYCBvbmx5IHJ1bnMgaW5zaWRlIGEgbWljcm90YXNrO1xuICAvLyBob3dldmVyLCBzaW5jZSBtb3N0IG9mIHRoZSBsb2dpYyBmb3IgZGV0ZXJtaW5pbmcgaWYgd2UgbmVlZCBhIGNvbnRpbnVhdGlvblxuICAvLyB2ZXJzdXMgYSBuZXcgdGFzayBpcyB0aGUgc2FtZSwgd2UgY2hlYXQgYSBiaXQgYW5kIGNhbGwgaXQgaGVyZS4gVGhpcyBpc1xuICAvLyBvbmx5IHNhZmUgdG8gZG8gYmVjYXVzZSB3ZSBrbm93IHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGJyb3dzZXIgdGFzay5cbiAgLy8gU28gYWx0aG91Z2ggaXQncyBub3QgYW4gYWN0dWFsIG1pY3JvdGFzaywgaXQgbWlnaHQgYXMgd2VsbCBiZS5cbiAgc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBub3ckMSgpKTtcblxuICBpZiAocm9vdC5jYWxsYmFja05vZGUgPT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgLy8gVGhlIHRhc2sgbm9kZSBzY2hlZHVsZWQgZm9yIHRoaXMgcm9vdCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzXG4gICAgLy8gY3VycmVudGx5IGV4ZWN1dGVkLiBOZWVkIHRvIHJldHVybiBhIGNvbnRpbnVhdGlvbi5cbiAgICByZXR1cm4gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEgPSB7fTtcblxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayQyKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKSB7XG4gIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogV2UncmUgaW5zaWRlIGFuIGBhY3RgIHNjb3BlIChhIHRlc3RpbmcgdXRpbGl0eSkuXG4gICAgLy8gSW5zdGVhZCBvZiBzY2hlZHVsaW5nIHdvcmsgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQsIGFkZCBpdCB0byBhXG4gICAgLy8gZmFrZSBpbnRlcm5hbCBxdWV1ZSB0aGF0J3MgbWFuYWdlZCBieSB0aGUgYGFjdGAgaW1wbGVtZW50YXRpb24uXG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIGZha2VBY3RDYWxsYmFja05vZGUkMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NoZWR1bGVDYWxsYmFjayQzKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpIHtcbiAgaWYgKGNhbGxiYWNrTm9kZSA9PT0gZmFrZUFjdENhbGxiYWNrTm9kZSQxKSA7IGVsc2UgaWYgKGNhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgIGNhbmNlbENhbGxiYWNrJDEoY2FsbGJhY2tOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZUltbWVkaWF0ZVRhc2soY2IpIHtcbiAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBJbnNpZGUgYW4gYGFjdGAgc2NvcGUsIHdlIHB1c2ggbWljcm90YXNrcyB0byB0aGUgZmFrZSBgYWN0YFxuICAgIC8vIGNhbGxiYWNrIHF1ZXVlLiBUaGlzIGlzIGJlY2F1c2Ugd2UgY3VycmVudGx5IHN1cHBvcnQgY2FsbGluZyBgYWN0YFxuICAgIC8vIHdpdGhvdXQgYXdhaXRpbmcgdGhlIHJlc3VsdC4gVGhlIHBsYW4gaXMgdG8gZGVwcmVjYXRlIHRoYXQsIGFuZCByZXF1aXJlXG4gICAgLy8gdGhhdCB5b3UgYWx3YXlzIGF3YWl0IHRoZSByZXN1bHQgc28gdGhhdCB0aGUgbWljcm90YXNrcyBoYXZlIGEgY2hhbmNlIHRvXG4gICAgLy8gcnVuLiBCdXQgaXQgaGFzbid0IGhhcHBlbmVkIHlldC5cbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfSAvLyBUT0RPOiBDYW4gd2UgbGFuZCBzdXBwb3J0c01pY3JvdGFza3M/IFdoaWNoIGVudmlyb25tZW50cyBkb24ndCBzdXBwb3J0IGl0P1xuICAvLyBBbHRlcm5hdGl2ZWx5LCBjYW4gd2UgbW92ZSB0aGlzIGNoZWNrIHRvIHRoZSBob3N0IGNvbmZpZz9cblxuXG4gIGlmIChzdXBwb3J0c01pY3JvdGFza3MpIHtcbiAgICBzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBJbiBTYWZhcmksIGFwcGVuZGluZyBhbiBpZnJhbWUgZm9yY2VzIG1pY3JvdGFza3MgdG8gcnVuLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMjQ1OVxuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBydW5uaW5nIGNhbGxiYWNrcyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlclxuICAgICAgLy8gb3IgY29tbWl0IHNvIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdCB0aGF0LlxuICAgICAgdmFyIGV4ZWN1dGlvbkNvbnRleHQgPSBnZXRFeGVjdXRpb25Db250ZXh0KCk7XG5cbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgd291bGQgc3RpbGwgcHJlbWF0dXJlbHkgZmx1c2ggdGhlIGNhbGxiYWNrc1xuICAgICAgICAvLyBpZiB0aGlzIGhhcHBlbnMgb3V0c2lkZSByZW5kZXIgb3IgY29tbWl0IHBoYXNlIChlLmcuIGluIGFuIGV2ZW50KS5cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2luZyBhIG1hY3JvdGFzayBpbnN0ZWFkIG9mIGEgbWljcm90YXNrIGhlcmUuIFRoaXMgaXNcbiAgICAgICAgLy8gd3Jvbmcgc2VtYW50aWNhbGx5IGJ1dCBpdCBwcmV2ZW50cyBhbiBpbmZpbml0ZSBsb29wLiBUaGUgYnVnIGlzXG4gICAgICAgIC8vIFNhZmFyaSdzLCBub3Qgb3Vycywgc28gd2UganVzdCBkbyBvdXIgYmVzdCB0byBub3QgY3Jhc2ggZXZlbiB0aG91Z2hcbiAgICAgICAgLy8gdGhlIGJlaGF2aW9yIGlzbid0IGNvbXBsZXRlbHkgY29ycmVjdC5cbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayQzKEltbWVkaWF0ZVByaW9yaXR5LCBjYik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2IoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBtaWNyb3Rhc2tzIGFyZSBub3Qgc3VwcG9ydGVkLCB1c2UgU2NoZWR1bGVyLlxuICAgIHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RUcmFuc2l0aW9uTGFuZSggLy8gVGhpcyBhcmd1bWVudCBpc24ndCB1c2VkLCBpdCdzIG9ubHkgaGVyZSB0byBlbmNvdXJhZ2UgdGhlIGNhbGxlciB0b1xuLy8gY2hlY2sgdGhhdCBpdCdzIGluc2lkZSBhIHRyYW5zaXRpb24gYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbi8vIFRPRE86IE1ha2UgdGhpcyBub24tbnVsbGFibGUuIFJlcXVpcmVzIGEgdHdlYWsgdG8gdXNlT3B0aW1pc3RpYy5cbnRyYW5zaXRpb24pIHtcbiAgLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gIC8vIHVwZGF0ZXMgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aGluIHRoZSBzYW1lIGV2ZW50LiBUbyBkbyB0aGlzLCB0aGVcbiAgLy8gaW5wdXRzIHRvIHRoZSBhbGdvcml0aG0gbXVzdCBiZSB0aGUgc2FtZS5cbiAgLy9cbiAgLy8gVGhlIHRyaWNrIHdlIHVzZSBpcyB0byBjYWNoZSB0aGUgZmlyc3Qgb2YgZWFjaCBvZiB0aGVzZSBpbnB1dHMgd2l0aGluIGFuXG4gIC8vIGV2ZW50LiBUaGVuIHJlc2V0IHRoZSBjYWNoZWQgdmFsdWVzIG9uY2Ugd2UgY2FuIGJlIHN1cmUgdGhlIGV2ZW50IGlzXG4gIC8vIG92ZXIuIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cbiAgaWYgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBBbGwgdHJhbnNpdGlvbnMgd2l0aGluIHRoZSBzYW1lIGV2ZW50IGFyZSBhc3NpZ25lZCB0aGUgc2FtZSBsYW5lLlxuICAgIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKTtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbn1cblxuLy8gdHJhbnNpdGlvbiB1cGRhdGVzIHRoYXQgb2NjdXIgd2hpbGUgdGhlIGFzeW5jIGFjdGlvbiBpcyBzdGlsbCBpbiBwcm9ncmVzc1xuLy8gYXJlIHRyZWF0ZWQgYXMgcGFydCBvZiB0aGUgYWN0aW9uLlxuLy9cbi8vIFRoZSBpZGVhbCBiZWhhdmlvciB3b3VsZCBiZSB0byB0cmVhdCBlYWNoIGFzeW5jIGZ1bmN0aW9uIGFzIGFuIGluZGVwZW5kZW50XG4vLyBhY3Rpb24uIEhvd2V2ZXIsIHdpdGhvdXQgYSBtZWNoYW5pc20gbGlrZSBBc3luY0NvbnRleHQsIHdlIGNhbid0IHRlbGwgd2hpY2hcbi8vIGFjdGlvbiBhbiB1cGRhdGUgY29ycmVzcG9uZHMgdG8uIFNvIGluc3RlYWQsIHdlIGVudGFuZ2xlIHRoZW0gYWxsIGludG8gb25lLlxuLy8gVGhlIGxpc3RlbmVycyB0byBub3RpZnkgb25jZSB0aGUgZW50YW5nbGVkIHNjb3BlIGNvbXBsZXRlcy5cblxudmFyIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsOyAvLyBUaGUgbnVtYmVyIG9mIHBlbmRpbmcgYXN5bmMgYWN0aW9ucyBpbiB0aGUgZW50YW5nbGVkIHNjb3BlLlxuXG52YXIgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDA7IC8vIFRoZSB0cmFuc2l0aW9uIGxhbmUgc2hhcmVkIGJ5IGFsbCB1cGRhdGVzIGluIHRoZSBlbnRhbmdsZWQgc2NvcGUuXG5cbnZhciBjdXJyZW50RW50YW5nbGVkTGFuZSA9IE5vTGFuZTsgLy8gQSB0aGVuYWJsZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGVudGFuZ2xlZCBzY29wZSBjb21wbGV0ZXMuIEl0IGRvZXMgbm90XG4vLyByZXNvbHZlIHRvIGEgcGFydGljdWxhciB2YWx1ZSBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZvciBzdXNwZW5kaW5nIHRoZSBVSVxuLy8gdW50aWwgdGhlIGFzeW5jIGFjdGlvbiBzY29wZSBoYXMgY29tcGxldGVkLlxuXG52YXIgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcbmZ1bmN0aW9uIGVudGFuZ2xlQXN5bmNBY3Rpb24odHJhbnNpdGlvbiwgdGhlbmFibGUpIHtcbiAgLy8gYHRoZW5hYmxlYCBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBhc3luYyBhY3Rpb24gc2NvcGUgZnVuY3Rpb24uIENyZWF0ZVxuICAvLyBhIGNvbWJpbmVkIHRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgb25jZSBldmVyeSBlbnRhbmdsZWQgc2NvcGUgZnVuY3Rpb25cbiAgLy8gaGFzIGZpbmlzaGVkLlxuICBpZiAoY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gb3V0ZXIgYXN5bmMgYWN0aW9uIHNjb3BlLiBDcmVhdGUgYSBuZXcgb25lLlxuICAgIHZhciBlbnRhbmdsZWRMaXN0ZW5lcnMgPSBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gW107XG4gICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDA7XG4gICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICB2YXIgZW50YW5nbGVkVGhlbmFibGUgPSB7XG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBlbnRhbmdsZWRMaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IGVudGFuZ2xlZFRoZW5hYmxlO1xuICB9XG5cbiAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICB0aGVuYWJsZS50aGVuKHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUsIHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUpO1xuICByZXR1cm4gdGhlbmFibGU7XG59XG5cbmZ1bmN0aW9uIHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUoKSB7XG4gIGlmIChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzICE9PSBudWxsICYmIC0tY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgIC8vIEFsbCB0aGUgYWN0aW9ucyBoYXZlIGZpbmlzaGVkLiBDbG9zZSB0aGUgZW50YW5nbGVkIGFzeW5jIGFjdGlvbiBzY29wZVxuICAgIC8vIGFuZCBub3RpZnkgYWxsIHRoZSBsaXN0ZW5lcnMuXG4gICAgaWYgKGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnM7XG4gICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7XG4gICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSBOb0xhbmU7XG4gICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGFpblRoZW5hYmxlVmFsdWUodGhlbmFibGUsIHJlc3VsdCkge1xuICAvLyBFcXVpdmFsZW50IHRvOiBQcm9taXNlLnJlc29sdmUodGhlbmFibGUpLnRoZW4oKCkgPT4gcmVzdWx0KSwgZXhjZXB0IHdlIGNhblxuICAvLyBjaGVhdCBhIGJpdCBzaW5jZSB3ZSBrbm93IHRoYXQgdGhhdCB0aGlzIHRoZW5hYmxlIGlzIG9ubHkgZXZlciBjb25zdW1lZFxuICAvLyBieSBSZWFjdC5cbiAgLy9cbiAgLy8gV2UgZG9uJ3QgdGVjaG5pY2FsbHkgcmVxdWlyZSBwcm9taXNlIHN1cHBvcnQgb24gdGhlIGNsaWVudCB5ZXQsIGhlbmNlIHRoaXNcbiAgLy8gZXh0cmEgY29kZS5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgdGhlbmFibGVXaXRoT3ZlcnJpZGUgPSB7XG4gICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgcmVhc29uOiBudWxsLFxuICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBsaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICB9XG4gIH07XG4gIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG4gICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSByZXN1bHQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIocmVzdWx0KTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG4gICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldOyAvLyBUaGlzIGlzIGEgcGVyZiBoYWNrIHdoZXJlIHdlIGNhbGwgdGhlIGBvbkZ1bGZpbGxgIHBpbmcgZnVuY3Rpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYG9uUmVqZWN0YCwgYmVjYXVzZSB3ZSBrbm93IHRoYXQgUmVhY3QgaXMgdGhlIG9ubHlcbiAgICAgIC8vIGNvbnN1bWVyIG9mIHRoZXNlIHByb21pc2VzLCBhbmQgaXQgcGFzc2VzIHRoZSBzYW1lIGxpc3RlbmVyIHRvIGJvdGguXG4gICAgICAvLyBXZSBhbHNvIGtub3cgdGhhdCBpdCB3aWxsIHJlYWQgdGhlIGVycm9yIGRpcmVjdGx5IG9mZiB0aGVcbiAgICAgIC8vIGAucmVhc29uYCBmaWVsZC5cblxuICAgICAgbGlzdGVuZXIodW5kZWZpbmVkKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG59XG5mdW5jdGlvbiBwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRFbnRhbmdsZWRMYW5lO1xufVxuZnVuY3Rpb24gcGVla0VudGFuZ2xlZEFjdGlvblRoZW5hYmxlKCkge1xuICByZXR1cm4gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xufVxuXG52YXIgVXBkYXRlU3RhdGUgPSAwO1xudmFyIFJlcGxhY2VTdGF0ZSA9IDE7XG52YXIgRm9yY2VVcGRhdGUgPSAyO1xudmFyIENhcHR1cmVVcGRhdGUgPSAzOyAvLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG4vLyBJdCBzaG91bGQgb25seSBiZSByZWFkIHJpZ2h0IGFmdGVyIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAsIHZpYVxuLy8gYGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmdgLlxuXG52YXIgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlO1xudmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZTtcblxue1xuICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG4gIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBsYXN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBzaGFyZWQ6IHtcbiAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgIGhpZGRlbkNhbGxiYWNrczogbnVsbFxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiBudWxsXG4gIH07XG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG59XG5mdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIENsb25lIHRoZSB1cGRhdGUgcXVldWUgZnJvbSBjdXJyZW50LiBVbmxlc3MgaXQncyBhbHJlYWR5IGEgY2xvbmUuXG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICBpZiAocXVldWUgPT09IGN1cnJlbnRRdWV1ZSkge1xuICAgIHZhciBjbG9uZSA9IHtcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgIGZpcnN0QmFzZVVwZGF0ZTogY3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSxcbiAgICAgIGxhc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGUsXG4gICAgICBzaGFyZWQ6IGN1cnJlbnRRdWV1ZS5zaGFyZWQsXG4gICAgICBjYWxsYmFja3M6IG51bGxcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY2xvbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZShsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG5cbiAge1xuICAgIGlmIChjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHNoYXJlZFF1ZXVlICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpO1xuXG4gICAgICBlcnJvcignQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnQ6ICVzJywgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUoKSkge1xuICAgIC8vIFRoaXMgaXMgYW4gdW5zYWZlIHJlbmRlciBwaGFzZSB1cGRhdGUuIEFkZCBkaXJlY3RseSB0byB0aGUgdXBkYXRlXG4gICAgLy8gcXVldWUgc28gd2UgY2FuIHByb2Nlc3MgaXQgaW1tZWRpYXRlbHkgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlci5cbiAgICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cbiAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICAgIH1cblxuICAgIHNoYXJlZFF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7IC8vIFVwZGF0ZSB0aGUgY2hpbGRMYW5lcyBldmVuIHRob3VnaCB3ZSdyZSBtb3N0IGxpa2VseSBhbHJlYWR5IHJlbmRlcmluZ1xuICAgIC8vIHRoaXMgZmliZXIuIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGluIHRoZSBjYXNlIHdoZXJlIHlvdVxuICAgIC8vIHVwZGF0ZSBhIGRpZmZlcmVudCBjb21wb25lbnQgZHVyaW5nIHJlbmRlciBwaGFzZSB0aGFuIHRoZSBvbmUgdGhhdCBpc1xuICAgIC8vIGN1cnJlbnRseSByZW5kZXJpbmdzIChhIHBhdHRlcm4gdGhhdCBpcyBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcpLlxuXG4gICAgcmV0dXJuIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbGFuZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUoZmliZXIsIHNoYXJlZFF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuXG4gIGlmIChpc1RyYW5zaXRpb25MYW5lKGxhbmUpKSB7XG4gICAgdmFyIHF1ZXVlTGFuZXMgPSBzaGFyZWRRdWV1ZS5sYW5lczsgLy8gSWYgYW55IGVudGFuZ2xlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIHBlbmRpbmcgb24gdGhlIHJvb3QsIHRoZW4gdGhleSBtdXN0XG4gICAgLy8gaGF2ZSBmaW5pc2hlZC4gV2UgY2FuIHJlbW92ZSB0aGVtIGZyb20gdGhlIHNoYXJlZCBxdWV1ZSwgd2hpY2ggcmVwcmVzZW50c1xuICAgIC8vIGEgc3VwZXJzZXQgb2YgdGhlIGFjdHVhbGx5IHBlbmRpbmcgbGFuZXMuIEluIHNvbWUgY2FzZXMgd2UgbWF5IGVudGFuZ2xlXG4gICAgLy8gbW9yZSB0aGFuIHdlIG5lZWQgdG8sIGJ1dCB0aGF0J3MgT0suIEluIGZhY3QgaXQncyB3b3JzZSBpZiB3ZSAqZG9uJ3QqXG4gICAgLy8gZW50YW5nbGUgd2hlbiB3ZSBzaG91bGQuXG5cbiAgICBxdWV1ZUxhbmVzID0gaW50ZXJzZWN0TGFuZXMocXVldWVMYW5lcywgcm9vdC5wZW5kaW5nTGFuZXMpOyAvLyBFbnRhbmdsZSB0aGUgbmV3IHRyYW5zaXRpb24gbGFuZSB3aXRoIHRoZSBvdGhlciB0cmFuc2l0aW9uIGxhbmVzLlxuXG4gICAgdmFyIG5ld1F1ZXVlTGFuZXMgPSBtZXJnZUxhbmVzKHF1ZXVlTGFuZXMsIGxhbmUpO1xuICAgIHNoYXJlZFF1ZXVlLmxhbmVzID0gbmV3UXVldWVMYW5lczsgLy8gRXZlbiBpZiBxdWV1ZS5sYW5lcyBhbHJlYWR5IGluY2x1ZGUgbGFuZSwgd2UgZG9uJ3Qga25vdyBmb3IgY2VydGFpbiBpZlxuICAgIC8vIHRoZSBsYW5lIGZpbmlzaGVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2UgZW50YW5nbGVkIGl0LiBTbyB3ZSBuZWVkIHRvXG4gICAgLy8gZW50YW5nbGUgaXQgYWdhaW4sIGp1c3QgdG8gYmUgc3VyZS5cblxuICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIG5ld1F1ZXVlTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gIC8vIENhcHR1cmVkIHVwZGF0ZXMgYXJlIHVwZGF0ZXMgdGhhdCBhcmUgdGhyb3duIGJ5IGEgY2hpbGQgZHVyaW5nIHRoZSByZW5kZXJcbiAgLy8gcGhhc2UuIFRoZXkgc2hvdWxkIGJlIGRpc2NhcmRlZCBpZiB0aGUgcmVuZGVyIGlzIGFib3J0ZWQuIFRoZXJlZm9yZSxcbiAgLy8gd2Ugc2hvdWxkIG9ubHkgcHV0IHRoZW0gb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIG5vdCB0aGUgY3VycmVudCBvbmUuXG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOyAvLyBDaGVjayBpZiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhIGNsb25lLlxuXG4gIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgICBpZiAocXVldWUgPT09IGN1cnJlbnRRdWV1ZSkge1xuICAgICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgdGhlIHNhbWUgYXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW5cbiAgICAgIC8vIHdlIGJhaWwgb3V0IG9uIGEgcGFyZW50IGZpYmVyIHRoYXQgdGhlbiBjYXB0dXJlcyBhbiBlcnJvciB0aHJvd24gYnlcbiAgICAgIC8vIGEgY2hpbGQuIFNpbmNlIHdlIHdhbnQgdG8gYXBwZW5kIHRoZSB1cGRhdGUgb25seSB0byB0aGUgd29yay1pblxuICAgICAgLy8gLXByb2dyZXNzIHF1ZXVlLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB1cGRhdGVzLiBXZSB1c3VhbGx5IGNsb25lIGR1cmluZ1xuICAgICAgLy8gcHJvY2Vzc1VwZGF0ZVF1ZXVlLCBidXQgdGhhdCBkaWRuJ3QgaGFwcGVuIGluIHRoaXMgY2FzZSBiZWNhdXNlIHdlXG4gICAgICAvLyBza2lwcGVkIG92ZXIgdGhlIHBhcmVudCB3aGVuIHdlIGJhaWxlZCBvdXQuXG4gICAgICB2YXIgbmV3Rmlyc3QgPSBudWxsO1xuICAgICAgdmFyIG5ld0xhc3QgPSBudWxsO1xuICAgICAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHVwZGF0ZXMgYW5kIGNsb25lIHRoZW0uXG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICAgIGxhbmU6IHVwZGF0ZS5sYW5lLFxuICAgICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgICAvLyBXaGVuIHRoaXMgdXBkYXRlIGlzIHJlYmFzZWQsIHdlIHNob3VsZCBub3QgZmlyZSBpdHNcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGFnYWluLlxuICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2xvbmU7XG4gICAgICAgICAgICBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vIEFwcGVuZCB0aGUgY2FwdHVyZWQgdXBkYXRlIHRoZSBlbmQgb2YgdGhlIGNsb25lZCBsaXN0LlxuXG5cbiAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgICBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBubyBiYXNlIHVwZGF0ZXMuXG4gICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZSA9IHtcbiAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG5ld0ZpcnN0LFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgICBjYWxsYmFja3M6IGN1cnJlbnRRdWV1ZS5jYWxsYmFja3NcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXG5cbiAgdmFyIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG5cbiAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICB9XG5cbiAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBwcmV2U3RhdGUsIG5leHRQcm9wcywgaW5zdGFuY2UpIHtcbiAgc3dpdGNoICh1cGRhdGUudGFnKSB7XG4gICAgY2FzZSBSZXBsYWNlU3RhdGU6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQYXJ0aWFsIHN0YXRlIG9iamVjdFxuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIE51bGwgYW5kIHVuZGVmaW5lZCBhcmUgdHJlYXRlZCBhcyBuby1vcHMuXG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgICAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgICAgICAgcmV0dXJuIGFzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cblxudmFyIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSBmYWxzZTsgLy8gRWFjaCBjYWxsIHRvIHByb2Nlc3NVcGRhdGVRdWV1ZSBzaG91bGQgYmUgYWNjb21wYW5pZWQgYnkgYSBjYWxsIHRvIHRoaXMuIEl0J3Ncbi8vIG9ubHkgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiBiZWNhdXNlIGluIHVwZGF0ZUhvc3RSb290LCBpdCBtdXN0IGhhcHBlbiBhZnRlclxuLy8gYWxsIHRoZSBjb250ZXh0IHN0YWNrcyBoYXZlIGJlZW4gcHVzaGVkIHRvLCB0byBwcmV2ZW50IGEgc3RhY2sgbWlzbWF0Y2guIEFcbi8vIGJpdCB1bmZvcnR1bmF0ZS5cblxuZnVuY3Rpb24gc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpIHtcbiAgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgaXMgcGFydCBvZiBhIHBlbmRpbmcgYXN5bmMgYWN0aW9uLiBJZiBzbywgd2UnbGxcbiAgLy8gbmVlZCB0byBzdXNwZW5kIHVudGlsIHRoZSBhY3Rpb24gaGFzIGZpbmlzaGVkLCBzbyB0aGF0IGl0J3MgYmF0Y2hlZFxuICAvLyB0b2dldGhlciB3aXRoIGZ1dHVyZSB1cGRhdGVzIGluIHRoZSBzYW1lIGFjdGlvbi5cbiAgLy8gVE9ETzogT25jZSB3ZSBzdXBwb3J0IGhvb2tzIGluc2lkZSB1c2VNZW1vIChvciBhbiBlcXVpdmFsZW50XG4gIC8vIG1lbW9pemF0aW9uIGJvdW5kYXJ5IGxpa2UgRm9yZ2V0KSwgaG9pc3QgdGhpcyBsb2dpYyBzbyB0aGF0IGl0IG9ubHlcbiAgLy8gc3VzcGVuZHMgaWYgdGhlIG1lbW8gYm91bmRhcnkgcHJvZHVjZXMgYSBuZXcgdmFsdWUuXG4gIGlmIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKSB7XG4gICAgdmFyIGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gcGVla0VudGFuZ2xlZEFjdGlvblRoZW5hYmxlKCk7XG5cbiAgICBpZiAoZW50YW5nbGVkQWN0aW9uVGhlbmFibGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IEluc3RlYWQgb2YgdGhlIHRocm93aW5nIHRoZSB0aGVuYWJsZSBkaXJlY3RseSwgdGhyb3cgYVxuICAgICAgLy8gc3BlY2lhbCBvYmplY3QgbGlrZSBgdXNlYCBkb2VzIHNvIHdlIGNhbiBkZXRlY3QgaWYgaXQncyBjYXB0dXJlZFxuICAgICAgLy8gYnkgdXNlcnNwYWNlLlxuICAgICAgdGhyb3cgZW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpIHtcbiAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9IGZhbHNlOyAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgfVxuXG4gIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlOyAvLyBDaGVjayBpZiB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBJZiBzbywgdHJhbnNmZXIgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmdRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDsgLy8gVGhlIHBlbmRpbmcgcXVldWUgaXMgY2lyY3VsYXIuIERpc2Nvbm5lY3QgdGhlIHBvaW50ZXIgYmV0d2VlbiBmaXJzdFxuICAgIC8vIGFuZCBsYXN0IHNvIHRoYXQgaXQncyBub24tY2lyY3VsYXIuXG5cbiAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgdmFyIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7IC8vIEFwcGVuZCBwZW5kaW5nIHVwZGF0ZXMgdG8gYmFzZSBxdWV1ZVxuXG4gICAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfVxuXG4gICAgbGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTsgLy8gSWYgdGhlcmUncyBhIGN1cnJlbnQgcXVldWUsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBiYXNlIHF1ZXVlLCB0aGVuXG4gICAgLy8gd2UgbmVlZCB0byB0cmFuc2ZlciB0aGUgdXBkYXRlcyB0byB0aGF0IHF1ZXVlLCB0b28uIEJlY2F1c2UgdGhlIGJhc2VcbiAgICAvLyBxdWV1ZSBpcyBhIHNpbmdseS1saW5rZWQgbGlzdCB3aXRoIG5vIGN5Y2xlcywgd2UgY2FuIGFwcGVuZCB0byBib3RoXG4gICAgLy8gbGlzdHMgYW5kIHRha2UgYWR2YW50YWdlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy5cbiAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudFxuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuICAgICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB2YXIgY3VycmVudExhc3RCYXNlVXBkYXRlID0gY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlICE9PSBsYXN0QmFzZVVwZGF0ZSkge1xuICAgICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGVzZSB2YWx1ZXMgbWF5IGNoYW5nZSBhcyB3ZSBwcm9jZXNzIHRoZSBxdWV1ZS5cblxuXG4gIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gICAgdmFyIG5ld1N0YXRlID0gcXVldWUuYmFzZVN0YXRlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZSByZW5kZXJMYW5lc1xuICAgIC8vIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG4gICAgdmFyIG5ld0xhbmVzID0gTm9MYW5lcztcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgbmV3TGFzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICAvLyBBbiBleHRyYSBPZmZzY3JlZW5MYW5lIGJpdCBpcyBhZGRlZCB0byB1cGRhdGVzIHRoYXQgd2VyZSBtYWRlIHRvXG4gICAgICAvLyBhIGhpZGRlbiB0cmVlLCBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB0aGVtIGZyb20gdXBkYXRlcyB0aGF0IHdlcmVcbiAgICAgIC8vIGFscmVhZHkgdGhlcmUgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLlxuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSByZW1vdmVMYW5lcyh1cGRhdGUubGFuZSwgT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB2YXIgaXNIaWRkZW5VcGRhdGUgPSB1cGRhdGVMYW5lICE9PSB1cGRhdGUubGFuZTsgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgd2FzIG1hZGUgd2hpbGUgdGhlIHRyZWUgd2FzIGhpZGRlbi4gSWYgc28sIHRoZW5cbiAgICAgIC8vIGl0J3Mgbm90IGEgXCJiYXNlXCIgdXBkYXRlIGFuZCB3ZSBzaG91bGQgZGlzcmVnYXJkIHRoZSBleHRyYSBiYXNlIGxhbmVzXG4gICAgICAvLyB0aGF0IHdlcmUgYWRkZWQgdG8gcmVuZGVyTGFuZXMgd2hlbiB3ZSBlbnRlcmVkIHRoZSBPZmZzY3JlZW4gdHJlZS5cblxuICAgICAgdmFyIHNob3VsZFNraXBVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSA/ICFpc1N1YnNldE9mTGFuZXMoZ2V0V29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMoKSwgdXBkYXRlTGFuZSkgOiAhaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKTtcblxuICAgICAgaWYgKHNob3VsZFNraXBVcGRhdGUpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUgPSBjbG9uZTtcbiAgICAgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG5cblxuICAgICAgICBuZXdMYW5lcyA9IG1lcmdlTGFuZXMobmV3TGFuZXMsIHVwZGF0ZUxhbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgdXBkYXRlIGlzIHBhcnQgb2YgYSBwZW5kaW5nIGFzeW5jIGFjdGlvbi4gSWYgc28sXG4gICAgICAgIC8vIHdlJ2xsIG5lZWQgdG8gc3VzcGVuZCB1bnRpbCB0aGUgYWN0aW9uIGhhcyBmaW5pc2hlZCwgc28gdGhhdCBpdCdzXG4gICAgICAgIC8vIGJhdGNoZWQgdG9nZXRoZXIgd2l0aCBmdXR1cmUgdXBkYXRlcyBpbiB0aGUgc2FtZSBhY3Rpb24uXG4gICAgICAgIGlmICh1cGRhdGVMYW5lICE9PSBOb0xhbmUgJiYgdXBkYXRlTGFuZSA9PT0gcGVla0VudGFuZ2xlZEFjdGlvbkxhbmUoKSkge1xuICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jbG9uZSA9IHtcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4gICAgICAgICAgICAvLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcyB1cGRhdGUgaXMgcmViYXNlZCwgd2Ugc2hvdWxkIG5vdCBmaXJlIGl0c1xuICAgICAgICAgICAgLy8gY2FsbGJhY2sgYWdhaW4uXG4gICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgbmV3U3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIG5ld1N0YXRlLCBwcm9wcywgaW5zdGFuY2UpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2FsbGJhY2s7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW5VcGRhdGUpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHF1ZXVlLmNhbGxiYWNrcztcblxuICAgICAgICAgIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXVlLmNhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG5cbiAgICAgIGlmICh1cGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGEgcmVkdWNlci4gQWRkIHRoZSBuZXdcbiAgICAgICAgICAvLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxuICAgICAgICAgIHZhciBfbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7IC8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2VcbiAgICAgICAgICAvLyB1bnJhdmVsIHRoZW0gd2hlbiB0cmFuc2ZlcnJpbmcgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICAgICAgICAgIHZhciBfZmlyc3RQZW5kaW5nVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgICAgX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICAgIHVwZGF0ZSA9IF9maXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBfbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBuZXdGaXJzdEJhc2VVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZTtcblxuICAgIGlmIChmaXJzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgICAvLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAgcXVldWUuc2hhcmVkLmxhbmVzID0gTm9MYW5lcztcbiAgICB9IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cblxuICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobmV3TGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbmV3TGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkICcgKyAoXCJyZWNlaXZlZDogXCIgKyBjYWxsYmFjaykpO1xuICB9XG5cbiAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKSB7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5mdW5jdGlvbiBkZWZlckhpZGRlbkNhbGxiYWNrcyh1cGRhdGVRdWV1ZSkge1xuICAvLyBXaGVuIGFuIHVwZGF0ZSBmaW5pc2hlcyBvbiBhIGhpZGRlbiBjb21wb25lbnQsIGl0cyBjYWxsYmFjayBzaG91bGQgbm90XG4gIC8vIGJlIGZpcmVkIHVudGlsL3VubGVzcyB0aGUgY29tcG9uZW50IGlzIG1hZGUgdmlzaWJsZSBhZ2Fpbi4gU3Rhc2ggdGhlXG4gIC8vIGNhbGxiYWNrIG9uIHRoZSBzaGFyZWQgcXVldWUgb2JqZWN0IHNvIGl0IGNhbiBiZSBmaXJlZCBsYXRlci5cbiAgdmFyIG5ld0hpZGRlbkNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcztcblxuICBpZiAobmV3SGlkZGVuQ2FsbGJhY2tzICE9PSBudWxsKSB7XG4gICAgdmFyIGV4aXN0aW5nSGlkZGVuQ2FsbGJhY2tzID0gdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcztcblxuICAgIGlmIChleGlzdGluZ0hpZGRlbkNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgICAgdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IG5ld0hpZGRlbkNhbGxiYWNrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IGV4aXN0aW5nSGlkZGVuQ2FsbGJhY2tzLmNvbmNhdChuZXdIaWRkZW5DYWxsYmFja3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0SGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gIC8vIFRoaXMgY29tcG9uZW50IGlzIHN3aXRjaGluZyBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlLiBDb21taXQgYW55IGNhbGxiYWNrc1xuICAvLyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZWZlcnJlZC5cbiAgdmFyIGhpZGRlbkNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3M7XG5cbiAgaWYgKGhpZGRlbkNhbGxiYWNrcyAhPT0gbnVsbCkge1xuICAgIHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5DYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGhpZGRlbkNhbGxiYWNrc1tpXTtcbiAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGNvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcztcblxuICBpZiAoY2FsbGJhY2tzICE9PSBudWxsKSB7XG4gICAgdXBkYXRlUXVldWUuY2FsbGJhY2tzID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG4gICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iamVjdElzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzQVtpXTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBjdXJyZW50S2V5KSB8fCAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGxvc3QgcmVmaW5lbWVudCBvZiBgb2JqQmBcbiAgICAhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSwgb2JqQltjdXJyZW50S2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXBlIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cy5cbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFdlIGRvIGFuIGluaXRpYWwgcGFzcyB0byBnYXRoZXIgY29tcG9uZW50IG5hbWVzXG4gICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9IC8vIEZpbmFsbHksIHdlIGZsdXNoIGFsbCB0aGUgd2FybmluZ3NcbiAgICAvLyBVTlNBRkVfIG9uZXMgYmVmb3JlIHRoZSBkZXByZWNhdGVkIG9uZXMsIHNpbmNlIHRoZXknbGwgYmUgJ2xvdWRlcidcblxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBzb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgXCIgKyAncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0LmRldi9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMyID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczIpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczQgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArIFwiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIFwiICsgJ2NvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byAnICsgJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzNCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczUgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM1KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcblxuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG5cblxuICAgIGlmIChkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO1xuXG4gICAgaWYgKGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGwgfHwgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh3YXJuaW5nc0ZvclJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuaW5nc0ZvclJvb3QgPSBbXTtcbiAgICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgICAgfVxuXG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXksIHN0cmljdFJvb3QpIHtcbiAgICAgIGlmIChmaWJlckFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdEZpYmVyID0gZmliZXJBcnJheVswXTtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcbiAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpcnN0RmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXJyb3IoJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlLicgKyAnXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgJyArICd1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uJyArICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQnLCBzb3J0ZWROYW1lcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRoZW5hYmxlc0Zyb21TdGF0ZShzdGF0ZSkge1xuICB7XG4gICAgdmFyIGRldlN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIGRldlN0YXRlLnRoZW5hYmxlcztcbiAgfVxufSAvLyBBbiBlcnJvciB0aGF0IGlzIHRocm93biAoZS5nLiBieSBgdXNlYCkgdG8gdHJpZ2dlciBTdXNwZW5zZS4gSWYgd2Vcbi8vIGRldGVjdCB0aGlzIGlzIGNhdWdodCBieSB1c2Vyc3BhY2UsIHdlJ2xsIGxvZyBhIHdhcm5pbmcgaW4gZGV2ZWxvcG1lbnQuXG5cblxudmFyIFN1c3BlbnNlRXhjZXB0aW9uID0gbmV3IEVycm9yKFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gXCIgKyAnZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciAnICsgJ3JldGhyb3cgaXQgaW1tZWRpYXRlbHksIG9yIG1vdmUgdGhlIGB1c2VgIGNhbGwgb3V0c2lkZSBvZiB0aGUgJyArICdgdHJ5L2NhdGNoYCBibG9jay4gQ2FwdHVyaW5nIHdpdGhvdXQgcmV0aHJvd2luZyB3aWxsIGxlYWQgdG8gJyArICd1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcbicgKyAnVG8gaGFuZGxlIGFzeW5jIGVycm9ycywgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhbiBlcnJvciBib3VuZGFyeSwgb3IgJyArIFwiY2FsbCB0aGUgcHJvbWlzZSdzIGAuY2F0Y2hgIG1ldGhvZCBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGB1c2VgXCIpO1xudmFyIFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbiA9IG5ldyBFcnJvcignU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byAnICsgXCJ1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCIpOyAvLyBUaGlzIGlzIGEgbm9vcCB0aGVuYWJsZSB0aGF0IHdlIHVzZSB0byB0cmlnZ2VyIGEgZmFsbGJhY2sgaW4gdGhyb3dFeGNlcHRpb24uXG4vLyBUT0RPOiBJdCB3b3VsZCBiZSBiZXR0ZXIgdG8gcmVmYWN0b3IgdGhyb3dFeGNlcHRpb24gaW50byBtdWx0aXBsZSBmdW5jdGlvbnNcbi8vIHNvIHdlIGNhbiB0cmlnZ2VyIGEgZmFsbGJhY2sgZGlyZWN0bHkgd2l0aG91dCBoYXZpbmcgdG8gY2hlY2sgdGhlIHR5cGUuIEJ1dFxuLy8gZm9yIG5vdyB0aGlzIHdpbGwgZG8uXG5cbnZhciBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUgPSB7XG4gIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEEgbGlzdGVuZXIgd2FzIHVuZXhwZWN0ZWRseSBhdHRhY2hlZCB0byBhICcgKyAnXCJub29wXCIgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSB7XG4gIC8vIFRoZSBUaGVuYWJsZVN0YXRlIGlzIGNyZWF0ZWQgdGhlIGZpcnN0IHRpbWUgYSBjb21wb25lbnQgc3VzcGVuZHMuIElmIGl0XG4gIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSdsbCByZXVzZSB0aGUgc2FtZSBzdGF0ZS5cbiAge1xuICAgIHJldHVybiB7XG4gICAgICBkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2U6IGZhbHNlLFxuICAgICAgdGhlbmFibGVzOiBbXVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVGhlbmFibGVSZXNvbHZlZCh0aGVuYWJsZSkge1xuICB2YXIgc3RhdHVzID0gdGhlbmFibGUuc3RhdHVzO1xuICByZXR1cm4gc3RhdHVzID09PSAnZnVsZmlsbGVkJyB8fCBzdGF0dXMgPT09ICdyZWplY3RlZCc7XG59XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbmZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5kaWRVc2VQcm9taXNlID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciB0cmFja2VkVGhlbmFibGVzID0gZ2V0VGhlbmFibGVzRnJvbVN0YXRlKHRoZW5hYmxlU3RhdGUpO1xuICB2YXIgcHJldmlvdXMgPSB0cmFja2VkVGhlbmFibGVzW2luZGV4XTtcblxuICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRyYWNrZWRUaGVuYWJsZXMucHVzaCh0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByZXZpb3VzICE9PSB0aGVuYWJsZSkge1xuICAgICAgLy8gUmV1c2UgdGhlIHByZXZpb3VzIHRoZW5hYmxlLCBhbmQgZHJvcCB0aGUgbmV3IG9uZS4gV2UgY2FuIGFzc3VtZVxuICAgICAgLy8gdGhleSByZXByZXNlbnQgdGhlIHNhbWUgdmFsdWUsIGJlY2F1c2UgY29tcG9uZW50cyBhcmUgaWRlbXBvdGVudC5cbiAgICAgIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlU3RhdGVEZXYgPSB0aGVuYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghdGhlbmFibGVTdGF0ZURldi5kaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UpIHtcbiAgICAgICAgICAvLyBXZSBzaG91bGQgb25seSB3YXJuIHRoZSBmaXJzdCB0aW1lIGFuIHVuY2FjaGVkIHRoZW5hYmxlIGlzXG4gICAgICAgICAgLy8gZGlzY292ZXJlZCBwZXIgY29tcG9uZW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSwgdGhlXG4gICAgICAgICAgLy8gc3Vic2VxdWVudCBvbmVzIGFyZSBsaWtlbHkgZGVyaXZlZCBmcm9tIHRoZSBmaXJzdC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdlIHRyYWNrIHRoaXMgb24gdGhlIHRoZW5hYmxlU3RhdGUgaW5zdGVhZCBvZiBkZWR1cGluZyB1c2luZyB0aGVcbiAgICAgICAgICAvLyBjb21wb25lbnQgbmFtZSBsaWtlIHdlIHVzdWFsbHkgZG8sIGJlY2F1c2UgaW4gdGhlIGNhc2Ugb2YgYVxuICAgICAgICAgIC8vIHByb21pc2UtYXMtUmVhY3Qtbm9kZSwgdGhlIG93bmVyIGNvbXBvbmVudCBpcyBsaWtlbHkgZGlmZmVyZW50IGZyb21cbiAgICAgICAgICAvLyB0aGUgcGFyZW50IHRoYXQncyBjdXJyZW50bHkgYmVpbmcgcmVjb25jaWxlZC4gV2UnZCBoYXZlIHRvIHRyYWNrXG4gICAgICAgICAgLy8gdGhlIG93bmVyIHVzaW5nIHN0YXRlLCB3aGljaCB3ZSdyZSB0cnlpbmcgdG8gbW92ZSBhd2F5IGZyb20uIFRob3VnaFxuICAgICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgZGV2LW9ubHksIG1heWJlIHRoYXQnZCBiZSBPSy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIGFub3RoZXIgYmVuZWZpdCBvZiBkb2luZyBpdCB0aGlzIHdheSBpcyB3ZSBtaWdodFxuICAgICAgICAgIC8vIGV2ZW50dWFsbHkgaGF2ZSBhIHRoZW5hYmxlU3RhdGUgcGVyIG1lbW8vRm9yZ2V0IGJvdW5kYXJ5IGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBwZXIgY29tcG9uZW50LCBzbyB0aGlzIHdvdWxkIGFsbG93IHVzIHRvIGhhdmUgbW9yZVxuICAgICAgICAgIC8vIGdyYW51bGFyIHdhcm5pbmdzLlxuICAgICAgICAgIHRoZW5hYmxlU3RhdGVEZXYuZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlID0gdHJ1ZTsgLy8gVE9ETzogVGhpcyB3YXJuaW5nIHNob3VsZCBsaW5rIHRvIGEgY29ycmVzcG9uZGluZyBkb2NzIHBhZ2UuXG5cbiAgICAgICAgICBlcnJvcignQSBjb21wb25lbnQgd2FzIHN1c3BlbmRlZCBieSBhbiB1bmNhY2hlZCBwcm9taXNlLiBDcmVhdGluZyAnICsgJ3Byb21pc2VzIGluc2lkZSBhIENsaWVudCBDb21wb25lbnQgb3IgaG9vayBpcyBub3QgeWV0ICcgKyAnc3VwcG9ydGVkLCBleGNlcHQgdmlhIGEgU3VzcGVuc2UtY29tcGF0aWJsZSBsaWJyYXJ5IG9yIGZyYW1ld29yay4nKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBBdm9pZCBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGVycm9ycyBmb3IgdGhlIFByb21pc2VzIHRoYXQgd2UnbGxcbiAgICAgIC8vIGludGVudGlvbmFsbHkgaWdub3JlLlxuXG5cbiAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpO1xuICAgICAgdGhlbmFibGUgPSBwcmV2aW91cztcbiAgICB9XG4gIH0gLy8gV2UgdXNlIGFuIGV4cGFuZG8gdG8gdHJhY2sgdGhlIHN0YXR1cyBhbmQgcmVzdWx0IG9mIGEgdGhlbmFibGUgc28gdGhhdCB3ZVxuICAvLyBjYW4gc3luY2hyb25vdXNseSB1bndyYXAgdGhlIHZhbHVlLiBUaGluayBvZiB0aGlzIGFzIGFuIGV4dGVuc2lvbiBvZiB0aGVcbiAgLy8gUHJvbWlzZSBBUEksIG9yIGEgY3VzdG9tIGludGVyZmFjZSB0aGF0IGlzIGEgc3VwZXJzZXQgb2YgVGhlbmFibGUuXG4gIC8vXG4gIC8vIElmIHRoZSB0aGVuYWJsZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMsIHNldCBpdCB0byBcInBlbmRpbmdcIiBhbmQgYXR0YWNoXG4gIC8vIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHVwZGF0ZSBpdHMgc3RhdHVzIGFuZCByZXN1bHQgd2hlbiBpdCByZXNvbHZlcy5cblxuXG4gIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZ1bGZpbGxlZFZhbHVlID0gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIHJldHVybiBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHJlamVjdGVkRXJyb3IgPSB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHJlamVjdGVkRXJyb3IpO1xuICAgICAgICB0aHJvdyByZWplY3RlZEVycm9yO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gT25seSBpbnN0cnVtZW50IHRoZSB0aGVuYWJsZSBpZiB0aGUgc3RhdHVzIGlmIG5vdCBkZWZpbmVkLiBJZlxuICAgICAgICAgIC8vIGl0J3MgZGVmaW5lZCwgYnV0IGFuIHVua25vd24gdmFsdWUsIGFzc3VtZSBpdCdzIGJlZW4gaW5zdHJ1bWVudGVkIGJ5XG4gICAgICAgICAgLy8gc29tZSBjdXN0b20gdXNlcnNwYWNlIGltcGxlbWVudGF0aW9uLiBXZSB0cmVhdCBpdCBhcyBcInBlbmRpbmdcIi5cbiAgICAgICAgICAvLyBBdHRhY2ggYSBkdW1teSBsaXN0ZW5lciwgdG8gZW5zdXJlIHRoYXQgYW55IGxhenkgaW5pdGlhbGl6YXRpb24gY2FuXG4gICAgICAgICAgLy8gaGFwcGVuLiBGbGlnaHQgbGF6aWx5IHBhcnNlcyBKU09OIHdoZW4gdGhlIHZhbHVlIGlzIGFjdHVhbGx5IGF3YWl0ZWQuXG4gICAgICAgICAgdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhbiB1bmNhY2hlZCB0aGVuYWJsZSB0aGF0IHdlIGhhdmVuJ3Qgc2VlbiBiZWZvcmUuXG4gICAgICAgICAgLy8gRGV0ZWN0IGluZmluaXRlIHBpbmcgbG9vcHMgY2F1c2VkIGJ5IHVuY2FjaGVkIHByb21pc2VzLlxuICAgICAgICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCAmJiByb290LnNoZWxsU3VzcGVuZENvdW50ZXIgPiAxMDApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgcm9vdCBoYXMgc3VzcGVuZGVkIHJlcGVhdGVkbHkgaW4gdGhlIHNoZWxsIHdpdGhvdXQgbWFraW5nIGFueVxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3MgKGkuZS4gY29tbWl0dGluZyBzb21ldGhpbmcpLiBUaGlzIGlzIGhpZ2hseSBzdWdnZXN0aXZlIG9mXG4gICAgICAgICAgICAvLyBhbiBpbmZpbml0ZSBwaW5nIGxvb3AsIG9mdGVuIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIEFzeW5jIENsaWVudFxuICAgICAgICAgICAgLy8gQ29tcG9uZW50LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIER1cmluZyBhIHRyYW5zaXRpb24sIHdlIGNhbiBzdXNwZW5kIHRoZSB3b3JrIGxvb3AgdW50aWwgdGhlIHByb21pc2VcbiAgICAgICAgICAgIC8vIHRvIHJlc29sdmUsIGJ1dCB0aGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHRoYXQncyBub3QgYW4gb3B0aW9uLiBXZVxuICAgICAgICAgICAgLy8gYWxzbyBjYW4ndCBzaG93IGEgZmFsbGJhY2ssIGJlY2F1c2Ugbm9uZSB3YXMgcHJvdmlkZWQuIFNvIG91ciBsYXN0XG4gICAgICAgICAgICAvLyByZXNvcnQgaXMgdG8gdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgZXJyb3IgaW4gYSBmdXR1cmUgcmVsZWFzZS4gT3RoZXIgd2F5cyBvZiBoYW5kbGluZ1xuICAgICAgICAgICAgLy8gdGhpcyBjYXNlIGluY2x1ZGUgZm9yY2luZyBhIGNvbmN1cnJlbnQgcmVuZGVyLCBvciBwdXR0aW5nIHRoZSB3aG9sZVxuICAgICAgICAgICAgLy8gcm9vdCBpbnRvIG9mZnNjcmVlbiBtb2RlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3luYy9hd2FpdCBpcyBub3QgeWV0IHN1cHBvcnRlZCBpbiBDbGllbnQgQ29tcG9uZW50cywgb25seSAnICsgJ1NlcnZlciBDb21wb25lbnRzLiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgJyArIFwiYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBcIiArICdmb3IgdGhlIHNlcnZlci4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGVuZGluZ1RoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgcGVuZGluZ1RoZW5hYmxlLnN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgICBwZW5kaW5nVGhlbmFibGUudGhlbihmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIENoZWNrIG9uZSBtb3JlIHRpbWUgaW4gY2FzZSB0aGUgdGhlbmFibGUgcmVzb2x2ZWQgc3luY2hyb25vdXNseS5cblxuXG4gICAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAnZnVsZmlsbGVkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgdmFyIF9yZWplY3RlZEVycm9yID0gcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb247XG4gICAgICAgICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKF9yZWplY3RlZEVycm9yKTtcbiAgICAgICAgICAgICAgdGhyb3cgX3JlamVjdGVkRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gU3VzcGVuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhyb3dpbmcgaGVyZSBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgdGhhdCBhbGxvd3MgdXMgdG8gdW53aW5kIHRoZVxuICAgICAgICAvLyBjYWxsIHN0YWNrLiBCdXQgd2Ugc2hvdWxkbid0IGFsbG93IGl0IHRvIGxlYWsgaW50byB1c2Vyc3BhY2UuIFRocm93IGFuXG4gICAgICAgIC8vIG9wYXF1ZSBwbGFjZWhvbGRlciB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgdGhlbmFibGUuIElmIGl0IGRvZXNuJ3RcbiAgICAgICAgLy8gZ2V0IGNhcHR1cmVkIGJ5IHRoZSB3b3JrIGxvb3AsIGxvZyBhIHdhcm5pbmcsIGJlY2F1c2UgdGhhdCBtZWFuc1xuICAgICAgICAvLyBzb21ldGhpbmcgaW4gdXNlcnNwYWNlIG11c3QgaGF2ZSBjYXVnaHQgaXQuXG5cblxuICAgICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3VzcGVuZENvbW1pdCgpIHtcbiAgLy8gVGhpcyBleHRyYSBpbmRpcmVjdGlvbiBvbmx5IGV4aXN0cyBzbyBpdCBjYW4gaGFuZGxlIHBhc3NpbmdcbiAgLy8gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlIHRocm91Z2ggdG8gdGhyb3dFeGNlcHRpb24uXG4gIC8vIFRPRE86IEZhY3RvciB0aGUgdGhlbmFibGUgY2hlY2sgb3V0IG9mIHRocm93RXhjZXB0aW9uXG4gIHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlO1xuICB0aHJvdyBTdXNwZW5zZXlDb21taXRFeGNlcHRpb247XG59IC8vIFRoaXMgaXMgdXNlZCB0byB0cmFjayB0aGUgYWN0dWFsIHRoZW5hYmxlIHRoYXQgc3VzcGVuZGVkIHNvIGl0IGNhbiBiZVxuLy8gcGFzc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiDigJQgd2hpY2gsIGZvciBoaXN0b3JpY2FsXG4vLyByZWFzb25zLCBleHBlY3RzIHRvIHJlY2VpdmUgYSB0aGVuYWJsZS5cblxudmFyIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbnZhciBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIGB1c2VgIHN1c3BlbmRzIGJ5IHRocm93aW5nIGFuIGV4Y2VwdGlvbi4gYHVzZWBcbiAgLy8gdGhyb3dzIGFuIG9wYXF1ZSB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSB0aGVuYWJsZSBpdHNlbGYgc28gdGhhdCBpdCBjYW4ndCBiZVxuICAvLyBjYXVnaHQgaW4gdXNlcnNwYWNlLiBUaGVuIHRoZSB3b3JrIGxvb3AgYWNjZXNzZXMgdGhlIGFjdHVhbCB0aGVuYWJsZSB1c2luZ1xuICAvLyB0aGlzIGZ1bmN0aW9uLlxuICBpZiAoc3VzcGVuZGVkVGhlbmFibGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSAnICsgJ2FuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcblxuICB7XG4gICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0aGVuYWJsZTtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZVc2VXcmFwcGVkSW5UcnlDYXRjaCgpIHtcbiAge1xuICAgIC8vIFRoaXMgd2FzIHNldCByaWdodCBiZWZvcmUgU3VzcGVuc2VFeGNlcHRpb24gd2FzIHRocm93biwgYW5kIGl0IHNob3VsZFxuICAgIC8vIGhhdmUgYmVlbiBjbGVhcmVkIHdoZW4gdGhlIGV4Y2VwdGlvbiB3YXMgaGFuZGxlZC4gSWYgaXQgd2Fzbid0LFxuICAgIC8vIGl0IG11c3QgaGF2ZSBiZWVuIGNhdWdodCBieSB1c2Vyc3BhY2UuXG4gICAgaWYgKG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWKSB7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2gocmVqZWN0ZWRSZWFzb24pIHtcbiAgLy8gVGhpcyBjaGVjayBydW5zIGluIHByb2QsIHRvbywgYmVjYXVzZSBpdCBwcmV2ZW50cyBhIG1vcmUgY29uZnVzaW5nXG4gIC8vIGRvd25zdHJlYW0gZXJyb3IsIHdoZXJlIFN1c3BlbnNlRXhjZXB0aW9uIGlzIGNhdWdodCBieSBhIHByb21pc2UgYW5kXG4gIC8vIHRocm93biBhc3luY2hyb25vdXNseS5cbiAgLy8gVE9ETzogQW5vdGhlciB3YXkgdG8gcHJldmVudCBTdXNwZW5zZUV4Y2VwdGlvbiBmcm9tIGxlYWtpbmcgaW50byBhbiBhc3luY1xuICAvLyBleGVjdXRpb24gY29udGV4dCBpcyB0byBjaGVjayB0aGUgZGlzcGF0Y2hlciBldmVyeSB0aW1lIGB1c2VgIGlzIGNhbGxlZCxcbiAgLy8gb3Igc29tZSBlcXVpdmFsZW50LiBUaGF0IG1pZ2h0IGJlIHByZWZlcmFibGUgZm9yIG90aGVyIHJlYXNvbnMsIHRvbywgc2luY2VcbiAgLy8gaXQgbWF0Y2hlcyBob3cgd2UgcHJldmVudCBzaW1pbGFyIG1pc3Rha2VzIGZvciBvdGhlciBob29rcy5cbiAgaWYgKHJlamVjdGVkUmVhc29uID09PSBTdXNwZW5zZUV4Y2VwdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignSG9va3MgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGFuIGFzeW5jIGNvbXBvbmVudC4gVGhpcyAnICsgXCJlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5IGFkZGluZyBgJ3VzZSBjbGllbnQnYCBcIiArICd0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gZm9yIHRoZSBzZXJ2ZXIuJyk7XG4gIH1cbn1cblxudmFyIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG52YXIgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG5cbmZ1bmN0aW9uIG1lcmdlRGVidWdJbmZvKG91dGVyLCBpbm5lcikge1xuXG4gIGlmIChpbm5lciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG91dGVyO1xuICB9IGVsc2UgaWYgKG91dGVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGlubmVyO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlIGhhdmUgdHdvIGRlYnVnSW5mbywgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lLiBUaGlzIG1ha2VzIHRoZSBhcnJheSBubyBsb25nZXJcbiAgICAvLyBsaXZlIHNvIHdlJ2xsIG1pc3MgYW55IGZ1dHVyZSB1cGRhdGVzIGlmIHdlIHJlY2VpdmVkIG1vcmUgc28gaWRlYWxseSB3ZSBzaG91bGQgYWx3YXlzXG4gICAgLy8gZG8gdGhpcyBhZnRlciBib3RoIGhhdmUgZnVsbHkgcmVzb2x2ZWQvdW5zdXNwZW5kZWQuXG4gICAgcmV0dXJuIG91dGVyLmNvbmNhdChpbm5lcik7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dE1hcHM7XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycztcbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmc7XG52YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nO1xudmFyIG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmc7XG5cbnZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuICBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCAoY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjaGlsZC5rZXkgIT0gbnVsbCkgJiYgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCAhPT0gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGQuX3N0b3JlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSB1bmFibGUgdG8gbmFycm93IHR5cGUgZnJvbSBtaXhlZCB0byB3cml0YWJsZSBvYmplY3RcblxuXG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IDE7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKTtcbiAgICB2YXIgY29tcG9uZW50S2V5ID0gY29tcG9uZW50TmFtZSB8fCAnbnVsbCc7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudEtleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50S2V5XSA9IHRydWU7XG4gICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZC5fb3duZXI7XG4gICAgdmFyIHBhcmVudE93bmVyID0gcmV0dXJuRmliZXIuX2RlYnVnT3duZXI7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnJztcblxuICAgIGlmIChwYXJlbnRPd25lciAmJiB0eXBlb2YgcGFyZW50T3duZXIudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHBhcmVudE93bmVyKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY3VycmVudENvbXBvbmVudEVycm9ySW5mbykge1xuICAgICAgaWYgKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH0gLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG5cbiAgICB2YXIgY2hpbGRPd25lckFwcGVuZGl4ID0gJyc7XG5cbiAgICBpZiAoY2hpbGRPd25lciAhPSBudWxsICYmIHBhcmVudE93bmVyICE9PSBjaGlsZE93bmVyKSB7XG4gICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZE93bmVyLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgb3duZXJOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjaGlsZE93bmVyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkT3duZXIubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3duZXJOYW1lID0gY2hpbGRPd25lci5uYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgICBjaGlsZE93bmVyQXBwZW5kaXggPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIG93bmVyTmFtZSArIFwiLlwiO1xuICAgICAgfVxuICAgIH0gLy8gV2UgY3JlYXRlIGEgZmFrZSBGaWJlciBmb3IgdGhlIGNoaWxkIHRvIGxvZyB0aGUgc3RhY2sgdHJhY2UgZnJvbS5cbiAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGUgd2FybkZvck1pc3NpbmdLZXkgY2FsbHMgdG8gaGFwcGVuIGFmdGVyIGZpYmVyIGNyZWF0aW9uXG4gICAgLy8gc28gdGhhdCB3ZSBjYW4gZ2V0IGFjY2VzcyB0byB0aGUgZmliZXIgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgY3JlYXRlZC5cbiAgICAvLyBUaGF0IHdheSB0aGUgbG9nIGNhbiBzaG93IHVwIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmlnaHQgaW5zdGFuY2UgaW4gRGV2VG9vbHMuXG5cblxuICAgIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoY2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIDApO1xuICAgIGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lckFwcGVuZGl4KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4vLyBXZSBkbyB0aGlzIGhlcmUgaW5zdGVhZCBvZiBCZWdpbldvcmsgYmVjYXVzZSB0aGUgRnJhZ21lbnQgZmliZXIgZG9lc24ndCBoYXZlXG4vLyB0aGUgd2hvbGUgcHJvcHMgb2JqZWN0LCBvbmx5IHRoZSBjaGlsZHJlbiBhbmQgaXMgc2hhcmVkIHdpdGggYXJyYXlzLlxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBmaWJlciwgcmV0dXJuRmliZXIpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gRm9yIHVua2V5ZWQgcm9vdCBmcmFnbWVudHMgdGhlcmUncyBubyBGaWJlci4gV2UgY3JlYXRlIGEgZmFrZSBvbmUganVzdCBmb3JcbiAgICAgICAgICAvLyBlcnJvciBzdGFjayBoYW5kbGluZy5cbiAgICAgICAgICBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgMCk7XG4gICAgICAgICAgZmliZXIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgZnVuY3Rpb24gKGVycm9yZWRLZXkpIHtcbiAgICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGVycm9yZWRLZXkpO1xuICAgICAgICB9LCBrZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXIkMTtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIkMSArPSAxO1xuXG4gIGlmICh0aGVuYWJsZVN0YXRlJDEgPT09IG51bGwpIHtcbiAgICB0aGVuYWJsZVN0YXRlJDEgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCk7XG4gIH1cblxuICByZXR1cm4gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSQxLCB0aGVuYWJsZSwgaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50KSB7XG4gIHZhciByZWY7XG5cbiAge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgYSB0ZW1wb3JhcnksIGludGVybWVkaWF0ZSBzdGVwLiBXaGVuIGVuYWJsZVJlZkFzUHJvcCBpcyBvbixcbiAgICAvLyB3ZSBzaG91bGQgcmVzb2x2ZSB0aGUgYHJlZmAgcHJvcCBkdXJpbmcgdGhlIGJlZ2luIHBoYXNlIG9mIHRoZSBjb21wb25lbnRcbiAgICAvLyBpdCdzIGF0dGFjaGVkIHRvIChIb3N0Q29tcG9uZW50LCBDbGFzc0NvbXBvbmVudCwgZXRjKS5cbiAgICB2YXIgcmVmUHJvcCA9IGVsZW1lbnQucHJvcHMucmVmO1xuICAgIHJlZiA9IHJlZlByb3AgIT09IHVuZGVmaW5lZCA/IHJlZlByb3AgOiBudWxsO1xuICB9IC8vIFRPRE86IElmIGVuYWJsZVJlZkFzUHJvcCBpcyBvbiwgd2Ugc2hvdWxkbid0IHVzZSB0aGUgYHJlZmAgZmllbGQuIFdlXG4gIC8vIHNob3VsZCBhbHdheXMgcmVhZCB0aGUgcmVmIGZyb20gdGhlIHByb3AuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSByZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIFJlYWN0IEVsZW1lbnQgZnJvbSBhbiBvbGRlciB2ZXJzaW9uIG9mIFJlYWN0IHdhcyByZW5kZXJlZC4gJyArICdUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEl0IGNhbiBoYXBwZW4gaWY6XFxuJyArICctIE11bHRpcGxlIGNvcGllcyBvZiB0aGUgXCJyZWFjdFwiIHBhY2thZ2UgaXMgdXNlZC5cXG4nICsgJy0gQSBsaWJyYXJ5IHByZS1idW5kbGVkIGFuIG9sZCBjb3B5IG9mIFwicmVhY3RcIiBvciBcInJlYWN0L2pzeC1ydW50aW1lXCIuXFxuJyArICctIEEgY29tcGlsZXIgdHJpZXMgdG8gXCJpbmxpbmVcIiBKU1ggaW5zdGVhZCBvZiB1c2luZyB0aGUgcnVudGltZS4nKTtcbiAgfSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG5cblxuICB2YXIgY2hpbGRTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZFN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSB0cnVlO1xuICAgIHZhciBuYW1lID0gaW52YWxpZENoaWxkLmRpc3BsYXlOYW1lIHx8IGludmFsaWRDaGlsZC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKHJldHVybkZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlxcbicgKyAnICByb290LnJlbmRlciglcyknLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXFxuJyArICcgIDwlcz57JXN9PC8lcz4nLCBuYW1lLCBuYW1lLCBwYXJlbnROYW1lLCBuYW1lLCBwYXJlbnROYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKSB7XG4gIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nW3BhcmVudE5hbWVdID0gdHJ1ZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cbiAgICB2YXIgbmFtZSA9IFN0cmluZyhpbnZhbGlkQ2hpbGQpO1xuXG4gICAgaWYgKHJldHVybkZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGVycm9yKCdTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4nICsgJyAgcm9vdC5yZW5kZXIoJXMpJywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4nICsgJyAgPCVzPiVzPC8lcz4nLCBwYXJlbnROYW1lLCBuYW1lLCBwYXJlbnROYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUxhenkobGF6eVR5cGUpIHtcbiAge1xuICAgIHJldHVybiBjYWxsTGF6eUluaXRJbkRFVihsYXp5VHlwZSk7XG4gIH1cbn0gLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cblxuXG5mdW5jdGlvbiBjcmVhdGVDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2NoaWxkVG9EZWxldGVdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuXG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHRvIGEgdGVtcG9yYXJ5IG1hcCBzbyB0aGF0IHdlIGNhbiBmaW5kIHRoZW0gYnlcbiAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4gICAgLy8gaW5zdGVhZC5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGV4aXN0aW5nQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChleGlzdGluZ0NoaWxkLmtleSAhPT0gbnVsbCkge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH1cblxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuICAgIC8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG4gICAgdmFyIGNsb25lID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcyk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuXG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBEdXJpbmcgaHlkcmF0aW9uLCB0aGUgdXNlSWQgYWxnb3JpdGhtIG5lZWRzIHRvIGtub3cgd2hpY2ggZmliZXJzIGFyZVxuICAgICAgLy8gcGFydCBvZiBhIGxpc3Qgb2YgY2hpbGRyZW4gKGFycmF5cywgaXRlcmF0b3JzKS5cbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IEZvcmtlZDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudC5pbmRleDtcblxuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5mbGFncyB8PSBQbGFjZW1lbnQgfCBQbGFjZW1lbnRERVY7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5mbGFncyB8PSBQbGFjZW1lbnQgfCBQbGFjZW1lbnRERVY7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5mbGFncyB8PSBQbGFjZW1lbnQgfCBQbGFjZW1lbnRERVY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBjcmVhdGVkLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgdXBkYXRlZCA9IHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LnByb3BzLmNoaWxkcmVuLCBsYW5lcywgZWxlbWVudC5rZXksIGRlYnVnSW5mbyk7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgdXBkYXRlZCwgcmV0dXJuRmliZXIpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsIGVsZW1lbnQpICkgfHwgLy8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4gICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG4gICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2VcbiAgICAgIC8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbiAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGN1cnJlbnQudHlwZSkge1xuICAgICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGVsZW1lbnQucHJvcHMpO1xuICAgICAgICBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGV4aXN0aW5nLCBlbGVtZW50KTtcbiAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAge1xuICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cbiAgICB9IC8vIEluc2VydFxuXG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgY3JlYXRlZCwgZWxlbWVudCk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgIHtcbiAgICAgIGNyZWF0ZWQuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgbGFuZXMsIGtleSwgZGVidWdJbmZvKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBjcmVhdGVkLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdiaWdpbnQnKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBGbG93IGRvZXNuJ3Qgd2FudCB1cyB0byB1c2UgYCtgIG9wZXJhdG9yIHdpdGggc3RyaW5nIGFuZCBiaWdpbnRcbiAgICAgICcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgX2NyZWF0ZWQsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9jcmVhdGVkLl9kZWJ1Z0luZm8gPSBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBfY3JlYXRlZDIucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZENoaWxkO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlc29sdmVkQ2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihuZXdDaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgcmVzb2x2ZWRDaGlsZCwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykgLy8gY2FsbCBtZXJnZSBhZnRlciBpbml0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpIHx8IGVuYWJsZUFzeW5jSXRlcmFibGVDaGlsZHJlbiApIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkMyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywgbnVsbCk7XG5cbiAgICAgICAgX2NyZWF0ZWQzLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBfY3JlYXRlZDMuX2RlYnVnSW5mbyA9IG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgfSAvLyBVc2FibGUgbm9kZSB0eXBlc1xuICAgICAgLy9cbiAgICAgIC8vIFVud3JhcCB0aGUgaW5uZXIgdmFsdWUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cblxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgdW53cmFwVGhlbmFibGUodGhlbmFibGUpLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgY29udGV4dCwgbGFuZXMpLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBmaWJlciBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdiaWdpbnQnKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gRmxvdyBkb2Vzbid0IHdhbnQgdXMgdG8gdXNlIGArYCBvcGVyYXRvciB3aXRoIHN0cmluZyBhbmQgYmlnaW50XG4gICAgICAnJyArIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkQ2hpbGQ7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCByZXNvbHZlZENoaWxkLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkgfHwgZW5hYmxlQXN5bmNJdGVyYWJsZUNoaWxkcmVuICkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgfSAvLyBVc2FibGUgbm9kZSB0eXBlc1xuICAgICAgLy9cbiAgICAgIC8vIFVud3JhcCB0aGUgaW5uZXIgdmFsdWUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cblxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgdW53cmFwVGhlbmFibGUodGhlbmFibGUpLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBjb250ZXh0LCBsYW5lcyksIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3ltYm9sJykge1xuICAgICAgICB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnYmlnaW50Jykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBGbG93IGRvZXNuJ3Qgd2FudCB1cyB0byB1c2UgYCtgIG9wZXJhdG9yIHdpdGggc3RyaW5nIGFuZCBiaWdpbnRcbiAgICAgICcnICsgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIyLCBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZENoaWxkO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlc29sdmVkQ2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihuZXdDaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHJlc29sdmVkQ2hpbGQsIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSB8fCBlbmFibGVBc3luY0l0ZXJhYmxlQ2hpbGRyZW4gKSB7XG4gICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgfSAvLyBVc2FibGUgbm9kZSB0eXBlc1xuICAgICAgLy9cbiAgICAgIC8vIFVud3JhcCB0aGUgaW5uZXIgdmFsdWUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cblxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIGNvbnRleHQsIGxhbmVzKSwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG5cblxuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcgfHwgY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCwgcmV0dXJuRmliZXIpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvcignRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4nLCBrZXkpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkQ2hpbGQ7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2Fybk9uSW52YWxpZEtleShyZXNvbHZlZENoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aCBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcywgZGVidWdJbmZvKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIF9udW1iZXJPZkZvcmtzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfSAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cblxuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXIyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgdmFyIF9udW1iZXJPZkZvcmtzMiA9IG5ld0lkeDtcbiAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0YWJsZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuSXRlcmFibGUsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiAnICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICB7XG4gICAgICBpZiAobmV3Q2hpbGRyZW4gPT09IG5ld0NoaWxkcmVuSXRlcmFibGUpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBhcyBwcm9wcyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICAgICAgLy8gV2UgZG8gc3VwcG9ydCBnZW5lcmF0b3JzIGlmIHRoZXkgd2VyZSBjcmVhdGVkIGJ5IGEgR2VuZXJhdG9yRnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgIC8vIGFzIGl0cyBkaXJlY3QgY2hpbGQgc2luY2Ugd2UgY2FuIHJlY3JlYXRlIHRob3NlIGJ5IHJlcmVuZGVyaW5nIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gYXMgbmVlZGVkLlxuICAgICAgICB2YXIgaXNHZW5lcmF0b3JDb21wb25lbnQgPSByZXR1cm5GaWJlci50YWcgPT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJldHVybkZpYmVyLnR5cGUpID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nICYmIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkcmVuKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG5cbiAgICAgICAgaWYgKCFpc0dlbmVyYXRvckNvbXBvbmVudCkge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0R2VuZXJhdG9ycykge1xuICAgICAgICAgICAgZXJyb3IoJ1VzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiAnICsgJ0l0ZXJhYmxlIHRoYXQgY2FuIGl0ZXJhdGUgbXVsdGlwbGUgdGltZXMgb3ZlciB0aGUgc2FtZSBpdGVtcy4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICBpZiAobmV3Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgIHtcbiAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoc3RlcC52YWx1ZSwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgfVxuXG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpLCBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KHN0ZXAudmFsdWUsIGtub3duS2V5cywgcmV0dXJuRmliZXIpICkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBudW1iZXJPZkZvcmtzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG51bWJlck9mRm9ya3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSwga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShzdGVwLnZhbHVlLCBrbm93bktleXMsIHJldHVybkZpYmVyKSApIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIF9udW1iZXJPZkZvcmtzMyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3JrczMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpLCBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KHN0ZXAudmFsdWUsIGtub3duS2V5cywgcmV0dXJuRmliZXIpICkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGxhbmVzLCBkZWJ1Z0luZm8pO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczQgPSBuZXdJZHg7XG4gICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG5cblxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgZXhpc3RpbmcsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjaGlsZCwgZWxlbWVudCkgKSB8fCAvLyBMYXp5IHR5cGVzIHNob3VsZCByZWNvbmNpbGUgdGhlaXIgcmVzb2x2ZWQgdHlwZS5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG4gICAgICAgICAgLy8gYmVjYXVzZSBob3QgcmVsb2FkaW5nIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gcHJvZCBiZWNhdXNlXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCByZXN1c3BlbmQuIFNvIHdlIGNhbid0IGxldCB0aGUgY2FsbCBiZWxvdyBzdXNwZW5kLlxuICAgICAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGNoaWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcblxuICAgICAgICAgICAgdmFyIF9leGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnByb3BzKTtcblxuICAgICAgICAgICAgY29lcmNlUmVmKHJldHVybkZpYmVyLCBjaGlsZCwgX2V4aXN0aW5nLCBlbGVtZW50KTtcbiAgICAgICAgICAgIF9leGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgX2V4aXN0aW5nLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfZXhpc3Rpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIERpZG4ndCBtYXRjaC5cblxuXG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgY3JlYXRlZCwgcmV0dXJuRmliZXIpO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgX2NyZWF0ZWQ0LCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBfY3JlYXRlZDQuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfSAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSByZWN1cnNpdmUgZm9yIFVzYWJsZXMvTGF6eSBhbmQgbm90IG5lc3RlZCBhcnJheXMuXG4gICAgLy8gVGhhdCdzIHNvIHRoYXQgdXNpbmcgYSBMYXp5IHdyYXBwZXIgaXMgdW5vYnNlcnZhYmxlIHRvIHRoZSBGcmFnbWVudFxuICAgIC8vIGNvbnZlbnRpb24uXG4gICAgLy8gSWYgdGhlIHRvcCBsZXZlbCBpdGVtIGlzIGFuIGFycmF5LCB3ZSB0cmVhdCBpdCBhcyBhIHNldCBvZiBjaGlsZHJlbixcbiAgICAvLyBub3QgYXMgYSBmcmFnbWVudC4gTmVzdGVkIGFycmF5cyBvbiB0aGUgb3RoZXIgaGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBmcmFnbWVudCBub2Rlcy4gUmVjdXJzaW9uIGhhcHBlbnMgYXQgdGhlIG5vcm1hbCBmbG93LlxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICAvLyBXZSBkb24ndCB1c2UgcmVjdXJzaW9uIGhlcmUgYmVjYXVzZSBhIGZyYWdtZW50IGluc2lkZSBhIGZyYWdtZW50XG4gICAgLy8gaXMgbm8gbG9uZ2VyIGNvbnNpZGVyZWQgXCJ0b3AgbGV2ZWxcIiBmb3IgdGhlc2UgcHVycG9zZXMuXG4gICAgdmFyIGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuXG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhuZXdDaGlsZCwgbnVsbCwgcmV0dXJuRmliZXIpO1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9IC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcblxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IG5ld0NoaWxkLl9pbml0O1xuICAgICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBpbml0KHBheWxvYWQpLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSkge1xuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRhYmxlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH1cbiAgICAgIC8vIGEgY2hpbGQgcG9zaXRpb24sIGl0IHVud3JhcHMgaXQgdXNpbmcgdGhlIHNhbWUgYWxnb3JpdGhtIGFzIGB1c2VgLiBGb3JcbiAgICAgIC8vIGV4YW1wbGUsIGZvciBwcm9taXNlcywgUmVhY3Qgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gdG8gdW53aW5kIHRoZVxuICAgICAgLy8gc3RhY2ssIHRoZW4gcmVwbGF5IHRoZSBjb21wb25lbnQgb25jZSB0aGUgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAgIC8vXG4gICAgICAvLyBBIGRpZmZlcmVuY2UgZnJvbSBgdXNlYCBpcyB0aGF0IFJlYWN0IHdpbGwga2VlcCB1bndyYXBwaW5nIHRoZSB2YWx1ZVxuICAgICAgLy8gdW50aWwgaXQgcmVhY2hlcyBhIG5vbi1Vc2FibGUgdHlwZS5cbiAgICAgIC8vXG4gICAgICAvLyBlLmcuIFVzYWJsZTxVc2FibGU8VXNhYmxlPFQ+Pj4gc2hvdWxkIHJlc29sdmUgdG8gVFxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBzdHJ1Y3R1cmUgaXMgYSBiaXQgdW5mb3J0dW5hdGUuIElkZWFsbHksIHdlIHNob3VsZG4ndCBuZWVkIHRvXG4gICAgICAvLyByZXBsYXkgdGhlIGVudGlyZSBiZWdpbiBwaGFzZSBvZiB0aGUgcGFyZW50IGZpYmVyIGluIG9yZGVyIHRvIHJlY29uY2lsZVxuICAgICAgLy8gdGhlIGNoaWxkcmVuIGFnYWluLiBUaGlzIHdvdWxkIHJlcXVpcmUgYSBzb21ld2hhdCBzaWduaWZpY2FudCByZWZhY3RvcixcbiAgICAgIC8vIGJlY2F1c2UgcmVjb25jaWxhdGlvbiBoYXBwZW5zIGRlZXAgd2l0aGluIHRoZSBiZWdpbiBwaGFzZSwgYW5kXG4gICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2Ygd29yaywgbm90IGFsd2F5cyBhdCB0aGUgZW5kLiBXZSBzaG91bGRcbiAgICAgIC8vIGNvbnNpZGVyIGFzIGFuIGZ1dHVyZSBpbXByb3ZlbWVudC5cblxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSksIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIHRoZW5hYmxlLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIGNvbnRleHQsIGxhbmVzKSwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnICYmIG5ld0NoaWxkICE9PSAnJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIEZsb3cgZG9lc24ndCB3YW50IHVzIHRvIHVzZSBgK2Agb3BlcmF0b3Igd2l0aCBzdHJpbmcgYW5kIGJpZ2ludFxuICAgICAgJycgKyBuZXdDaGlsZCwgbGFuZXMpKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3ltYm9sJykge1xuICAgICAgICB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG4gICAgfSAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuXG5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBpbmRpcmVjdGlvbiBvbmx5IGV4aXN0cyBzbyB3ZSBjYW4gcmVzZXQgYHRoZW5hYmxlU3RhdGVgIGF0IHRoZSBlbmQuXG4gICAgLy8gSXQgc2hvdWxkIGdldCBpbmxpbmVkIGJ5IENsb3N1cmUuXG4gICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgdmFyIGZpcnN0Q2hpbGRGaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCAvLyBkZWJ1Z0luZm9cbiAgICApO1xuICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7IC8vIERvbid0IGJvdGhlciB0byByZXNldCBgdGhlbmFibGVJbmRleENvdW50ZXJgIHRvIDAgYmVjYXVzZSBpdCBhbHdheXMgZ2V0c1xuICAgIC8vIHNldCBhdCB0aGUgYmVnaW5uaW5nLlxuXG4gICAgcmV0dXJuIGZpcnN0Q2hpbGRGaWJlcjtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuZnVuY3Rpb24gcmVzZXRDaGlsZFJlY29uY2lsZXJPblVud2luZCgpIHtcbiAgLy8gT24gdW53aW5kLCBjbGVhciBhbnkgcGVuZGluZyB0aGVuYWJsZXMgdGhhdCB3ZXJlIHVzZWQuXG4gIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xufVxuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcblxuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO1xuICAgIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG5cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59IC8vIFJlc2V0IGEgd29ya0luUHJvZ3Jlc3MgY2hpbGQgc2V0IHRvIHByZXBhcmUgaXQgZm9yIGEgc2Vjb25kIHBhc3MuXG5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MoY2hpbGQsIGxhbmVzKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxuLy8gVE9ETzogVGhpcyBpc24ndCBiZWluZyB1c2VkIHlldCwgYnV0IGl0J3MgaW50ZW5kZWQgdG8gcmVwbGFjZSB0aGVcbi8vIEludmlzaWJsZVBhcmVudENvbnRleHQgdGhhdCBpcyBjdXJyZW50bHkgbWFuYWdlZCBieSBTdXNwZW5zZUNvbnRleHQuXG5cbnZhciBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xudmFyIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTtcbmZ1bmN0aW9uIHB1c2hIaWRkZW5Db250ZXh0KGZpYmVyLCBjb250ZXh0KSB7XG4gIHZhciBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMgPSBnZXRFbnRhbmdsZWRSZW5kZXJMYW5lcygpO1xuICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzLCBmaWJlcik7XG4gIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpOyAvLyBXaGVuIHJlbmRlcmluZyBhIHN1YnRyZWUgdGhhdCdzIGN1cnJlbnRseSBoaWRkZW4sIHdlIG11c3QgaW5jbHVkZSBhbGxcbiAgLy8gbGFuZXMgdGhhdCB3b3VsZCBoYXZlIHJlbmRlcmVkIGlmIHRoZSBoaWRkZW4gc3VidHJlZSBoYWRuJ3QgYmVlbiBkZWZlcnJlZC5cbiAgLy8gVGhhdCBpcywgaW4gb3JkZXIgdG8gcmV2ZWFsIGNvbnRlbnQgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZSwgd2UgbXVzdCBjb21taXRcbiAgLy8gYWxsIHRoZSB1cGRhdGVzIHRoYXQgd2Ugc2tpcHBlZCB3aGVuIHdlIG9yaWdpbmFsbHkgaGlkIHRoZSB0cmVlLlxuXG4gIHNldEVudGFuZ2xlZFJlbmRlckxhbmVzKG1lcmdlTGFuZXMocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzLCBjb250ZXh0LmJhc2VMYW5lcykpO1xufVxuZnVuY3Rpb24gcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayhmaWJlcikge1xuICAvLyBUaGlzIHN1YnRyZWUgaXMgbm90IGN1cnJlbnRseSBoaWRkZW4sIHNvIHdlIGRvbid0IG5lZWQgdG8gYWRkIGFueSBsYW5lc1xuICAvLyB0byB0aGUgcmVuZGVyIGxhbmVzLiBCdXQgd2Ugc3RpbGwgbmVlZCB0byBwdXNoIHNvbWV0aGluZyB0byBhdm9pZCBhXG4gIC8vIGNvbnRleHQgbWlzbWF0Y2guIFJldXNlIHRoZSBleGlzdGluZyBjb250ZXh0IG9uIHRoZSBzdGFjay5cbiAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIGdldEVudGFuZ2xlZFJlbmRlckxhbmVzKCksIGZpYmVyKTtcbiAgcHVzaChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnQsIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcEhpZGRlbkNvbnRleHQoZmliZXIpIHtcbiAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgcmVuZGVyIGxhbmVzIGZyb20gdGhlIHN0YWNrXG4gIHNldEVudGFuZ2xlZFJlbmRlckxhbmVzKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvci5jdXJyZW50KTtcbiAgcG9wKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xufVxuZnVuY3Rpb24gaXNDdXJyZW50VHJlZUhpZGRlbigpIHtcbiAgcmV0dXJuIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gbnVsbDtcbn1cblxuLy8gc3VzcGVuZHMsIGkuZS4gaXQncyB0aGUgbmVhcmVzdCBgY2F0Y2hgIGJsb2NrIG9uIHRoZSBzdGFjay5cblxudmFyIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpOyAvLyBSZXByZXNlbnRzIHRoZSBvdXRlcm1vc3QgYm91bmRhcnkgdGhhdCBpcyBub3QgdmlzaWJsZSBpbiB0aGUgY3VycmVudCB0cmVlLlxuLy8gRXZlcnl0aGluZyBhYm92ZSB0aGlzIGlzIHRoZSBcInNoZWxsXCIuIFdoZW4gdGhpcyBpcyBudWxsLCBpdCBtZWFucyB3ZSdyZVxuLy8gcmVuZGVyaW5nIGluIHRoZSBzaGVsbCBvZiB0aGUgYXBwLiBJZiBpdCdzIG5vbi1udWxsLCBpdCBtZWFucyB3ZSdyZSByZW5kZXJpbmdcbi8vIGRlZXBlciB0aGFuIHRoZSBzaGVsbCwgaW5zaWRlIGEgbmV3IHRyZWUgdGhhdCB3YXNuJ3QgYWxyZWFkeSB2aXNpYmxlLlxuLy9cbi8vIFRoZSBtYWluIHdheSB3ZSB1c2UgdGhpcyBjb25jZXB0IGlzIHRvIGRldGVybWluZSB3aGV0aGVyIHNob3dpbmcgYSBmYWxsYmFja1xuLy8gd291bGQgcmVzdWx0IGluIGEgZGVzaXJhYmxlIG9yIHVuZGVzaXJhYmxlIGxvYWRpbmcgc3RhdGUuIEFjdGl2aW5nIGEgZmFsbGJhY2tcbi8vIGluIHRoZSBzaGVsbCBpcyBjb25zaWRlcmVkIGFuIHVuZGVyc2lyYWJsZSBsb2FkaW5nIHN0YXRlLCBiZWNhdXNlIGl0IHdvdWxkXG4vLyBtZWFuIGhpZGluZyB2aXNpYmxlIChhbGJlaXQgc3RhbGUpIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgdHJlZSDigJQgd2UgcHJlZmVyIHRvXG4vLyBzaG93IHRoZSBzdGFsZSBjb250ZW50LCByYXRoZXIgdGhhbiBzd2l0Y2ggdG8gYSBmYWxsYmFjay4gQnV0IHNob3dpbmcgYVxuLy8gZmFsbGJhY2sgaW4gYSBuZXcgdHJlZSBpcyBmaW5lLCBiZWNhdXNlIHRoZXJlJ3Mgbm8gc3RhbGUgY29udGVudCB0b1xuLy8gcHJlZmVyIGluc3RlYWQuXG5cbnZhciBzaGVsbEJvdW5kYXJ5ID0gbnVsbDtcbmZ1bmN0aW9uIGdldFNoZWxsQm91bmRhcnkoKSB7XG4gIHJldHVybiBzaGVsbEJvdW5kYXJ5O1xufVxuZnVuY3Rpb24gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKGhhbmRsZXIpIHtcbiAgLy8gVE9ETzogUGFzcyBhcyBhcmd1bWVudFxuICB2YXIgY3VycmVudCA9IGhhbmRsZXIuYWx0ZXJuYXRlO1xuICAvLyBwcm9wYWdhdGVkIGEgc2luZ2xlIGxldmVsLiBGb3IgZXhhbXBsZSwgd2hlbiBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgaXMgc2V0LFxuICAvLyBpdCBzaG91bGQgb25seSBmb3JjZSB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeSBpbnRvIGZhbGxiYWNrIG1vZGUuXG5cbiAgcHVzaFN1c3BlbnNlTGlzdENvbnRleHQoaGFuZGxlciwgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpOyAvLyBFeHBlcmltZW50YWwgZmVhdHVyZTogU29tZSBTdXNwZW5zZSBib3VuZGFyaWVzIGFyZSBtYXJrZWQgYXMgaGF2aW5nIGFuXG4gIC8vIHRvIHB1c2ggYSBuZXN0ZWQgU3VzcGVuc2UgaGFuZGxlciwgYmVjYXVzZSBpdCB3aWxsIGdldCByZXBsYWNlZCBieSB0aGVcbiAgLy8gb3V0ZXIgZmFsbGJhY2ssIGFueXdheS4gQ29uc2lkZXIgdGhpcyBhcyBhIGZ1dHVyZSBvcHRpbWl6YXRpb24uXG5cblxuICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBoYW5kbGVyLCBoYW5kbGVyKTtcblxuICBpZiAoc2hlbGxCb3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGlzQ3VycmVudFRyZWVIaWRkZW4oKSkge1xuICAgICAgLy8gVGhpcyBib3VuZGFyeSBpcyBub3QgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBVSS5cbiAgICAgIHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgc2hvd2luZyBhIGZhbGxiYWNrIGluIHRoZSBjdXJyZW50IFVJLlxuICAgICAgICBzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgLy8gV2UncmUgYWJvdXQgdG8gcmVuZGVyIHRoZSBmYWxsYmFjay4gSWYgc29tZXRoaW5nIGluIHRoZSBmYWxsYmFjayBzdXNwZW5kcyxcbiAgLy8gaXQncyBha2luIHRvIHRocm93aW5nIGluc2lkZSBvZiBhIGBjYXRjaGAgYmxvY2suIFRoaXMgYm91bmRhcnkgc2hvdWxkIG5vdFxuICAvLyBjYXB0dXJlLiBSZXVzZSB0aGUgZXhpc3RpbmcgaGFuZGxlciBvbiB0aGUgc3RhY2suXG4gIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcik7XG59XG5mdW5jdGlvbiBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCkge1xuICAgIC8vIEEgU3VzcGVuc2VMaXN0IGNvbnRleHQgaXMgb25seSBwdXNoZWQgaGVyZSB0byBhdm9pZCBhIHB1c2gvcG9wIG1pc21hdGNoLlxuICAgIC8vIFJldXNlIHRoZSBjdXJyZW50IHZhbHVlIG9uIHRoZSBzdGFjay5cbiAgICAvLyBUT0RPOiBXZSBjYW4gYXZvaWQgbmVlZGluZyB0byBwdXNoIGhlcmUgYnkgYnkgZm9ya2luZyBwb3BTdXNwZW5zZUhhbmRsZXJcbiAgICAvLyBpbnRvIHNlcGFyYXRlIGZ1bmN0aW9ucyBmb3IgU3VzcGVuc2UgYW5kIE9mZnNjcmVlbi5cbiAgICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dChmaWJlciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuXG4gICAgaWYgKHNoZWxsQm91bmRhcnkgIT09IG51bGwpIDsgZWxzZSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgYm91bmRhcnkgaW4gdGhlIHN0YWNrIHRoYXQncyBhbHJlYWR5IHNob3dpbmdcbiAgICAgICAgICAvLyBhIGZhbGxiYWNrLiBTbyBldmVyeXRoaW5nIG91dHNpZGUgaXMgY29uc2lkZXJlZCB0aGUgc2hlbGwuXG4gICAgICAgICAgc2hlbGxCb3VuZGFyeSA9IGZpYmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBMZWdhY3lIaWRkZW4gY29tcG9uZW50LlxuICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcikge1xuICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dChmaWJlciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZ2V0U3VzcGVuc2VIYW5kbGVyKCksIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSGFuZGxlcigpIHtcbiAgcmV0dXJuIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5mdW5jdGlvbiBwb3BTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG5cbiAgaWYgKHNoZWxsQm91bmRhcnkgPT09IGZpYmVyKSB7XG4gICAgLy8gUG9wcGluZyBiYWNrIGludG8gdGhlIHNoZWxsLlxuICAgIHNoZWxsQm91bmRhcnkgPSBudWxsO1xuICB9XG5cbiAgcG9wU3VzcGVuc2VMaXN0Q29udGV4dChmaWJlcik7XG59IC8vIFN1c3BlbnNlTGlzdCBjb250ZXh0XG4vLyBUT0RPOiBNb3ZlIHRvIGEgc2VwYXJhdGUgbW9kdWxlPyBXZSBtYXkgY2hhbmdlIHRoZSBTdXNwZW5zZUxpc3Rcbi8vIGltcGxlbWVudGF0aW9uIHRvIGhpZGUvc2hvdyBpbiB0aGUgY29tbWl0IHBoYXNlLCBhbnl3YXkuXG5cbnZhciBEZWZhdWx0U3VzcGVuc2VDb250ZXh0ID0gMDtcbnZhciBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayA9IDE7IC8vIEZvcmNlU3VzcGVuc2VGYWxsYmFjayBjYW4gYmUgdXNlZCBieSBTdXNwZW5zZUxpc3QgdG8gZm9yY2UgbmV3bHkgYWRkZWRcbi8vIGl0ZW1zIGludG8gdGhlaXIgZmFsbGJhY2sgc3RhdGUgZHVyaW5nIG9uZSBvZiB0aGUgcmVuZGVyIHBhc3Nlcy5cblxudmFyIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDI7XG52YXIgc3VzcGVuc2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihEZWZhdWx0U3VzcGVuc2VDb250ZXh0KTtcbmZ1bmN0aW9uIGhhc1N1c3BlbnNlTGlzdENvbnRleHQocGFyZW50Q29udGV4dCwgZmxhZykge1xuICByZXR1cm4gKHBhcmVudENvbnRleHQgJiBmbGFnKSAhPT0gMDtcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChwYXJlbnRDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG59XG5mdW5jdGlvbiBzZXRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChwYXJlbnRDb250ZXh0LCBzaGFsbG93Q29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIHwgc2hhbGxvd0NvbnRleHQ7XG59XG5mdW5jdGlvbiBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dChmaWJlciwgbmV3Q29udGV4dCkge1xuICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5ld0NvbnRleHQsIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcFN1c3BlbnNlTGlzdENvbnRleHQoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuLy8gQSBub24tbnVsbCBTdXNwZW5zZVN0YXRlIG1lYW5zIHRoYXQgaXQgaXMgYmxvY2tlZCBmb3Igb25lIHJlYXNvbiBvciBhbm90aGVyLlxuLy8gLSBBIG5vbi1udWxsIGRlaHlkcmF0ZWQgZmllbGQgbWVhbnMgaXQncyBibG9ja2VkIHBlbmRpbmcgaHlkcmF0aW9uLlxuLy8gICAtIEEgbm9uLW51bGwgZGVoeWRyYXRlZCBmaWVsZCBjYW4gdXNlIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcgb3Jcbi8vICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayB0byBxdWVyeSB0aGUgcmVhc29uIGZvciBiZWluZyBkZWh5ZHJhdGVkLlxuLy8gLSBBIG51bGwgZGVoeWRyYXRlZCBmaWVsZCBtZWFucyBpdCdzIGJsb2NrZWQgYnkgc29tZXRoaW5nIHN1c3BlbmRpbmcgYW5kXG4vLyAgIHdlJ3JlIGN1cnJlbnRseSBzaG93aW5nIGEgZmFsbGJhY2sgaW5zdGVhZC5cblxuZnVuY3Rpb24gZmluZEZpcnN0U3VzcGVuZGVkKHJvdykge1xuICB2YXIgbm9kZSA9IHJvdztcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZWh5ZHJhdGVkID0gc3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoZGVoeWRyYXRlZCA9PT0gbnVsbCB8fCBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKGRlaHlkcmF0ZWQpIHx8IGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGRlaHlkcmF0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUxpc3RDb21wb25lbnQgJiYgLy8gcmV2ZWFsT3JkZXIgdW5kZWZpbmVkIGNhbid0IGJlIHRydXN0ZWQgYmVjYXVzZSBpdCBkb24ndFxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBpdCBzdXNwZW5kZWQgb3Igbm90LlxuICAgIG5vZGUubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZGlkU3VzcGVuZCA9IChub2RlLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MgPVxuLyogICAqL1xuMDsgLy8gUmVwcmVzZW50cyB3aGV0aGVyIGVmZmVjdCBzaG91bGQgZmlyZS5cblxudmFyIEhhc0VmZmVjdCA9XG4vKiAqL1xuMTsgLy8gUmVwcmVzZW50cyB0aGUgcGhhc2UgaW4gd2hpY2ggdGhlIGVmZmVjdCAobm90IHRoZSBjbGVhbi11cCkgZmlyZXMuXG5cbnZhciBJbnNlcnRpb24gPVxuLyogKi9cbjI7XG52YXIgTGF5b3V0ID1cbi8qICAgICovXG40O1xudmFyIFBhc3NpdmUgPVxuLyogICAqL1xuODtcblxudmFyIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdDtcbnZhciBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaDtcbnZhciBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGU7XG5cbntcbiAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSA9IG5ldyBTZXQoKTtcbn0gLy8gVGhlIGVmZmVjdCBcImluc3RhbmNlXCIgaXMgYSBzaGFyZWQgb2JqZWN0IHRoYXQgcmVtYWlucyB0aGUgc2FtZSBmb3IgdGhlIGVudGlyZVxuLy8gbGlmZXRpbWUgb2YgYW4gZWZmZWN0LiBJbiBSdXN0IHRlcm1zLCBhIFJlZkNlbGwuIFdlIHVzZSBpdCB0byBzdG9yZSB0aGVcbi8vIFwiZGVzdHJveVwiIGZ1bmN0aW9uIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBhbiBlZmZlY3QsIGJlY2F1c2UgdGhhdCBpcyBzdGF0ZWZ1bC5cbi8vIFRoZSBmaWVsZCBpcyBgdW5kZWZpbmVkYCBpZiB0aGUgZWZmZWN0IGlzIHVubW91bnRlZCwgb3IgaWYgdGhlIGVmZmVjdCByYW5cbi8vIGJ1dCBpcyBub3Qgc3RhdGVmdWwuIFdlIGRvbid0IGV4cGxpY2l0bHkgdHJhY2sgd2hldGhlciB0aGUgZWZmZWN0IGlzIG1vdW50ZWRcbi8vIG9yIHVubW91bnRlZCBiZWNhdXNlIHRoYXQgY2FuIGJlIGluZmVycmVkIGJ5IHRoZSBoaWRkZW5uZXNzIG9mIHRoZSBmaWJlciBpblxuLy8gdGhlIHRyZWUsIGkuZS4gd2hldGhlciB0aGVyZSBpcyBhIGhpZGRlbiBPZmZzY3JlZW4gZmliZXIgYWJvdmUgaXQuXG4vL1xuLy8gSXQncyB1bmZvcnR1bmF0ZSB0aGF0IHRoaXMgaXMgc3RvcmVkIG9uIGEgc2VwYXJhdGUgb2JqZWN0LCBiZWNhdXNlIGl0IGFkZHNcbi8vIG1vcmUgbWVtb3J5IHBlciBlZmZlY3QgaW5zdGFuY2UsIGJ1dCBpdCdzIGNvbmNlcHR1YWxseSBzb3VuZC4gSSB0aGluayB0aGVyZSdzXG4vLyBsaWtlbHkgYSBiZXR0ZXIgZGF0YSBzdHJ1Y3R1cmUgd2UgY291bGQgdXNlIGZvciBlZmZlY3RzOyBwZXJoYXBzIGp1c3Qgb25lXG4vLyBhcnJheSBvZiBlZmZlY3QgaW5zdGFuY2VzIHBlciBmaWJlci4gQnV0IEkgdGhpbmsgdGhpcyBpcyBPSyBmb3Igbm93IGRlc3BpdGVcbi8vIHRoZSBhZGRpdGlvbmFsIG1lbW9yeSBhbmQgd2UgY2FuIGZvbGxvdyB1cCB3aXRoIHBlcmZvcm1hbmNlXG4vLyBvcHRpbWl6YXRpb25zIGxhdGVyLlxuLy8gVGhlc2UgYXJlIHNldCByaWdodCBiZWZvcmUgY2FsbGluZyB0aGUgY29tcG9uZW50LlxuXG5cbnZhciByZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblxudmFyIGN1cnJlbnRIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG52YXIgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSBmYWxzZTsgLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlSWQgaG9va3MgaW4gdGhpcyBjb21wb25lbnQuXG5cbnZhciBsb2NhbElkQ291bnRlciA9IDA7IC8vIENvdW50cyBudW1iZXIgb2YgYHVzZWAtZCB0aGVuYWJsZXNcblxudmFyIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbnZhciB0aGVuYWJsZVN0YXRlID0gbnVsbDsgLy8gVXNlZCBmb3IgaWRzIHRoYXQgYXJlIGdlbmVyYXRlZCBjb21wbGV0ZWx5IGNsaWVudC1zaWRlIChpLmUuIG5vdCBkdXJpbmdcbi8vIGh5ZHJhdGlvbikuIFRoaXMgY291bnRlciBpcyBnbG9iYWwsIHNvIGNsaWVudCBpZHMgYXJlIG5vdCBzdGFibGUgYWNyb3NzXG4vLyByZW5kZXIgYXR0ZW1wdHMuXG5cbnZhciBnbG9iYWxDbGllbnRJZENvdW50ZXIgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1OyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDsgLy8gSW4gREVWLCB0aGlzIGxpc3QgZW5zdXJlcyB0aGF0IGhvb2tzIGFyZSBjYWxsZWQgaW4gdGhlIHNhbWUgb3JkZXIgYmV0d2VlbiByZW5kZXJzLlxuLy8gVGhlIGxpc3Qgc3RvcmVzIHRoZSBvcmRlciBvZiBob29rcyB1c2VkIGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXIgKG1vdW50KS5cbi8vIFN1YnNlcXVlbnQgcmVuZGVycyAodXBkYXRlcykgcmVmZXJlbmNlIHRoaXMgbGlzdC5cblxudmFyIGhvb2tUeXBlc0RldiA9IG51bGw7XG52YXIgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gSW4gREVWLCB0aGlzIHRyYWNrcyB3aGV0aGVyIGN1cnJlbnRseSByZW5kZXJpbmcgY29tcG9uZW50IG5lZWRzIHRvIGlnbm9yZVxuLy8gdGhlIGRlcGVuZGVuY2llcyBmb3IgSG9va3MgdGhhdCBuZWVkIHRoZW0gKGUuZy4gdXNlRWZmZWN0IG9yIHVzZU1lbW8pLlxuLy8gV2hlbiB0cnVlLCBzdWNoIEhvb2tzIHdpbGwgYWx3YXlzIGJlIFwicmVtb3VudGVkXCIuIE9ubHkgdXNlZCBkdXJpbmcgaG90IHJlbG9hZC5cblxudmFyIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG1vdW50SG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ID09PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNEZXYgPSBbaG9va05hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rVHlwZXNEZXYucHVzaChob29rTmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvb2tUeXBlc0RldigpIHtcbiAge1xuICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG4gICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYrKztcblxuICAgICAgaWYgKGhvb2tUeXBlc0Rldltob29rVHlwZXNVcGRhdGVJbmRleERldl0gIT09IGhvb2tOYW1lKSB7XG4gICAgICAgIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGhvb2tOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcykge1xuICB7XG4gICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCAmJiBkZXBzICE9PSBudWxsICYmICFpc0FycmF5KGRlcHMpKSB7XG4gICAgICAvLyBWZXJpZnkgZGVwcywgYnV0IG9ubHkgb24gbW91bnQgdG8gYXZvaWQgZXh0cmEgY2hlY2tzLlxuICAgICAgLy8gSXQncyB1bmxpa2VseSB0aGVpciB0eXBlIHdvdWxkIGNoYW5nZSBhcyB1c3VhbGx5IHlvdSBkZWZpbmUgdGhlbSBpbmxpbmUuXG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCB0aGF0IGlzIG5vdCBhbiBhcnJheSAoaW5zdGVhZCwgcmVjZWl2ZWQgYCVzYCkuIFdoZW4gJyArICdzcGVjaWZpZWQsIHRoZSBmaW5hbCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LicsIGN1cnJlbnRIb29rTmFtZUluRGV2LCB0eXBlb2YgZGVwcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGN1cnJlbnRIb29rTmFtZSkge1xuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuXG4gICAgaWYgKCFkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0YWJsZSA9ICcnO1xuICAgICAgICB2YXIgc2Vjb25kQ29sdW1uU3RhcnQgPSAzMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBob29rVHlwZXNVcGRhdGVJbmRleERldjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9sZEhvb2tOYW1lID0gaG9va1R5cGVzRGV2W2ldO1xuICAgICAgICAgIHZhciBuZXdIb29rTmFtZSA9IGkgPT09IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID8gY3VycmVudEhvb2tOYW1lIDogb2xkSG9va05hbWU7XG4gICAgICAgICAgdmFyIHJvdyA9IGkgKyAxICsgXCIuIFwiICsgb2xkSG9va05hbWU7IC8vIEV4dHJhIHNwYWNlIHNvIHNlY29uZCBjb2x1bW4gbGluZXMgdXBcbiAgICAgICAgICAvLyBsb2wgQCBJRSBub3Qgc3VwcG9ydGluZyBTdHJpbmcjcmVwZWF0XG5cbiAgICAgICAgICB3aGlsZSAocm93Lmxlbmd0aCA8IHNlY29uZENvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgICByb3cgKz0gJyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdyArPSBuZXdIb29rTmFtZSArICdcXG4nO1xuICAgICAgICAgIHRhYmxlICs9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCdSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gJyArICdUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbicgKyAnICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4nICsgJyAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicgKyAnJXMnICsgJyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcbicsIGNvbXBvbmVudE5hbWUsIHRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG5cbiAgICBpZiAoIWRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGVycm9yKCdSZWFjdERPTS51c2VGb3JtU3RhdGUgaGFzIGJlZW4gcmVuYW1lZCB0byBSZWFjdC51c2VBY3Rpb25TdGF0ZS4gJyArICdQbGVhc2UgdXBkYXRlICVzIHRvIHVzZSBSZWFjdC51c2VBY3Rpb25TdGF0ZS4nLCBjb21wb25lbnROYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmQXN5bmNDbGllbnRDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHtcbiAgICAvLyBUaGlzIGRldi1vbmx5IGNoZWNrIG9ubHkgd29ya3MgZm9yIGRldGVjdGluZyBuYXRpdmUgYXN5bmMgZnVuY3Rpb25zLFxuICAgIC8vIG5vdCB0cmFuc3BpbGVkIG9uZXMuIFRoZXJlJ3MgYWxzbyBhIHByb2QgY2hlY2sgdGhhdCB3ZSB1c2UgdG8gcHJldmVudFxuICAgIC8vIGFzeW5jIGNsaWVudCBjb21wb25lbnRzIGZyb20gY3Jhc2hpbmcgdGhlIGFwcDsgdGhlIHByb2Qgb25lIHdvcmtzIGV2ZW5cbiAgICAvLyBmb3IgdHJhbnNwaWxlZCBhc3luYyBmdW5jdGlvbnMuIE5laXRoZXIgbWVjaGFuaXNtIGlzIGNvbXBsZXRlbHlcbiAgICAvLyBidWxsZXRwcm9vZiBidXQgdG9nZXRoZXIgdGhleSBjb3ZlciB0aGUgbW9zdCBjb21tb24gY2FzZXMuXG4gICAgdmFyIGlzQXN5bmNGdW5jdGlvbiA9IC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudCkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyB8fCAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChDb21wb25lbnQpID09PSAnW29iamVjdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbiAgICBpZiAoaXNBc3luY0Z1bmN0aW9uKSB7XG4gICAgICAvLyBFbmNvdW50ZXJlZCBhbiBhc3luYyBDbGllbnQgQ29tcG9uZW50LiBUaGlzIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLlxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2FzeW5jL2F3YWl0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGluIENsaWVudCBDb21wb25lbnRzLCBvbmx5ICcgKyAnU2VydmVyIENvbXBvbmVudHMuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSAnICsgXCJhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIFwiICsgJ2ZvciB0aGUgc2VydmVyLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICB7XG4gICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSB7XG4gICAgICAvLyBPbmx5IHRydWUgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBiZWluZyBob3QgcmVsb2FkZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnLCBuZXh0UmVuZGVyTGFuZXMpIHtcbiAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzIDogbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG4gICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB3YXJuSWZBc3luY0NsaWVudENvbXBvbmVudChDb21wb25lbnQpO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzOyAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBjdXJyZW50SG9vayA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAvLyB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gIC8vIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAvLyBUT0RPIFdhcm4gaWYgbm8gaG9va3MgYXJlIHVzZWQgYXQgYWxsIGR1cmluZyBtb3VudCwgdGhlbiBzb21lIGFyZSB1c2VkIGR1cmluZyB1cGRhdGUuXG4gIC8vIEN1cnJlbnRseSB3ZSB3aWxsIGlkZW50aWZ5IHRoZSB1cGRhdGUgcmVuZGVyIGFzIGEgbW91bnQgYmVjYXVzZSBtZW1vaXplZFN0YXRlID09PSBudWxsLlxuICAvLyBUaGlzIGlzIHRyaWNreSBiZWNhdXNlIGl0J3MgdmFsaWQgZm9yIGNlcnRhaW4gdHlwZXMgb2YgY29tcG9uZW50cyAoZS5nLiBSZWFjdC5sYXp5KVxuICAvLyBVc2luZyBtZW1vaXplZFN0YXRlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBtb3VudC91cGRhdGUgb25seSB3b3JrcyBpZiBhdCBsZWFzdCBvbmUgc3RhdGVmdWwgaG9vayBpcyB1c2VkLlxuICAvLyBOb24tc3RhdGVmdWwgaG9va3MgKGUuZy4gY29udGV4dCkgZG9uJ3QgZ2V0IGFkZGVkIHRvIG1lbW9pemVkU3RhdGUsXG4gIC8vIHNvIG1lbW9pemVkU3RhdGUgd291bGQgYmUgbnVsbCBkdXJpbmcgdXBkYXRlcyBhbmQgbW91bnRzLlxuXG4gIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVjtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICB9XG4gIH0gLy8gSW4gU3RyaWN0IE1vZGUsIGR1cmluZyBkZXZlbG9wbWVudCwgdXNlciBmdW5jdGlvbnMgYXJlIGRvdWJsZSBpbnZva2VkIHRvXG4gIC8vIGhlbHAgZGV0ZWN0IHNpZGUgZWZmZWN0cy4gVGhlIGxvZ2ljIGZvciBob3cgdGhpcyBpcyBpbXBsZW1lbnRlZCBmb3IgaW5cbiAgLy8gaG9vayBjb21wb25lbnRzIGlzIGEgYml0IGNvbXBsZXggc28gbGV0J3MgYnJlYWsgaXQgZG93bi5cbiAgLy9cbiAgLy8gV2Ugd2lsbCBpbnZva2UgdGhlIGVudGlyZSBjb21wb25lbnQgZnVuY3Rpb24gdHdpY2UuIEhvd2V2ZXIsIGR1cmluZyB0aGVcbiAgLy8gc2Vjb25kIGludm9jYXRpb24gb2YgdGhlIGNvbXBvbmVudCwgdGhlIGhvb2sgc3RhdGUgZnJvbSB0aGUgZmlyc3RcbiAgLy8gaW52b2NhdGlvbiB3aWxsIGJlIHJldXNlZC4gVGhhdCBtZWFucyB0aGluZ3MgbGlrZSBgdXNlTWVtb2AgZnVuY3Rpb25zIHdvbid0XG4gIC8vIHJ1biBhZ2FpbiwgYmVjYXVzZSB0aGUgZGVwcyB3aWxsIG1hdGNoIGFuZCB0aGUgbWVtb2l6ZWQgcmVzdWx0IHdpbGxcbiAgLy8gYmUgcmV1c2VkLlxuICAvL1xuICAvLyBXZSB3YW50IG1lbW9pemVkIGZ1bmN0aW9ucyB0byBydW4gdHdpY2UsIHRvbywgc28gYWNjb3VudCBmb3IgdGhpcywgdXNlclxuICAvLyBmdW5jdGlvbnMgYXJlIGRvdWJsZSBpbnZva2VkIGR1cmluZyB0aGUgKmZpcnN0KiBpbnZvY2F0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgLy8gZnVuY3Rpb24sIGFuZCBhcmUgKm5vdCogZG91YmxlIGludm9rZWQgZHVyaW5nIHRoZSBzZWNvbmQgaW5jb3ZhdGlvbjpcbiAgLy9cbiAgLy8gLSBGaXJzdCBleGVjdXRpb24gb2YgY29tcG9uZW50IGZ1bmN0aW9uOiB1c2VyIGZ1bmN0aW9ucyBhcmUgZG91YmxlIGludm9rZWRcbiAgLy8gLSBTZWNvbmQgZXhlY3V0aW9uIG9mIGNvbXBvbmVudCBmdW5jdGlvbiAoaW4gU3RyaWN0IE1vZGUsIGR1cmluZ1xuICAvLyAgIGRldmVsb3BtZW50KTogdXNlciBmdW5jdGlvbnMgYXJlIG5vdCBkb3VibGUgaW52b2tlZC5cbiAgLy9cbiAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbCBmb3IgYSBmZXcgcmVhc29uczsgbW9zdCBpbXBvcnRhbnRseSwgaXQncyBiZWNhdXNlIG9mXG4gIC8vIGhvdyBgdXNlYCB3b3JrcyB3aGVuIHNvbWV0aGluZyBzdXNwZW5kczogaXQgcmV1c2VzIHRoZSBwcm9taXNlIHRoYXQgd2FzXG4gIC8vIHBhc3NlZCBkdXJpbmcgdGhlIGZpcnN0IGF0dGVtcHQuIFRoaXMgaXMgaXRzZWxmIGEgZm9ybSBvZiBtZW1vaXphdGlvbi5cbiAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIG1lbW9pemUgdGhlIHJlYWN0aXZlIGlucHV0cyB0byB0aGUgYHVzZWAgY2FsbCB1c2luZ1xuICAvLyBhIGhvb2sgKGkuZS4gYHVzZU1lbW9gKSwgd2hpY2ggbWVhbnMsIHRoZSByZWFjdGl2ZSBpbnB1dHMgdG8gYHVzZWAgbXVzdFxuICAvLyBjb21lIGZyb20gdGhlIHNhbWUgY29tcG9uZW50IGludm9jYXRpb24gYXMgdGhlIG91dHB1dC5cbiAgLy9cbiAgLy8gVGhlcmUgYXJlIHBsZW50eSBvZiB0ZXN0cyB0byBlbnN1cmUgdGhpcyBiZWhhdmlvciBpcyBjb3JyZWN0LlxuXG5cbiAgdmFyIHNob3VsZERvdWJsZVJlbmRlckRFViA9ICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkgIT09IE5vTW9kZTtcbiAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSBzaG91bGREb3VibGVSZW5kZXJERVY7XG4gIHZhciBjaGlsZHJlbiA9IGNhbGxDb21wb25lbnRJbkRFVihDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIDtcbiAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSBmYWxzZTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAvLyBLZWVwIHJlbmRlcmluZyB1bnRpbCB0aGUgY29tcG9uZW50IHN0YWJpbGl6ZXMgKHRoZXJlIGFyZSBubyBtb3JlIHJlbmRlclxuICAgIC8vIHBoYXNlIHVwZGF0ZXMpLlxuICAgIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gIH1cblxuICBpZiAoc2hvdWxkRG91YmxlUmVuZGVyREVWKSB7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIGNvbXBvbmVudHMgYXJlIGludm9rZWQgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZSBlZmZlY3RzLlxuICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCkge1xuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICB9IC8vIFdlIGNhbiBhc3N1bWUgdGhlIHByZXZpb3VzIGRpc3BhdGNoZXIgaXMgYWx3YXlzIHRoaXMgb25lLCBzaW5jZSB3ZSBzZXQgaXRcbiAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmNlLlxuXG5cbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjsgLy8gVGhpcyBjaGVjayB1c2VzIGN1cnJlbnRIb29rIHNvIHRoYXQgaXQgd29ya3MgdGhlIHNhbWUgaW4gREVWIGFuZCBwcm9kIGJ1bmRsZXMuXG4gIC8vIGhvb2tUeXBlc0RldiBjb3VsZCBjYXRjaCBtb3JlIGNhc2VzIChlLmcuIGNvbnRleHQpIGJ1dCBvbmx5IGluIERFViBidW5kbGVzLlxuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gQ29uZmlybSB0aGF0IGEgc3RhdGljIGZsYWcgd2FzIG5vdCBhZGRlZCBvciByZW1vdmVkIHNpbmNlIHRoZSBsYXN0XG4gICAgLy8gcmVuZGVyLiBJZiB0aGlzIGZpcmVzLCBpdCBzdWdnZXN0cyB0aGF0IHdlIGluY29ycmVjdGx5IHJlc2V0IHRoZSBzdGF0aWNcbiAgICAvLyBmbGFncyBpbiBzb21lIG90aGVyIHBhcnQgb2YgdGhlIGNvZGViYXNlLiBUaGlzIGhhcyBoYXBwZW5lZCBiZWZvcmUsIGZvclxuICAgIC8vIGV4YW1wbGUsIGluIHRoZSBTdXNwZW5zZUxpc3QgaW1wbGVtZW50YXRpb24uXG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAoY3VycmVudC5mbGFncyAmIFN0YXRpY01hc2spICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBTdGF0aWNNYXNrKSAmJiAoIC8vIERpc2FibGUgdGhpcyB3YXJuaW5nIGluIGxlZ2FjeSBtb2RlLCBiZWNhdXNlIGxlZ2FjeSBTdXNwZW5zZSBpcyB3ZWlyZFxuICAgIC8vIGFuZCBjcmVhdGVzIGZhbHNlIHBvc2l0aXZlcy4gVG8gbWFrZSB0aGlzIHdvcmsgaW4gbGVnYWN5IG1vZGUsIHdlJ2RcbiAgICAvLyBuZWVkIHRvIG1hcmsgZmliZXJzIHRoYXQgY29tbWl0IGluIGFuIGluY29tcGxldGUgc3RhdGUsIHNvbWVob3cuIEZvclxuICAgIC8vIG5vdyBJJ2xsIGRpc2FibGUgdGhlIHdhcm5pbmcgdGhhdCBtb3N0IG9mIHRoZSBidWdzIHRoYXQgd291bGQgdHJpZ2dlclxuICAgIC8vIGl0IGFyZSBlaXRoZXIgZXhjbHVzaXZlIHRvIGNvbmN1cnJlbnQgbW9kZSBvciBleGlzdCBpbiBib3RoLlxuICAgIGRpc2FibGVMZWdhY3lNb2RlICkpIHtcbiAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgc3RhdGljIGZsYWcgd2FzIG1pc3NpbmcuIFBsZWFzZSAnICsgJ25vdGlmeSB0aGUgUmVhY3QgdGVhbS4nKTtcbiAgICB9XG4gIH1cblxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIFRoaXMgaXMgcmVzZXQgYnkgY2hlY2tEaWRSZW5kZXJJZEhvb2tcbiAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuXG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG5cbiAgaWYgKGRpZFJlbmRlclRvb0Zld0hvb2tzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBmZXdlciBob29rcyB0aGFuIGV4cGVjdGVkLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW4gYWNjaWRlbnRhbCAnICsgJ2Vhcmx5IHJldHVybiBzdGF0ZW1lbnQuJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKGNoZWNrSWZVc2VXcmFwcGVkSW5UcnlDYXRjaCgpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5oYXMoY29tcG9uZW50TmFtZSkgJiYgLy8gVGhpcyB3YXJuaW5nIGFsc28gZmlyZXMgaWYgeW91IHN1c3BlbmQgd2l0aCBgdXNlYCBpbnNpZGUgYW5cbiAgICAgIC8vIGFzeW5jIGNvbXBvbmVudC4gU2luY2Ugd2Ugd2FybiBmb3IgdGhhdCBhYm92ZSwgd2UnbGwgc2lsZW5jZSB0aGlzXG4gICAgICAvLyBzZWNvbmQgd2FybmluZyBieSBjaGVja2luZyBoZXJlLlxuICAgICAgIWRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2B1c2VgIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSB0cnkvY2F0Y2ggYmxvY2suIFRoaXMgaXMgbm90IGFsbG93ZWQgJyArICdhbmQgY2FuIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci4gVG8gaGFuZGxlIGVycm9ycyB0cmlnZ2VyZWQgJyArICdieSBgdXNlYCwgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhIGVycm9yIGJvdW5kYXJ5LicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlTdXNwZW5kZWRDb21wb25lbnRXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVwbGF5IGEgY29tcG9uZW50IHRoYXQgcHJldmlvdXNseSBzdXNwZW5kZWQsXG4gIC8vIGFmdGVyIGl0cyBkYXRhIHJlc29sdmVzLlxuICAvL1xuICAvLyBJdCdzIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHJlbmRlcldpdGhIb29rcywgYnV0IGl0IGRvZXNuJ3QgbmVlZCB0byBkb1xuICAvLyBtb3N0IG9mIHRoZSBzZXQgdXAgd29yayBiZWNhdXNlIHRoZXkgd2VyZW4ndCByZXNldCB3aGVuIHdlIHN1c3BlbmRlZDsgdGhleVxuICAvLyBvbmx5IGdldCByZXNldCB3aGVuIHRoZSBjb21wb25lbnQgZWl0aGVyIGNvbXBsZXRlcyAoZmluaXNoUmVuZGVyaW5nSG9va3MpXG4gIC8vIG9yIHVud2luZHMgKHJlc2V0SG9va3NPblVud2luZCkuXG4gIHtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG4gICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAvLyBUaGlzIGlzIHVzZWQgdG8gcGVyZm9ybSBhbm90aGVyIHJlbmRlciBwYXNzLiBJdCdzIHVzZWQgd2hlbiBzZXRTdGF0ZSBpc1xuICAvLyBjYWxsZWQgZHVyaW5nIHJlbmRlciwgYW5kIGZvciBkb3VibGUgaW52b2tpbmcgY29tcG9uZW50cyBpbiBTdHJpY3QgTW9kZVxuICAvLyBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gIC8vXG4gIC8vIFRoZSBzdGF0ZSBmcm9tIHRoZSBwcmV2aW91cyBwYXNzIGlzIHJldXNlZCB3aGVuZXZlciBwb3NzaWJsZS4gU28sIHN0YXRlXG4gIC8vIHVwZGF0ZXMgdGhhdCB3ZXJlIGFscmVhZHkgcHJvY2Vzc2VkIGFyZSBub3QgcHJvY2Vzc2VkIGFnYWluLCBhbmQgbWVtb2l6ZWRcbiAgLy8gZnVuY3Rpb25zIChgdXNlTWVtb2ApIGFyZSBub3QgaW52b2tlZCBhZ2Fpbi5cbiAgLy9cbiAgLy8gS2VlcCByZW5kZXJpbmcgaW4gYSBsb29wIGZvciBhcyBsb25nIGFzIHJlbmRlciBwaGFzZSB1cGRhdGVzIGNvbnRpbnVlIHRvXG4gIC8vIGJlIHNjaGVkdWxlZC4gVXNlIGEgY291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIHZhciBjaGlsZHJlbjtcblxuICBkbyB7XG4gICAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcykge1xuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGEgdXNlKCkgdmFsdWUgZGVwZW5kZWQgb24gYSBzdGF0ZSB0aGF0IHdhcyB1cGRhdGVkIGluXG4gICAgICAvLyB0aGlzIHJlcmVuZGVyLCBzbyB3ZSBuZWVkIHRvIHdhdGNoIGZvciBkaWZmZXJlbnQgdGhlbmFibGVzIHRoaXMgdGltZS5cbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcblxuICAgIGlmIChudW1iZXJPZlJlUmVuZGVycyA+PSBSRV9SRU5ERVJfTElNSVQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50ICcgKyAnYW4gaW5maW5pdGUgbG9vcC4nKTtcbiAgICB9XG5cbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG4gICAge1xuICAgICAgLy8gRXZlbiB3aGVuIGhvdCByZWxvYWRpbmcsIGFsbG93IGRlcGVuZGVuY2llcyB0byBzdGFiaWxpemVcbiAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcbiAgICB9IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cblxuICAgIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIEFsc28gdmFsaWRhdGUgaG9vayBvcmRlciBmb3IgY2FzY2FkaW5nIHVwZGF0ZXMuXG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgIH1cblxuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgO1xuICAgIGNoaWxkcmVuID0gY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykgO1xuICB9IHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO1xuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudFdpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcblxuICByZXR1cm4gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50LCBudWxsLCBudWxsLCBsYW5lcyk7XG59XG5mdW5jdGlvbiBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50KCkge1xuXG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcblxuICB2YXIgX2Rpc3BhdGNoZXIkdXNlU3RhdGUgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKCksXG4gICAgICBtYXliZVRoZW5hYmxlID0gX2Rpc3BhdGNoZXIkdXNlU3RhdGVbMF07XG5cbiAgdmFyIG5leHRTdGF0ZTtcblxuICBpZiAodHlwZW9mIG1heWJlVGhlbmFibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciB0aGVuYWJsZSA9IG1heWJlVGhlbmFibGU7XG4gICAgbmV4dFN0YXRlID0gdXNlVGhlbmFibGUodGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdGF0dXMgPSBtYXliZVRoZW5hYmxlO1xuICAgIG5leHRTdGF0ZSA9IHN0YXR1cztcbiAgfSAvLyBUaGUgXCJyZXNldCBzdGF0ZVwiIGlzIGFuIG9iamVjdC4gSWYgaXQgY2hhbmdlcywgdGhhdCBtZWFucyBzb21ldGhpbmdcbiAgLy8gcmVxdWVzdGVkIHRoYXQgd2UgcmVzZXQgdGhlIGZvcm0uXG5cblxuICB2YXIgX2Rpc3BhdGNoZXIkdXNlU3RhdGUyID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpLFxuICAgICAgbmV4dFJlc2V0U3RhdGUgPSBfZGlzcGF0Y2hlciR1c2VTdGF0ZTJbMF07XG5cbiAgdmFyIHByZXZSZXNldFN0YXRlID0gY3VycmVudEhvb2sgIT09IG51bGwgPyBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuICBpZiAocHJldlJlc2V0U3RhdGUgIT09IG5leHRSZXNldFN0YXRlKSB7XG4gICAgLy8gU2NoZWR1bGUgYSBmb3JtIHJlc2V0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBGb3JtUmVzZXQ7XG4gIH1cblxuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSByZW5kZXJXaXRoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiByZW5kZXJXaXRoSG9va3M7IGl0J3Mgb25seSBhXG4gIC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxuICB2YXIgZGlkUmVuZGVySWRIb29rID0gbG9jYWxJZENvdW50ZXIgIT09IDA7XG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn1cbmZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBmbGFncyBoZXJlLCBiZWNhdXNlIHRoZXkncmUgcmVzZXQgaW4gdGhlXG4gIC8vIGNvbXBsZXRlIHBoYXNlIChidWJibGVQcm9wZXJ0aWVzKS5cblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH4oTW91bnRQYXNzaXZlRGV2IHwgTW91bnRMYXlvdXREZXYgfCBQYXNzaXZlJDEgfCBVcGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH4oUGFzc2l2ZSQxIHwgVXBkYXRlKTtcbiAgfVxuXG4gIGN1cnJlbnQubGFuZXMgPSByZW1vdmVMYW5lcyhjdXJyZW50LmxhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiByZXNldEhvb2tzQWZ0ZXJUaHJvdygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgaW1tZWRpYWV0bHkgYWZ0ZXIgYSB0aHJvdy4gSXQgc2hvdWxkbid0IHJlc2V0IHRoZSBlbnRpcmVcbiAgLy8gbW9kdWxlIHN0YXRlLCBiZWNhdXNlIHRoZSB3b3JrIGxvb3AgbWlnaHQgZGVjaWRlIHRvIHJlcGxheSB0aGUgY29tcG9uZW50XG4gIC8vIGFnYWluIHdpdGhvdXQgcmV3aW5kaW5nLlxuICAvL1xuICAvLyBJdCBzaG91bGQgb25seSByZXNldCB0aGluZ3MgbGlrZSB0aGUgY3VycmVudCBkaXNwYXRjaGVyLCB0byBwcmV2ZW50IGhvb2tzXG4gIC8vIGZyb20gYmVpbmcgY2FsbGVkIG91dHNpZGUgb2YgYSBjb21wb25lbnQuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsOyAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jZS5cblxuICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xufVxuZnVuY3Rpb24gcmVzZXRIb29rc09uVW53aW5kKHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVGhlcmUgd2VyZSByZW5kZXIgcGhhc2UgdXBkYXRlcy4gVGhlc2UgYXJlIG9ubHkgdmFsaWQgZm9yIHRoaXMgcmVuZGVyXG4gICAgLy8gcGhhc2UsIHdoaWNoIHdlIGFyZSBub3cgYWJvcnRpbmcuIFJlbW92ZSB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZXMgc29cbiAgICAvLyB0aGV5IGRvIG5vdCBwZXJzaXN0IHRvIHRoZSBuZXh0IHJlbmRlci4gRG8gbm90IHJlbW92ZSB1cGRhdGVzIGZyb20gaG9va3NcbiAgICAvLyB0aGF0IHdlcmVuJ3QgcHJvY2Vzc2VkLlxuICAgIC8vXG4gICAgLy8gT25seSByZXNldCB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZSBpZiBpdCBoYXMgYSBjbG9uZS4gSWYgaXQgZG9lc1xuICAgIC8vIG5vdCBoYXZlIGEgY2xvbmUsIHRoYXQgbWVhbnMgaXQgd2Fzbid0IHByb2Nlc3NlZCwgYW5kIHRoZSB1cGRhdGVzIHdlcmVcbiAgICAvLyBzY2hlZHVsZWQgYmVmb3JlIHdlIGVudGVyZWQgdGhlIHJlbmRlciBwaGFzZS5cbiAgICB2YXIgaG9vayA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBob29rID0gaG9vay5uZXh0O1xuICAgIH1cblxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlO1xuICBsb2NhbElkQ291bnRlciA9IDA7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4gIC8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuICAvLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4gIC8vIHVzZSBhcyBhIGJhc2UuXG4gIHZhciBuZXh0Q3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIH1cblxuICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIH1cblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbiAgICBpZiAobmV4dEN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudEZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgaW5pdGlhbCByZW5kZXIuIFRoaXMgYnJhbmNoIGlzIHJlYWNoZWQgd2hlbiB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIHN1c3BlbmRzLCByZXN1bWVzLCB0aGVuIHJlbmRlcnMgYW4gYWRkaXRpb25hbCBob29rLlxuICAgICAgICAvLyBTaG91bGQgbmV2ZXIgYmUgcmVhY2hlZCBiZWNhdXNlIHdlIHNob3VsZCBzd2l0Y2ggdG8gdGhlIG1vdW50IGRpc3BhdGNoZXIgZmlyc3QuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlIGhvb2sgY2FsbGVkIG9uIGluaXRpYWwgcmVuZGVyLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS4gV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgY3VycmVudCBob29rLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgICB2YXIgbmV3SG9vayA9IHtcbiAgICAgIG1lbW9pemVkU3RhdGU6IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgcXVldWU6IGN1cnJlbnRIb29rLnF1ZXVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0LlxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gbmV3SG9vaztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IG5ld0hvb2s7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn0gLy8gTk9URTogZGVmaW5pbmcgdHdvIHZlcnNpb25zIG9mIHRoaXMgZnVuY3Rpb24gdG8gYXZvaWQgc2l6ZSBpbXBhY3Qgd2hlbiB0aGlzIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4vLyBQcmV2aW91c2x5IHRoaXMgZnVuY3Rpb24gd2FzIGlubGluZWQsIHRoZSBhZGRpdGlvbmFsIGBtZW1vQ2FjaGVgIHByb3BlcnR5IG1ha2VzIGl0IG5vdCBpbmxpbmVkLlxuXG5cbnZhciBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuXG57XG4gIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RFZmZlY3Q6IG51bGwsXG4gICAgICBldmVudHM6IG51bGwsXG4gICAgICBzdG9yZXM6IG51bGwsXG4gICAgICBtZW1vQ2FjaGU6IG51bGxcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAvLyBUcmFjayB0aGUgcG9zaXRpb24gb2YgdGhlIHRoZW5hYmxlIHdpdGhpbiB0aGlzIGZpYmVyLlxuICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgKz0gMTtcblxuICBpZiAodGhlbmFibGVTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRoZW5hYmxlU3RhdGUgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTsgLy8gV2hlbiBzb21ldGhpbmcgc3VzcGVuZHMgd2l0aCBgdXNlYCwgd2UgcmVwbGF5IHRoZSBjb21wb25lbnQgd2l0aCB0aGVcbiAgLy8gXCJyZS1yZW5kZXJcIiBkaXNwYXRjaGVyIGluc3RlYWQgb2YgdGhlIFwibW91bnRcIiBvciBcInVwZGF0ZVwiIGRpc3BhdGNoZXIuXG4gIC8vXG4gIC8vIEJ1dCBpZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBob29rcyB0aGF0IG9jY3VyIGFmdGVyIHRoZSBgdXNlYCBpbnZvY2F0aW9uXG4gIC8vIHRoYXQgc3VzcGVuZGVkLCB0aGV5IHdvdWxkbid0IGhhdmUgYmVlbiBwcm9jZXNzZWQgZHVyaW5nIHRoZSBwcmV2aW91c1xuICAvLyBhdHRlbXB0LiBTbyBhZnRlciB3ZSBpbnZva2UgYHVzZWAgYWdhaW4sIHdlIG1heSBuZWVkIHRvIHN3aXRjaCBmcm9tIHRoZVxuICAvLyBcInJlLXJlbmRlclwiIGRpc3BhdGNoZXIgYmFjayB0byB0aGUgXCJtb3VudFwiIG9yIFwidXBkYXRlXCIgZGlzcGF0Y2hlci4gVGhhdCdzXG4gIC8vIHdoYXQgdGhlIGZvbGxvd2luZyBsb2dpYyBhY2NvdW50cyBmb3IuXG4gIC8vXG4gIC8vIFRPRE86IFRoZW9yZXRpY2FsbHkgdGhpcyBsb2dpYyBvbmx5IG5lZWRzIHRvIGdvIGludG8gdGhlIHJlcmVuZGVyXG4gIC8vIGRpc3BhdGNoZXIuIENvdWxkIG9wdGltaXplLCBidXQgcHJvYmFibHkgbm90IGJlIHdvcnRoIGl0LlxuICAvLyBUaGlzIGlzIHRoZSBzYW1lIGxvZ2ljIGFzIGluIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vay5cblxuICB2YXIgd29ya0luUHJvZ3Jlc3NGaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gIHZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsID8gLy8gV2UncmUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdCwgc28gcmVhZCBmcm9tIHRoZSBmaXJzdCBob29rIGZyb21cbiAgLy8gdGhlIGZpYmVyLlxuICB3b3JrSW5Qcm9ncmVzc0ZpYmVyLm1lbW9pemVkU3RhdGUgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkgOyBlbHNlIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gcmVtYWluaW5nIGhvb2tzIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQuIFdlJ3JlIG5vIGxvbmdlclxuICAgIC8vIGluIFwicmUtcmVuZGVyXCIgbW9kZS4gU3dpdGNoIHRvIHRoZSBub3JtYWwgbW91bnQgb3IgdXBkYXRlIGRpc3BhdGNoZXIuXG4gICAgLy9cbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBsb2dpYyBpbiByZW5kZXJXaXRoSG9va3MsIGV4Y2VwdCB3ZSBkb24ndCBib3RoZXJcbiAgICAvLyB0byB0cmFjayB0aGUgaG9vayB0eXBlcyBkZWJ1ZyBpbmZvcm1hdGlvbiBpbiB0aGlzIGNhc2UgKHN1ZmZpY2llbnQgdG9cbiAgICAvLyBvbmx5IGRvIHRoYXQgd2hlbiBub3RoaW5nIHN1c3BlbmRzKS5cbiAgICB2YXIgY3VycmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3NGaWJlci5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsICYmIGN1cnJlbnRGaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1c2UodXNhYmxlKSB7XG4gIGlmICh1c2FibGUgIT09IG51bGwgJiYgdHlwZW9mIHVzYWJsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgaWYgKHR5cGVvZiB1c2FibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRoZW5hYmxlLlxuICAgICAgdmFyIHRoZW5hYmxlID0gdXNhYmxlO1xuICAgICAgcmV0dXJuIHVzZVRoZW5hYmxlKHRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHVzYWJsZTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0FuIHVuc3VwcG9ydGVkIHR5cGUgd2FzIHBhc3NlZCB0byB1c2UoKTogJyArIFN0cmluZyh1c2FibGUpKTtcbn1cblxuZnVuY3Rpb24gdXNlTWVtb0NhY2hlKHNpemUpIHtcbiAgdmFyIG1lbW9DYWNoZSA9IG51bGw7IC8vIEZhc3QtcGF0aCwgbG9hZCBtZW1vIGNhY2hlIGZyb20gd2lwIGZpYmVyIGlmIGFscmVhZHkgcHJlcGFyZWRcblxuICB2YXIgdXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgIG1lbW9DYWNoZSA9IHVwZGF0ZVF1ZXVlLm1lbW9DYWNoZTtcbiAgfSAvLyBPdGhlcndpc2UgY2xvbmUgZnJvbSB0aGUgY3VycmVudCBmaWJlclxuXG5cbiAgaWYgKG1lbW9DYWNoZSA9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAgICAgaWYgKGN1cnJlbnRVcGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY3VycmVudE1lbW9DYWNoZSA9IGN1cnJlbnRVcGRhdGVRdWV1ZS5tZW1vQ2FjaGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRNZW1vQ2FjaGUgIT0gbnVsbCkge1xuICAgICAgICAgIG1lbW9DYWNoZSA9IHtcbiAgICAgICAgICAgIC8vIFdoZW4gZW5hYmxlTm9DbG9uaW5nTWVtb0NhY2hlIGlzIGVuYWJsZWQsIGluc3RlYWQgb2YgdHJlYXRpbmcgdGhlXG4gICAgICAgICAgICAvLyBjYWNoZSBhcyBjb3B5LW9uLXdyaXRlLCBsaWtlIHdlIGRvIHdpdGggZmliZXJzLCB3ZSBzaGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gY2FjaGUgaW5zdGFuY2UgYWNyb3NzIGFsbCByZW5kZXIgYXR0ZW1wdHMsIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gaXMgaW50ZXJydXB0ZWQgYmVmb3JlIGl0IGNvbW1pdHMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSWYgYW4gdXBkYXRlIGlzIGludGVycnVwdGVkLCBlaXRoZXIgYmVjYXVzZSBpdCBzdXNwZW5kZWQgb3JcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugb2YgYW5vdGhlciB1cGRhdGUsIHdlIGNhbiByZXVzZSB0aGUgbWVtb2l6ZWQgY29tcHV0YXRpb25zXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LiBXZSBjYW4gZG8gdGhpcyBiZWNhdXNlIHRoZSBSZWFjdFxuICAgICAgICAgICAgLy8gQ29tcGlsZXIgcGVyZm9ybXMgYXRvbWljIHdyaXRlcyB0byB0aGUgbWVtbyBjYWNoZSwgaS5lLiBpdCB3aWxsXG4gICAgICAgICAgICAvLyBub3QgcmVjb3JkIHRoZSBpbnB1dHMgdG8gYSBtZW1vaXphdGlvbiB3aXRob3V0IGFsc28gcmVjb3JkaW5nIGl0c1xuICAgICAgICAgICAgLy8gb3V0cHV0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgZ2l2ZXMgdXMgYSBmb3JtIG9mIFwicmVzdW1pbmdcIiB3aXRoaW4gY29tcG9uZW50cyBhbmQgaG9va3MuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IHdvcmtzIHdoZW4gdXBkYXRpbmcgYSBjb21wb25lbnQgdGhhdCBhbHJlYWR5IG1vdW50ZWQuXG4gICAgICAgICAgICAvLyBJdCBoYXMgbm8gaW1wYWN0IGR1cmluZyBpbml0aWFsIHJlbmRlciwgYmVjYXVzZSB0aGUgbWVtbyBjYWNoZSBpc1xuICAgICAgICAgICAgLy8gc3RvcmVkIG9uIHRoZSBmaWJlciwgYW5kIHNpbmNlIHdlIGhhdmUgbm90IGltcGxlbWVudGVkIHJlc3VtaW5nXG4gICAgICAgICAgICAvLyBmb3IgZmliZXJzLCBpdCdzIGFsd2F5cyBhIGZyZXNoIG1lbW8gY2FjaGUsIGFueXdheS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGlzIGFsb25lIGlzIHByZXR0eSB1c2VmdWwg4oCUIGl0IGhhcHBlbnMgd2hlbmV2ZXIgeW91XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIFVJIHdpdGggZnJlc2ggZGF0YSBhZnRlciBhIG11dGF0aW9uL2FjdGlvbiwgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGV4dHJlbWVseSBjb21tb24gaW4gYSBTdXNwZW5zZS1kcml2ZW4gKGUuZy4gUlNDIG9yIFJlbGF5KSBhcHAuXG4gICAgICAgICAgICBkYXRhOiAvLyBDbG9uZSB0aGUgbWVtbyBjYWNoZSBiZWZvcmUgZWFjaCByZW5kZXIgKGNvcHktb24td3JpdGUpXG4gICAgICAgICAgICBjdXJyZW50TWVtb0NhY2hlLmRhdGEubWFwKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuc2xpY2UoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEZpbmFsbHkgZmFsbCBiYWNrIHRvIGFsbG9jYXRpbmcgYSBmcmVzaCBpbnN0YW5jZSBvZiB0aGUgY2FjaGVcblxuXG4gIGlmIChtZW1vQ2FjaGUgPT0gbnVsbCkge1xuICAgIG1lbW9DYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgaW5kZXg6IDBcbiAgICB9O1xuICB9XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgdXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlO1xuICB9XG5cbiAgdXBkYXRlUXVldWUubWVtb0NhY2hlID0gbWVtb0NhY2hlO1xuICB2YXIgZGF0YSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF07XG5cbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGRhdGEgPSBtZW1vQ2FjaGUuZGF0YVttZW1vQ2FjaGUuaW5kZXhdID0gbmV3IEFycmF5KHNpemUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIHdhcm5pbmcgb3IgdGhyb3dpbmcgaGVyZVxuICAgIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBhIGNvbnN0YW50IHNpemUgYXJndW1lbnQgZm9yIGVhY2ggaW52b2NhdGlvbiBvZiB1c2VNZW1vQ2FjaGUuICcgKyAnVGhlIHByZXZpb3VzIGNhY2hlIHdhcyBhbGxvY2F0ZWQgd2l0aCBzaXplICVzIGJ1dCBzaXplICVzIHdhcyByZXF1ZXN0ZWQuJywgZGF0YS5sZW5ndGgsIHNpemUpO1xuICAgIH1cbiAgfVxuXG4gIG1lbW9DYWNoZS5pbmRleCsrO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcblxuICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG4gICAgICBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICBob29rLnF1ZXVlID0gcXVldWU7XG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCByZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudCwgcmVkdWNlcikge1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gWW91IGFyZSBsaWtlbHkgY2FsbGluZyBIb29rcyBjb25kaXRpb25hbGx5LCAnICsgJ3doaWNoIGlzIG5vdCBhbGxvd2VkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCknKTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyOyAvLyBUaGUgbGFzdCByZWJhc2UgdXBkYXRlIHRoYXQgaXMgTk9UIHBhcnQgb2YgdGhlIGJhc2Ugc3RhdGUuXG5cbiAgdmFyIGJhc2VRdWV1ZSA9IGhvb2suYmFzZVF1ZXVlOyAvLyBUaGUgbGFzdCBwZW5kaW5nIHVwZGF0ZSB0aGF0IGhhc24ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG5cbiAgdmFyIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmdRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFdlIGhhdmUgbmV3IHVwZGF0ZXMgdGhhdCBoYXZlbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cbiAgICAvLyBXZSdsbCBhZGQgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cbiAgICBpZiAoYmFzZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAvLyBNZXJnZSB0aGUgcGVuZGluZyBxdWV1ZSBhbmQgdGhlIGJhc2UgcXVldWUuXG4gICAgICB2YXIgYmFzZUZpcnN0ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgICB2YXIgcGVuZGluZ0ZpcnN0ID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICBiYXNlUXVldWUubmV4dCA9IHBlbmRpbmdGaXJzdDtcbiAgICAgIHBlbmRpbmdRdWV1ZS5uZXh0ID0gYmFzZUZpcnN0O1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChjdXJyZW50LmJhc2VRdWV1ZSAhPT0gYmFzZVF1ZXVlKSB7XG4gICAgICAgIC8vIEludGVybmFsIGludmFyaWFudCB0aGF0IHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBmZWFzaWJseSBjb3VsZCBpblxuICAgICAgICAvLyB0aGUgZnV0dXJlIGlmIHdlIGltcGxlbWVudCByZXN1bWluZywgb3Igc29tZSBmb3JtIG9mIHRoYXQuXG4gICAgICAgIGVycm9yKCdJbnRlcm5hbCBlcnJvcjogRXhwZWN0ZWQgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSB0byBiZSBhIGNsb25lLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudC5iYXNlUXVldWUgPSBiYXNlUXVldWUgPSBwZW5kaW5nUXVldWU7XG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gIH1cblxuICB2YXIgYmFzZVN0YXRlID0gaG9vay5iYXNlU3RhdGU7XG5cbiAgaWYgKGJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBwZW5kaW5nIHVwZGF0ZXMsIHRoZW4gdGhlIG1lbW9pemVkIHN0YXRlIHNob3VsZCBiZSB0aGVcbiAgICAvLyBzYW1lIGFzIHRoZSBiYXNlIHN0YXRlLiBDdXJyZW50bHkgdGhlc2Ugb25seSBkaXZlcmdlIGluIHRoZSBjYXNlIG9mXG4gICAgLy8gdXNlT3B0aW1pc3RpYywgYmVjYXVzZSB1c2VPcHRpbWlzdGljIGFjY2VwdHMgYSBuZXcgYmFzZVN0YXRlIG9uXG4gICAgLy8gZXZlcnkgcmVuZGVyLlxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGJhc2VTdGF0ZTsgLy8gV2UgZG9uJ3QgbmVlZCB0byBjYWxsIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlIGJlY2F1c2VcbiAgICAvLyBiYXNlU3RhdGUgaXMgZGVyaXZlZCBmcm9tIG90aGVyIHJlYWN0aXZlIHZhbHVlcy5cbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbiAgICB2YXIgZmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3U3RhdGUgPSBiYXNlU3RhdGU7XG4gICAgdmFyIG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlTGFzdCA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0O1xuICAgIHZhciBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gZmFsc2U7XG5cbiAgICBkbyB7XG4gICAgICAvLyBBbiBleHRyYSBPZmZzY3JlZW5MYW5lIGJpdCBpcyBhZGRlZCB0byB1cGRhdGVzIHRoYXQgd2VyZSBtYWRlIHRvXG4gICAgICAvLyBhIGhpZGRlbiB0cmVlLCBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB0aGVtIGZyb20gdXBkYXRlcyB0aGF0IHdlcmVcbiAgICAgIC8vIGFscmVhZHkgdGhlcmUgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLlxuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSByZW1vdmVMYW5lcyh1cGRhdGUubGFuZSwgT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB2YXIgaXNIaWRkZW5VcGRhdGUgPSB1cGRhdGVMYW5lICE9PSB1cGRhdGUubGFuZTsgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgd2FzIG1hZGUgd2hpbGUgdGhlIHRyZWUgd2FzIGhpZGRlbi4gSWYgc28sIHRoZW5cbiAgICAgIC8vIGl0J3Mgbm90IGEgXCJiYXNlXCIgdXBkYXRlIGFuZCB3ZSBzaG91bGQgZGlzcmVnYXJkIHRoZSBleHRyYSBiYXNlIGxhbmVzXG4gICAgICAvLyB0aGF0IHdlcmUgYWRkZWQgdG8gcmVuZGVyTGFuZXMgd2hlbiB3ZSBlbnRlcmVkIHRoZSBPZmZzY3JlZW4gdHJlZS5cblxuICAgICAgdmFyIHNob3VsZFNraXBVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSA/ICFpc1N1YnNldE9mTGFuZXMoZ2V0V29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMoKSwgdXBkYXRlTGFuZSkgOiAhaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKTtcblxuICAgICAgaWYgKHNob3VsZFNraXBVcGRhdGUpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbiAgICAgICAgLy8gcmVuZGVyTGFuZXMgZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cblxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgICAgICB2YXIgcmV2ZXJ0TGFuZSA9IHVwZGF0ZS5yZXZlcnRMYW5lO1xuXG4gICAgICAgIGlmIChyZXZlcnRMYW5lID09PSBOb0xhbmUpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIG5vdCBhbiBvcHRpbWlzdGljIHVwZGF0ZSwgYW5kIHdlJ3JlIGdvaW5nIHRvIGFwcGx5IGl0IG5vdy5cbiAgICAgICAgICAvLyBCdXQsIGlmIHRoZXJlIHdlcmUgZWFybGllciB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLCB3ZSBuZWVkIHRvXG4gICAgICAgICAgLy8gbGVhdmUgdGhpcyB1cGRhdGUgaW4gdGhlIHF1ZXVlIHNvIGl0IGNhbiBiZSByZWJhc2VkIGxhdGVyLlxuICAgICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgICAvLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4gICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgICByZXZlcnRMYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgICB9IC8vIENoZWNrIGlmIHRoaXMgdXBkYXRlIGlzIHBhcnQgb2YgYSBwZW5kaW5nIGFzeW5jIGFjdGlvbi4gSWYgc28sXG4gICAgICAgICAgLy8gd2UnbGwgbmVlZCB0byBzdXNwZW5kIHVudGlsIHRoZSBhY3Rpb24gaGFzIGZpbmlzaGVkLCBzbyB0aGF0IGl0J3NcbiAgICAgICAgICAvLyBiYXRjaGVkIHRvZ2V0aGVyIHdpdGggZnV0dXJlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgYWN0aW9uLlxuXG5cbiAgICAgICAgICBpZiAodXBkYXRlTGFuZSA9PT0gcGVla0VudGFuZ2xlZEFjdGlvbkxhbmUoKSkge1xuICAgICAgICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gb3B0aW1pc3RpYyB1cGRhdGUuIElmIHRoZSBcInJldmVydFwiIHByaW9yaXR5IGlzXG4gICAgICAgICAgLy8gc3VmZmljaWVudCwgZG9uJ3QgYXBwbHkgdGhlIHVwZGF0ZS4gT3RoZXJ3aXNlLCBhcHBseSB0aGUgdXBkYXRlLFxuICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBpdCBpbiB0aGUgcXVldWUgc28gaXQgY2FuIGJlIGVpdGhlciByZXZlcnRlZCBvclxuICAgICAgICAgIC8vIHJlYmFzZWQgaW4gYSBzdWJzZXF1ZW50IHJlbmRlci5cbiAgICAgICAgICBpZiAoaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCByZXZlcnRMYW5lKSkge1xuICAgICAgICAgICAgLy8gVGhlIHRyYW5zaXRpb24gdGhhdCB0aGlzIG9wdGltaXN0aWMgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAgICAgICAgLy8gaGFzIGZpbmlzaGVkLiBQcmV0ZW5kIHRoZSB1cGRhdGUgZG9lc24ndCBleGlzdCBieSBza2lwcGluZ1xuICAgICAgICAgICAgLy8gb3ZlciBpdC5cbiAgICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0OyAvLyBDaGVjayBpZiB0aGlzIHVwZGF0ZSBpcyBwYXJ0IG9mIGEgcGVuZGluZyBhc3luYyBhY3Rpb24uIElmIHNvLFxuICAgICAgICAgICAgLy8gd2UnbGwgbmVlZCB0byBzdXNwZW5kIHVudGlsIHRoZSBhY3Rpb24gaGFzIGZpbmlzaGVkLCBzbyB0aGF0IGl0J3NcbiAgICAgICAgICAgIC8vIGJhdGNoZWQgdG9nZXRoZXIgd2l0aCBmdXR1cmUgdXBkYXRlcyBpbiB0aGUgc2FtZSBhY3Rpb24uXG5cbiAgICAgICAgICAgIGlmIChyZXZlcnRMYW5lID09PSBwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSgpKSB7XG4gICAgICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9jbG9uZTIgPSB7XG4gICAgICAgICAgICAgIC8vIE9uY2Ugd2UgY29tbWl0IGFuIG9wdGltaXN0aWMgdXBkYXRlLCB3ZSBzaG91bGRuJ3QgdW5jb21taXQgaXRcbiAgICAgICAgICAgICAgLy8gdW50aWwgdGhlIHRyYW5zaXRpb24gaXQgaXMgYXNzb2NpYXRlZCB3aXRoIGhhcyBmaW5pc2hlZFxuICAgICAgICAgICAgICAvLyAocmVwcmVzZW50ZWQgYnkgcmV2ZXJ0TGFuZSkuIFVzaW5nIE5vTGFuZSBoZXJlIHdvcmtzIGJlY2F1c2UgMFxuICAgICAgICAgICAgICAvLyBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5XG4gICAgICAgICAgICAgIC8vIHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgICAvLyBSZXVzZSB0aGUgc2FtZSByZXZlcnRMYW5lIHNvIHdlIGtub3cgd2hlbiB0aGUgdHJhbnNpdGlvblxuICAgICAgICAgICAgICAvLyBoYXMgZmluaXNoZWQuXG4gICAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gX2Nsb25lMjtcbiAgICAgICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gX2Nsb25lMjtcbiAgICAgICAgICAgIH0gLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbiAgICAgICAgICAgIC8vIHJlbmRlckxhbmVzIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG5cbiAgICAgICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIHJldmVydExhbmUpO1xuICAgICAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhyZXZlcnRMYW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuXG4gICAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICAgIHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlLmhhc0VhZ2VyU3RhdGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHVwZGF0ZSBpcyBhIHN0YXRlIHVwZGF0ZSAobm90IGEgcmVkdWNlcikgYW5kIHdhcyBwcm9jZXNzZWQgZWFnZXJseSxcbiAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlXG4gICAgICAgICAgbmV3U3RhdGUgPSB1cGRhdGUuZWFnZXJTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsICYmIHVwZGF0ZSAhPT0gZmlyc3QpO1xuXG4gICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBuZXdCYXNlUXVldWVGaXJzdDtcbiAgICB9IC8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG4gICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTsgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgaXMgcGFydCBvZiBhIHBlbmRpbmcgYXN5bmMgYWN0aW9uLiBJZiBzbywgd2UnbGxcbiAgICAgIC8vIG5lZWQgdG8gc3VzcGVuZCB1bnRpbCB0aGUgYWN0aW9uIGhhcyBmaW5pc2hlZCwgc28gdGhhdCBpdCdzIGJhdGNoZWRcbiAgICAgIC8vIHRvZ2V0aGVyIHdpdGggZnV0dXJlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgYWN0aW9uLlxuICAgICAgLy8gVE9ETzogT25jZSB3ZSBzdXBwb3J0IGhvb2tzIGluc2lkZSB1c2VNZW1vIChvciBhbiBlcXVpdmFsZW50XG4gICAgICAvLyBtZW1vaXphdGlvbiBib3VuZGFyeSBsaWtlIEZvcmdldCksIGhvaXN0IHRoaXMgbG9naWMgc28gdGhhdCBpdCBvbmx5XG4gICAgICAvLyBzdXNwZW5kcyBpZiB0aGUgbWVtbyBib3VuZGFyeSBwcm9kdWNlcyBhIG5ldyB2YWx1ZS5cblxuICAgICAgaWYgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24pIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gcGVla0VudGFuZ2xlZEFjdGlvblRoZW5hYmxlKCk7XG5cbiAgICAgICAgaWYgKGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB0aGUgdGhyb3dpbmcgdGhlIHRoZW5hYmxlIGRpcmVjdGx5LCB0aHJvdyBhXG4gICAgICAgICAgLy8gc3BlY2lhbCBvYmplY3QgbGlrZSBgdXNlYCBkb2VzIHNvIHdlIGNhbiBkZXRlY3QgaWYgaXQncyBjYXB0dXJlZFxuICAgICAgICAgIC8vIGJ5IHVzZXJzcGFjZS5cbiAgICAgICAgICB0aHJvdyBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgaWYgKGJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICBxdWV1ZS5sYW5lcyA9IE5vTGFuZXM7XG4gIH1cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFlvdSBhcmUgbGlrZWx5IGNhbGxpbmcgSG9va3MgY29uZGl0aW9uYWxseSwgJyArICd3aGljaCBpcyBub3QgYWxsb3dlZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwpJyk7XG4gIH1cblxuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjsgLy8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbiAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rLlxuXG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZztcbiAgdmFyIG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgcXVldWUgZG9lc24ndCBwZXJzaXN0IHBhc3QgdGhpcyByZW5kZXIgcGFzcy5cbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgLy8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG4gICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAvLyByZW5kZXIncy5cbiAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgfSB3aGlsZSAodXBkYXRlICE9PSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlKTsgLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlOyAvLyBEb24ndCBwZXJzaXN0IHRoZSBzdGF0ZSBhY2N1bXVsYXRlZCBmcm9tIHRoZSByZW5kZXIgcGhhc2UgdXBkYXRlcyB0b1xuICAgIC8vIHRoZSBiYXNlIHN0YXRlIHVubGVzcyB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgLy8gVE9ETzogTm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgZGVzaXJlZCBzZW1hbnRpY3MsIGJ1dCBpdCdzIHdoYXQgd2VcbiAgICAvLyBkbyBmb3IgZ0RTRlAuIEkgY2FuJ3QgcmVtZW1iZXIgd2h5LlxuXG4gICAgaWYgKGhvb2suYmFzZVF1ZXVlID09PSBudWxsKSB7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dFNuYXBzaG90O1xuICB2YXIgaXNIeWRyYXRpbmcgPSBnZXRJc0h5ZHJhdGluZygpO1xuXG4gIGlmIChpc0h5ZHJhdGluZykge1xuICAgIGlmIChnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciAnICsgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuICAgIH1cblxuICAgIG5leHRTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICAgIGlmIChuZXh0U25hcHNob3QgIT09IGdldFNlcnZlclNuYXBzaG90KCkpIHtcbiAgICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTZXJ2ZXJTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXh0U25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICB2YXIgY2FjaGVkU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAgICAgIGlmICghb2JqZWN0SXMobmV4dFNuYXBzaG90LCBjYWNoZWRTbmFwc2hvdCkpIHtcbiAgICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gVW5sZXNzIHdlJ3JlIHJlbmRlcmluZyBhIGJsb2NraW5nIGxhbmUsIHNjaGVkdWxlIGEgY29uc2lzdGVuY3kgY2hlY2suXG4gICAgLy8gUmlnaHQgYmVmb3JlIGNvbW1pdHRpbmcsIHdlIHdpbGwgd2FsayB0aGUgdHJlZSBhbmQgY2hlY2sgaWYgYW55IG9mIHRoZVxuICAgIC8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQuXG4gICAgLy9cbiAgICAvLyBXZSB3b24ndCBkbyB0aGlzIGlmIHdlJ3JlIGh5ZHJhdGluZyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCwgYmVjYXVzZSBpZlxuICAgIC8vIHRoZSBjb250ZW50IGlzIHN0YWxlLCBpdCdzIGFscmVhZHkgdmlzaWJsZSBhbnl3YXkuIEluc3RlYWQgd2UnbGwgcGF0Y2hcbiAgICAvLyBpdCB1cCBpbiBhIHBhc3NpdmUgZWZmZWN0LlxuXG5cbiAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIHZhciByb290UmVuZGVyTGFuZXMgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcygpO1xuXG4gICAgaWYgKCFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LCByb290UmVuZGVyTGFuZXMpKSB7XG4gICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcbiAgICB9XG4gIH0gLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIFRoaXMgYnJlYWtzIHRoZVxuICAvLyBub3JtYWwgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGJlY2F1c2Ugc3RvcmUgdXBkYXRlcyBhcmVcbiAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICB2YXIgaW5zdCA9IHtcbiAgICB2YWx1ZTogbmV4dFNuYXBzaG90LFxuICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdFxuICB9O1xuICBob29rLnF1ZXVlID0gaW5zdDsgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIHN1YnNjcmliZSB0byB0aGUgc3RvcmUuXG5cbiAgbW91bnRFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbc3Vic2NyaWJlXSk7IC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byB1cGRhdGUgdGhlIG11dGFibGUgaW5zdGFuY2UgZmllbGRzLiBXZSB3aWxsIHVwZGF0ZVxuICAvLyB0aGlzIHdoZW5ldmVyIHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIG9yIHZhbHVlIGNoYW5nZXMuIEJlY2F1c2UgdGhlcmUncyBub1xuICAvLyBjbGVhbi11cCBmdW5jdGlvbiwgYW5kIHdlIHRyYWNrIHRoZSBkZXBzIGNvcnJlY3RseSwgd2UgY2FuIGNhbGwgcHVzaEVmZmVjdFxuICAvLyBkaXJlY3RseSwgd2l0aG91dCBzdG9yaW5nIGFueSBhZGRpdGlvbmFsIHN0YXRlLiBGb3IgdGhlIHNhbWUgcmVhc29uLCB3ZVxuICAvLyBkb24ndCBuZWVkIHRvIHNldCBhIHN0YXRpYyBmbGFnLCBlaXRoZXIuXG5cbiAgZmliZXIuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IFBhc3NpdmUsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIGNyZWF0ZUVmZmVjdEluc3RhbmNlKCksIG51bGwpO1xuICByZXR1cm4gbmV4dFNuYXBzaG90O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpOyAvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gVGhpcyBicmVha3MgdGhlXG4gIC8vIG5vcm1hbCBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgYmVjYXVzZSBzdG9yZSB1cGRhdGVzIGFyZVxuICAvLyBhbHdheXMgc3luY2hyb25vdXMuXG5cbiAgdmFyIG5leHRTbmFwc2hvdDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZ2V0SXNIeWRyYXRpbmcoKTtcblxuICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBOZWVkZWQgZm9yIHN0cmljdCBtb2RlIGRvdWJsZSByZW5kZXJcbiAgICBpZiAoZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgICB9XG5cbiAgICBuZXh0U25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICB9IGVsc2Uge1xuICAgIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgICAgaWYgKCFvYmplY3RJcyhuZXh0U25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSkge1xuICAgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG4gICAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZTbmFwc2hvdCA9IChjdXJyZW50SG9vayB8fCBob29rKS5tZW1vaXplZFN0YXRlO1xuICB2YXIgc25hcHNob3RDaGFuZ2VkID0gIW9iamVjdElzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcblxuICBpZiAoc25hcHNob3RDaGFuZ2VkKSB7XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gIH1cblxuICB2YXIgaW5zdCA9IGhvb2sucXVldWU7XG4gIHVwZGF0ZUVmZmVjdChzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIHN1YnNjcmliZSksIFtzdWJzY3JpYmVdKTsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuICAvLyB0aGlzIGNhbiBoYXBwZW4gYWxsIHRoZSB0aW1lLCBidXQgZXZlbiBpbiBzeW5jaHJvbm91cyBtb2RlLCBhbiBlYXJsaWVyXG4gIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICBpZiAoaW5zdC5nZXRTbmFwc2hvdCAhPT0gZ2V0U25hcHNob3QgfHwgc25hcHNob3RDaGFuZ2VkIHx8IC8vIENoZWNrIGlmIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb24gY2hhbmdlZC4gV2UgY2FuIHNhdmUgc29tZSBtZW1vcnkgYnlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB3ZSBzY2hlZHVsZWQgYSBzdWJzY3JpcHRpb24gZWZmZWN0IGFib3ZlLlxuICB3b3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUudGFnICYgSGFzRWZmZWN0KSB7XG4gICAgZmliZXIuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICAgIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSwgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSwgY3JlYXRlRWZmZWN0SW5zdGFuY2UoKSwgbnVsbCk7IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbiAgICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuXG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzSHlkcmF0aW5nICYmICFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LCByZW5kZXJMYW5lcykpIHtcbiAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCByZW5kZXJlZFNuYXBzaG90KSB7XG4gIGZpYmVyLmZsYWdzIHw9IFN0b3JlQ29uc2lzdGVuY3k7XG4gIHZhciBjaGVjayA9IHtcbiAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsXG4gICAgdmFsdWU6IHJlbmRlcmVkU25hcHNob3RcbiAgfTtcbiAgdmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcblxuICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY29tcG9uZW50VXBkYXRlUXVldWU7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzID0gW2NoZWNrXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RvcmVzID0gY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzO1xuXG4gICAgaWYgKHN0b3JlcyA9PT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzID0gW2NoZWNrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmVzLnB1c2goY2hlY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTdG9yZUluc3RhbmNlKGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSB7XG4gIC8vIFRoZXNlIGFyZSB1cGRhdGVkIGluIHRoZSBwYXNzaXZlIHBoYXNlXG4gIGluc3QudmFsdWUgPSBuZXh0U25hcHNob3Q7XG4gIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gU29tZXRoaW5nIG1heSBoYXZlIGJlZW4gbXV0YXRlZCBpbiBiZXR3ZWVuIHJlbmRlciBhbmQgY29tbWl0LiBUaGlzIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiBpbiBhbiBldmVudCB0aGF0IGZpcmVkIGJlZm9yZSB0aGUgcGFzc2l2ZSBlZmZlY3RzLCBvciBpdCBjb3VsZFxuICAvLyBoYXZlIGJlZW4gaW4gYSBsYXlvdXQgZWZmZWN0LiBJbiB0aGF0IGNhc2UsIHdlIHdvdWxkIGhhdmUgdXNlZCB0aGUgb2xkXG4gIC8vIHNuYXBzaG8gYW5kIGdldFNuYXBzaG90IHZhbHVlcyB0byBiYWlsIG91dC4gV2UgbmVlZCB0byBjaGVjayBvbmUgbW9yZSB0aW1lLlxuXG4gIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmVUb1N0b3JlKGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpIHtcbiAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgLy8gcmVhZCBmcm9tIHRoZSBzdG9yZS5cbiAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICAgIH1cbiAgfTsgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG5cblxuICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gIHZhciBwcmV2VmFsdWUgPSBpbnN0LnZhbHVlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgcmV0dXJuICFvYmplY3RJcyhwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKSB7XG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyID0gaW5pdGlhbFN0YXRlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuXG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcblxuICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV06IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG5cbiAgICAgIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyKCk7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICByZXR1cm4gaG9vaztcbn1cblxuZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgLy8gT3B0aW1pc3RpYyBzdGF0ZSBkb2VzIG5vdCB1c2UgdGhlIGVhZ2VyIHVwZGF0ZSBvcHRpbWl6YXRpb24uXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogbnVsbFxuICB9O1xuICBob29rLnF1ZXVlID0gcXVldWU7IC8vIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIG5vcm1hbCBzZXRTdGF0ZSBmdW5jdGlvbi5cblxuICB2YXIgZGlzcGF0Y2ggPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHRydWUsIHF1ZXVlKTtcbiAgcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50LCBwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAvLyBPcHRpbWlzdGljIHVwZGF0ZXMgYXJlIGFsd2F5cyByZWJhc2VkIG9uIHRvcCBvZiB0aGUgbGF0ZXN0IHZhbHVlIHBhc3NlZCBpblxuICAvLyBhcyBhbiBhcmd1bWVudC4gSXQncyBjYWxsZWQgYSBwYXNzdGhyb3VnaCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBubyBwZW5kaW5nXG4gIC8vIHVwZGF0ZXMsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gIC8vXG4gIC8vIFJlc2V0IHRoZSBiYXNlIHN0YXRlIHRvIHRoZSBwYXNzdGhyb3VnaC4gRnV0dXJlIHVwZGF0ZXMgd2lsbCBiZSBhcHBsaWVkXG4gIC8vIG9uIHRvcCBvZiB0aGlzLlxuICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoOyAvLyBJZiBhIHJlZHVjZXIgaXMgbm90IHByb3ZpZGVkLCBkZWZhdWx0IHRvIHRoZSBzYW1lIG9uZSB1c2VkIGJ5IHVzZVN0YXRlLlxuXG4gIHZhciByZXNvbHZlZFJlZHVjZXIgPSB0eXBlb2YgcmVkdWNlciA9PT0gJ2Z1bmN0aW9uJyA/IHJlZHVjZXIgOiBiYXNpY1N0YXRlUmVkdWNlcjtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCByZXNvbHZlZFJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgLy8gVW5saWtlIHVzZVN0YXRlLCB1c2VPcHRpbWlzdGljIGRvZXNuJ3Qgc3VwcG9ydCByZW5kZXIgcGhhc2UgdXBkYXRlcy5cbiAgLy8gQWxzbyB1bmxpa2UgdXNlU3RhdGUsIHdlIG5lZWQgdG8gcmVwbGF5IGFsbCBwZW5kaW5nIHVwZGF0ZXMgYWdhaW4gaW4gY2FzZVxuICAvLyB0aGUgcGFzc3Rocm91Z2ggdmFsdWUgY2hhbmdlZC5cbiAgLy9cbiAgLy8gU28gaW5zdGVhZCBvZiBhIGZvcmtlZCByZS1yZW5kZXIgaW1wbGVtZW50YXRpb24gdGhhdCBrbm93cyBob3cgdG8gaGFuZGxlXG4gIC8vIHJlbmRlciBwaGFzZSB1ZHBhdGVzLCB3ZSBjYW4gdXNlIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIGR1cmluZyBhXG4gIC8vIHJlZ3VsYXIgbW91bnQgb3IgdXBkYXRlLlxuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmIChjdXJyZW50SG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYW4gdXBkYXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gIH0gLy8gVGhpcyBpcyBhIG1vdW50LiBObyB1cGRhdGVzIHRvIHByb2Nlc3MuXG4gIC8vIFJlc2V0IHRoZSBiYXNlIHN0YXRlIHRvIHRoZSBwYXNzdGhyb3VnaC4gRnV0dXJlIHVwZGF0ZXMgd2lsbCBiZSBhcHBsaWVkXG4gIC8vIG9uIHRvcCBvZiB0aGlzLlxuXG5cbiAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgdmFyIGRpc3BhdGNoID0gaG9vay5xdWV1ZS5kaXNwYXRjaDtcbiAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgZGlzcGF0Y2hdO1xufSAvLyB1c2VBY3Rpb25TdGF0ZSBhY3Rpb25zIHJ1biBzZXF1ZW50aWFsbHksIGJlY2F1c2UgZWFjaCBhY3Rpb24gcmVjZWl2ZXMgdGhlXG4vLyBwcmV2aW91cyBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gV2Ugc3RvcmUgcGVuZGluZyBhY3Rpb25zIG9uIGEgcXVldWUuXG5cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb25TdGF0ZShmaWJlciwgYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUsIHBheWxvYWQpIHtcbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGZvcm0gc3RhdGUgd2hpbGUgcmVuZGVyaW5nLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRBY3Rpb24gPSBhY3Rpb25RdWV1ZS5hY3Rpb247XG5cbiAgaWYgKGN1cnJlbnRBY3Rpb24gPT09IG51bGwpIHtcbiAgICAvLyBBbiBlYXJsaWVyIGFjdGlvbiBlcnJvcmVkLiBTdWJzZXF1ZW50IGFjdGlvbnMgc2hvdWxkIG5vdCBydW4uXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFjdGlvbk5vZGUgPSB7XG4gICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICBhY3Rpb246IGN1cnJlbnRBY3Rpb24sXG4gICAgbmV4dDogbnVsbCxcbiAgICAvLyBjaXJjdWxhclxuICAgIGlzVHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICByZWFzb246IG51bGwsXG4gICAgbGlzdGVuZXJzOiBbXSxcbiAgICB0aGVuOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIC8vIFdlIGtub3cgdGhlIG9ubHkgdGhpbmcgdGhhdCBzdWJzY3JpYmVzIHRvIHRoZXNlIHByb21pc2VzIGlzIGB1c2VgIHNvXG4gICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIHNpbXBsZXIgdGhhbiBhIGdlbmVyaWMgdGhlbmFibGUuIEUuZy4gd2UgZG9uJ3RcbiAgICAgIC8vIGJvdGhlciB0byBjaGVjayBpZiB0aGUgdGhlbmFibGUgaXMgc3RpbGwgcGVuZGluZyBiZWNhdXNlIGB1c2VgIGFscmVhZHlcbiAgICAgIC8vIGRvZXMgdGhhdC5cbiAgICAgIGFjdGlvbk5vZGUubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgfTsgLy8gQ2hlY2sgaWYgd2UncmUgaW5zaWRlIGEgdHJhbnNpdGlvbi4gSWYgc28sIHdlJ2xsIG5lZWQgdG8gcmVzdG9yZSB0aGVcbiAgLy8gdHJhbnNpdGlvbiBjb250ZXh0IHdoZW4gdGhlIGFjdGlvbiBpcyBydW4uXG5cbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcblxuICBpZiAocHJldlRyYW5zaXRpb24gIT09IG51bGwpIHtcbiAgICAvLyBPcHRpbWlzdGljYWxseSB1cGRhdGUgdGhlIHBlbmRpbmcgc3RhdGUsIHNpbWlsYXIgdG8gdXNlVHJhbnNpdGlvbi5cbiAgICAvLyBUaGlzIHdpbGwgYmUgcmV2ZXJ0ZWQgYXV0b21hdGljYWxseSB3aGVuIGFsbCBhY3Rpb25zIGFyZSBmaW5pc2hlZC5cbiAgICBzZXRQZW5kaW5nU3RhdGUodHJ1ZSk7IC8vIGBhY3Rpb25Ob2RlYCBpcyBhIHRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJldHVybiB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3Rpb24uXG5cbiAgICBzZXRTdGF0ZShhY3Rpb25Ob2RlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhIHRyYW5zaXRpb24uXG4gICAgYWN0aW9uTm9kZS5pc1RyYW5zaXRpb24gPSBmYWxzZTtcbiAgICBzZXRTdGF0ZShhY3Rpb25Ob2RlKTtcbiAgfVxuXG4gIHZhciBsYXN0ID0gYWN0aW9uUXVldWUucGVuZGluZztcblxuICBpZiAobGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlIGFyZSBubyBwZW5kaW5nIGFjdGlvbnM7IHRoaXMgaXMgdGhlIGZpcnN0IG9uZS4gV2UgY2FuIHJ1blxuICAgIC8vIGl0IGltbWVkaWF0ZWx5LlxuICAgIGFjdGlvbk5vZGUubmV4dCA9IGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBhY3Rpb25Ob2RlO1xuICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSdzIGFscmVhZHkgYW4gYWN0aW9uIHJ1bm5pbmcuIEFkZCB0byB0aGUgcXVldWUuXG4gICAgdmFyIGZpcnN0ID0gbGFzdC5uZXh0O1xuICAgIGFjdGlvbk5vZGUubmV4dCA9IGZpcnN0O1xuICAgIGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBsYXN0Lm5leHQgPSBhY3Rpb25Ob2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBub2RlKSB7XG4gIC8vIGBub2RlLmFjdGlvbmAgcmVwcmVzZW50cyB0aGUgYWN0aW9uIGZ1bmN0aW9uIGF0IHRoZSB0aW1lIGl0IHdhcyBkaXNwYXRjaGVkLlxuICAvLyBJZiB0aGlzIGFjdGlvbiB3YXMgcXVldWVkLCBpdCBtaWdodCBiZSBzdGFsZSwgaS5lLiBpdCdzIG5vdCBuZWNlc3NhcmlseSB0aGVcbiAgLy8gbW9zdCBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoZSBhY3Rpb24sIHN0b3JlZCBvbiBgYWN0aW9uUXVldWVgLiBUaGlzIGlzXG4gIC8vIGludGVudGlvbmFsLiBUaGUgY29uY2VwdHVhbCBtb2RlbCBmb3IgcXVldWVkIGFjdGlvbnMgaXMgdGhhdCB0aGV5IGFyZVxuICAvLyBxdWV1ZWQgaW4gYSByZW1vdGUgd29ya2VyOyB0aGUgZGlzcGF0Y2ggaGFwcGVucyBpbW1lZGlhdGVseSwgb25seSB0aGVcbiAgLy8gZXhlY3V0aW9uIGlzIGRlbGF5ZWQuXG4gIHZhciBhY3Rpb24gPSBub2RlLmFjdGlvbjtcbiAgdmFyIHBheWxvYWQgPSBub2RlLnBheWxvYWQ7XG4gIHZhciBwcmV2U3RhdGUgPSBhY3Rpb25RdWV1ZS5zdGF0ZTtcblxuICBpZiAobm9kZS5pc1RyYW5zaXRpb24pIHtcbiAgICAvLyBUaGUgb3JpZ2luYWwgZGlzcGF0Y2ggd2FzIHBhcnQgb2YgYSB0cmFuc2l0aW9uLiBXZSByZXN0b3JlIGl0c1xuICAgIC8vIHRyYW5zaXRpb24gY29udGV4dCBoZXJlLlxuICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHN0YXJ0VHJhbnNpdGlvblxuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVC5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCk7XG4gICAgICB2YXIgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuXG4gICAgICBpZiAob25TdGFydFRyYW5zaXRpb25GaW5pc2ggIT09IG51bGwpIHtcbiAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG5cbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgICB3YXJuKCdEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uICcgKyAnSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gJyArICdPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBvcmlnaW5hbCBkaXNwYXRjaCB3YXMgbm90IHBhcnQgb2YgYSB0cmFuc2l0aW9uLlxuICAgIHRyeSB7XG4gICAgICB2YXIgX3JldHVyblZhbHVlID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCk7XG5cbiAgICAgIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCBfcmV0dXJuVmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSkge1xuICBpZiAocmV0dXJuVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHJldHVyblZhbHVlID09PSAnb2JqZWN0JyAmJiAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHRoZW5hYmxlID0gcmV0dXJuVmFsdWU7IC8vIEF0dGFjaCBhIGxpc3RlbmVyIHRvIHJlYWQgdGhlIHJldHVybiBzdGF0ZSBvZiB0aGUgYWN0aW9uLiBBcyBzb29uIGFzXG4gICAgLy8gdGhpcyByZXNvbHZlcywgd2UgY2FuIHJ1biB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlIHNlcXVlbmNlLlxuXG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIG5vZGUsIG5leHRTdGF0ZSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgIH0pO1xuXG4gICAge1xuICAgICAgaWYgKCFub2RlLmlzVHJhbnNpdGlvbikge1xuICAgICAgICBlcnJvcignQW4gYXN5bmMgZnVuY3Rpb24gd2FzIHBhc3NlZCB0byB1c2VBY3Rpb25TdGF0ZSwgYnV0IGl0IHdhcyAnICsgJ2Rpc3BhdGNoZWQgb3V0c2lkZSBvZiBhbiBhY3Rpb24gY29udGV4dC4gVGhpcyBpcyBsaWtlbHkgbm90ICcgKyAnd2hhdCB5b3UgaW50ZW5kZWQuIEVpdGhlciBwYXNzIHRoZSBkaXNwYXRjaCBmdW5jdGlvbiB0byBhbiAnICsgJ2BhY3Rpb25gIHByb3AsIG9yIGRpc3BhdGNoIG1hbnVhbGx5IGluc2lkZSBgc3RhcnRUcmFuc2l0aW9uYCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dFN0YXRlID0gcmV0dXJuVmFsdWU7XG4gICAgb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCBuZXh0U3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgbmV4dFN0YXRlKSB7XG4gIC8vIFRoZSBhY3Rpb24gZmluaXNoZWQgcnVubmluZy5cbiAgYWN0aW9uTm9kZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgYWN0aW9uTm9kZS52YWx1ZSA9IG5leHRTdGF0ZTtcbiAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpO1xuICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IG5leHRTdGF0ZTsgLy8gUG9wIHRoZSBhY3Rpb24gZnJvbSB0aGUgcXVldWUgYW5kIHJ1biB0aGUgbmV4dCBwZW5kaW5nIGFjdGlvbiwgaWYgdGhlcmVcbiAgLy8gYXJlIGFueS5cblxuICB2YXIgbGFzdCA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3QgPSBsYXN0Lm5leHQ7XG5cbiAgICBpZiAoZmlyc3QgPT09IGxhc3QpIHtcbiAgICAgIC8vIFRoaXMgd2FzIHRoZSBsYXN0IGFjdGlvbiBpbiB0aGUgcXVldWUuXG4gICAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBub2RlIGZyb20gdGhlIGNpcmN1bGFyIHF1ZXVlLlxuICAgICAgdmFyIG5leHQgPSBmaXJzdC5uZXh0O1xuICAgICAgbGFzdC5uZXh0ID0gbmV4dDsgLy8gUnVuIHRoZSBuZXh0IGFjdGlvbi5cblxuICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIG5leHQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlLCBlcnJvcikge1xuICAvLyBNYXJrIGFsbCB0aGUgZm9sbG93aW5nIGFjdGlvbnMgYXMgcmVqZWN0ZWQuXG4gIHZhciBsYXN0ID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGw7XG5cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3QgPSBsYXN0Lm5leHQ7XG5cbiAgICBkbyB7XG4gICAgICBhY3Rpb25Ob2RlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICBhY3Rpb25Ob2RlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpO1xuICAgICAgYWN0aW9uTm9kZSA9IGFjdGlvbk5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChhY3Rpb25Ob2RlICE9PSBmaXJzdCk7XG4gIH0gLy8gUHJldmVudCBzdWJzZXF1ZW50IGFjdGlvbnMgZnJvbSBiZWluZyBkaXNwYXRjaGVkLlxuXG5cbiAgYWN0aW9uUXVldWUuYWN0aW9uID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpIHtcbiAgLy8gTm90aWZ5IFJlYWN0IHRoYXQgdGhlIGFjdGlvbiBoYXMgZmluaXNoZWQuXG4gIHZhciBsaXN0ZW5lcnMgPSBhY3Rpb25Ob2RlLmxpc3RlbmVycztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFRoaXMgaXMgYWx3YXlzIGEgUmVhY3QgaW50ZXJuYWwgbGlzdGVuZXIsIHNvIHdlIGRvbid0IG5lZWQgdG8gd29ycnlcbiAgICAvLyBhYm91dCBpdCB0aHJvd2luZy5cbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgbGlzdGVuZXIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3Rpb25TdGF0ZVJlZHVjZXIob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuZnVuY3Rpb24gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZVByb3AsIHBlcm1hbGluaykge1xuICB2YXIgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlUHJvcDtcblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG4gICAgdmFyIHNzckZvcm1TdGF0ZSA9IHJvb3QuZm9ybVN0YXRlOyAvLyBJZiBhIGZvcm1TdGF0ZSBvcHRpb24gd2FzIHBhc3NlZCB0byB0aGUgcm9vdCwgdGhlcmUgYXJlIGZvcm0gc3RhdGVcbiAgICAvLyBtYXJrZXJzIHRoYXQgd2UgbmVlZCB0byBoeWRyYXRlLiBUaGVzZSBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBmb3JtIHN0YXRlXG4gICAgLy8gbWF0Y2hlcyB0aGlzIGhvb2sgaW5zdGFuY2UuXG5cbiAgICBpZiAoc3NyRm9ybVN0YXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgaXNNYXRjaGluZyA9IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUZvcm1NYXJrZXJJbnN0YW5jZShjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcblxuICAgICAgaWYgKGlzTWF0Y2hpbmcpIHtcbiAgICAgICAgaW5pdGlhbFN0YXRlID0gc3NyRm9ybVN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTdGF0ZSBob29rLiBUaGUgc3RhdGUgaXMgc3RvcmVkIGluIGEgdGhlbmFibGUgd2hpY2ggaXMgdGhlbiB1bndyYXBwZWQgYnlcbiAgLy8gdGhlIGB1c2VgIGFsZ29yaXRobSBkdXJpbmcgcmVuZGVyLlxuXG5cbiAgdmFyIHN0YXRlSG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHN0YXRlSG9vay5tZW1vaXplZFN0YXRlID0gc3RhdGVIb29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTsgLy8gVE9ETzogVHlwaW5nIHRoaXMgXCJjb3JyZWN0bHlcIiByZXN1bHRzIGluIHJlY3Vyc2lvbiBsaW1pdCBlcnJvcnNcbiAgLy8gY29uc3Qgc3RhdGVRdWV1ZTogVXBkYXRlUXVldWU8UyB8IEF3YWl0ZWQ8Uz4sIFMgfCBBd2FpdGVkPFM+PiA9IHtcblxuICB2YXIgc3RhdGVRdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGFjdGlvblN0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIHN0YXRlSG9vay5xdWV1ZSA9IHN0YXRlUXVldWU7XG4gIHZhciBzZXRTdGF0ZSA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBzdGF0ZVF1ZXVlKTtcbiAgc3RhdGVRdWV1ZS5kaXNwYXRjaCA9IHNldFN0YXRlOyAvLyBQZW5kaW5nIHN0YXRlLiBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIHBlbmRpbmcgc3RhdGUgb2YgdGhlIGFjdGlvbi5cbiAgLy8gVHJhY2tlZCBvcHRpbWlzdGljYWxseSwgbGlrZSBhIHRyYW5zaXRpb24gcGVuZGluZyBzdGF0ZS5cblxuICB2YXIgcGVuZGluZ1N0YXRlSG9vayA9IG1vdW50U3RhdGVJbXBsKGZhbHNlKTtcbiAgdmFyIHNldFBlbmRpbmdTdGF0ZSA9IGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgZmFsc2UsIHBlbmRpbmdTdGF0ZUhvb2sucXVldWUpOyAvLyBBY3Rpb24gcXVldWUgaG9vay4gVGhpcyBpcyB1c2VkIHRvIHF1ZXVlIHBlbmRpbmcgYWN0aW9ucy4gVGhlIHF1ZXVlIGlzXG4gIC8vIHNoYXJlZCBiZXR3ZWVuIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGhvb2suIFNpbWlsYXIgdG8gYSByZWd1bGFyIHN0YXRlIHF1ZXVlLFxuICAvLyBidXQgZGlmZmVyZW50IGJlY2F1c2UgdGhlIGFjdGlvbnMgYXJlIHJ1biBzZXF1ZW50aWFsbHksIGFuZCB0aGV5IHJ1biBpblxuICAvLyBhbiBldmVudCBpbnN0ZWFkIG9mIGR1cmluZyByZW5kZXIuXG5cbiAgdmFyIGFjdGlvblF1ZXVlSG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBhY3Rpb25RdWV1ZSA9IHtcbiAgICBzdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIC8vIGNpcmN1bGFyXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgcGVuZGluZzogbnVsbFxuICB9O1xuICBhY3Rpb25RdWV1ZUhvb2sucXVldWUgPSBhY3Rpb25RdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb25TdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlKTtcbiAgYWN0aW9uUXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaDsgLy8gU3Rhc2ggdGhlIGFjdGlvbiBmdW5jdGlvbiBvbiB0aGUgbWVtb2l6ZWQgc3RhdGUgb2YgdGhlIGhvb2suIFdlJ2xsIHVzZSB0aGlzXG4gIC8vIHRvIGRldGVjdCB3aGVuIHRoZSBhY3Rpb24gZnVuY3Rpb24gY2hhbmdlcyBzbyB3ZSBjYW4gdXBkYXRlIGl0IGluXG4gIC8vIGFuIGVmZmVjdC5cblxuICBhY3Rpb25RdWV1ZUhvb2subWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgcmV0dXJuIFtpbml0aWFsU3RhdGUsIGRpc3BhdGNoLCBmYWxzZV07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgY3VycmVudFN0YXRlSG9vayA9IGN1cnJlbnRIb29rO1xuICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudFN0YXRlSG9vaywgYWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudFN0YXRlSG9vaywgYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICB2YXIgX3VwZGF0ZVJlZHVjZXJJbXBsID0gdXBkYXRlUmVkdWNlckltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb25TdGF0ZVJlZHVjZXIpLFxuICAgICAgYWN0aW9uUmVzdWx0ID0gX3VwZGF0ZVJlZHVjZXJJbXBsWzBdO1xuXG4gIHZhciBfdXBkYXRlU3RhdGUgPSB1cGRhdGVTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3VwZGF0ZVN0YXRlWzBdOyAvLyBUaGlzIHdpbGwgc3VzcGVuZCB1bnRpbCB0aGUgYWN0aW9uIGZpbmlzaGVzLlxuXG5cbiAgdmFyIHN0YXRlID0gdHlwZW9mIGFjdGlvblJlc3VsdCA9PT0gJ29iamVjdCcgJiYgYWN0aW9uUmVzdWx0ICE9PSBudWxsICYmIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgdHlwZW9mIGFjdGlvblJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nID8gdXNlVGhlbmFibGUoYWN0aW9uUmVzdWx0KSA6IGFjdGlvblJlc3VsdDtcbiAgdmFyIGFjdGlvblF1ZXVlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgYWN0aW9uUXVldWUgPSBhY3Rpb25RdWV1ZUhvb2sucXVldWU7XG4gIHZhciBkaXNwYXRjaCA9IGFjdGlvblF1ZXVlLmRpc3BhdGNoOyAvLyBDaGVjayBpZiBhIG5ldyBhY3Rpb24gd2FzIHBhc3NlZC4gSWYgc28sIHVwZGF0ZSBpdCBpbiBhbiBlZmZlY3QuXG5cbiAgdmFyIHByZXZBY3Rpb24gPSBhY3Rpb25RdWV1ZUhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoYWN0aW9uICE9PSBwcmV2QWN0aW9uKSB7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBQYXNzaXZlJDE7XG4gICAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlLCBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdC5iaW5kKG51bGwsIGFjdGlvblF1ZXVlLCBhY3Rpb24pLCBjcmVhdGVFZmZlY3RJbnN0YW5jZSgpLCBudWxsKTtcbiAgfVxuXG4gIHJldHVybiBbc3RhdGUsIGRpc3BhdGNoLCBpc1BlbmRpbmddO1xufVxuXG5mdW5jdGlvbiBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdChhY3Rpb25RdWV1ZSwgYWN0aW9uKSB7XG4gIGFjdGlvblF1ZXVlLmFjdGlvbiA9IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gIC8vIFVubGlrZSB1c2VTdGF0ZSwgdXNlQWN0aW9uU3RhdGUgZG9lc24ndCBzdXBwb3J0IHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAvLyBBbHNvIHVubGlrZSB1c2VTdGF0ZSwgd2UgbmVlZCB0byByZXBsYXkgYWxsIHBlbmRpbmcgdXBkYXRlcyBhZ2FpbiBpbiBjYXNlXG4gIC8vIHRoZSBwYXNzdGhyb3VnaCB2YWx1ZSBjaGFuZ2VkLlxuICAvL1xuICAvLyBTbyBpbnN0ZWFkIG9mIGEgZm9ya2VkIHJlLXJlbmRlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGtub3dzIGhvdyB0byBoYW5kbGVcbiAgLy8gcmVuZGVyIHBoYXNlIHVkcGF0ZXMsIHdlIGNhbiB1c2UgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgZHVyaW5nIGFcbiAgLy8gcmVndWxhciBtb3VudCBvciB1cGRhdGUuXG4gIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGN1cnJlbnRTdGF0ZUhvb2sgPSBjdXJyZW50SG9vaztcblxuICBpZiAoY3VycmVudFN0YXRlSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYW4gdXBkYXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbik7XG4gIH1cblxuICB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTsgLy8gU3RhdGVcbiAgLy8gVGhpcyBpcyBhIG1vdW50LiBObyB1cGRhdGVzIHRvIHByb2Nlc3MuXG5cbiAgdmFyIHN0YXRlID0gc3RhdGVIb29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciBhY3Rpb25RdWV1ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVIb29rLnF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBhY3Rpb25RdWV1ZS5kaXNwYXRjaDsgLy8gVGhpcyBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyB0aGUgcmVyZW5kZXIuXG5cbiAgYWN0aW9uUXVldWVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247IC8vIEZvciBtb3VudCwgcGVuZGluZyBpcyBhbHdheXMgZmFsc2UuXG5cbiAgcmV0dXJuIFtzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlXTtcbn1cblxuZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgaW5zdCwgZGVwcykge1xuICB2YXIgZWZmZWN0ID0ge1xuICAgIHRhZzogdGFnLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGluc3Q6IGluc3QsXG4gICAgZGVwczogZGVwcyxcbiAgICAvLyBDaXJjdWxhclxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgdmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcblxuICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY29tcG9uZW50VXBkYXRlUXVldWU7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICB9IGVsc2Uge1xuICAgIHZhciBsYXN0RWZmZWN0ID0gY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgIGlmIChsYXN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgIGxhc3RFZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICAgIGVmZmVjdC5uZXh0ID0gZmlyc3RFZmZlY3Q7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlZmZlY3Q7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVmZmVjdEluc3RhbmNlKCkge1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICB9O1xuICBob29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gIHJldHVybiByZWY7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIGhvb2subWVtb2l6ZWRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBob29rRmxhZ3MsIGNyZWF0ZSwgY3JlYXRlRWZmZWN0SW5zdGFuY2UoKSwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgZWZmZWN0ID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICB2YXIgaW5zdCA9IGVmZmVjdC5pbnN0OyAvLyBjdXJyZW50SG9vayBpcyBudWxsIG9uIGluaXRpYWwgbW91bnQgd2hlbiByZXJlbmRlcmluZyBhZnRlciBhIHJlbmRlciBwaGFzZVxuICAvLyBzdGF0ZSB1cGRhdGUgb3IgZm9yIHN0cmljdCBtb2RlLlxuXG4gIGlmIChjdXJyZW50SG9vayAhPT0gbnVsbCkge1xuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZFZmZlY3QgPSBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldkVmZmVjdC5kZXBzO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgaW5zdCwgbmV4dERlcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCBpbnN0LCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICBpZiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlICYmIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIG1vdW50RWZmZWN0SW1wbChNb3VudFBhc3NpdmVEZXYgfCBQYXNzaXZlJDEgfCBQYXNzaXZlU3RhdGljLCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICB9IGVsc2Uge1xuICAgIG1vdW50RWZmZWN0SW1wbChQYXNzaXZlJDEgfCBQYXNzaXZlU3RhdGljLCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdXBkYXRlRWZmZWN0SW1wbChQYXNzaXZlJDEsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICBtb3VudEVmZmVjdEltcGwoVXBkYXRlLCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZSB8IExheW91dFN0YXRpYztcblxuICBpZiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxuXG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlZkNhbGxiYWNrID0gcmVmO1xuICAgIHZhciBpbnN0ID0gY3JlYXRlKCk7XG4gICAgdmFyIHJlZkNsZWFudXAgPSByZWZDYWxsYmFjayhpbnN0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiByZWZDbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gd2UgbmVlZCB0byBhc3N1bWUgbm8gcGFyYW1ldGVyc1xuICAgICAgICByZWZDbGVhbnVwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZWZPYmplY3QgPSByZWY7XG5cbiAgICB7XG4gICAgICBpZiAoIXJlZk9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgJyArICdyZWYgY2FsbGJhY2sgb3IgUmVhY3QuY3JlYXRlUmVmKCkgb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCAnYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKHJlZk9iamVjdCkuam9pbignLCAnKSArICd9Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG5cbiAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZWZPYmplY3QuY3VycmVudCA9IG51bGw7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZSB8IExheW91dFN0YXRpYztcblxuICBpZiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxuXG4gIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHsvLyBUaGlzIGhvb2sgaXMgbm9ybWFsbHkgYSBuby1vcC5cbiAgLy8gVGhlIHJlYWN0LWRlYnVnLWhvb2tzIHBhY2thZ2UgaW5qZWN0cyBpdHMgb3duIGltcGxlbWVudGF0aW9uXG4gIC8vIHNvIHRoYXQgZS5nLiBEZXZUb29scyBjYW4gZGlzcGxheSBjdXN0b20gaG9vayB2YWx1ZXMuXG59XG5cbnZhciB1cGRhdGVEZWJ1Z1ZhbHVlID0gbW91bnREZWJ1Z1ZhbHVlO1xuXG5mdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICB9XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBtb3VudE1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuICAgIG5leHRDcmVhdGUoKTtcbiAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTsgLy8gQXNzdW1lIHRoZXNlIGFyZSBkZWZpbmVkLiBJZiB0aGV5J3JlIG5vdCwgYXJlSG9va0lucHV0c0VxdWFsIHdpbGwgd2Fybi5cblxuICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblxuICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcbiAgICBuZXh0Q3JlYXRlKCk7XG4gICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJlc29sdmVkQ3VycmVudEhvb2sgPSBjdXJyZW50SG9vaztcbiAgdmFyIHByZXZWYWx1ZSA9IHJlc29sdmVkQ3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUsIGluaXRpYWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlcmVuZGVyIGR1cmluZyBhIG1vdW50LlxuICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSByZXJlbmRlciBkdXJpbmcgYW4gdXBkYXRlLlxuICAgIHZhciBwcmV2VmFsdWUgPSBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLCBwcmV2VmFsdWUsIHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICBpZiAoLy8gV2hlbiBgaW5pdGlhbFZhbHVlYCBpcyBwcm92aWRlZCwgd2UgZGVmZXIgdGhlIGluaXRpYWwgcmVuZGVyIGV2ZW4gaWYgdGhlXG4gIC8vIGN1cnJlbnQgcmVuZGVyIGlzIG5vdCBzeW5jaHJvbm91cy5cbiAgaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQgJiYgLy8gSG93ZXZlciwgdG8gYXZvaWQgd2F0ZXJmYWxscywgd2UgZG8gbm90IGRlZmVyIGlmIHRoaXMgcmVuZGVyXG4gIC8vIHdhcyBpdHNlbGYgc3Bhd25lZCBieSBhbiBlYXJsaWVyIHVzZURlZmVycmVkVmFsdWUuIENoZWNrIGlmIERlZmVycmVkTGFuZVxuICAvLyBpcyBwYXJ0IG9mIHRoZSByZW5kZXIgbGFuZXMuXG4gICFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBEZWZlcnJlZExhbmUpKSB7XG4gICAgLy8gUmVuZGVyIHdpdGggdGhlIGluaXRpYWwgdmFsdWVcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWU7IC8vIFNjaGVkdWxlIGEgZGVmZXJyZWQgcmVuZGVyIHRvIHN3aXRjaCB0byB0aGUgZmluYWwgdmFsdWUuXG5cbiAgICB2YXIgZGVmZXJyZWRMYW5lID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIGRlZmVycmVkTGFuZSk7XG4gICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhkZWZlcnJlZExhbmUpO1xuICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICBpZiAob2JqZWN0SXModmFsdWUsIHByZXZWYWx1ZSkpIHtcbiAgICAvLyBUaGUgaW5jb21pbmcgdmFsdWUgaXMgcmVmZXJlbnRpYWxseSBpZGVudGljYWwgdG8gdGhlIGN1cnJlbnRseSByZW5kZXJlZFxuICAgIC8vIHZhbHVlLCBzbyB3ZSBjYW4gYmFpbCBvdXQgcXVpY2tseS5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBuZXcgdmFsdWUgdGhhdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluc2lkZSBhIGhpZGRlbiB0cmVlXG4gICAgaWYgKGlzQ3VycmVudFRyZWVIaWRkZW4oKSkge1xuICAgICAgLy8gUmV2ZWFsaW5nIGEgcHJlcmVuZGVyZWQgdHJlZSBpcyBjb25zaWRlcmVkIHRoZSBzYW1lIGFzIG1vdW50aW5nIG5ld1xuICAgICAgLy8gb25lLCBzbyB3ZSByZXVzZSB0aGUgXCJtb3VudFwiIHBhdGggaW4gdGhpcyBjYXNlLlxuICAgICAgdmFyIHJlc3VsdFZhbHVlID0gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTsgLy8gVW5saWtlIGR1cmluZyBhbiBhY3R1YWwgbW91bnQsIHdlIG5lZWQgdG8gbWFyayB0aGlzIGFzIGFuIHVwZGF0ZSBpZlxuICAgICAgLy8gdGhlIHZhbHVlIGNoYW5nZWQuXG5cbiAgICAgIGlmICghb2JqZWN0SXMocmVzdWx0VmFsdWUsIHByZXZWYWx1ZSkpIHtcbiAgICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFZhbHVlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGREZWZlclZhbHVlID0gIWluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzKHJlbmRlckxhbmVzKTtcblxuICAgIGlmIChzaG91bGREZWZlclZhbHVlKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIHVyZ2VudCB1cGRhdGUuIFNpbmNlIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwga2VlcCB1c2luZyB0aGVcbiAgICAgIC8vIHByZXZpb3VzIHZhbHVlIGFuZCBzcGF3biBhIGRlZmVycmVkIHJlbmRlciB0byB1cGRhdGUgaXQgbGF0ZXIuXG4gICAgICAvLyBTY2hlZHVsZSBhIGRlZmVycmVkIHJlbmRlclxuICAgICAgdmFyIGRlZmVycmVkTGFuZSA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIGRlZmVycmVkTGFuZSk7XG4gICAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGRlZmVycmVkTGFuZSk7IC8vIFJldXNlIHRoZSBwcmV2aW91cyB2YWx1ZS4gV2UgZG8gbm90IG5lZWQgdG8gbWFyayB0aGlzIGFzIGFuIHVwZGF0ZSxcbiAgICAgIC8vIGJlY2F1c2Ugd2UgZGlkIG5vdCByZW5kZXIgYSBuZXcgdmFsdWUuXG5cbiAgICAgIHJldHVybiBwcmV2VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgbm90IGFuIHVyZ2VudCB1cGRhdGUsIHNvIHdlIGNhbiB1c2UgdGhlIGxhdGVzdCB2YWx1ZSByZWdhcmRsZXNzXG4gICAgICAvLyBvZiB3aGF0IGl0IGlzLiBObyBuZWVkIHRvIGRlZmVyIGl0LlxuICAgICAgLy8gTWFyayB0aGlzIGFzIGFuIHVwZGF0ZSB0byBwcmV2ZW50IHRoZSBmaWJlciBmcm9tIGJhaWxpbmcgb3V0LlxuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oZmliZXIsIHF1ZXVlLCBwZW5kaW5nU3RhdGUsIGZpbmlzaGVkU3RhdGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShoaWdoZXJFdmVudFByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5KSk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuXG4gIHtcbiAgICAvLyBXZSBkb24ndCByZWFsbHkgbmVlZCB0byB1c2UgYW4gb3B0aW1pc3RpYyB1cGRhdGUgaGVyZSwgYmVjYXVzZSB3ZVxuICAgIC8vIHNjaGVkdWxlIGEgc2Vjb25kIFwicmV2ZXJ0XCIgdXBkYXRlIGJlbG93ICh3aGljaCB3ZSB1c2UgdG8gc3VzcGVuZCB0aGVcbiAgICAvLyB0cmFuc2l0aW9uIHVudGlsIHRoZSBhc3luYyBhY3Rpb24gc2NvcGUgaGFzIGZpbmlzaGVkKS4gQnV0IHdlJ2xsIHVzZSBhblxuICAgIC8vIG9wdGltaXN0aWMgdXBkYXRlIGFueXdheSB0byBtYWtlIGl0IGxlc3MgbGlrZWx5IHRoZSBiZWhhdmlvciBhY2NpZGVudGFsbHlcbiAgICAvLyBkaXZlcmdlczsgZm9yIGV4YW1wbGUsIGJvdGggYW4gb3B0aW1pc3RpYyB1cGRhdGUgYW5kIHRoaXMgb25lIHNob3VsZFxuICAgIC8vIHNoYXJlIHRoZSBzYW1lIGxhbmUuXG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCBmYWxzZSwgcXVldWUsIHBlbmRpbmdTdGF0ZSk7XG4gIH1cblxuICB7XG4gICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChlbmFibGVBc3luY0FjdGlvbnMpIHtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCk7XG4gICAgICB2YXIgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuXG4gICAgICBpZiAob25TdGFydFRyYW5zaXRpb25GaW5pc2ggIT09IG51bGwpIHtcbiAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgd2UncmUgaW5zaWRlIGFuIGFzeW5jIGFjdGlvbiBzY29wZS4gSWYgc28sIHdlJ2xsIGVudGFuZ2xlXG4gICAgICAvLyB0aGlzIG5ldyBhY3Rpb24gd2l0aCB0aGUgZXhpc3Rpbmcgc2NvcGUuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UncmUgbm90IGFscmVhZHkgaW5zaWRlIGFuIGFzeW5jIGFjdGlvbiBzY29wZSwgYW5kIHRoaXMgYWN0aW9uIGlzXG4gICAgICAvLyBhc3luYywgdGhlbiB3ZSdsbCBjcmVhdGUgYSBuZXcgYXN5bmMgc2NvcGUuXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGFzeW5jIGNhc2UsIHRoZSByZXN1bHRpbmcgcmVuZGVyIHdpbGwgc3VzcGVuZCB1bnRpbCB0aGUgYXN5bmNcbiAgICAgIC8vIGFjdGlvbiBzY29wZSBoYXMgZmluaXNoZWQuXG5cblxuICAgICAgaWYgKHJldHVyblZhbHVlICE9PSBudWxsICYmIHR5cGVvZiByZXR1cm5WYWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gcmV0dXJuVmFsdWU7IC8vIENyZWF0ZSBhIHRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gYGZpbmlzaGVkU3RhdGVgIG9uY2UgdGhlIGFzeW5jXG4gICAgICAgIC8vIGFjdGlvbiBoYXMgY29tcGxldGVkLlxuXG4gICAgICAgIHZhciB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUgPSBjaGFpblRoZW5hYmxlVmFsdWUodGhlbmFibGUsIGZpbmlzaGVkU3RhdGUpO1xuICAgICAgICBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoU2V0U3RhdGUoZmliZXIsIHF1ZXVlLCBmaW5pc2hlZFN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAge1xuICAgICAgLy8gVGhpcyBpcyBhIHRyaWNrIHRvIGdldCB0aGUgYHVzZVRyYW5zaXRpb25gIGhvb2sgdG8gcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAvLyBXaGVuIGl0IHVud3JhcHMgdGhlIHRoZW5hYmxlIHdpdGggdGhlIGB1c2VgIGFsZ29yaXRobSwgdGhlIGVycm9yXG4gICAgICAvLyB3aWxsIGJlIHRocm93bi5cbiAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgc3RhdHVzOiAncmVqZWN0ZWQnLFxuICAgICAgICByZWFzb246IGVycm9yXG4gICAgICB9O1xuICAgICAgZGlzcGF0Y2hTZXRTdGF0ZShmaWJlciwgcXVldWUsIHJlamVjdGVkVGhlbmFibGUpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIHN0YXJ0SG9zdFRyYW5zaXRpb24oZm9ybUZpYmVyLCBwZW5kaW5nU3RhdGUsIGFjdGlvbiwgZm9ybURhdGEpIHtcblxuICBpZiAoZm9ybUZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGZvcm0gaW5zdGFuY2UgdG8gYmUgYSBIb3N0Q29tcG9uZW50LiBUaGlzICcgKyAnaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICB2YXIgc3RhdGVIb29rID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKTtcbiAgdmFyIHF1ZXVlID0gc3RhdGVIb29rLnF1ZXVlO1xuICBzdGFydFRyYW5zaXRpb24oZm9ybUZpYmVyLCBxdWV1ZSwgcGVuZGluZ1N0YXRlLCBOb3RQZW5kaW5nVHJhbnNpdGlvbiwgLy8gVE9ETzogYHN0YXJ0VHJhbnNpdGlvbmAgYm90aCBzZXRzIHRoZSBwZW5kaW5nIHN0YXRlIGFuZCBkaXNwYXRjaGVzXG4gIC8vIHRoZSBhY3Rpb24sIGlmIG9uZSBpcyBwcm92aWRlZC4gQ29uc2lkZXIgcmVmYWN0b3JpbmcgdGhlc2UgdHdvXG4gIC8vIGNvbmNlcm5zIHRvIGF2b2lkIHRoZSBleHRyYSBsYW1iZGEuXG4gIGFjdGlvbiA9PT0gbnVsbCA/IC8vIE5vIGFjdGlvbiB3YXMgcHJvdmlkZWQsIGJ1dCB3ZSBzdGlsbCBjYWxsIGBzdGFydFRyYW5zaXRpb25gIHRvXG4gIC8vIHNldCB0aGUgcGVuZGluZyBmb3JtIHN0YXR1cy5cbiAgbm9vcCA6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBdXRvbWF0aWNhbGx5IHJlc2V0IHRoZSBmb3JtIHdoZW4gdGhlIGFjdGlvbiBjb21wbGV0ZXMuXG4gICAgcmVxdWVzdEZvcm1SZXNldChmb3JtRmliZXIpO1xuICAgIHJldHVybiBhY3Rpb24oZm9ybURhdGEpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKSB7XG4gIHZhciBleGlzdGluZ1N0YXRlSG9vayA9IGZvcm1GaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChleGlzdGluZ1N0YXRlSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgZmliZXIgd2FzIGFscmVhZHkgdXBncmFkZWQgdG8gYmUgc3RhdGVmdWwuXG4gICAgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xuICB9IC8vIFVwZ3JhZGUgdGhpcyBob3N0IGNvbXBvbmVudCBmaWJlciB0byBiZSBzdGF0ZWZ1bC4gV2UncmUgZ29pbmcgdG8gcHJldGVuZFxuICAvLyBpdCB3YXMgc3RhdGVmdWwgYWxsIGFsb25nIHNvIHdlIGNhbiByZXVzZSBtb3N0IG9mIHRoZSBpbXBsZW1lbnRhdGlvblxuICAvLyBmb3IgZnVuY3Rpb24gY29tcG9uZW50cyBhbmQgdXNlVHJhbnNpdGlvbi5cbiAgLy9cbiAgLy8gQ3JlYXRlIHRoZSBzdGF0ZSBob29rIHVzZWQgYnkgVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudC4gVGhpcyBpc1xuICAvLyBlc3NlbnRpYWxseSBhbiBpbmxpbmVkIHZlcnNpb24gb2YgbW91bnRTdGF0ZS5cblxuXG4gIHZhciBuZXdRdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNoZWF0IGFuZCBpbnRlbnRpb25hbGx5IG5vdCBjcmVhdGUgYSBib3VuZCBkaXNwYXRjaFxuICAgIC8vIG1ldGhvZCwgYmVjYXVzZSB3ZSBjYW4gY2FsbCBpdCBkaXJlY3RseSBpbiBzdGFydFRyYW5zaXRpb24uXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uXG4gIH07XG4gIHZhciBzdGF0ZUhvb2sgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgYmFzZVN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG5ld1F1ZXVlLFxuICAgIG5leHQ6IG51bGxcbiAgfTsgLy8gV2UgdXNlIGFub3RoZXIgc3RhdGUgaG9vayB0byB0cmFjayB3aGV0aGVyIHRoZSBmb3JtIG5lZWRzIHRvIGJlIHJlc2V0LlxuICAvLyBUaGUgc3RhdGUgaXMgYW4gZW1wdHkgb2JqZWN0LiBUbyB0cmlnZ2VyIGEgcmVzZXQsIHdlIHVwZGF0ZSB0aGUgc3RhdGVcbiAgLy8gdG8gYSBuZXcgb2JqZWN0LiBUaGVuIGR1cmluZyByZW5kZXJpbmcsIHdlIGRldGVjdCB0aGF0IHRoZSBzdGF0ZSBoYXNcbiAgLy8gY2hhbmdlZCBhbmQgc2NoZWR1bGUgYSBjb21taXQgZWZmZWN0LlxuXG4gIHZhciBpbml0aWFsUmVzZXRTdGF0ZSA9IHt9O1xuICB2YXIgbmV3UmVzZXRTdGF0ZVF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgLy8gV2UncmUgZ29pbmcgdG8gY2hlYXQgYW5kIGludGVudGlvbmFsbHkgbm90IGNyZWF0ZSBhIGJvdW5kIGRpc3BhdGNoXG4gICAgLy8gbWV0aG9kLCBiZWNhdXNlIHdlIGNhbiBjYWxsIGl0IGRpcmVjdGx5IGluIHN0YXJ0VHJhbnNpdGlvbi5cbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGVcbiAgfTtcbiAgdmFyIHJlc2V0U3RhdGVIb29rID0ge1xuICAgIG1lbW9pemVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgIGJhc2VTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgIHF1ZXVlOiBuZXdSZXNldFN0YXRlUXVldWUsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBzdGF0ZUhvb2submV4dCA9IHJlc2V0U3RhdGVIb29rOyAvLyBBZGQgdGhlIGhvb2sgbGlzdCB0byBib3RoIGZpYmVyIGFsdGVybmF0ZXMuIFRoZSBpZGVhIGlzIHRoYXQgdGhlIGZpYmVyXG4gIC8vIGhhZCB0aGlzIGhvb2sgYWxsIGFsb25nLlxuXG4gIGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gc3RhdGVIb29rO1xuICB2YXIgYWx0ZXJuYXRlID0gZm9ybUZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2s7XG4gIH1cblxuICByZXR1cm4gc3RhdGVIb29rO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0Rm9ybVJlc2V0KGZvcm1GaWJlcikge1xuICB2YXIgdHJhbnNpdGlvbiA9IHJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbigpO1xuXG4gIHtcbiAgICBpZiAodHJhbnNpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgLy8gQW4gb3B0aW1pc3RpYyB1cGRhdGUgb2NjdXJyZWQsIGJ1dCBzdGFydFRyYW5zaXRpb24gaXMgbm90IG9uIHRoZSBzdGFjay5cbiAgICAgIC8vIFRoZSBmb3JtIHJlc2V0IHdpbGwgYmUgc2NoZWR1bGVkIGF0IGRlZmF1bHQgKHN5bmMpIHByaW9yaXR5LCB3aGljaFxuICAgICAgLy8gaXMgcHJvYmFibHkgbm90IHdoYXQgdGhlIHVzZXIgaW50ZW5kZWQuIE1vc3QgbGlrZWx5IGJlY2F1c2UgdGhlXG4gICAgICAvLyByZXF1ZXN0Rm9ybVJlc2V0IGNhbGwgaGFwcGVuZWQgYWZ0ZXIgYW4gYGF3YWl0YC5cbiAgICAgIC8vIFRPRE86IFRoZW9yZXRpY2FsbHksIHJlcXVlc3RGb3JtUmVzZXQgaXMgc3RpbGwgdXNlZnVsIGV2ZW4gZm9yXG4gICAgICAvLyBub24tdHJhbnNpdGlvbiB1cGRhdGVzIGJlY2F1c2UgaXQgYWxsb3dzIHlvdSB0byB1cGRhdGUgZGVmYXVsdFZhbHVlXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IGFuZCB0aGVuIHdhaXQgdG8gcmVzZXQgdW50aWwgYWZ0ZXIgdGhlIHVwZGF0ZSBjb21taXRzLlxuICAgICAgLy8gSSd2ZSBjaG9zZW4gdG8gd2FybiBhbnl3YXkgYmVjYXVzZSBpdCdzIG1vcmUgbGlrZWx5IHRoZSBgYXdhaXRgIG1pc3Rha2VcbiAgICAgIC8vIGRlc2NyaWJlZCBhYm92ZS4gQnV0IGFyZ3VhYmx5IHdlIHNob3VsZG4ndC5cbiAgICAgIGVycm9yKCdyZXF1ZXN0Rm9ybVJlc2V0IHdhcyBjYWxsZWQgb3V0c2lkZSBhIHRyYW5zaXRpb24gb3IgYWN0aW9uLiBUbyAnICsgJ2ZpeCwgbW92ZSB0byBhbiBhY3Rpb24sIG9yIHdyYXAgd2l0aCBzdGFydFRyYW5zaXRpb24uJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlSG9vayA9IGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcik7XG4gIHZhciBuZXdSZXNldFN0YXRlID0ge307XG4gIHZhciByZXNldFN0YXRlSG9vayA9IHN0YXRlSG9vay5uZXh0O1xuICB2YXIgcmVzZXRTdGF0ZVF1ZXVlID0gcmVzZXRTdGF0ZUhvb2sucXVldWU7XG4gIGRpc3BhdGNoU2V0U3RhdGUoZm9ybUZpYmVyLCByZXNldFN0YXRlUXVldWUsIG5ld1Jlc2V0U3RhdGUpO1xufVxuXG5mdW5jdGlvbiBtb3VudFRyYW5zaXRpb24oKSB7XG4gIHZhciBzdGF0ZUhvb2sgPSBtb3VudFN0YXRlSW1wbChmYWxzZSk7IC8vIFRoZSBgc3RhcnRgIG1ldGhvZCBuZXZlciBjaGFuZ2VzLlxuXG4gIHZhciBzdGFydCA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHN0YXRlSG9vay5xdWV1ZSwgdHJ1ZSwgZmFsc2UpO1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHN0YXJ0O1xuICByZXR1cm4gW2ZhbHNlLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gIHZhciBfdXBkYXRlU3RhdGUyID0gdXBkYXRlU3RhdGUoKSxcbiAgICAgIGJvb2xlYW5PclRoZW5hYmxlID0gX3VwZGF0ZVN0YXRlMlswXTtcblxuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgc3RhcnQgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciBpc1BlbmRpbmcgPSB0eXBlb2YgYm9vbGVhbk9yVGhlbmFibGUgPT09ICdib29sZWFuJyA/IGJvb2xlYW5PclRoZW5hYmxlIDogLy8gVGhpcyB3aWxsIHN1c3BlbmQgdW50aWwgdGhlIGFzeW5jIGFjdGlvbiBzY29wZSBoYXMgZmluaXNoZWQuXG4gIHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUgPSByZXJlbmRlclN0YXRlKCksXG4gICAgICBib29sZWFuT3JUaGVuYWJsZSA9IF9yZXJlbmRlclN0YXRlWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGlzUGVuZGluZyA9IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZSA9PT0gJ2Jvb2xlYW4nID8gYm9vbGVhbk9yVGhlbmFibGUgOiAvLyBUaGlzIHdpbGwgc3VzcGVuZCB1bnRpbCB0aGUgYXN5bmMgYWN0aW9uIHNjb3BlIGhhcyBmaW5pc2hlZC5cbiAgdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpO1xuICByZXR1cm4gW2lzUGVuZGluZywgc3RhcnRdO1xufVxuXG5mdW5jdGlvbiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpIHtcblxuICB2YXIgc3RhdHVzID0gcmVhZENvbnRleHQoSG9zdFRyYW5zaXRpb25Db250ZXh0KTtcbiAgcmV0dXJuIHN0YXR1cyAhPT0gbnVsbCA/IHN0YXR1cyA6IE5vdFBlbmRpbmdUcmFuc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBtb3VudElkKCkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7IC8vIFRPRE86IEluIEZpenosIGlkIGdlbmVyYXRpb24gaXMgc3BlY2lmaWMgdG8gZWFjaCBzZXJ2ZXIgY29uZmlnLiBNYXliZSB3ZVxuICAvLyBzaG91bGQgZG8gdGhpcyBpbiBGaWJlciwgdG9vPyBEZWZlcnJpbmcgdGhpcyBkZWNpc2lvbiBmb3Igbm93IGJlY2F1c2VcbiAgLy8gdGhlcmUncyBubyBvdGhlciBwbGFjZSB0byBzdG9yZSB0aGUgcHJlZml4IGV4Y2VwdCBmb3IgYW4gaW50ZXJuYWwgZmllbGQgb25cbiAgLy8gdGhlIHB1YmxpYyBjcmVhdGVSb290IG9iamVjdCwgd2hpY2ggdGhlIGZpYmVyIHRyZWUgZG9lcyBub3QgY3VycmVudGx5IGhhdmVcbiAgLy8gYSByZWZlcmVuY2UgdG8uXG5cbiAgdmFyIGlkZW50aWZpZXJQcmVmaXggPSByb290LmlkZW50aWZpZXJQcmVmaXg7XG4gIHZhciBpZDtcblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIHZhciB0cmVlSWQgPSBnZXRUcmVlSWQoKTsgLy8gVXNlIGEgY2FwdGlhbCBSIHByZWZpeCBmb3Igc2VydmVyLWdlbmVyYXRlZCBpZHMuXG5cbiAgICBpZCA9ICc6JyArIGlkZW50aWZpZXJQcmVmaXggKyAnUicgKyB0cmVlSWQ7IC8vIFVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCBpZCBhdCB0aGlzIGxldmVsLCBhcHBlbmQgYSBudW1iZXIgYXQgdGhlIGVuZFxuICAgIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VJZCBob29rIGFtb25nIGFsbCB0aGUgdXNlSWRcbiAgICAvLyBob29rcyBmb3IgdGhpcyBmaWJlci5cblxuICAgIHZhciBsb2NhbElkID0gbG9jYWxJZENvdW50ZXIrKztcblxuICAgIGlmIChsb2NhbElkID4gMCkge1xuICAgICAgaWQgKz0gJ0gnICsgbG9jYWxJZC50b1N0cmluZygzMik7XG4gICAgfVxuXG4gICAgaWQgKz0gJzonO1xuICB9IGVsc2Uge1xuICAgIC8vIFVzZSBhIGxvd2VyY2FzZSByIHByZWZpeCBmb3IgY2xpZW50LWdlbmVyYXRlZCBpZHMuXG4gICAgdmFyIGdsb2JhbENsaWVudElkID0gZ2xvYmFsQ2xpZW50SWRDb3VudGVyKys7XG4gICAgaWQgPSAnOicgKyBpZGVudGlmaWVyUHJlZml4ICsgJ3InICsgZ2xvYmFsQ2xpZW50SWQudG9TdHJpbmcoMzIpICsgJzonO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaWQ7XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSWQoKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBpZCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZnJlc2goKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJlZnJlc2ggPSBob29rLm1lbW9pemVkU3RhdGUgPSByZWZyZXNoQ2FjaGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgcmV0dXJuIHJlZnJlc2g7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZnJlc2goKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBob29rLm1lbW9pemVkU3RhdGU7XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2hDYWNoZShmaWJlciwgc2VlZEtleSwgc2VlZFZhbHVlKSB7XG4gIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgaWYgdGhlIHJlZnJlc2ggaXMgYXQgZGlzY3JldGUgcHJpb3JpdHksIG9yIGlmIHdlXG4gIC8vIG90aGVyd2lzZSBzdXNwZWN0IHRoYXQgaXQgd2Fzbid0IGJhdGNoZWQgcHJvcGVybHkuXG5cblxuICB2YXIgcHJvdmlkZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChwcm92aWRlci50YWcpIHtcbiAgICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjYWNoZSBib3VuZGFyeSB0byB0cmlnZ2VyIGEgcmVmcmVzaC5cbiAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKHByb3ZpZGVyKTtcbiAgICAgICAgICB2YXIgcmVmcmVzaFVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocHJvdmlkZXIsIHJlZnJlc2hVcGRhdGUsIGxhbmUpO1xuXG4gICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBwcm92aWRlciwgbGFuZSk7XG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIHByb3ZpZGVyLCBsYW5lKTtcbiAgICAgICAgICB9IC8vIFRPRE86IElmIGEgcmVmcmVzaCBuZXZlciBjb21taXRzLCB0aGUgbmV3IGNhY2hlIGNyZWF0ZWQgaGVyZSBtdXN0IGJlXG4gICAgICAgICAgLy8gcmVsZWFzZWQuIEEgc2ltcGxlIGNhc2UgaXMgc3RhcnQgcmVmcmVzaGluZyBhIGNhY2hlIGJvdW5kYXJ5LCBidXQgdGhlblxuICAgICAgICAgIC8vIHVubW91bnQgdGhhdCBib3VuZGFyeSBiZWZvcmUgdGhlIHJlZnJlc2ggY29tcGxldGVzLlxuXG5cbiAgICAgICAgICB2YXIgc2VlZGVkQ2FjaGUgPSBjcmVhdGVDYWNoZSgpO1xuXG4gICAgICAgICAgaWYgKHNlZWRLZXkgIT09IG51bGwgJiYgc2VlZEtleSAhPT0gdW5kZWZpbmVkICYmIHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVycm9yKCdUaGUgc2VlZCBhcmd1bWVudCBpcyBub3QgZW5hYmxlZCBvdXRzaWRlIGV4cGVyaW1lbnRhbCBjaGFubmVscy4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgY2FjaGU6IHNlZWRlZENhY2hlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWZyZXNoVXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3ZpZGVyID0gcHJvdmlkZXIucmV0dXJuO1xuICB9IC8vIFRPRE86IFdhcm4gaWYgdW5tb3VudGVkP1xuXG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoUmVkdWNlckFjdGlvbihmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICByZXZlcnRMYW5lOiBOb0xhbmUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgaGFzRWFnZXJTdGF0ZTogZmFsc2UsXG4gICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKTtcbiAgICB9XG4gIH1cblxuICBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGUoZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiICsgJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcgKyAncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgdXBkYXRlID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgcmV2ZXJ0TGFuZTogTm9MYW5lLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6IGZhbHNlLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGZpYmVyLmxhbmVzID09PSBOb0xhbmVzICYmIChhbHRlcm5hdGUgPT09IG51bGwgfHwgYWx0ZXJuYXRlLmxhbmVzID09PSBOb0xhbmVzKSkge1xuICAgICAgLy8gVGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBlbXB0eSwgd2hpY2ggbWVhbnMgd2UgY2FuIGVhZ2VybHkgY29tcHV0ZSB0aGVcbiAgICAgIC8vIG5leHQgc3RhdGUgYmVmb3JlIGVudGVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIElmIHRoZSBuZXcgc3RhdGUgaXMgdGhlXG4gICAgICAvLyBzYW1lIGFzIHRoZSBjdXJyZW50IHN0YXRlLCB3ZSBtYXkgYmUgYWJsZSB0byBiYWlsIG91dCBlbnRpcmVseS5cbiAgICAgIHZhciBsYXN0UmVuZGVyZWRSZWR1Y2VyID0gcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlcjtcblxuICAgICAgaWYgKGxhc3RSZW5kZXJlZFJlZHVjZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gbnVsbDtcblxuICAgICAgICB7XG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlO1xuICAgICAgICAgIHZhciBlYWdlclN0YXRlID0gbGFzdFJlbmRlcmVkUmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7IC8vIFN0YXNoIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlLCBhbmQgdGhlIHJlZHVjZXIgdXNlZCB0byBjb21wdXRlXG4gICAgICAgICAgLy8gaXQsIG9uIHRoZSB1cGRhdGUgb2JqZWN0LiBJZiB0aGUgcmVkdWNlciBoYXNuJ3QgY2hhbmdlZCBieSB0aGVcbiAgICAgICAgICAvLyB0aW1lIHdlIGVudGVyIHRoZSByZW5kZXIgcGhhc2UsIHRoZW4gdGhlIGVhZ2VyIHN0YXRlIGNhbiBiZSB1c2VkXG4gICAgICAgICAgLy8gd2l0aG91dCBjYWxsaW5nIHRoZSByZWR1Y2VyIGFnYWluLlxuXG4gICAgICAgICAgdXBkYXRlLmhhc0VhZ2VyU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcblxuICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKSB7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGguIFdlIGNhbiBiYWlsIG91dCB3aXRob3V0IHNjaGVkdWxpbmcgUmVhY3QgdG8gcmUtcmVuZGVyLlxuICAgICAgICAgICAgLy8gSXQncyBzdGlsbCBwb3NzaWJsZSB0aGF0IHdlJ2xsIG5lZWQgdG8gcmViYXNlIHRoaXMgdXBkYXRlIGxhdGVyLFxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzIGZvciBhIGRpZmZlcmVudCByZWFzb24gYW5kIGJ5IHRoYXRcbiAgICAgICAgICAgIC8vIHRpbWUgdGhlIHJlZHVjZXIgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBEbyB3ZSBzdGlsbCBuZWVkIHRvIGVudGFuZ2xlIHRyYW5zaXRpb25zIGluIHRoaXMgY2FzZT9cbiAgICAgICAgICAgIGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZUFuZEVhZ2VybHlCYWlsb3V0KGZpYmVyLCBxdWV1ZSwgdXBkYXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3VwcHJlc3MgdGhlIGVycm9yLiBJdCB3aWxsIHRocm93IGFnYWluIGluIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKTtcbiAgICB9XG4gIH1cblxuICBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCB0aHJvd0lmRHVyaW5nUmVuZGVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCk7XG5cbiAge1xuICAgIGlmICh0cmFuc2l0aW9uID09PSBudWxsKSB7XG4gICAgICAvLyBBbiBvcHRpbWlzdGljIHVwZGF0ZSBvY2N1cnJlZCwgYnV0IHN0YXJ0VHJhbnNpdGlvbiBpcyBub3Qgb24gdGhlIHN0YWNrLlxuICAgICAgLy8gVGhlcmUgYXJlIHR3byBsaWtlbHkgc2NlbmFyaW9zLlxuICAgICAgLy8gT25lIHBvc3NpYmlsaXR5IGlzIHRoYXQgdGhlIG9wdGltaXN0aWMgdXBkYXRlIGlzIHRyaWdnZXJlZCBieSBhIHJlZ3VsYXJcbiAgICAgIC8vIGV2ZW50IGhhbmRsZXIgKGUuZy4gYG9uU3VibWl0YCkgaW5zdGVhZCBvZiBhbiBhY3Rpb24uIFRoaXMgaXMgYSBtaXN0YWtlXG4gICAgICAvLyBhbmQgd2Ugd2lsbCB3YXJuLlxuICAgICAgLy8gVGhlIG90aGVyIHBvc3NpYmlsaXR5IGlzIHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpcyBpbnNpZGUgYW4gYXN5bmNcbiAgICAgIC8vIGFjdGlvbiwgYnV0IGFmdGVyIGFuIGBhd2FpdGAuIEluIHRoaXMgY2FzZSwgd2UgY2FuIG1ha2UgaXQgXCJqdXN0IHdvcmtcIlxuICAgICAgLy8gYnkgYXNzb2NpYXRpbmcgdGhlIG9wdGltaXN0aWMgdXBkYXRlIHdpdGggdGhlIHBlbmRpbmcgYXN5bmMgYWN0aW9uLlxuICAgICAgLy8gVGVjaG5pY2FsbHkgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpcyB1bnJlbGF0ZWQgdG9cbiAgICAgIC8vIHRoZSBwZW5kaW5nIGFjdGlvbiwgYnV0IHdlIGRvbid0IGhhdmUgYSB3YXkgb2Yga25vd2luZyB0aGlzIGZvciBzdXJlXG4gICAgICAvLyBiZWNhdXNlIGJyb3dzZXJzIGN1cnJlbnRseSBkbyBub3QgcHJvdmlkZSBhIHdheSB0byB0cmFjayBhc3luYyBzY29wZS5cbiAgICAgIC8vIChUaGUgQXN5bmNDb250ZXh0IHByb3Bvc2FsLCBpZiBpdCBsYW5kcywgd2lsbCBzb2x2ZSB0aGlzIGluIHRoZVxuICAgICAgLy8gZnV0dXJlLikgSG93ZXZlciwgdGhpcyBpcyBubyBkaWZmZXJlbnQgdGhhbiB0aGUgcHJvYmxlbSBvZiB1bnJlbGF0ZWRcbiAgICAgIC8vIHRyYW5zaXRpb25zIGJlaW5nIGdyb3VwZWQgdG9nZXRoZXIg4oCUIGl0J3Mgbm90IHdyb25nIHBlciBzZSwgYnV0IGl0J3NcbiAgICAgIC8vIG5vdCBpZGVhbC5cbiAgICAgIC8vIE9uY2UgQXN5bmNDb250ZXh0IHN0YXJ0cyBsYW5kaW5nIGluIGJyb3dzZXJzLCB3ZSB3aWxsIHByb3ZpZGUgYmV0dGVyXG4gICAgICAvLyB3YXJuaW5ncyBpbiBkZXZlbG9wbWVudCBmb3IgdGhlc2UgY2FzZXMuXG4gICAgICBpZiAocGVla0VudGFuZ2xlZEFjdGlvbkxhbmUoKSAhPT0gTm9MYW5lKSA7IGVsc2Uge1xuICAgICAgICAvLyBUaGVyZSdzIG5vIHBlbmRpbmcgYXN5bmMgYWN0aW9uLiBUaGUgbW9zdCBsaWtlbHkgY2F1c2UgaXMgdGhhdCB3ZSdyZVxuICAgICAgICAvLyBpbnNpZGUgYSByZWd1bGFyIGV2ZW50IGhhbmRsZXIgKGUuZy4gb25TdWJtaXQpIGluc3RlYWQgb2YgYW4gYWN0aW9uLlxuICAgICAgICBlcnJvcignQW4gb3B0aW1pc3RpYyBzdGF0ZSB1cGRhdGUgb2NjdXJyZWQgb3V0c2lkZSBhIHRyYW5zaXRpb24gb3IgJyArICdhY3Rpb24uIFRvIGZpeCwgbW92ZSB0aGUgdXBkYXRlIHRvIGFuIGFjdGlvbiwgb3Igd3JhcCAnICsgJ3dpdGggc3RhcnRUcmFuc2l0aW9uLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGUgPSB7XG4gICAgLy8gQW4gb3B0aW1pc3RpYyB1cGRhdGUgY29tbWl0cyBzeW5jaHJvbm91c2x5LlxuICAgIGxhbmU6IFN5bmNMYW5lLFxuICAgIC8vIEFmdGVyIGNvbW1pdHRpbmcsIHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpcyBcInJldmVydGVkXCIgdXNpbmcgdGhlIHNhbWVcbiAgICAvLyBsYW5lIGFzIHRoZSB0cmFuc2l0aW9uIGl0J3MgYXNzb2NpYXRlZCB3aXRoLlxuICAgIHJldmVydExhbmU6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6IGZhbHNlLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgIC8vIFdoZW4gY2FsbGluZyBzdGFydFRyYW5zaXRpb24gZHVyaW5nIHJlbmRlciwgdGhpcyB3YXJucyBpbnN0ZWFkIG9mXG4gICAgLy8gdGhyb3dpbmcgYmVjYXVzZSB0aHJvd2luZyB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZS4gc2V0T3B0aW1pc3RpY1N0YXRlXG4gICAgLy8gaXMgYSBuZXcgQVBJIHNvIGl0J3MgT0sgdG8gdGhyb3cuXG4gICAgaWYgKHRocm93SWZEdXJpbmdSZW5kZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBvcHRpbWlzdGljIHN0YXRlIHdoaWxlIHJlbmRlcmluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RhcnRUcmFuc2l0aW9uIHdhcyBjYWxsZWQgZHVyaW5nIHJlbmRlci4gV2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgLy8gYmVzaWRlcyB3YXJuIGhlcmUgYmVjYXVzZSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZSB3b3VsZCBiZSBvdmVyaWRkZW4gYnlcbiAgICAgIC8vIHRoZSBzZWNvbmQgdXBkYXRlLCBhbnl3YXkuIFdlIGNhbiByZW1vdmUgdGhpcyBicmFuY2ggYW5kIG1ha2UgaXQgdGhyb3dcbiAgICAgIC8vIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgICB7XG4gICAgICAgIGVycm9yKCdDYW5ub3QgY2FsbCBzdGFydFRyYW5zaXRpb24gd2hpbGUgcmVuZGVyaW5nLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgU3luY0xhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIC8vIE5PVEU6IFRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHRyYW5zaXRpb25cbiAgICAgIC8vIHdpbGwgbmV2ZXIgYmUgYXR0ZW1wdGVkIGJlZm9yZSB0aGUgb3B0aW1pc3RpYyB1cGRhdGUuIFRoaXMgY3VycmVudGx5XG4gICAgICAvLyBob2xkcyBiZWNhdXNlIHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpcyBhbHdheXMgc3luY2hyb25vdXMuIElmIHdlIGV2ZXJcbiAgICAgIC8vIGNoYW5nZSB0aGF0LCB3ZSdsbCBuZWVkIHRvIGFjY291bnQgZm9yIHRoaXMuXG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTsgLy8gT3B0aW1pc3RpYyB1cGRhdGVzIGFyZSBhbHdheXMgc3luY2hyb25vdXMsIHNvIHdlIGRvbid0IG5lZWQgdG8gY2FsbFxuICAgICAgLy8gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlIGhlcmUuXG4gICAgfVxuICB9XG5cbiAgbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIFN5bmNMYW5lKTtcbn1cblxuZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICByZXR1cm4gZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbiAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbn0gLy8gVE9ETzogTW92ZSB0byBSZWFjdEZpYmVyQ29uY3VycmVudFVwZGF0ZXM/XG5cblxuZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKSB7XG4gIGlmIChpc1RyYW5zaXRpb25MYW5lKGxhbmUpKSB7XG4gICAgdmFyIHF1ZXVlTGFuZXMgPSBxdWV1ZS5sYW5lczsgLy8gSWYgYW55IGVudGFuZ2xlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIHBlbmRpbmcgb24gdGhlIHJvb3QsIHRoZW4gdGhleVxuICAgIC8vIG11c3QgaGF2ZSBmaW5pc2hlZC4gV2UgY2FuIHJlbW92ZSB0aGVtIGZyb20gdGhlIHNoYXJlZCBxdWV1ZSwgd2hpY2hcbiAgICAvLyByZXByZXNlbnRzIGEgc3VwZXJzZXQgb2YgdGhlIGFjdHVhbGx5IHBlbmRpbmcgbGFuZXMuIEluIHNvbWUgY2FzZXMgd2VcbiAgICAvLyBtYXkgZW50YW5nbGUgbW9yZSB0aGFuIHdlIG5lZWQgdG8sIGJ1dCB0aGF0J3MgT0suIEluIGZhY3QgaXQncyB3b3JzZSBpZlxuICAgIC8vIHdlICpkb24ndCogZW50YW5nbGUgd2hlbiB3ZSBzaG91bGQuXG5cbiAgICBxdWV1ZUxhbmVzID0gaW50ZXJzZWN0TGFuZXMocXVldWVMYW5lcywgcm9vdC5wZW5kaW5nTGFuZXMpOyAvLyBFbnRhbmdsZSB0aGUgbmV3IHRyYW5zaXRpb24gbGFuZSB3aXRoIHRoZSBvdGhlciB0cmFuc2l0aW9uIGxhbmVzLlxuXG4gICAgdmFyIG5ld1F1ZXVlTGFuZXMgPSBtZXJnZUxhbmVzKHF1ZXVlTGFuZXMsIGxhbmUpO1xuICAgIHF1ZXVlLmxhbmVzID0gbmV3UXVldWVMYW5lczsgLy8gRXZlbiBpZiBxdWV1ZS5sYW5lcyBhbHJlYWR5IGluY2x1ZGUgbGFuZSwgd2UgZG9uJ3Qga25vdyBmb3IgY2VydGFpbiBpZlxuICAgIC8vIHRoZSBsYW5lIGZpbmlzaGVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2UgZW50YW5nbGVkIGl0LiBTbyB3ZSBuZWVkIHRvXG4gICAgLy8gZW50YW5nbGUgaXQgYWdhaW4sIGp1c3QgdG8gYmUgc3VyZS5cblxuICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIG5ld1F1ZXVlTGFuZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBsYW5lLCBhY3Rpb24pIHtcblxuICB7XG4gICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgfVxufVxuXG52YXIgQ29udGV4dE9ubHlEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZTogdXNlLFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJZDogdGhyb3dJbnZhbGlkSG9va0Vycm9yXG59O1xuXG57XG4gIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VDYWNoZVJlZnJlc2ggPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG59XG5cbntcbiAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZU1lbW9DYWNoZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbn1cblxue1xuICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VGb3JtU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VBY3Rpb25TdGF0ZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbn1cblxue1xuICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlT3B0aW1pc3RpYyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbn1cblxudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG5cbntcbiAgdmFyIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gIH07XG5cbiAgdmFyIHdhcm5JbnZhbGlkSG9va0FjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogdXNlLFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiB1c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRm9ybVN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUFjdGlvblN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gIH1cblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiB1c2UsXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VBY3Rpb25TdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICB9XG5cbiAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogdXNlLFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUlkKCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5cbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VBY3Rpb25TdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICB9XG5cbiAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiB1c2UsXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcHRpbWlzdGljJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgfVxuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU1lbW9DYWNoZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5cbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG5cbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICB9XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU1lbW9DYWNoZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuXG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcblxuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICB9XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlTWVtb0NhY2hlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUFjdGlvblN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBjb21taXRUaW1lID0gMDtcbnZhciBsYXlvdXRFZmZlY3RTdGFydFRpbWUgPSAtMTtcbnZhciBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xudmFyIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSAtMTtcbi8qKlxuICogVHJhY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXBkYXRlIHdhcyBhIG5lc3RlZC9jYXNjYWRpbmcgdXBkYXRlIChzY2hlZHVsZWQgZnJvbSBhIGxheW91dCBlZmZlY3QpLlxuICpcbiAqIFRoZSBvdmVyYWxsIHNlcXVlbmNlIGlzOlxuICogICAxLiByZW5kZXJcbiAqICAgMi4gY29tbWl0IChhbmQgY2FsbCBgb25SZW5kZXJgLCBgb25Db21taXRgKVxuICogICAzLiBjaGVjayBmb3IgbmVzdGVkIHVwZGF0ZXNcbiAqICAgNC4gZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIChhbmQgY2FsbCBgb25Qb3N0Q29tbWl0YClcbiAqXG4gKiBOZXN0ZWQgdXBkYXRlcyBhcmUgaWRlbnRpZmllZCBpbiBzdGVwIDMgYWJvdmUsXG4gKiBidXQgc3RlcCA0IHN0aWxsIGFwcGxpZXMgdG8gdGhlIHdvcmsgdGhhdCB3YXMganVzdCBjb21taXR0ZWQuXG4gKiBXZSB1c2UgdHdvIGZsYWdzIHRvIHRyYWNrIG5lc3RlZCB1cGRhdGVzIHRoZW46XG4gKiBvbmUgdHJhY2tzIHdoZXRoZXIgdGhlIHVwY29taW5nIHVwZGF0ZSBpcyBhIG5lc3RlZCB1cGRhdGUsXG4gKiBhbmQgdGhlIG90aGVyIHRyYWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVwZGF0ZSB3YXMgYSBuZXN0ZWQgdXBkYXRlLlxuICogVGhlIGZpcnN0IHZhbHVlIGdldHMgc3luY2VkIHRvIHRoZSBzZWNvbmQgYXQgdGhlIHN0YXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UuXG4gKi9cblxudmFyIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IGZhbHNlO1xudmFyIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSB7XG4gIHJldHVybiBjdXJyZW50VXBkYXRlSXNOZXN0ZWQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtOZXN0ZWRVcGRhdGVTY2hlZHVsZWQoKSB7XG4gIHtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0TmVzdGVkVXBkYXRlRmxhZygpIHtcbiAge1xuICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN5bmNOZXN0ZWRVcGRhdGVGbGFnKCkge1xuICB7XG4gICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gbmVzdGVkVXBkYXRlU2NoZWR1bGVkO1xuICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbW1pdFRpbWUoKSB7XG4gIHJldHVybiBjb21taXRUaW1lO1xufVxuXG5mdW5jdGlvbiByZWNvcmRDb21taXRUaW1lKCkge1xuXG4gIGNvbW1pdFRpbWUgPSBub3coKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3coKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShmaWJlciwgb3ZlcnJpZGVCYXNlVGltZSkge1xuXG4gIGlmIChwcm9maWxlclN0YXJ0VGltZSA+PSAwKSB7XG4gICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcblxuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuXG4gICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcikge1xuXG4gIGlmIChsYXlvdXRFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gbGF5b3V0RWZmZWN0U3RhcnRUaW1lO1xuICAgIGxheW91dEVmZmVjdFN0YXJ0VGltZSA9IC0xOyAvLyBTdG9yZSBkdXJhdGlvbiBvbiB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yXG4gICAgLy8gT3IgdGhlIHJvb3QgKGZvciB0aGUgRGV2VG9vbHMgUHJvZmlsZXIgdG8gcmVhZClcblxuICAgIHZhciBwYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcblxuICAgIHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICByb290LmVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgcGFyZW50U3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaWJlcikge1xuXG4gIGlmIChwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHBhc3NpdmVFZmZlY3RTdGFydFRpbWU7XG4gICAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IC0xOyAvLyBTdG9yZSBkdXJhdGlvbiBvbiB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yXG4gICAgLy8gT3IgdGhlIHJvb3QgKGZvciB0aGUgRGV2VG9vbHMgUHJvZmlsZXIgdG8gcmVhZClcblxuICAgIHZhciBwYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcblxuICAgIHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHBhcmVudFN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGV0YWNoZWQgZmliZXJzIGhhdmUgdGhlaXIgc3RhdGUgbm9kZSBjbGVhcmVkIG91dC5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIHJldHVybiBwb2ludGVyIGlzIGFsc28gY2xlYXJlZCBvdXQsXG4gICAgICAgICAgICAvLyBzbyB3ZSB3b24ndCBiZSBhYmxlIHRvIHJlcG9ydCB0aGUgdGltZSBzcGVudCBpbiB0aGlzIFByb2ZpbGVyJ3Mgc3VidHJlZS5cbiAgICAgICAgICAgIHBhcmVudFN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpIHtcblxuICBsYXlvdXRFZmZlY3RTdGFydFRpbWUgPSBub3coKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKSB7XG5cbiAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IG5vdygpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKGZpYmVyKSB7XG4gIC8vIFRyYW5zZmVyIHRpbWUgc3BlbnQgcmVuZGVyaW5nIHRoZXNlIGNoaWxkcmVuIHNvIHdlIGRvbid0IGxvc2UgaXRcbiAgLy8gYWZ0ZXIgd2UgcmVyZW5kZXIuIFRoaXMgaXMgdXNlZCBhcyBhIGhlbHBlciBpbiBzcGVjaWFsIGNhc2VzXG4gIC8vIHdoZXJlIHdlIHNob3VsZCBjb3VudCB0aGUgd29yayBvZiBtdWx0aXBsZSBwYXNzZXMuXG4gIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBhZGRpdGlvbiB3aXRoIHBvc3NpYmxlIG51bGwvdW5kZWZpbmVkIHZhbHVlXG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcbnZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2s7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZha2VJbnRlcm5hbEluc3RhbmNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5ICcgKyAnbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0ICcgKyAnYSBSZWFjdCAxNSB0cmVlIGluc2lkZSBhIFJlYWN0IDE2IHRyZWUgdXNpbmcgJyArIFwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzbid0IHN1cHBvcnRlZC4gVHJ5IFwiICsgJ3RvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoICcgKyAndG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS4nKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG5cbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuXG4gICAgICBlcnJvcignRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IsIHBhcnRpYWxTdGF0ZSk7XG4gIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gIHZhciBtZW1vaXplZFN0YXRlID0gcGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkID8gcHJldlN0YXRlIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlOyAvLyBPbmNlIHRoZSB1cGRhdGUgcXVldWUgaXMgZW1wdHksIHBlcnNpc3QgdGhlIGRlcml2ZWQgc3RhdGUgb250byB0aGVcbiAgLy8gYmFzZSBzdGF0ZS5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBRdWV1ZSBpcyBhbHdheXMgbm9uLW51bGwgZm9yIGNsYXNzZXNcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9LFxuICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gICAge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ05vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChjdG9yLmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyB1c2VzIHRoZSBsZWdhY3kgY2hpbGRDb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiAnICsgJ1VzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0b3IuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gJyArICdVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHVuZGVmaW5lZCAmJiBoYXNNdXRhdGVkUHJvcHMpIHtcbiAgICAgIGVycm9yKCdXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICAgIGlmIChzdGF0ZSAmJiAodHlwZW9mIHN0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KHN0YXRlKSkpIHtcbiAgICAgIGVycm9yKCclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY3Rvci5jaGlsZENvbnRleHRUeXBlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGVycm9yKCclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIG5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBwcm9wcykge1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpICsgJ30uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgKyAnY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXMnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIEluc3RhbnRpYXRlIHR3aWNlIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cblxuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlICE9PSBudWxsICYmIGluc3RhbmNlLnN0YXRlICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG4gIGluc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGluc3RhbmNlOyAvLyBUaGUgaW5zdGFuY2UgbmVlZHMgYWNjZXNzIHRvIHRoZSBmaWJlciBzbyB0aGF0IGl0IGNhbiBzY2hlZHVsZSB1cGRhdGVzXG5cbiAgc2V0KGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAge1xuICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nICYmIHN0YXRlID09PSBudWxsKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgZXJyb3IoJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgKyAnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicgKyAnVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0ge307XG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgfVxuXG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlIHwgTGF5b3V0U3RhdGljO1xuICB9XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgb2xkUHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhjdG9yLCB1bnJlc29sdmVkT2xkUHJvcHMpO1xuICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIHZhciBuZXh0Q29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIG5leHRDb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nOyAvLyBXaGVuIGNvbXBhcmluZyB3aGV0aGVyIHByb3BzIGNoYW5nZWQsIHdlIHNob3VsZCBjb21wYXJlIHVzaW5nIHRoZVxuICAvLyB1bnJlc29sdmVkIHByb3BzIG9iamVjdCB0aGF0IGlzIHN0b3JlZCBvbiB0aGUgZmliZXIsIHJhdGhlciB0aGFuIHRoZVxuICAvLyBvbmUgdGhhdCBnZXRzIGFzc2lnbmVkIHRvIHRoZSBpbnN0YW5jZSwgYmVjYXVzZSB0aGF0IG9iamVjdCBtYXkgaGF2ZSBiZWVuXG4gIC8vIGNsb25lZCB0byByZXNvbHZlIGRlZmF1bHQgcHJvcHMgYW5kL29yIHJlbW92ZSBgcmVmYC5cblxuICB2YXIgdW5yZXNvbHZlZE5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgZGlkUmVjZWl2ZU5ld1Byb3BzID0gdW5yZXNvbHZlZE5ld1Byb3BzICE9PSB1bnJlc29sdmVkT2xkUHJvcHM7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKGRpZFJlY2VpdmVOZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7XG4gIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICghZGlkUmVjZWl2ZU5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGUgfCBMYXlvdXRTdGF0aWM7XG4gICAgfVxuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlIHwgTGF5b3V0U3RhdGljO1xuICAgIH1cblxuICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGUgfCBMYXlvdXRTdGF0aWM7XG4gICAgfVxuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHN0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cblxuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn0gLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cblxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKGN0b3IsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyA9PT0gdW5yZXNvbHZlZE5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpICYmICEoZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiAgICkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXdQcm9wcyk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB8fCBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KSB8fCAvLyBUT0RPOiBJbiBzb21lIGNhc2VzLCB3ZSdsbCBlbmQgdXAgY2hlY2tpbmcgaWYgY29udGV4dCBoYXMgY2hhbmdlZCB0d2ljZSxcbiAgLy8gYm90aCBiZWZvcmUgYW5kIGFmdGVyIGBzaG91bGRDb21wb25lbnRVcGRhdGVgIGhhcyBiZWVuIGNhbGxlZC4gTm90IGlkZWFsLFxuICAvLyBidXQgSSdtIGxvYXRoIHRvIHJlZmFjdG9yIHRoaXMgZnVuY3Rpb24uIFRoaXMgb25seSBoYXBwZW5zIGZvciBtZW1vaXplZFxuICAvLyBjb21wb25lbnRzIHNvIGl0J3Mgbm90IHRoYXQgY29tbW9uLlxuICBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uICAgO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cblxuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMsIC8vIE9ubHkgcmVzb2x2ZSBkZWZhdWx0IHByb3BzIGlmIHRoaXMgaXMgYSBsYXp5IGNvbXBvbmVudC4gT3RoZXJ3aXNlLCB0aGV5XG4vLyB3b3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNvbHZlZCBieSB0aGUgSlNYIHJ1bnRpbWUuXG4vLyBUT0RPOiBXZSdyZSBnb2luZyB0byByZW1vdmUgZGVmYXVsdCBwcm9wIHJlc29sdXRpb24gZnJvbSB0aGUgSlNYIHJ1bnRpbWVcbi8vIGFuZCBrZWVwIGl0IG9ubHkgZm9yIGNsYXNzIGNvbXBvbmVudHMuIEFzIHBhcnQgb2YgdGhhdCBjaGFuZ2UsIHdlIHNob3VsZFxuLy8gcmVtb3ZlIHRoaXMgZXh0cmEgY2hlY2suXG5hbHJlYWR5UmVzb2x2ZWREZWZhdWx0UHJvcHMpIHtcbiAgdmFyIG5ld1Byb3BzID0gYmFzZVByb3BzO1xuXG4gIHtcbiAgICAvLyBSZW1vdmUgcmVmIGZyb20gdGhlIHByb3BzIG9iamVjdCwgaWYgaXQgZXhpc3RzLlxuICAgIGlmICgncmVmJyBpbiBiYXNlUHJvcHMpIHtcbiAgICAgIG5ld1Byb3BzID0ge307XG5cbiAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGJhc2VQcm9wcykge1xuICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdyZWYnKSB7XG4gICAgICAgICAgbmV3UHJvcHNbcHJvcE5hbWVdID0gYmFzZVByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHMuXG5cblxuICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcblxuICBpZiAoZGVmYXVsdFByb3BzICYmICggLy8gSWYgZGlzYWJsZURlZmF1bHRQcm9wc0V4Y2VwdEZvckNsYXNzZXMgaXMgdHJ1ZSwgd2UgYWx3YXlzIHJlc29sdmVcbiAgLy8gZGVmYXVsdCBwcm9wcyBoZXJlIGluIHRoZSByZWNvbmNpbGVyLCByYXRoZXIgdGhhbiBpbiB0aGUgSlNYIHJ1bnRpbWUuXG4gIGRpc2FibGVEZWZhdWx0UHJvcHNFeGNlcHRGb3JDbGFzc2VzICkpIHtcbiAgICAvLyBXZSBtYXkgaGF2ZSBhbHJlYWR5IGNvcGllZCB0aGUgcHJvcHMgb2JqZWN0IGFib3ZlIHRvIHJlbW92ZSByZWYuIElmIHNvLFxuICAgIC8vIHdlIGNhbiBtb2RpZnkgdGhhdC4gT3RoZXJ3aXNlLCBjb3B5IHRoZSBwcm9wcyBvYmplY3Qgd2l0aCBPYmplY3QuYXNzaWduLlxuICAgIGlmIChuZXdQcm9wcyA9PT0gYmFzZVByb3BzKSB7XG4gICAgICBuZXdQcm9wcyA9IGFzc2lnbih7fSwgbmV3UHJvcHMpO1xuICAgIH0gLy8gVGFrZW4gZnJvbSBvbGQgSlNYIHJ1bnRpbWUsIHdoZXJlIHRoaXMgdXNlZCB0byBsaXZlLlxuXG5cbiAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAobmV3UHJvcHNbX3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1Byb3BzW19wcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbX3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3UHJvcHM7XG59XG5cbnZhciByZXBvcnRHbG9iYWxFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbi8vIGVtdWxhdGluZyBhbiB1bmNhdWdodCBKYXZhU2NyaXB0IGVycm9yLlxucmVwb3J0RXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEJyb3dzZXIgUG9seWZpbGxcbiAgICB2YXIgbWVzc2FnZSA9IHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgU3RyaW5nKGVycm9yLm1lc3NhZ2UpIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgU3RyaW5nKGVycm9yKTtcbiAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfSk7XG4gICAgdmFyIHNob3VsZExvZyA9IHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgIGlmICghc2hvdWxkTG9nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBOb2RlIFBvbHlmaWxsXG4gICAgcHJvY2Vzcy5lbWl0KCd1bmNhdWdodEV4Y2VwdGlvbicsIGVycm9yKTtcbiAgICByZXR1cm47XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG5cbiAgY29uc29sZVsnZXJyb3InXShlcnJvcik7XG59O1xuXG52YXIgY29tcG9uZW50TmFtZSA9IG51bGw7XG52YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuZnVuY3Rpb24gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcihlcnJvciwgZXJyb3JJbmZvKSB7XG4gIC8vIE92ZXJyaWRpbmcgdGhpcyBjYW4gc2lsZW5jZSB0aGVzZSB3YXJuaW5ncyBlLmcuIGZvciB0ZXN0cy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMzg0XG4gIC8vIEZvciB1bmNhdWdodCByb290IGVycm9ycyB3ZSByZXBvcnQgdGhlbSBhcyB1bmNhdWdodCB0byB0aGUgYnJvd3NlcidzXG4gIC8vIG9uZXJyb3IgY2FsbGJhY2suIFRoaXMgd29uJ3QgaGF2ZSBjb21wb25lbnQgc3RhY2tzIGFuZCB0aGUgZXJyb3IgYWRkZW5kdW0uXG4gIC8vIFNvIHdlIGFkZCB0aG9zZSBpbnRvIGEgc2VwYXJhdGUgY29uc29sZS53YXJuLlxuICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyBcIkFuIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIiA6ICdBbiBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzLic7XG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuXG4gICAge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgRmliZXIgaXMgZGlzY29ubmVjdGVkIGF0IHRoaXMgcG9pbnQgd2hpY2ggbWVhbnMgdGhhdCBjb25zb2xlIHByaW50aW5nXG4gICAgICAvLyBjYW5ub3QgYWRkIGEgY29tcG9uZW50IHN0YWNrIHNpbmNlIGl0IHRlcm1pbmF0ZXMgYXQgdGhlIGRlbGV0aW9uIG5vZGUuIFRoaXMgaXMgbm90XG4gICAgICAvLyBhIHByb2JsZW0gZm9yIG93bmVyIHN0YWNrcyB3aGljaCBhcmUgbm90IGRpc2Nvbm5lY3RlZCBidXQgZm9yIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICAvLyBzdGFja3Mgd2UgbmVlZCB0byB1c2UgdGhlIHNuYXBzaG90IHdlJ3ZlIHByZXZpb3VzbHkgZXh0cmFjdGVkLlxuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrICE9IG51bGwgPyBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgOiAnJzsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnJXNcXG5cXG4lc1xcbiVzJywgY29tcG9uZW50TmFtZU1lc3NhZ2UsIGVycm9yQm91bmRhcnlNZXNzYWdlLCBjb21wb25lbnRTdGFjayk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWZhdWx0T25DYXVnaHRFcnJvcihlcnJvciQxLCBlcnJvckluZm8pIHtcbiAgLy8gT3ZlcnJpZGluZyB0aGlzIGNhbiBzaWxlbmNlIHRoZXNlIHdhcm5pbmdzIGUuZy4gZm9yIHRlc3RzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcbiAgLy8gQ2F1Z2h0IGJ5IGVycm9yIGJvdW5kYXJ5XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50LlwiIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzLic7IC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aGljaCBpbmNsdWRlcyB0aGUgY29tcG9uZW50IHN0YWNrXG4gICAgLy8gaW4gYWRkaXRpb24gdG8gdGhlIGVycm9yLlxuXG4gICAgdmFyIHJlY3JlYXRlTWVzc2FnZSA9IFwiUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggXCIgKyAoXCJ1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCBcIiArIChlcnJvckJvdW5kYXJ5TmFtZSB8fCAnQW5vbnltb3VzJykgKyBcIi5cIik7XG5cbiAgICB7XG4gICAgICAvLyBUaGUgY3VycmVudCBGaWJlciBpcyBkaXNjb25uZWN0ZWQgYXQgdGhpcyBwb2ludCB3aGljaCBtZWFucyB0aGF0IGNvbnNvbGUgcHJpbnRpbmdcbiAgICAgIC8vIGNhbm5vdCBhZGQgYSBjb21wb25lbnQgc3RhY2sgc2luY2UgaXQgdGVybWluYXRlcyBhdCB0aGUgZGVsZXRpb24gbm9kZS4gVGhpcyBpcyBub3RcbiAgICAgIC8vIGEgcHJvYmxlbSBmb3Igb3duZXIgc3RhY2tzIHdoaWNoIGFyZSBub3QgZGlzY29ubmVjdGVkIGJ1dCBmb3IgdGhlIHBhcmVudCBjb21wb25lbnRcbiAgICAgIC8vIHN0YWNrcyB3ZSBuZWVkIHRvIHVzZSB0aGUgc25hcHNob3Qgd2UndmUgcHJldmlvdXNseSBleHRyYWN0ZWQuXG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgIT0gbnVsbCA/IGVycm9ySW5mby5jb21wb25lbnRTdGFjayA6ICcnOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcblxuICAgICAgY29uc29sZVsnZXJyb3InXSgnJW9cXG5cXG4lc1xcblxcbiVzXFxuJXMnLCBlcnJvciQxLCBjb21wb25lbnROYW1lTWVzc2FnZSwgcmVjcmVhdGVNZXNzYWdlLCBjb21wb25lbnRTdGFjayk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yKGVycm9yLCBlcnJvckluZm8pIHtcbiAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xufVxuZnVuY3Rpb24gbG9nVW5jYXVnaHRFcnJvcihyb290LCBlcnJvckluZm8pIHtcbiAgdHJ5IHtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGVycm9ySW5mby5zb3VyY2UgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGVycm9ySW5mby5zb3VyY2UpIDogbnVsbDtcbiAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gRm9yIHVuY2F1Z2h0IGVycm9ycyBpbnNpZGUgYWN0LCB3ZSB0cmFjayB0aGVtIG9uIHRoZSBhY3QgYW5kIHRoZW5cbiAgICAgIC8vIHJldGhyb3cgdGhlbSBpbnRvIHRoZSB0ZXN0LlxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvblVuY2F1Z2h0RXJyb3IgPSByb290Lm9uVW5jYXVnaHRFcnJvcjtcbiAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IsIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2tcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4gICAgLy8gSWYgY29uc29sZS5lcnJvciBpcyBvdmVycmlkZGVuLCBvciBsb2dDYXB0dXJlZEVycm9yKCkgc2hvd3MgYSBkaWFsb2cgdGhhdCB0aHJvd3MsXG4gICAgLy8gd2Ugd2FudCB0byByZXBvcnQgdGhpcyBlcnJvciBvdXRzaWRlIG9mIHRoZSBub3JtYWwgc3RhY2sgYXMgYSBsYXN0IHJlc29ydC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBsb2dDYXVnaHRFcnJvcihyb290LCBib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHRyeSB7XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBlcnJvckluZm8uc291cmNlID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKSA6IG51bGw7XG4gICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoYm91bmRhcnkpO1xuICAgIH1cblxuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICB2YXIgb25DYXVnaHRFcnJvciA9IHJvb3Qub25DYXVnaHRFcnJvcjtcbiAgICBvbkNhdWdodEVycm9yKGVycm9yLCB7XG4gICAgICBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrLFxuICAgICAgZXJyb3JCb3VuZGFyeTogYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCA/IGJvdW5kYXJ5LnN0YXRlTm9kZSAvLyBUaGlzIHNob3VsZCBhbHdheXMgYmUgdGhlIGNhc2UgYXMgbG9uZyBhcyB3ZSBvbmx5IGhhdmUgY2xhc3MgYm91bmRhcmllc1xuICAgICAgOiBudWxsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuICAgIC8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdCwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7IC8vIFVubW91bnQgdGhlIHJvb3QgYnkgcmVuZGVyaW5nIG51bGwuXG5cbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IG51bGxcbiAgfTtcblxuICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZXJyb3JJbmZvLnNvdXJjZSwgbG9nVW5jYXVnaHRFcnJvciwgcm9vdCwgZXJyb3JJbmZvKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIGZpYmVyLCBlcnJvckluZm8pIHtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IkMSk7XG4gICAgfTtcblxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHtcbiAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGVycm9ySW5mby5zb3VyY2UsIGxvZ0NhdWdodEVycm9yLCByb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgaWYgKGluc3QgIT09IG51bGwgJiYgdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctdGhpcy1hbm5vdF1cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIHtcbiAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGVycm9ySW5mby5zb3VyY2UsIGxvZ0NhdWdodEVycm9yLCByb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9yJDEsIHtcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJ1xuICAgICAgfSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBJZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZCxcbiAgICAgICAgICAvLyB0aGVuIGl0IG5lZWRzIHRvIGNhbGwgc2V0U3RhdGUgdG8gcmVjb3ZlciBmcm9tIGVycm9ycy5cbiAgICAgICAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgaXMgc2NoZWR1bGVkIHRoZW4gdGhlIGJvdW5kYXJ5IHdpbGwgc3dhbGxvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKGZpYmVyLmxhbmVzLCBTeW5jTGFuZSkpIHtcbiAgICAgICAgICAgIGVycm9yKCclczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiAnICsgJ0luIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUoc3VzcGVuc2VCb3VuZGFyeSwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByb290LCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gd2l0aCB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cbiAgLy9cbiAgLy8gQWZ0ZXIgdGhpcyB3ZSdsbCB1c2UgYSBzZXQgb2YgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG4gIC8vIHJlbmRlciBwYXNzIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gb3IgcmVzdGFydCBvciBcInN1c3BlbmRcIiB0aGUgY29tbWl0LlxuICAvLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbiAgLy9cbiAgLy8gVGhpcyBmaXJzdCBwcmluY2lwbGUgaXMgdGhhdCBpZiB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdoZW4gd2UgY29tcGxldGVcbiAgLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbiAgLy8gbWlnaHQgdW5zdXNwZW5kIGl0LCBhbmQgdmljZSB2ZXJzYS4gVGhlIG9ubHkgcmVhc29uIHRvIHN1c3BlbmQgaXNcbiAgLy8gYmVjYXVzZSB5b3UgdGhpbmsgeW91IG1pZ2h0IHdhbnQgdG8gcmVzdGFydCBiZWZvcmUgY29tbWl0dGluZy4gSG93ZXZlcixcbiAgLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbiAgLy9cbiAgLy8gUmVzdGFydGluZyB0b28gYWdncmVzc2l2ZWx5IGlzIGFsc28gbm90IGdvb2QgYmVjYXVzZSBpdCBzdGFydmVzIG91dCBhbnlcbiAgLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuICAvLyBTdXNwZW5zZSBIZXVyaXN0aWNzXG4gIC8vXG4gIC8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbiAgLy8gdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuXG4gIC8vXG4gIC8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAvLyB0aG9zZSB0cmlnZ2VyIGEgZmFsbGJhY2ssIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGNhbiBzaG93IHRoZSBpbml0aWFsIGxvYWRpbmcgc3RhdGUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgLy9cbiAgLy8gSWYgd2UgaGl0IGEgXCJEZWxheWVkXCIgY2FzZSwgc3VjaCBhcyB3aGVuIHdlJ2Qgc3dpdGNoIGZyb20gY29udGVudCBiYWNrIGludG9cbiAgLy8gYSBmYWxsYmFjaywgdGhlbiB3ZSBzaG91bGQgYWx3YXlzIHN1c3BlbmQvcmVzdGFydC4gVHJhbnNpdGlvbnMgYXBwbHlcbiAgLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4gIC8vXG4gIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIGFuZCBpdCBnZXRzIFwicmV0cmllZFwiLCBhbGxvd2luZyB1cyB0byBzaG93XG4gIC8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuICAvLyB0aGVuIHdlIHN1c3BlbmQvcmVzdGFydCBmb3IgNTAwbXMgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzaG93ZWQgYSBmYWxsYmFja1xuICAvLyBhbnl3aGVyZSBpbiB0aGUgdHJlZS4gVGhpcyBlZmZlY3RpdmVseSB0aHJvdHRsZXMgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpbnRvIGFcbiAgLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuICAvLyBnZXQgdG8gdGhlIGNvbXBsZXRlZCBzdGF0ZSBzbGlnaHRseSBlYXJsaWVyLlxuICAvL1xuICAvLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuICAvLyAxKSBcImRlbGF5ZWRcIiwgMikgXCJpbml0aWFsIHJlbmRlclwiLCAzKSBcInJldHJ5XCIuXG4gIC8vXG4gIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbiAgLy8gZW5zdXJlIHRoYXQgbmV3IGluaXRpYWwgbG9hZGluZyBzdGF0ZXMgY2FuIGNvbW1pdCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTaG91bGRDYXB0dXJlOyAvLyBUT0RPOiBJIHRoaW5rIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2Ugbm93IHVzZSBgRGlkQ2FwdHVyZWAgaW5cbiAgLy8gdGhlIGJlZ2luIHBoYXNlIHRvIHByZXZlbnQgYW4gZWFybHkgYmFpbG91dC5cblxuICBzdXNwZW5zZUJvdW5kYXJ5LmxhbmVzID0gcm9vdFJlbmRlckxhbmVzO1xuICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgc291cmNlRmliZXIuZmxhZ3MgfD0gSW5jb21wbGV0ZTtcblxuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgd2FrZWFibGUuIFRoZSBjb21wb25lbnQgc3VzcGVuZGVkLlxuICAgICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgKGRpc2FibGVMZWdhY3lNb2RlICkpIHtcbiAgICAgICAgICBtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgdmFyIHN1c3BlbnNlQm91bmRhcnkgPSBnZXRTdXNwZW5zZUhhbmRsZXIoKTtcblxuICAgICAgaWYgKHN1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChzdXNwZW5zZUJvdW5kYXJ5LnRhZykge1xuICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLCBtYXJrXG4gICAgICAgICAgICAgIC8vIHRoZSBpbi1wcm9ncmVzcyByZW5kZXIgYXMgc3VzcGVuZGVkLiBXZSB0cnkgdG8gcGVyZm9ybSB0aGlzIGxvZ2ljXG4gICAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgc29vbiBhcyBwb3NzaWJsZSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc28gdGhlIHdvcmtcbiAgICAgICAgICAgICAgLy8gbG9vcCBjYW4ga25vdyB0aGluZ3MgbGlrZSB3aGV0aGVyIGl0J3MgT0sgdG8gc3dpdGNoIHRvIG90aGVyIHRhc2tzLFxuICAgICAgICAgICAgICAvLyBvciB3aGV0aGVyIGl0IGNhbiB3YWl0IGZvciBkYXRhIHRvIHJlc29sdmUgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgICAgIC8vIFRPRE86IE1vc3Qgb2YgdGhlc2UgY2hlY2tzIGFyZSBhbHJlYWR5IHBlcmZvcm1lZCB3aGVuIGVudGVyaW5nIGFcbiAgICAgICAgICAgICAgLy8gU3VzcGVuc2UgYm91bmRhcnkuIFdlIHNob3VsZCB0cmFjayB0aGUgaW5mb3JtYXRpb24gb24gdGhlIHN0YWNrIHNvXG4gICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIGl0IG9uIGRlbWFuZC4gVGhpcyB3b3VsZCBhbHNvIGFsbG93IHVzXG4gICAgICAgICAgICAgIC8vIHRvIHVuaWZ5IHdpdGggYHVzZWAgd2hpY2ggbmVlZHMgdG8gcGVyZm9ybSB0aGlzIGxvZ2ljIGV2ZW4gc29vbmVyLFxuICAgICAgICAgICAgICAvLyBiZWZvcmUgYHRocm93RXhjZXB0aW9uYCBpcyBjYWxsZWQuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0U2hlbGxCb3VuZGFyeSgpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5kZWQgaW4gdGhlIFwic2hlbGxcIiBvZiB0aGUgYXBwLiBUaGlzIGlzIGFuIHVuZGVzaXJhYmxlXG4gICAgICAgICAgICAgICAgICAvLyBsb2FkaW5nIHN0YXRlLiBXZSBzaG91bGQgYXZvaWQgY29tbWl0dGluZyB0aGlzIHRyZWUuXG4gICAgICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHN1c3BlbmRlZCBkZWVwZXIgdGhhbiB0aGUgc2hlbGwsIHdlIGRvbid0IG5lZWQgdG8gZGVsYXlcbiAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb21tbWl0LiBIb3dldmVyLCB3ZSBzdGlsbCBjYWxsIHJlbmRlckRpZFN1c3BlbmQgaWYgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAgLy8gYSBuZXcgYm91bmRhcnksIHRvIHRlbGwgdGhlIHdvcmsgbG9vcCB0aGF0IGEgbmV3IGZhbGxiYWNrIGhhc1xuICAgICAgICAgICAgICAgICAgLy8gYXBwZWFyZWQgZHVyaW5nIHRoaXMgcmVuZGVyLlxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVGhlb3JldGljYWxseSB3ZSBzaG91bGQgYmUgYWJsZSB0byBkZWxldGUgdGhpcyBicmFuY2guXG4gICAgICAgICAgICAgICAgICAvLyBJdCdzIGN1cnJlbnRseSB1c2VkIGZvciB0d28gdGhpbmdzOiAxKSB0byB0aHJvdHRsZSB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIGFwcGVhcmFuY2Ugb2Ygc3VjY2Vzc2l2ZSBsb2FkaW5nIHN0YXRlcywgYW5kIDIpIGluXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3QsIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBjaGlsZHJlbiBpbmNsdWRlIGFueVxuICAgICAgICAgICAgICAgICAgLy8gcGVuZGluZyBmYWxsYmFja3MuIEZvciAxLCB3ZSBzaG91bGQgYXBwbHkgdGhyb3R0bGluZyB0byBhbGxcbiAgICAgICAgICAgICAgICAgIC8vIHJldHJpZXMsIG5vdCBqdXN0IG9uZXMgdGhhdCByZW5kZXIgYW4gYWRkaXRpb25hbCBmYWxsYmFjay4gRm9yXG4gICAgICAgICAgICAgICAgICAvLyAyLCB3ZSBzaG91bGQgY2hlY2sgc3VidHJlZUZsYWdzIGluc3RlYWQuIFRoZW4gd2UgY2FuIGRlbGV0ZVxuICAgICAgICAgICAgICAgICAgLy8gdGhpcyBicmFuY2guXG4gICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHN1c3BlbnNlQm91bmRhcnkuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyAmPSB+Rm9yY2VDbGllbnRSZW5kZXI7XG4gICAgICAgICAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7IC8vIFJldHJ5IGxpc3RlbmVyXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBmYWxsYmFjayBkb2VzIGNvbW1pdCwgd2UgbmVlZCB0byBhdHRhY2ggYSBkaWZmZXJlbnQgdHlwZSBvZlxuICAgICAgICAgICAgICAvLyBsaXN0ZW5lci4gVGhpcyBvbmUgc2NoZWR1bGVzIGFuIHVwZGF0ZSBvbiB0aGUgU3VzcGVuc2UgYm91bmRhcnkgdG9cbiAgICAgICAgICAgICAgLy8gdHVybiB0aGUgZmFsbGJhY2sgc3RhdGUgb2ZmLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBTdGFzaCB0aGUgd2FrZWFibGUgb24gdGhlIGJvdW5kYXJ5IGZpYmVyIHNvIHdlIGNhbiBhY2Nlc3MgaXQgaW4gdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdCBwaGFzZS5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgd2FrZWFibGUgcmVzb2x2ZXMsIHdlJ2xsIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBib3VuZGFyeVxuICAgICAgICAgICAgICAvLyBhZ2FpbiAoXCJyZXRyeVwiKS5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIFN1c3BlbnNleSByZXNvdXJjZS4gV2UgZG8gbm90IGF0dGFjaCByZXRyeVxuICAgICAgICAgICAgICAvLyBsaXN0ZW5lcnMgdG8gdGhlc2UsIGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0aGVtIGZvclxuICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuIE9ubHkgZm9yIGNvbW1pdHRpbmcuIEluc3RlYWQsIGlmIGEgZmFsbGJhY2sgY29tbWl0c1xuICAgICAgICAgICAgICAvLyBhbmQgdGhlIG9ubHkgdGhpbmcgdGhhdCBzdXNwZW5kZWQgd2FzIGEgU3VzcGVuc2V5IHJlc291cmNlLCB3ZVxuICAgICAgICAgICAgICAvLyByZXRyeSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgLy8gVE9ETzogUmVmYWN0b3IgdGhyb3dFeGNlcHRpb24gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGRvIHRoaXMgdHlwZVxuICAgICAgICAgICAgICAvLyBjaGVjay4gVGhlIGNhbGxlciBhbHJlYWR5IGtub3dzIHdoYXQgdGhlIGNhdXNlIHdhcy5cblxuICAgICAgICAgICAgICB2YXIgaXNTdXNwZW5zZXlSZXNvdXJjZSA9IHdha2VhYmxlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGU7XG5cbiAgICAgICAgICAgICAgaWYgKGlzU3VzcGVuc2V5UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNjaGVkdWxlUmV0cnk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldHJ5UXVldWUgPSBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJldHJ5UXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHN1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWUgPSBuZXcgU2V0KFt3YWtlYWJsZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXRyeVF1ZXVlLmFkZCh3YWtlYWJsZSk7XG4gICAgICAgICAgICAgICAgfSAvLyBXZSBvbmx5IGF0dGFjaCBwaW5nIGxpc3RlbmVycyBpbiBjb25jdXJyZW50IG1vZGUuIExlZ2FjeVxuICAgICAgICAgICAgICAgIC8vIFN1c3BlbnNlIGFsd2F5cyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgICAgICAvLyBubyBwaW5ncy5cblxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9pc1N1c3BlbnNleVJlc291cmNlID0gd2FrZWFibGUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZTtcblxuICAgICAgICAgICAgICAgIGlmIChfaXNTdXNwZW5zZXlSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTY2hlZHVsZVJldHJ5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb2Zmc2NyZWVuUXVldWUgPSBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAob2Zmc2NyZWVuUXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld09mZnNjcmVlblF1ZXVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICByZXRyeVF1ZXVlOiBuZXcgU2V0KFt3YWtlYWJsZV0pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWUgPSBuZXdPZmZzY3JlZW5RdWV1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZSA9IG9mZnNjcmVlblF1ZXVlLnJldHJ5UXVldWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXRyeVF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2NyZWVuUXVldWUucmV0cnlRdWV1ZSA9IG5ldyBTZXQoW3dha2VhYmxlXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3JldHJ5UXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFN1c3BlbnNlIGhhbmRsZXIgdGFnIChcIiArIHN1c3BlbnNlQm91bmRhcnkudGFnICsgXCIpLiBUaGlzIFwiICsgJ2lzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gYm91bmRhcnkgd2FzIGZvdW5kLiBVbmxlc3MgdGhpcyBpcyBhIHN5bmMgdXBkYXRlLCB0aGlzIGlzIE9LLlxuICAgICAgICAvLyBXZSBjYW4gc3VzcGVuZCBhbmQgd2FpdCBmb3IgbW9yZSBkYXRhIHRvIGFycml2ZS5cbiAgICAgICAge1xuICAgICAgICAgIC8vIEluIGEgY29uY3VycmVudCByb290LCBzdXNwZW5kaW5nIHdpdGhvdXQgYSBTdXNwZW5zZSBib3VuZGFyeSBpc1xuICAgICAgICAgIC8vIGFsbG93ZWQuIEl0IHdpbGwgc3VzcGVuZCBpbmRlZmluaXRlbHkgd2l0aG91dCBjb21taXR0aW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIGhhdmUgZGlmZmVyZW50IGJlaGF2aW9yIGZvciBkaXNjcmV0ZSB1cGRhdGVzPyBXaGF0XG4gICAgICAgICAgLy8gYWJvdXQgZmx1c2hTeW5jPyBNYXliZSBpdCBzaG91bGQgcHV0IHRoZSB0cmVlIGludG8gYW4gaW5lcnQgc3RhdGUsXG4gICAgICAgICAgLy8gYW5kIHBvdGVudGlhbGx5IGxvZyBhIHdhcm5pbmcuIFJldmlzaXQgdGhpcyBmb3IgYSBmdXR1cmUgcmVsZWFzZS5cbiAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGlzIGlzIGEgcmVndWxhciBlcnJvciwgbm90IGEgU3VzcGVuc2Ugd2FrZWFibGUuXG5cblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiAoZGlzYWJsZUxlZ2FjeU1vZGUgKSkge1xuICAgIG1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWKCk7XG5cbiAgICB2YXIgX3N1c3BlbnNlQm91bmRhcnkgPSBnZXRTdXNwZW5zZUhhbmRsZXIoKTsgLy8gSWYgdGhlIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIGh5ZHJhdGlvbiwgd2UgbWF5IGJlIGFibGUgdG8gcmVjb3ZlciBieVxuICAgIC8vIGRpc2NhcmRpbmcgdGhlIGRlaHlkcmF0ZWQgY29udGVudCBhbmQgc3dpdGNoaW5nIHRvIGEgY2xpZW50IHJlbmRlci5cbiAgICAvLyBJbnN0ZWFkIG9mIHN1cmZhY2luZyB0aGUgZXJyb3IsIGZpbmQgdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnlcbiAgICAvLyBhbmQgcmVuZGVyIGl0IGFnYWluIHdpdGhvdXQgaHlkcmF0aW9uLlxuXG5cbiAgICBpZiAoX3N1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIGlmICgoX3N1c3BlbnNlQm91bmRhcnkuZmxhZ3MgJiBTaG91bGRDYXB0dXJlKSA9PT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIFNldCBhIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB3ZSBzaG91bGQgdHJ5IHJlbmRlcmluZyB0aGUgbm9ybWFsXG4gICAgICAgIC8vIGNoaWxkcmVuIGFnYWluLCBub3QgdGhlIGZhbGxiYWNrLlxuICAgICAgICBfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgIH1cblxuICAgICAgbWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKF9zdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7IC8vIEV2ZW4gdGhvdWdoIHRoZSB1c2VyIG1heSBub3QgYmUgYWZmZWN0ZWQgYnkgdGhpcyBlcnJvciwgd2Ugc2hvdWxkXG4gICAgICAvLyBzdGlsbCBsb2cgaXQgc28gaXQgY2FuIGJlIGZpeGVkLlxuXG4gICAgICBpZiAodmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uKSB7XG4gICAgICAgIHZhciBfd3JhcHBlckVycm9yID0gbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5ICcgKyAnaW5zdGVhZCBjbGllbnQgcmVuZGVyaW5nIGZyb20gdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnkuJywge1xuICAgICAgICAgIGNhdXNlOiB2YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKF93cmFwcGVyRXJyb3IsIHNvdXJjZUZpYmVyKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbikge1xuICAgICAgICB2YXIgX3dyYXBwZXJFcnJvcjIgPSBuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgJyArICdpbnN0ZWFkIGNsaWVudCByZW5kZXJpbmcgdGhlIGVudGlyZSByb290LicsIHtcbiAgICAgICAgICBjYXVzZTogdmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihfd3JhcHBlckVycm9yMiwgc291cmNlRmliZXIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF93b3JrSW5Qcm9ncmVzcyA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7IC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBhdCB0aGUgcm9vdCB0byBsb2cgdGhlIGVycm9yIGJ1dCB0aGlzIHNob3VsZG4ndFxuICAgICAgLy8gYWN0dWFsbHkgaGFwcGVuIGJlY2F1c2Ugd2Ugc2hvdWxkIHJlY292ZXIuXG5cbiAgICAgIF93b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuICAgICAgX3dvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyhfd29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpO1xuICAgICAgdmFyIHJvb3RFcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShfd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCByb290RXJyb3JJbmZvLCAvLyBUaGlzIHNob3VsZCBuZXZlciBhY3R1YWxseSBnZXQgbG9nZ2VkIGR1ZSB0byB0aGUgcmVjb3ZlcnkuXG4gICAgICBsYW5lKTtcbiAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShfd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSk7XG4gICAgICByZW5kZXJEaWRFcnJvcigpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB3cmFwcGVyRXJyb3IgPSBuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgY29uY3VycmVudCByZW5kZXJpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgJyArICdpbnN0ZWFkIHN5bmNocm9ub3VzbHkgcmVuZGVyaW5nIHRoZSBlbnRpcmUgcm9vdC4nLCB7XG4gICAgY2F1c2U6IHZhbHVlXG4gIH0pO1xuICBxdWV1ZUNvbmN1cnJlbnRFcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih3cmFwcGVyRXJyb3IsIHNvdXJjZUZpYmVyKSk7XG4gIHJlbmRlckRpZEVycm9yKCk7IC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuXG4gIGlmIChyZXR1cm5GaWJlciA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gcmV0dXJuIGZpYmVyLCB3aGljaCBtZWFucyB0aGUgcm9vdCBlcnJvcmVkLiBUaGlzIHNob3VsZCBuZXZlclxuICAgIC8vIGhhcHBlbi4gUmV0dXJuIGB0cnVlYCB0byB0cmlnZ2VyIGEgZmF0YWwgZXJyb3IgKHBhbmljKS5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpO1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICBkbyB7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG4gICAgICAgICAgdmFyIF9sYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgX2xhbmUpO1xuXG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIC8vIENhcHR1cmUgYW5kIHJldHJ5XG4gICAgICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyQxICYmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG4gICAgICAgICAgdmFyIF9sYW5lMiA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIF9sYW5lMik7IC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuXG4gICAgICAgICAgdmFyIF91cGRhdGUyID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShfbGFuZTIpO1xuXG4gICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoX3VwZGF0ZTIsIHJvb3QsIHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8pO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZTIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBpbnRvIGEgZGVoeWRyYXRlZCBib3VuZGFyeS5cblxudmFyIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbiA9IG5ldyBFcnJvcihcIlRoaXMgaXMgbm90IGEgcmVhbCBlcnJvci4gSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgUmVhY3QncyBcIiArIFwic2VsZWN0aXZlIGh5ZHJhdGlvbiBmZWF0dXJlLiBJZiB0aGlzIGxlYWtzIGludG8gdXNlcnNwYWNlLCBpdCdzIGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHZhciByZW5kZXIgPSBDb21wb25lbnQucmVuZGVyO1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICB2YXIgcHJvcHNXaXRob3V0UmVmO1xuXG4gIGlmICgncmVmJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAvLyBgcmVmYCBpcyBqdXN0IGEgcHJvcCBub3csIGJ1dCBgZm9yd2FyZFJlZmAgZXhwZWN0cyBpdCB0byBub3QgYXBwZWFyIGluXG4gICAgLy8gdGhlIHByb3BzIG9iamVjdC4gVGhpcyB1c2VkIHRvIGhhcHBlbiBpbiB0aGUgSlNYIHJ1bnRpbWUsIGJ1dCBub3cgd2UgZG9cbiAgICAvLyBpdCBoZXJlLlxuICAgIHByb3BzV2l0aG91dFJlZiA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIG5leHRQcm9wcykge1xuICAgICAgLy8gU2luY2UgYHJlZmAgc2hvdWxkIG9ubHkgYXBwZWFyIGluIHByb3BzIHZpYSB0aGUgSlNYIHRyYW5zZm9ybSwgd2UgY2FuXG4gICAgICAvLyBhc3N1bWUgdGhhdCB0aGlzIGlzIGEgcGxhaW4gb2JqZWN0LiBTbyB3ZSBkb24ndCBuZWVkIGFcbiAgICAgIC8vIGhhc093blByb3BlcnR5IGNoZWNrLlxuICAgICAgaWYgKGtleSAhPT0gJ3JlZicpIHtcbiAgICAgICAgcHJvcHNXaXRob3V0UmVmW2tleV0gPSBuZXh0UHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJvcHNXaXRob3V0UmVmID0gbmV4dFByb3BzO1xuICB9IC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuXG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgdmFyIGhhc0lkO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXIsIHByb3BzV2l0aG91dFJlZiwgcmVmLCByZW5kZXJMYW5lcyk7XG4gICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuICAgIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuXG4gICAgaWYgKGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkgJiYgQ29tcG9uZW50LmNvbXBhcmUgPT09IG51bGwgJiYgKCAvLyBTaW1wbGVNZW1vQ29tcG9uZW50IGNvZGVwYXRoIGRvZXNuJ3QgcmVzb2x2ZSBvdXRlciBwcm9wcyBlaXRoZXIuXG4gICAgZGlzYWJsZURlZmF1bHRQcm9wc0V4Y2VwdEZvckNsYXNzZXMgKSkge1xuICAgICAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xuICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IHdpdGhvdXQgZGVmYXVsdCBwcm9wcyxcbiAgICAgIC8vIGFuZCB3aXRoIG9ubHkgdGhlIGRlZmF1bHQgc2hhbGxvdyBjb21wYXJpc29uLCB3ZSB1cGdyYWRlIGl0XG4gICAgICAvLyB0byBhIFNpbXBsZU1lbW9Db21wb25lbnQgdG8gYWxsb3cgZmFzdCBwYXRoIHVwZGF0ZXMuXG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gU2ltcGxlTWVtb0NvbXBvbmVudDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlZFR5cGU7XG5cbiAgICAgIHtcbiAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlc29sdmVkVHlwZSwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKENvbXBvbmVudC50eXBlLCBudWxsLCBuZXh0UHJvcHMsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCByZW5kZXJMYW5lcyk7XG4gICAgY2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGNoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCkge1xuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4gICAgLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOyAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuXG4gICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBjb21wYXJlID0gY29tcGFyZSAhPT0gbnVsbCA/IGNvbXBhcmUgOiBzaGFsbG93RXF1YWw7XG5cbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMpO1xuICBuZXdDaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICByZXR1cm4gbmV3Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgaWYgKHNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZiAmJiAoIC8vIFByZXZlbnQgYmFpbG91dCBpZiB0aGUgaW1wbGVtZW50YXRpb24gY2hhbmdlZCBkdWUgdG8gaG90IHJlbG9hZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID09PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlOyAvLyBUaGUgcHJvcHMgYXJlIHNoYWxsb3dseSBlcXVhbC4gUmV1c2UgdGhlIHByZXZpb3VzIHByb3BzIG9iamVjdCwgbGlrZSB3ZVxuICAgICAgLy8gd291bGQgZHVyaW5nIGEgbm9ybWFsIGZpYmVyIGJhaWxvdXQuXG4gICAgICAvL1xuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBzdHJvbmcgZ3VhcmFudGVlcyB0aGF0IHRoZSBwcm9wcyBvYmplY3QgaXMgcmVmZXJlbnRpYWxseVxuICAgICAgLy8gZXF1YWwgZHVyaW5nIHVwZGF0ZXMgd2hlcmUgd2UgY2FuJ3QgYmFpbCBvdXQgYW55d2F5IOKAlCBsaWtlIGlmIHRoZSBwcm9wc1xuICAgICAgLy8gYXJlIHNoYWxsb3dseSBlcXVhbCwgYnV0IHRoZXJlJ3MgYSBsb2NhbCBzdGF0ZSBvciBjb250ZXh0IHVwZGF0ZSBpbiB0aGVcbiAgICAgIC8vIHNhbWUgYmF0Y2guXG4gICAgICAvL1xuICAgICAgLy8gSG93ZXZlciwgYXMgYSBwcmluY2lwbGUsIHdlIHNob3VsZCBhaW0gdG8gbWFrZSB0aGUgYmVoYXZpb3IgY29uc2lzdGVudFxuICAgICAgLy8gYWNyb3NzIGRpZmZlcmVudCB3YXlzIG9mIG1lbW9pemluZyBhIGNvbXBvbmVudC4gRm9yIGV4YW1wbGUsIFJlYWN0Lm1lbW9cbiAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBpbnRlcm5hbCBGaWJlciBsYXlvdXQgaWYgeW91IHBhc3MgYSBub3JtYWwgZnVuY3Rpb25cbiAgICAgIC8vIGNvbXBvbmVudCAoU2ltcGxlTWVtb0NvbXBvbmVudCkgdmVyc3VzIGlmIHlvdSBwYXNzIGEgZGlmZmVyZW50IHR5cGVcbiAgICAgIC8vIGxpa2UgZm9yd2FyZFJlZiAoTWVtb0NvbXBvbmVudCkuIEJ1dCB0aGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC5cbiAgICAgIC8vIFdyYXBwaW5nIGEgY29tcG9uZW50IGluIGZvcndhcmRSZWYgKG9yIFJlYWN0LmxhenksIGV0Yykgc2hvdWxkbid0XG4gICAgICAvLyBhZmZlY3Qgd2hldGhlciB0aGUgcHJvcHMgb2JqZWN0IGlzIHJldXNlZCBkdXJpbmcgYSBiYWlsb3V0LlxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBuZXh0UHJvcHMgPSBwcmV2UHJvcHM7XG5cbiAgICAgIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbiAgICAgICAgLy8gYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB0aGVyZSBtaWdodCBiZSBvdGhlciBsYW5lcyB0aGF0IHdlcmVuJ3RcbiAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtdWxhdGVkIGR1cmluZyB0aGUgZXZhbHVhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IChpLmUuIHdoZW4gcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlKS4gQnV0IHNpbmNlIHNpbmNlXG4gICAgICAgIC8vIHdlJ3JlIGJhaWxpbmcgb3V0IGVhcmx5ICp3aXRob3V0KiBldmFsdWF0aW5nIHRoZSBjb21wb25lbnQsIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gYWNjb3VudCBmb3IgaXQgaGVyZSwgdG9vLiBSZXNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgZmliZXIuXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgb25seSBhcHBsaWVzIHRvIFNpbXBsZU1lbW9Db21wb25lbnQsIG5vdCBNZW1vQ29tcG9uZW50LFxuICAgICAgICAvLyBiZWNhdXNlIGEgTWVtb0NvbXBvbmVudCBmaWJlciBkb2VzIG5vdCBoYXZlIGhvb2tzIG9yIGFuIHVwZGF0ZSBxdWV1ZTtcbiAgICAgICAgLy8gcmF0aGVyLCBpdCB3cmFwcyBhcm91bmQgYW4gaW5uZXIgY29tcG9uZW50LCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuICAgICAgICAvLyBjb250YWlucyBob29rcy5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGUgcmVzZXQgYXQgaW4gYmVnaW5Xb3JrIG91dCBvZiB0aGUgY29tbW9uIHBhdGggc28gdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBuZXh0SXNEZXRhY2hlZCA9ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuX3BlbmRpbmdWaXNpYmlsaXR5ICYgT2Zmc2NyZWVuRGV0YWNoZWQpICE9PSAwO1xuICB2YXIgcHJldlN0YXRlID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChuZXh0UHJvcHMubW9kZSA9PT0gJ2hpZGRlbicgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCBuZXh0SXNEZXRhY2hlZCkge1xuICAgIC8vIFJlbmRlcmluZyBhIGhpZGRlbiB0cmVlLlxuICAgIHZhciBkaWRTdXNwZW5kID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICAgIGlmIChkaWRTdXNwZW5kKSB7XG4gICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGluc2lkZSBhIGhpZGRlbiB0cmVlXG4gICAgICAvLyBJbmNsdWRlIHRoZSBiYXNlIGxhbmVzIGZyb20gdGhlIGxhc3QgcmVuZGVyXG4gICAgICB2YXIgbmV4dEJhc2VMYW5lcyA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IG1lcmdlTGFuZXMocHJldlN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpIDogcmVuZGVyTGFuZXM7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFJlc2V0IHRvIHRoZSBjdXJyZW50IGNoaWxkcmVuXG4gICAgICAgIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoZSBjdXJyZW50IHJlbmRlciBzdXNwZW5kZWQsIGJ1dCB0aGVyZSBtYXkgYmUgb3RoZXIgbGFuZXMgd2l0aFxuICAgICAgICAvLyBwZW5kaW5nIHdvcmsuIFdlIGNhbid0IHJlYWQgYGNoaWxkTGFuZXNgIGZyb20gdGhlIGN1cnJlbnQgT2Zmc2NyZWVuXG4gICAgICAgIC8vIGZpYmVyIGJlY2F1c2Ugd2UgcmVzZXQgaXQgd2hlbiBpdCB3YXMgZGVmZXJyZWQ7IGhvd2V2ZXIsIHdlIGNhbiByZWFkXG4gICAgICAgIC8vIHRoZSBwZW5kaW5nIGxhbmVzIGZyb20gdGhlIGNoaWxkIGZpYmVycy5cblxuICAgICAgICB2YXIgY3VycmVudENoaWxkTGFuZXMgPSBOb0xhbmVzO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobWVyZ2VMYW5lcyhjdXJyZW50Q2hpbGRMYW5lcywgY3VycmVudENoaWxkLmxhbmVzKSwgY3VycmVudENoaWxkLmNoaWxkTGFuZXMpO1xuICAgICAgICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhbmVzV2VKdXN0QXR0ZW1wdGVkID0gbmV4dEJhc2VMYW5lcztcbiAgICAgICAgdmFyIHJlbWFpbmluZ0NoaWxkTGFuZXMgPSByZW1vdmVMYW5lcyhjdXJyZW50Q2hpbGRMYW5lcywgbGFuZXNXZUp1c3RBdHRlbXB0ZWQpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gcmVtYWluaW5nQ2hpbGRMYW5lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dEJhc2VMYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSkge1xuICAgICAgLy8gV2UncmUgaGlkZGVuLCBhbmQgd2UncmUgbm90IHJlbmRlcmluZyBhdCBPZmZzY3JlZW4uIFdlIHdpbGwgYmFpbCBvdXRcbiAgICAgIC8vIGFuZCByZXN1bWUgdGhpcyB0cmVlIGxhdGVyLlxuICAgICAgLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgT2Zmc2NyZWVuIHByaW9yaXR5XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTsgLy8gSW5jbHVkZSB0aGUgYmFzZSBsYW5lcyBmcm9tIHRoZSBsYXN0IHJlbmRlclxuXG4gICAgICB2YXIgX25leHRCYXNlTGFuZXMgPSBwcmV2U3RhdGUgIT09IG51bGwgPyBtZXJnZUxhbmVzKHByZXZTdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKSA6IHJlbmRlckxhbmVzO1xuXG4gICAgICByZXR1cm4gZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0QmFzZUxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgc2Vjb25kIHJlbmRlci4gVGhlIHN1cnJvdW5kaW5nIHZpc2libGUgY29udGVudCBoYXMgYWxyZWFkeVxuICAgICAgLy8gY29tbWl0dGVkLiBOb3cgd2UgcmVzdW1lIHJlbmRlcmluZyB0aGUgaGlkZGVuIHRyZWUuXG4gICAgICAvLyBSZW5kZXJpbmcgYXQgb2Zmc2NyZWVuLCBzbyB3ZSBjYW4gY2xlYXIgdGhlIGJhc2UgbGFuZXMuXG4gICAgICB2YXIgX25leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IG51bGxcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gX25leHRTdGF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlbmRlciB0aGF0IHNwYXduZWQgdGhpcyBvbmUgYWNjZXNzZWQgdGhlIGNhY2hlIHBvb2wsIHJlc3VtZVxuICAgICAgICAvLyB1c2luZyB0aGUgc2FtZSBjYWNoZS4gVW5sZXNzIHRoZSBwYXJlbnQgY2hhbmdlZCwgc2luY2UgdGhhdCBtZWFuc1xuICAgICAgICAvLyB0aGVyZSB3YXMgYSByZWZyZXNoLlxuICAgICAgICB2YXIgcHJldkNhY2hlUG9vbCA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IHByZXZTdGF0ZS5jYWNoZVBvb2wgOiBudWxsOyAvLyBUT0RPOiBDb25zaWRlciBpZiBhbmQgaG93IE9mZnNjcmVlbiBwcmUtcmVuZGVyaW5nIHNob3VsZFxuICAgICAgICAvLyBiZSBhdHRyaWJ1dGVkIHRvIHRoZSB0cmFuc2l0aW9uIHRoYXQgc3Bhd25lZCBpdFxuXG4gICAgICAgIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBwcmV2Q2FjaGVQb29sKTtcbiAgICAgIH0gLy8gUHVzaCB0aGUgbGFuZXMgdGhhdCB3ZXJlIHNraXBwZWQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlcmluZyBhIHZpc2libGUgdHJlZS5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBnb2luZyBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlLlxuICAgICAgdmFyIF9wcmV2Q2FjaGVQb29sID0gbnVsbDtcblxuICAgICAge1xuICAgICAgICAvLyBJZiB0aGUgcmVuZGVyIHRoYXQgc3Bhd25lZCB0aGlzIG9uZSBhY2Nlc3NlZCB0aGUgY2FjaGUgcG9vbCwgcmVzdW1lXG4gICAgICAgIC8vIHVzaW5nIHRoZSBzYW1lIGNhY2hlLiBVbmxlc3MgdGhlIHBhcmVudCBjaGFuZ2VkLCBzaW5jZSB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHRoZXJlIHdhcyBhIHJlZnJlc2guXG4gICAgICAgIF9wcmV2Q2FjaGVQb29sID0gcHJldlN0YXRlLmNhY2hlUG9vbDtcbiAgICAgIH1cblxuICAgICAgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIF9wcmV2Q2FjaGVQb29sKTsgLy8gUHVzaCB0aGUgbGFuZXMgdGhhdCB3ZXJlIHNraXBwZWQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXG4gICAgICBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKTtcbiAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7IC8vIFNpbmNlIHdlJ3JlIG5vdCBoaWRkZW4gYW55bW9yZSwgcmVzZXQgdGhlIHN0YXRlXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlbid0IHByZXZpb3VzbHkgaGlkZGVuLCBhbmQgd2Ugc3RpbGwgYXJlbid0LCBzbyB0aGVyZSdzIG5vdGhpbmdcbiAgICAgIC8vIHNwZWNpYWwgdG8gZG8uIE5lZWQgdG8gcHVzaCB0byB0aGUgc3RhY2sgcmVnYXJkbGVzcywgdGhvdWdoLCB0byBhdm9pZFxuICAgICAgLy8gYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG4gICAgICB7XG4gICAgICAgIC8vIElmIHRoZSByZW5kZXIgdGhhdCBzcGF3bmVkIHRoaXMgb25lIGFjY2Vzc2VkIHRoZSBjYWNoZSBwb29sLCByZXN1bWVcbiAgICAgICAgLy8gdXNpbmcgdGhlIHNhbWUgY2FjaGUuIFVubGVzcyB0aGUgcGFyZW50IGNoYW5nZWQsIHNpbmNlIHRoYXQgbWVhbnNcbiAgICAgICAgLy8gdGhlcmUgd2FzIGEgcmVmcmVzaC5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2UncmUgYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB3ZSBuZWVkIHRvIHB1c2ggdGhpcyB0byB0aGUgc3RhY2sgYW55d2F5XG4gICAgICAvLyB0byBhdm9pZCBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cblxuXG4gICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG5cbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0QmFzZUxhbmVzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFN0YXRlID0ge1xuICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lcyxcbiAgICAvLyBTYXZlIHRoZSBjYWNoZSBwb29sIHNvIHdlIGNhbiByZXN1bWUgbGF0ZXIuXG4gICAgY2FjaGVQb29sOiBnZXRPZmZzY3JlZW5EZWZlcnJlZENhY2hlKCkgXG4gIH07XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG5cbiAge1xuICAgIC8vIHB1c2ggdGhlIGNhY2hlIHBvb2wgZXZlbiB0aG91Z2ggd2UncmUgZ29pbmcgdG8gYmFpbCBvdXRcbiAgICAvLyBiZWNhdXNlIG90aGVyd2lzZSB0aGVyZSdkIGJlIGEgY29udGV4dCBtaXNtYXRjaFxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgfVxuICB9IC8vIFdlJ3JlIGFib3V0IHRvIGJhaWwgb3V0LCBidXQgd2UgbmVlZCB0byBwdXNoIHRoaXMgdG8gdGhlIHN0YWNrIGFueXdheVxuICAvLyB0byBhdm9pZCBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cblxuXG4gIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcblxuICByZXR1cm4gbnVsbDtcbn0gLy8gTm90ZTogVGhlc2UgaGFwcGVuIHRvIGhhdmUgaWRlbnRpY2FsIGJlZ2luIHBoYXNlcywgZm9yIG5vdy4gV2Ugc2hvdWxkbid0IGhvbGRcblxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIHBhcmVudENhY2hlID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluaXRpYWwgbW91bnQuIFJlcXVlc3QgYSBmcmVzaCBjYWNoZSBmcm9tIHRoZSBwb29sLlxuICAgIHZhciBmcmVzaENhY2hlID0gcmVxdWVzdENhY2hlRnJvbVBvb2wocmVuZGVyTGFuZXMpO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSB7XG4gICAgICBwYXJlbnQ6IHBhcmVudENhY2hlLFxuICAgICAgY2FjaGU6IGZyZXNoQ2FjaGVcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZnJlc2hDYWNoZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hlY2sgZm9yIHVwZGF0ZXNcbiAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShjdXJyZW50LmxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBudWxsLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTsgLy8gQ29tcGFyZSB0aGUgbmV3IHBhcmVudCBjYWNoZSB0byB0aGUgcHJldmlvdXMgdG8gc2VlIGRldGVjdCB0aGVyZSB3YXNcbiAgICAvLyBhIHJlZnJlc2guXG5cbiAgICBpZiAocHJldlN0YXRlLnBhcmVudCAhPT0gcGFyZW50Q2FjaGUpIHtcbiAgICAgIC8vIFJlZnJlc2ggaW4gcGFyZW50LiBVcGRhdGUgdGhlIHBhcmVudC5cbiAgICAgIHZhciBkZXJpdmVkU3RhdGUgPSB7XG4gICAgICAgIHBhcmVudDogcGFyZW50Q2FjaGUsXG4gICAgICAgIGNhY2hlOiBwYXJlbnRDYWNoZVxuICAgICAgfTsgLy8gQ29waWVkIGZyb20gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIGltcGxlbWVudGF0aW9uLiBPbmNlIHRoZSB1cGRhdGVcbiAgICAgIC8vIHF1ZXVlIGlzIGVtcHR5LCBwZXJzaXN0IHRoZSBkZXJpdmVkIHN0YXRlIG9udG8gdGhlIGJhc2Ugc3RhdGUuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBkZXJpdmVkU3RhdGU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IGRlcml2ZWRTdGF0ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHBhcmVudENhY2hlKTsgLy8gTm8gbmVlZCB0byBwcm9wYWdhdGUgYSBjb250ZXh0IGNoYW5nZSBiZWNhdXNlIHRoZSByZWZyZXNoZWQgcGFyZW50XG4gICAgICAvLyBhbHJlYWR5IGRpZC5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHBhcmVudCBkaWRuJ3QgcmVmcmVzaC4gTm93IGNoZWNrIGlmIHRoaXMgY2FjaGUgZGlkLlxuICAgICAgdmFyIG5leHRDYWNoZSA9IG5leHRTdGF0ZS5jYWNoZTtcbiAgICAgIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBuZXh0Q2FjaGUpO1xuXG4gICAgICBpZiAobmV4dENhY2hlICE9PSBwcmV2U3RhdGUuY2FjaGUpIHtcbiAgICAgICAgLy8gVGhpcyBjYWNoZSByZWZyZXNoZWQuIFByb3BhZ2F0ZSBhIGNvbnRleHQgY2hhbmdlLlxuICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn0gLy8gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgdGhlIG5hbWUgY2hhbmdlc1xuXG5mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQcm9maWxlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcblxuICAgIHtcbiAgICAgIC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbiAgICAgIC8vIFRoZXNlIGFyZSByZXNldCBkdXJpbmcgcmVuZGVyIHRvIGFsbG93IHRoZSBEZXZUb29scyBjb21taXQgaG9vayBhIGNoYW5jZSB0byByZWFkIHRoZW0sXG4gICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFRPRE86IENoZWNrIHByb3BzLnJlZiBpbnN0ZWFkIG9mIGZpYmVyLnJlZiB3aGVuIGVuYWJsZVJlZkFzUHJvcCBpcyBvbi5cbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcblxuICBpZiAocmVmID09PSBudWxsKSB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmIHwgUmVmU3RhdGljO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHJlZiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmVmICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciB1bmRlZmluZWQvbnVsbC4nKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKSB7XG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmIHwgUmVmU3RhdGljO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gU29tZSB2YWxpZGF0aW9ucyB3ZXJlIHByZXZpb3VzbHkgZG9uZSBpbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQgaG93ZXZlciBhbmQgYXJlIG5vdyBydW5cbiAgICAgIC8vIGluIHVwZGF0ZUZ1bnRpb25Db21wb25lbnQgYnV0IG9ubHkgb24gbW91bnRcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSk7XG5cbiAgICAgIGlmIChDb21wb25lbnQuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gJyArICdVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggUmVhY3QudXNlQ29udGV4dCgpIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dDtcblxuICB2YXIgbmV4dENoaWxkcmVuO1xuICB2YXIgaGFzSWQ7XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuICAgIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBDb21wb25lbnQsIHNlY29uZEFyZywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlcGxheSBhIGNvbXBvbmVudCB0aGF0IHByZXZpb3VzbHkgc3VzcGVuZGVkLFxuICAvLyBhZnRlciBpdHMgZGF0YSByZXNvbHZlcy4gSXQncyBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZlxuICAvLyB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudCB0aGF0IHJldXNlcyB0aGUgaG9va3MgZnJvbSB0aGUgcHJldmlvdXMgYXR0ZW1wdC5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IHJlcGxheVN1c3BlbmRlZENvbXBvbmVudFdpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHNlY29uZEFyZyk7XG4gIHZhciBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuICAgIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBlcnJvci5cbiAgICBzd2l0Y2ggKHNob3VsZEVycm9yKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlOyAvLyBUT0RPIFRoaXMgd2F5IG9mIHJlc2V0dGluZyB0aGUgZXJyb3IgYm91bmRhcnkgc3RhdGUgaXMgYSBoYWNrLlxuICAgICAgICAgIC8vIElzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzP1xuXG4gICAgICAgICAgdmFyIHRlbXBJbnN0YW5jZSA9IG5ldyBjdG9yKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsIF9pbnN0YW5jZS5jb250ZXh0KTtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0ZW1wSW5zdGFuY2Uuc3RhdGU7XG5cbiAgICAgICAgICBfaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoX2luc3RhbmNlLCBzdGF0ZSwgbnVsbCk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG5cbiAgICAgICAgICB2YXIgZXJyb3IkMSA9IG5ldyBFcnJvcignU2ltdWxhdGVkIGVycm9yIGNvbWluZyBmcm9tIERldlRvb2xzJyk7XG4gICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBsYW5lKTsgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG5cbiAgICAgICAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgICAgICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGxhbmUpO1xuICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKHVwZGF0ZSwgcm9vdCwgd29ya0luUHJvZ3Jlc3MsIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yJDEsIHdvcmtJblByb2dyZXNzKSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCB1cGRhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9IC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG5cbiAgdmFyIGhhc0NvbnRleHQ7XG5cbiAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciBzaG91bGRVcGRhdGU7XG5cbiAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG5cbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIHZhciBpbnN0ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSAmJiBpbnN0LnByb3BzICE9PSBuZXh0UHJvcHMpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBlcnJvcignSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRVbml0T2ZXb3JrO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIHtcbiAgICBzZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcblxuICBpZiAoZGlkQ2FwdHVyZUVycm9yICYmIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSWYgd2UgY2FwdHVyZWQgYW4gZXJyb3IsIGJ1dCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXMgbm90IGRlZmluZWQsXG4gICAgLy8gdW5tb3VudCBhbGwgdGhlIGNoaWxkcmVuLiBjb21wb25lbnREaWRDYXRjaCB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB0b1xuICAgIC8vIHJlLXJlbmRlciBhIGZhbGxiYWNrLiBUaGlzIGlzIHRlbXBvcmFyeSB1bnRpbCB3ZSBtaWdyYXRlIGV2ZXJ5b25lIHRvXG4gICAgLy8gdGhlIG5ldyBBUEkuXG4gICAgLy8gVE9ETzogV2FybiBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG5cbiAgICB7XG4gICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZygpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbmV4dENoaWxkcmVuID0gY2FsbFJlbmRlckluREVWKGluc3RhbmNlKTtcblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbFJlbmRlckluREVWKGluc3RhbmNlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2ZcbiAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4gICAgLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbiAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlOyAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBwcmV2Q2hpbGRyZW4gPSBwcmV2U3RhdGUuZWxlbWVudDtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICB2YXIgbmV4dENhY2hlID0gbmV4dFN0YXRlLmNhY2hlO1xuICAgIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBuZXh0Q2FjaGUpO1xuXG4gICAgaWYgKG5leHRDYWNoZSAhPT0gcHJldlN0YXRlLmNhY2hlKSB7XG4gICAgICAvLyBUaGUgcm9vdCBjYWNoZSByZWZyZXNoZWQuXG4gICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gVGhpcyB3b3VsZCBpZGVhbGx5IGdvIGluc2lkZSBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCBiZWNhdXNlIGl0IHN1c3BlbmRzLFxuICAvLyBpdCBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIGBwdXNoQ2FjaGVQcm92aWRlcmAgY2FsbCBhYm92ZSB0byBhdm9pZCBhXG4gIC8vIGNvbnRleHQgc3RhY2sgbWlzbWF0Y2guIEEgYml0IHVuZm9ydHVuYXRlLlxuXG5cbiAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uICYmIHByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAvLyBUaGlzIGlzIGEgaHlkcmF0aW9uIHJvb3Qgd2hvc2Ugc2hlbGwgaGFzIG5vdCB5ZXQgaHlkcmF0ZWQuIFdlIHNob3VsZFxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZS5cbiAgICAvLyBGbGlwIGlzRGVoeWRyYXRlZCB0byBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHdoZW4gdGhpcyByZW5kZXJcbiAgICAvLyBmaW5pc2hlcywgdGhlIHJvb3Qgd2lsbCBubyBsb25nZXIgYmUgZGVoeWRyYXRlZC5cbiAgICB2YXIgb3ZlcnJpZGVTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IG5leHRDaGlsZHJlbixcbiAgICAgIGlzRGVoeWRyYXRlZDogZmFsc2UsXG4gICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlXG4gICAgfTtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTsgLy8gYGJhc2VTdGF0ZWAgY2FuIGFsd2F5cyBiZSB0aGUgbGFzdCBzdGF0ZSBiZWNhdXNlIHRoZSByb290IGRvZXNuJ3RcbiAgICAvLyBoYXZlIHJlZHVjZXIgZnVuY3Rpb25zIHNvIGl0IGRvZXNuJ3QgbmVlZCByZWJhc2luZy5cblxuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG92ZXJyaWRlU3RhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG92ZXJyaWRlU3RhdGU7XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgLy8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGEgcHJldmlvdXMgYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBzaGVsbCwgc28gd2VcbiAgICAgIC8vIGZvcmNlZCBhIGNsaWVudCByZW5kZXIuIFdlIHNob3VsZCBoYXZlIGEgcmVjb3ZlcmFibGUgZXJyb3IgYWxyZWFkeSBzY2hlZHVsZWQuXG4gICAgICByZXR1cm4gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciByZWNvdmVyYWJsZUVycm9yID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIobmV3IEVycm9yKCdUaGlzIHJvb3QgcmVjZWl2ZWQgYW4gZWFybHkgdXBkYXRlLCBiZWZvcmUgYW55dGhpbmcgd2FzIGFibGUgJyArICdoeWRyYXRlLiBTd2l0Y2hlZCB0aGUgZW50aXJlIHJvb3QgdG8gY2xpZW50IHJlbmRlcmluZy4nKSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTtcbiAgICAgIHJldHVybiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBvdXRlcm1vc3Qgc2hlbGwgaGFzIG5vdCBoeWRyYXRlZCB5ZXQuIFN0YXJ0IGh5ZHJhdGluZy5cbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIGNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNoaWxkO1xuICAgICAgdmFyIG5vZGUgPSBjaGlsZDtcblxuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgLy8gTWFyayBlYWNoIGNoaWxkIGFzIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGZhc3QgcGF0aCB0byBrbm93IHdoZXRoZXIgdGhpc1xuICAgICAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgICAgIC8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuICAgICAgICAvLyBDb25jZXB0dWFsbHkgdGhpcyBpcyBzaW1pbGFyIHRvIFBsYWNlbWVudCBpbiB0aGF0IGEgbmV3IHN1YnRyZWUgaXNcbiAgICAgICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgICAgIC8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAgICBub2RlLmZsYWdzID0gbm9kZS5mbGFncyAmIH5QbGFjZW1lbnQgfCBIeWRyYXRpbmc7XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJvb3QgaXMgbm90IGRlaHlkcmF0ZWQuIEVpdGhlciB0aGlzIGlzIGEgY2xpZW50LW9ubHkgcm9vdCwgb3IgaXRcbiAgICAvLyBhbHJlYWR5IGh5ZHJhdGVkLlxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcblxuICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IHByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIC8vIFJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlxuICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IEZvcmNlQ2xpZW50UmVuZGVyO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhcyBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcyAhPT0gbnVsbCAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAobWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBmaWJlciBoYXMgYmVlbiB1cGdyYWRlZCB0byBhIHN0YXRlZnVsIGNvbXBvbmVudC4gVGhlIG9ubHkgd2F5XG4gICAgICAvLyBoYXBwZW5zIGN1cnJlbnRseSBpcyBmb3IgZm9ybSBhY3Rpb25zLiBXZSB1c2UgaG9va3MgdG8gdHJhY2sgdGhlXG4gICAgICAvLyBwZW5kaW5nIGFuZCBlcnJvciBzdGF0ZSBvZiB0aGUgZm9ybS5cbiAgICAgIC8vXG4gICAgICAvLyBPbmNlIGEgZmliZXIgaXMgdXBncmFkZWQgdG8gYmUgc3RhdGVmdWwsIGl0IHJlbWFpbnMgc3RhdGVmdWwgZm9yIHRoZVxuICAgICAgLy8gcmVzdCBvZiBpdHMgbGlmZXRpbWUuXG4gICAgICB2YXIgbmV3U3RhdGUgPSByZW5kZXJUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50V2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7IC8vIElmIHRoZSB0cmFuc2l0aW9uIHN0YXRlIGNoYW5nZWQsIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIHRvIGFsbCB0aGVcbiAgICAgIC8vIGRlc2NlbmRlbnRzLiBXZSB1c2UgQ29udGV4dCBhcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgZm9yIHRoaXMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHNldCBoZXJlIGluc3RlYWQgb2YgcHVzaEhvc3RDb250ZXh0IGJlY2F1c2VcbiAgICAgIC8vIHB1c2hIb3N0Q29udGV4dCBnZXRzIGNhbGxlZCBiZWZvcmUgd2UgcHJvY2VzcyB0aGUgc3RhdGUgaG9vaywgdG8gYXZvaWRcbiAgICAgIC8vIGEgc3RhdGUgbWlzbWF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgc29tZXRoaW5nIHN1c3BlbmRzLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFRoaXMgYXNzdW1lcyB0aGF0IHRoZXJlIGNhbm5vdCBiZSBuZXN0ZWQgdHJhbnNpdGlvbiBwcm92aWRlcnMsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBvbmx5IHJlbmRlcmVyIHRoYXQgaW1wbGVtZW50cyB0aGlzIGZlYXR1cmUgaXMgUmVhY3QgRE9NLFxuICAgICAgLy8gYW5kIGZvcm1zIGNhbm5vdCBiZSBuZXN0ZWQuIElmIHdlIGRpZCBzdXBwb3J0IG5lc3RlZCBwcm92aWRlcnMsIHRoZW5cbiAgICAgIC8vIHdlIHdvdWxkIG5lZWQgdG8gcHVzaCBhIGNvbnRleHQgdmFsdWUgZXZlbiBmb3IgaG9zdCBmaWJlcnMgdGhhdFxuICAgICAgLy8gaGF2ZW4ndCBiZWVuIHVwZ3JhZGVkIHlldC5cblxuICAgICAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgICAgIEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gbmV3U3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXdTdGF0ZTtcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICBpZiAoZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb2xkU3RhdGVIb29rID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gb2xkU3RhdGVIb29rLm1lbW9pemVkU3RhdGU7IC8vIFRoaXMgdXNlcyByZWd1bGFyIGVxdWFsaXR5IGluc3RlYWQgb2YgT2JqZWN0LmlzIGJlY2F1c2Ugd2UgYXNzdW1lXG4gICAgICAgICAgICAvLyB0aGF0IGhvc3QgdHJhbnNpdGlvbiBzdGF0ZSBkb2Vzbid0IGluY2x1ZGUgTmFOIGFzIGEgdmFsaWQgdHlwZS5cblxuICAgICAgICAgICAgaWYgKG9sZFN0YXRlICE9PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBIb3N0VHJhbnNpdGlvbkNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RIb2lzdGFibGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHJlc291cmNlID0gZ2V0UmVzb3VyY2Uod29ya0luUHJvZ3Jlc3MudHlwZSwgbnVsbCwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCBudWxsKTtcblxuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHJlc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBub3QgYSBSZXNvdXJjZSBIb2lzdGFibGUgYW5kIHdlIGFyZW4ndCBoeWRyYXRpbmcgc28gd2UgY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCBnZXRSb290SG9zdENvbnRhaW5lcigpLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEdldCBSZXNvdXJjZSBtYXkgb3IgbWF5IG5vdCByZXR1cm4gYSByZXNvdXJjZS4gZWl0aGVyIHdheSB3ZSBzdGFzaCB0aGUgcmVzdWx0XG4gICAgLy8gb24gbWVtb2l6ZWQgc3RhdGUuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGdldFJlc291cmNlKHdvcmtJblByb2dyZXNzLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCBjdXJyZW50Lm1lbW9pemVkU3RhdGUpO1xuICB9IC8vIFJlc291cmNlcyBuZXZlciBoYXZlIHJlY29uY2lsZXIgbWFuYWdlZCBjaGlsZHJlbi4gSXQgaXMgcG9zc2libGUgZm9yXG4gIC8vIHRoZSBob3N0IGltcGxlbWVudGF0aW9uIG9mIGdldFJlc291cmNlIHRvIGNvbnNpZGVyIGNoaWxkcmVuIGluIHRoZVxuICAvLyByZXNvdXJjZSBjb25zdHJ1Y3Rpb24gYnV0IHRoZXkgd2lsbCBvdGhlcndpc2UgYmUgZGlzY2FyZGVkLiBJbiBwcmFjdGljZVxuICAvLyB0aGlzIHByZWNsdWRlcyBhbGwgYnV0IHRoZSBzaW1wbGVzdCBjaGlsZHJlbiBhbmQgSG9zdCBzcGVjaWZpYyB3YXJuaW5nc1xuICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgdG8gd2FybiB3aGVuIGNoaWxkcmVuIGFyZSBwYXNzc2VkIHdoZW4gb3RoZXJ3aXNlIG5vdFxuICAvLyBleHBlY3RlZFxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RTaW5nbGV0b24oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBjbGFpbUh5ZHJhdGFibGVTaW5nbGV0b24od29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiAhZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIC8vIFNpbWlsYXIgdG8gUG9ydGFscyB3ZSBhcHBlbmQgU2luZ2xldG9uIGNoaWxkcmVuIGluIHRoZSBjb21taXQgcGhhc2UuIFNvIHdlXG4gICAgLy8gVHJhY2sgaW5zZXJ0aW9ucyBldmVuIG9uIG1vdW50LlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZVRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF6eUNvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnRUeXBlLCByZW5kZXJMYW5lcykge1xuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBsYXp5Q29tcG9uZW50ID0gZWxlbWVudFR5cGU7XG4gIHZhciBDb21wb25lbnQ7XG5cbiAge1xuICAgIENvbXBvbmVudCA9IGNhbGxMYXp5SW5pdEluREVWKGxhenlDb21wb25lbnQpO1xuICB9IC8vIFN0b3JlIHRoZSB1bndyYXBwZWQgY29tcG9uZW50IGluIHRoZSB0eXBlLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudDtcblxuICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc0Z1bmN0aW9uQ2xhc3NDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gcHJvcHMgO1xuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBGdW5jdGlvbkNvbXBvbmVudDtcblxuICAgICAge1xuICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKENvbXBvbmVudCAhPT0gdW5kZWZpbmVkICYmIENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IENvbXBvbmVudC4kJHR5cGVvZjtcblxuICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMiA9IHByb3BzIDtcblxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRm9yd2FyZFJlZjtcblxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgX3Jlc29sdmVkUHJvcHMyLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICB2YXIgX3Jlc29sdmVkUHJvcHMzID0gcHJvcHMgO1xuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBNZW1vQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgX3Jlc29sdmVkUHJvcHMzICwgLy8gVGhlIGlubmVyIHR5cGUgY2FuIGhhdmUgZGVmYXVsdHMgdG9vXG4gICAgICByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpbnQgPSAnJztcblxuICB7XG4gICAgaWYgKENvbXBvbmVudCAhPT0gbnVsbCAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgaGludCA9ICcgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT8nO1xuICAgIH1cbiAgfSAvLyBUaGlzIG1lc3NhZ2UgaW50ZW50aW9uYWxseSBkb2Vzbid0IG1lbnRpb24gRm9yd2FyZFJlZiBvciBNZW1vQ29tcG9uZW50XG4gIC8vIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCBpdCdzIGEgc2VwYXJhdGUgdHlwZSBvZiB3b3JrIGlzIGFuXG4gIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbC5cblxuXG4gIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgKyBDb21wb25lbnQgKyBcIi4gXCIgKyAoXCJMYXp5IGVsZW1lbnQgdHlwZSBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi5cIiArIGhpbnQpKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAge1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIGlmIChDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LlxcbicgKyAnICAlcy5jaGlsZENvbnRleHRUeXBlcyA9IC4uLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLicsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LmNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBjb250ZXh0VHlwZS4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFNVU1BFTkRFRF9NQVJLRVIgPSB7XG4gIGRlaHlkcmF0ZWQ6IG51bGwsXG4gIHRyZWVDb250ZXh0OiBudWxsLFxuICByZXRyeUxhbmU6IE5vTGFuZVxufTtcblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiByZW5kZXJMYW5lcyxcbiAgICBjYWNoZVBvb2w6IGdldFN1c3BlbmRlZENhY2hlKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjYWNoZVBvb2wgPSBudWxsO1xuXG4gIHtcbiAgICB2YXIgcHJldkNhY2hlUG9vbCA9IHByZXZPZmZzY3JlZW5TdGF0ZS5jYWNoZVBvb2w7XG5cbiAgICBpZiAocHJldkNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHBhcmVudENhY2hlID0gaXNQcmltYXJ5UmVuZGVyZXIgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMjtcblxuICAgICAgaWYgKHByZXZDYWNoZVBvb2wucGFyZW50ICE9PSBwYXJlbnRDYWNoZSkge1xuICAgICAgICAvLyBEZXRlY3RlZCBhIHJlZnJlc2ggaW4gdGhlIHBhcmVudC4gVGhpcyBvdmVycmlkZXMgYW55IHByZXZpb3VzbHlcbiAgICAgICAgLy8gc3VzcGVuZGVkIGNhY2hlLlxuICAgICAgICBjYWNoZVBvb2wgPSB7XG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRDYWNoZSxcbiAgICAgICAgICBwb29sOiBwYXJlbnRDYWNoZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgY2FuIHJldXNlIHRoZSBjYWNoZSBmcm9tIGxhc3QgdGltZS4gVGhlIG9ubHkgdGhpbmcgdGhhdCB3b3VsZCBoYXZlXG4gICAgICAgIC8vIG92ZXJyaWRkZW4gaXQgaXMgYSBwYXJlbnQgcmVmcmVzaCwgd2hpY2ggd2UgY2hlY2tlZCBmb3IgYWJvdmUuXG4gICAgICAgIGNhY2hlUG9vbCA9IHByZXZDYWNoZVBvb2w7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcHJldmlvdXMgY2FjaGUgcG9vbCwgZ3JhYiB0aGUgY3VycmVudCBvbmUuXG4gICAgICBjYWNoZVBvb2wgPSBnZXRTdXNwZW5kZWRDYWNoZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiBtZXJnZUxhbmVzKHByZXZPZmZzY3JlZW5TdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKSxcbiAgICBjYWNoZVBvb2w6IGNhY2hlUG9vbFxuICB9O1xufSAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgaW5saW5lIHRoaXMgYmFja1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uRmFsbGJhY2soY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgd2UgbmVlZCB0b1xuICAvLyByZW1haW4gb24gdGhhdCBmYWxsYmFjayByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGNvbnRlbnQgaGFzIHJlc29sdmVkLlxuICAvLyBGb3IgZXhhbXBsZSwgU3VzcGVuc2VMaXN0IGNvb3JkaW5hdGVzIHdoZW4gbmVzdGVkIGNvbnRlbnQgYXBwZWFycy5cbiAgLy8gVE9ETzogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBvZmZzY3JlZW4gcHJlcmVuZGVyaW5nLCB0aGlzIHNob3VsZCBhbHNvIGNoZWNrXG4gIC8vIHdoZXRoZXIgdGhlIGN1cnJlbnQgZmliZXIgKGlmIGl0IGV4aXN0cykgd2FzIHZpc2libGUgaW4gdGhlIHByZXZpb3VzIHRyZWUuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gQ3VycmVudGx5IHNob3dpbmcgY29udGVudC4gRG9uJ3QgaGlkZSBpdCwgZXZlbiBpZiBGb3JjZVN1c3BlbnNlRmFsbGJhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcmV0dXJuIGhhc1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShjdXJyZW50LCBwcmltYXJ5VHJlZURpZERlZmVyLCByZW5kZXJMYW5lcykge1xuICB2YXIgcmVtYWluaW5nTGFuZXMgPSBjdXJyZW50ICE9PSBudWxsID8gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykgOiBOb0xhbmVzO1xuXG4gIGlmIChwcmltYXJ5VHJlZURpZERlZmVyKSB7XG4gICAgLy8gQSB1c2VEZWZlcnJlZFZhbHVlIGhvb2sgc3Bhd25lZCBhIGRlZmVycmVkIHRhc2sgaW5zaWRlIHRoZSBwcmltYXJ5IHRyZWUuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgcmV0cnkgdGhpcyBjb21wb25lbnQgYXQgdGhlIGRlZmVycmVkIHByaW9yaXR5LlxuICAgIC8vIFRPRE86IFdlIGNvdWxkIG1ha2UgdGhpcyBhIHBlci1zdWJ0cmVlIHZhbHVlIGluc3RlYWQgb2YgYSBnbG9iYWwgb25lLlxuICAgIC8vIFdvdWxkIG5lZWQgdG8gdHJhY2sgaXQgb24gdGhlIGNvbnRleHQgc3RhY2sgc29tZWhvdywgc2ltaWxhciB0byB3aGF0XG4gICAgLy8gd2UnZCBoYXZlIHRvIGRvIGZvciByZXN1bWFibGUgY29udGV4dHMuXG4gICAgcmVtYWluaW5nTGFuZXMgPSBtZXJnZUxhbmVzKHJlbWFpbmluZ0xhbmVzLCBwZWVrRGVmZXJyZWRMYW5lKCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlbWFpbmluZ0xhbmVzO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsgLy8gVGhpcyBpcyB1c2VkIGJ5IERldlRvb2xzIHRvIGZvcmNlIGEgYm91bmRhcnkgdG8gc3VzcGVuZC5cblxuICB7XG4gICAgaWYgKHNob3VsZFN1c3BlbmQod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzaG93RmFsbGJhY2sgPSBmYWxzZTtcbiAgdmFyIGRpZFN1c3BlbmQgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soY3VycmVudCkpIHtcbiAgICAvLyBTb21ldGhpbmcgaW4gdGhpcyBib3VuZGFyeSdzIHN1YnRyZWUgYWxyZWFkeSBzdXNwZW5kZWQuIFN3aXRjaCB0b1xuICAgIC8vIHJlbmRlcmluZyB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgc2hvd0ZhbGxiYWNrID0gdHJ1ZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+RGlkQ2FwdHVyZTtcbiAgfSAvLyBDaGVjayBpZiB0aGUgcHJpbWFyeSBjaGlsZHJlbiBzcGF3bmVkIGEgZGVmZXJyZWQgdGFzayAodXNlRGVmZXJyZWRWYWx1ZSlcbiAgLy8gZHVyaW5nIHRoZSBmaXJzdCBwYXNzLlxuXG5cbiAgdmFyIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkRGVmZXIpICE9PSBOb0ZsYWdzJDE7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWREZWZlcjsgLy8gT0ssIHRoZSBuZXh0IHBhcnQgaXMgY29uZnVzaW5nLiBXZSdyZSBhYm91dCB0byByZWNvbmNpbGUgdGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoaXMgaW52b2x2ZXMgc29tZSBjdXN0b20gcmVjb25jaWxpYXRpb24gbG9naWMuIFR3b1xuICAvLyBtYWluIHJlYXNvbnMgdGhpcyBpcyBzbyBjb21wbGljYXRlZC5cbiAgLy9cbiAgLy8gRmlyc3QsIExlZ2FjeSBNb2RlIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhlXG4gIC8vIHByaW1hcnkgdHJlZSB3aWxsIGNvbW1pdCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUsIHNvIHdoZW4gd2UgZG8gdGhlXG4gIC8vIHNlY29uZCBwYXNzIHRvIHJlbmRlciB0aGUgZmFsbGJhY2ssIHdlIGRvIHNvbWUgZXhjZWVkaW5nbHksIHVoLCBjbGV2ZXJcbiAgLy8gaGFja3MgdG8gbWFrZSB0aGF0IG5vdCB0b3RhbGx5IGJyZWFrLiBMaWtlIHRyYW5zZmVycmluZyBlZmZlY3RzIGFuZFxuICAvLyBkZWxldGlvbnMgZnJvbSBoaWRkZW4gdHJlZS4gSW4gQ29uY3VycmVudCBNb2RlLCBpdCdzIG11Y2ggc2ltcGxlcixcbiAgLy8gYmVjYXVzZSB3ZSBiYWlsb3V0IG9uIHRoZSBwcmltYXJ5IHRyZWUgY29tcGxldGVseSBhbmQgbGVhdmUgaXQgaW4gaXRzIG9sZFxuICAvLyBzdGF0ZSwgbm8gZWZmZWN0cy4gU2FtZSBhcyB3aGF0IHdlIGRvIGZvciBPZmZzY3JlZW4gKGV4Y2VwdCB0aGF0XG4gIC8vIE9mZnNjcmVlbiBkb2Vzbid0IGhhdmUgdGhlIGZpcnN0IHJlbmRlciBwYXNzKS5cbiAgLy9cbiAgLy8gU2Vjb25kIGlzIGh5ZHJhdGlvbi4gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIFN1c3BlbnNlIGZpYmVyIGhhcyBhIHNsaWdodGx5XG4gIC8vIGRpZmZlcmVudCBsYXlvdXQsIHdoZXJlIHRoZSBjaGlsZCBwb2ludHMgdG8gYSBkZWh5ZHJhdGVkIGZyYWdtZW50LCB3aGljaFxuICAvLyBjb250YWlucyB0aGUgRE9NIHJlbmRlcmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vIFRoaXJkLCBldmVuIGlmIHlvdSBzZXQgYWxsIHRoYXQgYXNpZGUsIFN1c3BlbnNlIGlzIGxpa2UgZXJyb3IgYm91bmRhcmllcyBpblxuICAvLyB0aGF0IHdlIGZpcnN0IHdlIHRyeSB0byByZW5kZXIgb25lIHRyZWUsIGFuZCBpZiB0aGF0IGZhaWxzLCB3ZSByZW5kZXIgYWdhaW5cbiAgLy8gYW5kIHN3aXRjaCB0byBhIGRpZmZlcmVudCB0cmVlLiBMaWtlIGEgdHJ5L2NhdGNoIGJsb2NrLiBTbyB3ZSBoYXZlIHRvIHRyYWNrXG4gIC8vIHdoaWNoIGJyYW5jaCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nLiBJZGVhbGx5IHdlIHdvdWxkIG1vZGVsIHRoaXMgdXNpbmdcbiAgLy8gYSBzdGFjay5cblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICAvLyBTcGVjaWFsIHBhdGggZm9yIGh5ZHJhdGlvblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHRyeSB0byBoeWRyYXRlIHRoaXMgYm91bmRhcnkuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIC8vIFdlIG11c3QgcHVzaCB0aGUgc3VzcGVuc2UgaGFuZGxlciBjb250ZXh0ICpiZWZvcmUqIGF0dGVtcHRpbmcgdG9cbiAgICAgIC8vIGh5ZHJhdGUsIHRvIGF2b2lkIGEgbWlzbWF0Y2ggaW4gY2FzZSBpdCBlcnJvcnMuXG4gICAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmFsbGJhY2tUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgY291bGQndmUgYmVlbiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxuXG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZWh5ZHJhdGVkID0gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KHdvcmtJblByb2dyZXNzLCBkZWh5ZHJhdGVkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiBoeWRyYXRpb24gZGlkbid0IHN1Y2NlZWQsIGZhbGwgdGhyb3VnaCB0byB0aGUgbm9ybWFsIFN1c3BlbnNlIHBhdGguXG4gICAgICAvLyBUbyBhdm9pZCBhIHN0YWNrIG1pc21hdGNoIHdlIG5lZWQgdG8gcG9wIHRoZSBTdXNwZW5zZSBoYW5kbGVyIHRoYXQgd2VcbiAgICAgIC8vIHB1c2hlZCBhYm92ZS4gVGhpcyB3aWxsIGJlY29tZSBsZXNzIGF3a3dhcmQgd2hlbiBtb3ZlIHRoZSBoeWRyYXRpb25cbiAgICAgIC8vIGxvZ2ljIHRvIGl0cyBvd24gZmliZXIuXG5cblxuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG5cbiAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICBwdXNoRmFsbGJhY2tUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciBmYWxsYmFja0ZyYWdtZW50ID0gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4sIG5leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50Lm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyLCByZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcblxuICAgICAgcmV0dXJuIGZhbGxiYWNrRnJhZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYW4gdXBkYXRlLlxuICAgIC8vIFNwZWNpYWwgcGF0aCBmb3IgaHlkcmF0aW9uXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfZGVoeWRyYXRlZCA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICBpZiAoX2RlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZGlkU3VzcGVuZCwgZGlkUHJpbWFyeUNoaWxkcmVuRGVmZXIsIG5leHRQcm9wcywgX2RlaHlkcmF0ZWQsIHByZXZTdGF0ZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG93RmFsbGJhY2spIHtcbiAgICAgIHB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIF9uZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgIHZhciBfbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSB1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuLCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICB2YXIgcHJldk9mZnNjcmVlblN0YXRlID0gY3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlO1xuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5tZW1vaXplZFN0YXRlID0gcHJldk9mZnNjcmVlblN0YXRlID09PSBudWxsID8gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSA6IHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyLCByZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4yID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50MyA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjIpO1xuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSk7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSk7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLCBtb2RlLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbmAgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZVxuICAvLyB0aGlzIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxuICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKG9mZnNjcmVlblByb3BzLCBtb2RlLCBOb0xhbmVzLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZVdvcmtJblByb2dyZXNzYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlIHRoaXNcbiAgLy8gd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH0pO1xuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gbnVsbDtcblxuICBpZiAoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIC8vIERlbGV0ZSB0aGUgZmFsbGJhY2sgY2hpbGQgZnJhZ21lbnRcbiAgICB2YXIgZGVsZXRpb25zID0gd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gW2N1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnRdO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcbiAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXG4gIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCBwcmltYXJ5Q2hpbGRQcm9wcyk7IC8vIFNpbmNlIHdlJ3JlIHJldXNpbmcgYSBjdXJyZW50IHRyZWUsIHdlIG5lZWQgdG8gcmV1c2UgdGhlIGZsYWdzLCB0b28uXG4gICAgLy8gKFdlIGRvbid0IGRvIHRoaXMgaW4gbGVnYWN5IG1vZGUsIGJlY2F1c2UgaW4gbGVnYWN5IG1vZGUgd2UgZG9uJ3QgcmUtdXNlXG4gICAgLy8gdGhlIGN1cnJlbnQgdHJlZTsgc2VlIHByZXZpb3VzIGJyYW5jaC4pXG5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zdWJ0cmVlRmxhZ3MgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgfVxuXG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LCBmYWxsYmFja0NoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAgIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIEZhbGxpbmcgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLiBCZWNhdXNlIHRoaXMgaGFzIHBlcmZvcm1hbmNlXG4gIC8vIGltcGxpY2F0aW9ucywgaXQncyBjb25zaWRlcmVkIGEgcmVjb3ZlcmFibGUgZXJyb3IsIGV2ZW4gdGhvdWdoIHRoZSB1c2VyXG4gIC8vIGxpa2VseSB3b24ndCBvYnNlcnZlIGFueXRoaW5nIHdyb25nIHdpdGggdGhlIFVJLlxuICAvLyBUaGlzIHdpbGwgYWRkIHRoZSBvbGQgZmliZXIgdG8gdGhlIGRlbGV0aW9uIGxpc3RcbiAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTsgLy8gV2UncmUgbm93IG5vdCBzdXNwZW5kZWQgbm9yIGRlaHlkcmF0ZWQuXG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlIGJvdW5kYXJ5KSBhbHJlYWR5XG4gIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgZmliZXJNb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgZmliZXJNb2RlKTtcbiAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIGZpYmVyTW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2VcbiAgLy8gYm91bmRhcnkpIGFscmVhZHkgbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cblxuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXG4gIHtcbiAgICAvLyBXZSB3aWxsIGhhdmUgZHJvcHBlZCB0aGUgZWZmZWN0IGxpc3Qgd2hpY2ggY29udGFpbnMgdGhlXG4gICAgLy8gZGVsZXRpb24uIFdlIG5lZWQgdG8gcmVjb25jaWxlIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBjaGlsZC5cbiAgICByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG4gIC8vIER1cmluZyB0aGUgZmlyc3QgcGFzcywgd2UnbGwgYmFpbCBvdXQgYW5kIG5vdCBkcmlsbCBpbnRvIHRoZSBjaGlsZHJlbi5cbiAgLy8gSW5zdGVhZCwgd2UnbGwgbGVhdmUgdGhlIGNvbnRlbnQgaW4gcGxhY2UgYW5kIHRyeSB0byBoeWRyYXRlIGl0IGxhdGVyLlxuICBpZiAoaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAvLyBUaGlzIGlzIGEgY2xpZW50LW9ubHkgYm91bmRhcnkuIFNpbmNlIHdlIHdvbid0IGdldCBhbnkgY29udGVudCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAvLyBmb3IgdGhpcywgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGF0IGF0IGEgaGlnaGVyIHByaW9yaXR5IGJhc2VkIG9uIHdoZW4gaXQgd291bGRcbiAgICAvLyBoYXZlIHRpbWVkIG91dC4gSW4gdGhlb3J5IHdlIGNvdWxkIHJlbmRlciBpdCBpbiB0aGlzIHBhc3MgYnV0IGl0IHdvdWxkIGhhdmUgdGhlXG4gICAgLy8gd3JvbmcgcHJpb3JpdHkgYXNzb2NpYXRlZCB3aXRoIGl0IGFuZCB3aWxsIHByZXZlbnQgaHlkcmF0aW9uIG9mIHBhcmVudCBwYXRoLlxuICAgIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHdvcmsgbGVmdCBvbiBpdCB0byByZW5kZXIgaXQgaW4gYSBzZXBhcmF0ZSBjb21taXQuXG4gICAgLy8gVE9ETyBUaGlzIHRpbWUgc2hvdWxkIGJlIHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgcmVzcG9uc2UgdGhhdCBpc1xuICAgIC8vIGEgcGFyZW50IHRvIHRoaXMgYm91bmRhcnkgd2FzIGRpc3BsYXllZC4gSG93ZXZlciwgc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IGhhdmVcbiAgICAvLyBhIHByb3RvY29sIHRvIHRyYW5zZmVyIHRoYXQgdGltZSwgd2UnbGwganVzdCBlc3RpbWF0ZSBpdCBieSB1c2luZyB0aGUgY3VycmVudFxuICAgIC8vIHRpbWUuIFRoaXMgd2lsbCBtZWFuIHRoYXQgU3VzcGVuc2UgdGltZW91dHMgYXJlIHNsaWdodGx5IHNoaWZ0ZWQgdG8gbGF0ZXIgdGhhblxuICAgIC8vIHRoZXkgc2hvdWxkIGJlLlxuICAgIC8vIFNjaGVkdWxlIGEgbm9ybWFsIHByaSB1cGRhdGUgdG8gcmVuZGVyIHRoaXMgY29udGVudC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhbmVUb0xhbmVzKERlZmF1bHRIeWRyYXRpb25MYW5lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSdsbCBjb250aW51ZSBoeWRyYXRpbmcgdGhlIHJlc3QgYXQgb2Zmc2NyZWVuIHByaW9yaXR5IHNpbmNlIHdlJ2xsIGFscmVhZHlcbiAgICAvLyBiZSBzaG93aW5nIHRoZSByaWdodCBjb250ZW50IGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXIsIGl0IGlzIG5vIHJ1c2guXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGRpZFN1c3BlbmQsIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyLCBuZXh0UHJvcHMsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIGlmICghZGlkU3VzcGVuZCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBwYXNzLiBBdHRlbXB0IHRvIGh5ZHJhdGUuXG4gICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTsgLy8gV2Ugc2hvdWxkIG5ldmVyIGJlIGh5ZHJhdGluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgaXMgdGhlIGZpcnN0IHBhc3MsXG4gICAgLy8gYnV0IGFmdGVyIHdlJ3ZlIGFscmVhZHkgY29tbWl0dGVkIG9uY2UuXG5cbiAgICB3YXJuSWZIeWRyYXRpbmcoKTtcblxuICAgIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdXNwZW5zZUluc3RhbmNlKSkge1xuICAgICAgLy8gVGhpcyBib3VuZGFyeSBpcyBpbiBhIHBlcm1hbmVudCBmYWxsYmFjayBzdGF0ZS4gSW4gdGhpcyBjYXNlLCB3ZSdsbCBuZXZlclxuICAgICAgLy8gZ2V0IGFuIHVwZGF0ZSBhbmQgd2UnbGwgbmV2ZXIgYmUgYWJsZSB0byBoeWRyYXRlIHRoZSBmaW5hbCBjb250ZW50LiBMZXQncyBqdXN0IHRyeSB0aGVcbiAgICAgIC8vIGNsaWVudCBzaWRlIHJlbmRlciBpbnN0ZWFkLlxuICAgICAgdmFyIGRpZ2VzdDtcbiAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgdmFyIHN0YWNrID0gbnVsbDtcbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIF9nZXRTdXNwZW5zZUluc3RhbmNlRiA9IGdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyhzdXNwZW5zZUluc3RhbmNlKTtcblxuICAgICAgICBkaWdlc3QgPSBfZ2V0U3VzcGVuc2VJbnN0YW5jZUYuZGlnZXN0O1xuICAgICAgICBtZXNzYWdlID0gX2dldFN1c3BlbnNlSW5zdGFuY2VGLm1lc3NhZ2U7XG4gICAgICAgIHN0YWNrID0gX2dldFN1c3BlbnNlSW5zdGFuY2VGLnN0YWNrO1xuICAgICAgICBjb21wb25lbnRTdGFjayA9IF9nZXRTdXNwZW5zZUluc3RhbmNlRi5jb21wb25lbnRTdGFjaztcbiAgICAgIH0gLy8gVE9ETzogRmlndXJlIG91dCBhIGJldHRlciBzaWduYWwgdGhhbiBlbmNvZGluZyBhIG1hZ2ljIGRpZ2VzdCB2YWx1ZS5cblxuXG4gICAgICB7XG4gICAgICAgIHZhciBlcnJvcjtcblxuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgY291bGQgbm90IGZpbmlzaCB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5LCBsaWtlbHkgJyArICdkdWUgdG8gYW4gZXJyb3IgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuICcgKyAnU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgICAgICAgfSAvLyBSZXBsYWNlIHRoZSBzdGFjayB3aXRoIHRoZSBzZXJ2ZXIgc3RhY2tcblxuXG4gICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2sgfHwgJyc7XG4gICAgICAgIGVycm9yLmRpZ2VzdCA9IGRpZ2VzdDtcbiAgICAgICAgdmFyIGNhcHR1cmVkVmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlRnJvbUVycm9yKGVycm9yLCBjb21wb25lbnRTdGFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihjYXB0dXJlZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICAgIC8vIGFueSBjb250ZXh0IGhhcyBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHRyZWF0IGlzIGFzIGlmIHRoZSBpbnB1dCBtaWdodCBoYXZlIGNoYW5nZWQuXG5cblxuICAgIHZhciBoYXNDb250ZXh0Q2hhbmdlZCA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIGN1cnJlbnQuY2hpbGRMYW5lcyk7XG5cbiAgICBpZiAoZGlkUmVjZWl2ZVVwZGF0ZSB8fCBoYXNDb250ZXh0Q2hhbmdlZCkge1xuICAgICAgLy8gVGhpcyBib3VuZGFyeSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgZmlyc3QgcmVuZGVyLiBUaGlzIG1lYW5zIHRoYXQgd2UgYXJlIG5vdyB1bmFibGUgdG9cbiAgICAgIC8vIGh5ZHJhdGUgaXQuIFdlIG1pZ2h0IHN0aWxsIGJlIGFibGUgdG8gaHlkcmF0ZSBpdCB1c2luZyBhIGhpZ2hlciBwcmlvcml0eSBsYW5lLlxuICAgICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICBpZiAoYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSAhPT0gTm9MYW5lICYmIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgIT09IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKSB7XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBtdXRhdGluZyBzaW5jZSB0aGlzIHJlbmRlciB3aWxsIGdldCBpbnRlcnJ1cHRlZC4gVGhpc1xuICAgICAgICAgIC8vIGlzIG9uZSBvZiB0aGUgdmVyeSByYXJlIHRpbWVzIHdoZXJlIHdlIG11dGF0ZSB0aGUgY3VycmVudCB0cmVlXG4gICAgICAgICAgLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICAgICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lO1xuICAgICAgICAgIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShjdXJyZW50LCBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lKTtcbiAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgY3VycmVudCwgYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSk7IC8vIFRocm93IGEgc3BlY2lhbCBvYmplY3QgdGhhdCBzaWduYWxzIHRvIHRoZSB3b3JrIGxvb3AgdGhhdCBpdCBzaG91bGRcbiAgICAgICAgICAvLyBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSdyZSBpbnNpZGUgYSBSZWFjdC1vbmx5IGV4ZWN1dGlvbiBzdGFjaywgd2UgZG9uJ3RcbiAgICAgICAgICAvLyBzdHJpY3RseSBuZWVkIHRvIHRocm93IGhlcmUg4oCUIHdlIGNvdWxkIGluc3RlYWQgbW9kaWZ5IHNvbWUgaW50ZXJuYWxcbiAgICAgICAgICAvLyB3b3JrIGxvb3Agc3RhdGUuIEJ1dCB1c2luZyBhbiBleGNlcHRpb24gbWVhbnMgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgIC8vIGNoZWNrIGZvciB0aGlzIGNhc2Ugb24gZXZlcnkgaXRlcmF0aW9uIG9mIHRoZSB3b3JrIGxvb3AuIFNvIGRvaW5nXG4gICAgICAgICAgLy8gaXQgdGhpcyB3YXkgbW92ZXMgdGhlIGNoZWNrIG91dCBvZiB0aGUgZmFzdCBwYXRoLlxuXG4gICAgICAgICAgdGhyb3cgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uO1xuICAgICAgICB9XG4gICAgICB9IC8vIElmIHdlIGRpZCBub3Qgc2VsZWN0aXZlbHkgaHlkcmF0ZSwgd2UnbGwgY29udGludWUgcmVuZGVyaW5nIHdpdGhvdXRcbiAgICAgIC8vIGh5ZHJhdGluZy4gTWFyayB0aGlzIHRyZWUgYXMgc3VzcGVuZGVkIHRvIHByZXZlbnQgaXQgZnJvbSBjb21taXR0aW5nXG4gICAgICAvLyBvdXRzaWRlIGEgdHJhbnNpdGlvbi5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIHBhdGggc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBoeWRyYXRpb24gbGFuZSBhbHJlYWR5IHN1c3BlbmRlZC5cbiAgICAgIC8vIEN1cnJlbnRseSwgaXQgYWxzbyBoYXBwZW5zIGR1cmluZyBzeW5jIHVwZGF0ZXMgYmVjYXVzZSB0aGVyZSBpcyBub1xuICAgICAgLy8gaHlkcmF0aW9uIGxhbmUgZm9yIHN5bmMgdXBkYXRlcy5cbiAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBpZGVhbGx5IGhhdmUgYSBzeW5jIGh5ZHJhdGlvbiBsYW5lIHRoYXQgd2UgY2FuIGFwcGx5IHRvIGRvXG4gICAgICAvLyBhIHBhc3Mgd2hlcmUgd2UgaHlkcmF0ZSB0aGlzIHN1YnRyZWUgaW4gcGxhY2UgdXNpbmcgdGhlIHByZXZpb3VzIENvbnRleHQgYW5kIHRoZW5cbiAgICAgIC8vIHJlYXBwbHkgdGhlIHVwZGF0ZSBhZnRlcndhcmRzLlxuXG5cbiAgICAgIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKHN1c3BlbnNlSW5zdGFuY2UpKSA7IGVsc2Uge1xuICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAoaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhzdXNwZW5zZUluc3RhbmNlKSkge1xuICAgICAgLy8gVGhpcyBjb21wb25lbnQgaXMgc3RpbGwgcGVuZGluZyBtb3JlIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBjYW4ndCBoeWRyYXRlIGl0c1xuICAgICAgLy8gY29udGVudC4gV2UgdHJlYXQgaXQgYXMgaWYgdGhpcyBjb21wb25lbnQgc3VzcGVuZGVkIGl0c2VsZi4gSXQgbWlnaHQgc2VlbSBhcyBpZlxuICAgICAgLy8gd2UgY291bGQganVzdCB0cnkgdG8gcmVuZGVyIGl0IGNsaWVudC1zaWRlIGluc3RlYWQuIEhvd2V2ZXIsIHRoaXMgd2lsbCBwZXJmb3JtIGFcbiAgICAgIC8vIGxvdCBvZiB1bm5lY2Vzc2FyeSB3b3JrIGFuZCBpcyB1bmxpa2VseSB0byBjb21wbGV0ZSBzaW5jZSBpdCBvZnRlbiB3aWxsIHN1c3BlbmRcbiAgICAgIC8vIG9uIG1pc3NpbmcgZGF0YSBhbnl3YXkuIEFkZGl0aW9uYWxseSwgdGhlIHNlcnZlciBtaWdodCBiZSBhYmxlIHRvIHJlbmRlciBtb3JlXG4gICAgICAvLyB0aGFuIHdlIGNhbiBvbiB0aGUgY2xpZW50IHlldC4gSW4gdGhhdCBjYXNlIHdlJ2QgZW5kIHVwIHdpdGggbW9yZSBmYWxsYmFjayBzdGF0ZXNcbiAgICAgIC8vIG9uIHRoZSBjbGllbnQgdGhhbiBpZiB3ZSBqdXN0IGxlYXZlIGl0IGFsb25lLiBJZiB0aGUgc2VydmVyIHRpbWVzIG91dCBvciBlcnJvcnNcbiAgICAgIC8vIHRoZXNlIHNob3VsZCB1cGRhdGUgdGhpcyBib3VuZGFyeSB0byB0aGUgcGVybWFuZW50IEZhbGxiYWNrIHN0YXRlIGluc3RlYWQuXG4gICAgICAvLyBNYXJrIGl0IGFzIGhhdmluZyBjYXB0dXJlZCAoaS5lLiBzdXNwZW5kZWQpLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTsgLy8gTGVhdmUgdGhlIGNoaWxkIGluIHBsYWNlLiBJLmUuIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50LlxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gcmV0cnkgdGhpcyBib3VuZGFyeSBvbmNlIHRoZSBzZXJ2ZXIgaGFzIHNlbnQgdGhlIHJlc3VsdC5cblxuICAgICAgdmFyIHJldHJ5ID0gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeS5iaW5kKG51bGwsIGN1cnJlbnQpO1xuICAgICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkoc3VzcGVuc2VJbnN0YW5jZSwgcmV0cnkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQuXG4gICAgICByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUudHJlZUNvbnRleHQpO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbik7IC8vIE1hcmsgdGhlIGNoaWxkcmVuIGFzIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGZhc3QgcGF0aCB0byBrbm93IHdoZXRoZXIgdGhpc1xuICAgICAgLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuICAgICAgLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4gICAgICAvLyBDb25jZXB0dWFsbHkgdGhpcyBpcyBzaW1pbGFyIHRvIFBsYWNlbWVudCBpbiB0aGF0IGEgbmV3IHN1YnRyZWUgaXNcbiAgICAgIC8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuICAgICAgLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG5cbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmZsYWdzIHw9IEh5ZHJhdGluZztcbiAgICAgIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc2Vjb25kIHJlbmRlciBwYXNzLiBXZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBoeWRyYXRlZCwgYnV0XG4gICAgLy8gc29tZXRoaW5nIGVpdGhlciBzdXNwZW5kZWQgb3IgZXJyb3JlZC5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgLy8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVHJ5IGFnYWluIHdpdGhvdXQgaHlkcmF0aW5nLlxuICAgICAgLy8gVGhlIGVycm9yIHNob3VsZCd2ZSBhbHJlYWR5IGJlZW4gbG9nZ2VkIGluIHRocm93RXhjZXB0aW9uLlxuICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5Gb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZCBhbmQgd2Ugc2hvdWxkIHN0aWxsIGJlIGluIGRlaHlkcmF0ZWQgbW9kZS5cbiAgICAgIC8vIExlYXZlIHRoZSBleGlzdGluZyBjaGlsZCBpbiBwbGFjZS5cbiAgICAgIC8vIFB1c2ggdG8gYXZvaWQgYSBtaXNtYXRjaFxuICAgICAgcHVzaEZhbGxiYWNrVHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoZSBkZWh5ZHJhdGVkIGNvbXBsZXRpb24gcGFzcyBleHBlY3RzIHRoaXMgZmxhZyB0byBiZSB0aGVyZVxuICAgICAgLy8gYnV0IHRoZSBub3JtYWwgc3VzcGVuc2UgcGFzcyBkb2Vzbid0LlxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1c3BlbmRlZCBidXQgd2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBpbiBkZWh5ZHJhdGVkIG1vZGUuXG4gICAgICAvLyBUaGVyZWZvcmUgd2Ugbm93IGhhdmUgdG8gcmVuZGVyIHRoZSBmYWxsYmFjay5cbiAgICAgIHB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gbW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4sIG5leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50NC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyLCByZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KTtcbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBmaXJzdENoaWxkLCByZW5kZXJMYW5lcykge1xuICAvLyBNYXJrIGFueSBTdXNwZW5zZSBib3VuZGFyaWVzIHdpdGggZmFsbGJhY2tzIGFzIGhhdmluZyB3b3JrIHRvIGRvLlxuICAvLyBJZiB0aGV5IHdlcmUgcHJldmlvdXNseSBmb3JjZWQgaW50byBmYWxsYmFja3MsIHRoZXkgbWF5IG5vdyBiZSBhYmxlXG4gIC8vIHRvIHVuYmxvY2suXG4gIHZhciBub2RlID0gZmlyc3RDaGlsZDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCkge1xuICAgICAgLy8gSWYgdGhlIHRhaWwgaXMgaGlkZGVuIHRoZXJlIG1pZ2h0IG5vdCBiZSBhbiBTdXNwZW5zZSBib3VuZGFyaWVzXG4gICAgICAvLyB0byBzY2hlZHVsZSB3b3JrIG9uLiBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBvbiB0aGVcbiAgICAgIC8vIGxpc3QgaXRzZWxmLlxuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byB0cmF2ZXJzZSB0byB0aGUgY2hpbGRyZW4gb2YgdGhlIGxpc3Qgc2luY2VcbiAgICAgIC8vIHRoZSBsaXN0IHdpbGwgcHJvcGFnYXRlIHRoZSBjaGFuZ2Ugd2hlbiBpdCByZXJlbmRlcnMuXG4gICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRMYXN0Q29udGVudFJvdyhmaXJzdENoaWxkKSB7XG4gIC8vIFRoaXMgaXMgZ29pbmcgdG8gZmluZCB0aGUgbGFzdCByb3cgYW1vbmcgdGhlc2UgY2hpbGRyZW4gdGhhdCBpcyBhbHJlYWR5XG4gIC8vIHNob3dpbmcgY29udGVudCBvbiB0aGUgc2NyZWVuLCBhcyBvcHBvc2VkIHRvIGJlaW5nIGluIGZhbGxiYWNrIHN0YXRlIG9yXG4gIC8vIG5ldy4gSWYgYSByb3cgaGFzIG11bHRpcGxlIFN1c3BlbnNlIGJvdW5kYXJpZXMsIGFueSBvZiB0aGVtIGJlaW5nIGluIHRoZVxuICAvLyBmYWxsYmFjayBzdGF0ZSwgY291bnRzIGFzIHRoZSB3aG9sZSByb3cgYmVpbmcgaW4gYSBmYWxsYmFjayBzdGF0ZS5cbiAgLy8gTm90ZSB0aGF0IHRoZSBcInJvd3NcIiB3aWxsIGJlIHdvcmtJblByb2dyZXNzLCBidXQgYW55IG5lc3RlZCBjaGlsZHJlblxuICAvLyB3aWxsIHN0aWxsIGJlIGN1cnJlbnQgc2luY2Ugd2UgaGF2ZW4ndCByZW5kZXJlZCB0aGVtIHlldC4gVGhlIG1vdW50ZWRcbiAgLy8gb3JkZXIgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbmV3IG9yZGVyLiBXZSB1c2UgdGhlIG5ldyBvcmRlci5cbiAgdmFyIHJvdyA9IGZpcnN0Q2hpbGQ7XG4gIHZhciBsYXN0Q29udGVudFJvdyA9IG51bGw7XG5cbiAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICBsYXN0Q29udGVudFJvdyA9IHJvdztcbiAgICB9XG5cbiAgICByb3cgPSByb3cuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBsYXN0Q29udGVudFJvdztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQgJiYgcmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAndG9nZXRoZXInICYmICFkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0pIHtcbiAgICAgIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmV2ZWFsT3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdVc2UgbG93ZXJjYXNlIFwiJXNcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdSZWFjdCB1c2VzIHRoZSAtcyBzdWZmaXggaW4gdGhlIHNwZWxsaW5nLiBVc2UgXCIlc3NcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHRhaWxNb2RlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSkge1xuICAgICAgaWYgKHRhaWxNb2RlICE9PSAnY29sbGFwc2VkJyAmJiB0YWlsTW9kZSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcImNvbGxhcHNlZFwiIG9yIFwiaGlkZGVuXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfSBlbHNlIGlmIChyZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignPFN1c3BlbnNlTGlzdCB0YWlsPVwiJXNcIiAvPiBpcyBvbmx5IHZhbGlkIGlmIHJldmVhbE9yZGVyIGlzICcgKyAnXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsIHRhaWxNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZFNsb3QsIGluZGV4KSB7XG4gIHtcbiAgICB2YXIgaXNBbkFycmF5ID0gaXNBcnJheShjaGlsZFNsb3QpO1xuICAgIHZhciBpc0l0ZXJhYmxlID0gIWlzQW5BcnJheSAmJiB0eXBlb2YgZ2V0SXRlcmF0b3JGbihjaGlsZFNsb3QpID09PSAnZnVuY3Rpb24nO1xuXG4gICAgaWYgKGlzQW5BcnJheSB8fCBpc0l0ZXJhYmxlKSB7XG4gICAgICB2YXIgdHlwZSA9IGlzQW5BcnJheSA/ICdhcnJheScgOiAnaXRlcmFibGUnO1xuXG4gICAgICBlcnJvcignQSBuZXN0ZWQgJXMgd2FzIHBhc3NlZCB0byByb3cgIyVzIGluIDxTdXNwZW5zZUxpc3QgLz4uIFdyYXAgaXQgaW4gJyArICdhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiAnICsgJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj57JXN9PC9TdXNwZW5zZUxpc3Q+IC4uLiAnICsgJzwvU3VzcGVuc2VMaXN0PicsIHR5cGUsIGluZGV4LCB0eXBlKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuKGNoaWxkcmVuLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKChyZXZlYWxPcmRlciA9PT0gJ2ZvcndhcmRzJyB8fCByZXZlYWxPcmRlciA9PT0gJ2JhY2t3YXJkcycpICYmIGNoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgY2hpbGRyZW4gIT09IG51bGwgJiYgY2hpbGRyZW4gIT09IGZhbHNlKSB7XG4gICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZHJlbltpXSwgaSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuSXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gY2hpbGRyZW5JdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB2YXIgX2kgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpKSB7XG4gICAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChzdGVwLnZhbHVlLCBfaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gJyArICdUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gJyArICdEaWQgeW91IG1lYW4gdG8gcGFzcyBtdWx0aXBsZSBjaGlsZHJlbiBvciBhbiBhcnJheT8nLCByZXZlYWxPcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBpc0JhY2t3YXJkcywgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlKSB7XG4gIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgIGlzQmFja3dhcmRzOiBpc0JhY2t3YXJkcyxcbiAgICAgIHJlbmRlcmluZzogbnVsbCxcbiAgICAgIHJlbmRlcmluZ1N0YXJ0VGltZTogMCxcbiAgICAgIGxhc3Q6IGxhc3RDb250ZW50Um93LFxuICAgICAgdGFpbDogdGFpbCxcbiAgICAgIHRhaWxNb2RlOiB0YWlsTW9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgY2FuIHJldXNlIHRoZSBleGlzdGluZyBvYmplY3QgZnJvbSBwcmV2aW91cyByZW5kZXJzLlxuICAgIHJlbmRlclN0YXRlLmlzQmFja3dhcmRzID0gaXNCYWNrd2FyZHM7XG4gICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbnVsbDtcbiAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSAwO1xuICAgIHJlbmRlclN0YXRlLmxhc3QgPSBsYXN0Q29udGVudFJvdztcbiAgICByZW5kZXJTdGF0ZS50YWlsID0gdGFpbDtcbiAgICByZW5kZXJTdGF0ZS50YWlsTW9kZSA9IHRhaWxNb2RlO1xuICB9XG59IC8vIFRoaXMgY2FuIGVuZCB1cCByZW5kZXJpbmcgdGhpcyBjb21wb25lbnQgbXVsdGlwbGUgcGFzc2VzLlxuLy8gVGhlIGZpcnN0IHBhc3Mgc3BsaXRzIHRoZSBjaGlsZHJlbiBmaWJlcnMgaW50byB0d28gc2V0cy4gQSBoZWFkIGFuZCB0YWlsLlxuLy8gV2UgZmlyc3QgcmVuZGVyIHRoZSBoZWFkLiBJZiBhbnl0aGluZyBpcyBpbiBmYWxsYmFjayBzdGF0ZSwgd2UgZG8gYW5vdGhlclxuLy8gcGFzcyB0aHJvdWdoIGJlZ2luV29yayB0byByZXJlbmRlciBhbGwgY2hpbGRyZW4gKGluY2x1ZGluZyB0aGUgdGFpbCkgd2l0aFxuLy8gdGhlIGZvcmNlIHN1c3BlbmQgY29udGV4dC4gSWYgdGhlIGZpcnN0IHJlbmRlciBkaWRuJ3QgaGF2ZSBhbnl0aGluZyBpblxuLy8gaW4gZmFsbGJhY2sgc3RhdGUuIFRoZW4gd2UgcmVuZGVyIGVhY2ggcm93IGluIHRoZSB0YWlsIG9uZS1ieS1vbmUuXG4vLyBUaGF0IGhhcHBlbnMgaW4gdGhlIGNvbXBsZXRlV29yayBwaGFzZSB3aXRob3V0IGdvaW5nIGJhY2sgdG8gYmVnaW5Xb3JrLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHJldmVhbE9yZGVyID0gbmV4dFByb3BzLnJldmVhbE9yZGVyO1xuICB2YXIgdGFpbE1vZGUgPSBuZXh0UHJvcHMudGFpbDtcbiAgdmFyIG5ld0NoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YWxpZGF0ZVJldmVhbE9yZGVyKHJldmVhbE9yZGVyKTtcbiAgdmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSwgcmV2ZWFsT3JkZXIpO1xuICB2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuKG5ld0NoaWxkcmVuLCByZXZlYWxPcmRlcik7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuICB2YXIgc2hvdWxkRm9yY2VGYWxsYmFjayA9IGhhc1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuXG4gIGlmIChzaG91bGRGb3JjZUZhbGxiYWNrKSB7XG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSBjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGZvcmNlZCBhIGZhbGxiYWNrLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHdvcmtcbiAgICAgIC8vIG9uIGFueSBuZXN0ZWQgYm91bmRhcmllcyB0byBsZXQgdGhlbSBrbm93IHRvIHRyeSB0byByZW5kZXJcbiAgICAgIC8vIGFnYWluLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGNvbnRleHQgdXBkYXRpbmcuXG4gICAgICBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIH1cblxuICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTtcblxuICB7XG4gICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhc3RDb250ZW50Um93ID0gZmluZExhc3RDb250ZW50Um93KHdvcmtJblByb2dyZXNzLmNoaWxkKTtcbiAgICAgICAgICB2YXIgdGFpbDtcblxuICAgICAgICAgIGlmIChsYXN0Q29udGVudFJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIHdob2xlIGxpc3QgaXMgcGFydCBvZiB0aGUgdGFpbC5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIGNvdWxkIGZhc3QgcGF0aCBieSBqdXN0IHJlbmRlcmluZyB0aGUgdGFpbCBub3cuXG4gICAgICAgICAgICB0YWlsID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIHRhaWwgcm93cyBhZnRlciB0aGUgY29udGVudCByb3cuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IGxhdGVyLlxuICAgICAgICAgICAgdGFpbCA9IGxhc3RDb250ZW50Um93LnNpYmxpbmc7XG4gICAgICAgICAgICBsYXN0Q29udGVudFJvdy5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGZpbmQgdGhlIGZpcnN0IHJvdyB0aGF0IGhhcyBleGlzdGluZyBjb250ZW50LlxuICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgZ29pbmcgdG8gcmV2ZXJzZSB0aGUgbGlzdCBvZiBldmVyeXRoaW5nXG4gICAgICAgICAgLy8gd2UgcGFzcyBpbiB0aGUgbWVhbnRpbWUuIFRoYXQncyBnb2luZyB0byBiZSBvdXIgdGFpbCBpbiByZXZlcnNlXG4gICAgICAgICAgLy8gb3JkZXIuXG4gICAgICAgICAgdmFyIF90YWlsID0gbnVsbDtcbiAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuXG4gICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1haW4gY29udGVudC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByb3c7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV4dFJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgcm93LnNpYmxpbmcgPSBfdGFpbDtcbiAgICAgICAgICAgIF90YWlsID0gcm93O1xuICAgICAgICAgICAgcm93ID0gbmV4dFJvdztcbiAgICAgICAgICB9IC8vIFRPRE86IElmIHdvcmtJblByb2dyZXNzLmNoaWxkIGlzIG51bGwsIHdlIGNhbiBjb250aW51ZSBvbiB0aGUgdGFpbCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCB0cnVlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIF90YWlsLCBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdGFpbE1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAge1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgbnVsbCwgLy8gdGFpbFxuICAgICAgICAgIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB1bmRlZmluZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCByZXZlYWwgb3JkZXIgaXMgdGhlIHNhbWUgYXMgbm90IGhhdmluZ1xuICAgICAgICAgIC8vIGEgYm91bmRhcnkuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgY29udGV4dDtcblxuICB7XG4gICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIH1cblxuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuXG4gIHtcbiAgICBpZiAoISgndmFsdWUnIGluIG5ld1Byb3BzKSkge1xuICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlcikge1xuICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1RoZSBgdmFsdWVgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgPENvbnRleHQuUHJvdmlkZXI+YC4gRGlkIHlvdSBtaXNzcGVsbCBpdCBvciBmb3JnZXQgdG8gcGFzcyBpdD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIG5ld1ZhbHVlKTtcblxuICB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdElzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgLy8gTm8gY2hhbmdlLiBCYWlsb3V0IGVhcmx5IGlmIGNoaWxkcmVuIGFyZSB0aGUgc2FtZS5cbiAgICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBjb250ZXh0IHZhbHVlIGNoYW5nZWQuIFNlYXJjaCBmb3IgbWF0Y2hpbmcgY29uc3VtZXJzIGFuZCBzY2hlZHVsZVxuICAgICAgICAvLyB0aGVtIHRvIHVwZGF0ZS5cbiAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdDaGlsZHJlbiA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgY29uc3VtZXJUeXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBjb250ZXh0ID0gY29uc3VtZXJUeXBlLl9jb250ZXh0O1xuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0KTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuO1xuXG4gIHtcbiAgICBuZXdDaGlsZHJlbiA9IGNhbGxDb21wb25lbnRJbkRFVihyZW5kZXIsIG5ld1ZhbHVlLCB1bmRlZmluZWQpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gVGhpcyBmaWJlciBkb2Vzbid0IGhhdmUgd29yaywgYnV0IGl0cyBzdWJ0cmVlIGRvZXMuIENsb25lIHRoZSBjaGlsZFxuICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuXG5cbiAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci4nKTtcbiAgICB9IC8vIERpc2Nvbm5lY3QgZnJvbSB0aGUgb2xkIGN1cnJlbnQuXG4gICAgLy8gSXQgd2lsbCBnZXQgZGVsZXRlZC5cblxuXG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIG9sZFdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIENvbm5lY3QgdG8gdGhlIG5ldyB0cmVlLlxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuaW5kZXggPSBvbGRXb3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gb2xkV29ya0luUHJvZ3Jlc3Muc2libGluZztcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZXR1cm4gPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmVmID0gb2xkV29ya0luUHJvZ3Jlc3MucmVmO1xuXG4gICAge1xuICAgICAgbmV3V29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbyA9IG9sZFdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm87XG4gICAgfSAvLyBSZXBsYWNlIHRoZSBjaGlsZC9zaWJsaW5nIHBvaW50ZXJzIGFib3ZlIGl0LlxuXG5cbiAgICBpZiAob2xkV29ya0luUHJvZ3Jlc3MgPT09IHJldHVybkZpYmVyLmNoaWxkKSB7XG4gICAgICByZXR1cm5GaWJlci5jaGlsZCA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldlNpYmxpbmcgPSByZXR1cm5GaWJlci5jaGlsZDtcblxuICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGFyZW50IHRvIGhhdmUgYSBjaGlsZC4nKTtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgd2hpbGUgKHByZXZTaWJsaW5nLnNpYmxpbmcgIT09IG9sZFdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICBwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2N1cnJlbnRdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudCk7XG4gICAgfVxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50OyAvLyBSZXN0YXJ0IHdvcmsgZnJvbSB0aGUgbmV3IGZpYmVyLlxuXG4gICAgcmV0dXJuIG5ld1dvcmtJblByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIEJlZm9yZSBwZXJmb3JtaW5nIGFuIGVhcmx5IGJhaWxvdXQsIHdlIG11c3QgY2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmdcbiAgLy8gdXBkYXRlcyBvciBjb250ZXh0LlxuICB2YXIgdXBkYXRlTGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBObyBwZW5kaW5nIHVwZGF0ZSwgYnV0IGJlY2F1c2UgY29udGV4dCBpcyBwcm9wYWdhdGVkIGxhemlseSwgd2UgbmVlZFxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4gIC8vIGluIHRoaXMgb3B0aW1pemVkIHBhdGgsIG1vc3RseSBwdXNoaW5nIHN0dWZmIG9udG8gdGhlIHN0YWNrLlxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgICAge1xuICAgICAgICB2YXIgY2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICAgIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjYWNoZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBuZXdWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgLy8gUHJvZmlsZXIgc2hvdWxkIG9ubHkgY2FsbCBvblJlbmRlciB3aGVuIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAgICAgIHZhciBoYXNDaGlsZFdvcmsgPSBpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcblxuICAgICAgICBpZiAoaGFzQ2hpbGRXb3JrKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbiAgICAgICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byByZW5kZXIgdGhlIGNoaWxkcmVuLCBzbyB0aGlzIGlzIGp1c3QgdG8gbWFpbnRhaW5cbiAgICAgICAgICAgIC8vIHB1c2gvcG9wIHN5bW1ldHJ5XG4gICAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpOyAvLyBXZSBrbm93IHRoYXQgdGhpcyBjb21wb25lbnQgd2lsbCBzdXNwZW5kIGFnYWluIGJlY2F1c2UgaWYgaXQgaGFzXG4gICAgICAgICAgICAvLyBiZWVuIHVuc3VzcGVuZGVkIGl0IGhhcyBjb21taXR0ZWQgYXMgYSByZXNvbHZlZCBTdXNwZW5zZSBjb21wb25lbnQuXG4gICAgICAgICAgICAvLyBJZiBpdCBuZWVkcyB0byBiZSByZXRyaWVkLCBpdCBzaG91bGQgaGF2ZSB3b3JrIHNjaGVkdWxlZCBvbiBpdC5cblxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTsgLy8gV2Ugc2hvdWxkIG5ldmVyIHJlbmRlciB0aGUgY2hpbGRyZW4gb2YgYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IHVudGlsIHdlXG4gICAgICAgICAgICAvLyB1cGdyYWRlIGl0LiBXZSByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsuXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gLy8gSWYgdGhpcyBib3VuZGFyeSBpcyBjdXJyZW50bHkgdGltZWQgb3V0LCB3ZSBuZWVkIHRvIGRlY2lkZVxuICAgICAgICAgIC8vIHdoZXRoZXIgdG8gcmV0cnkgdGhlIHByaW1hcnkgY2hpbGRyZW4sIG9yIHRvIHNraXAgb3ZlciBpdCBhbmRcbiAgICAgICAgICAvLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgIC8vIGNoaWxkIGZyYWdtZW50LlxuXG5cbiAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkTGFuZXMgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzO1xuXG4gICAgICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHByaW1hcnlDaGlsZExhbmVzKSkge1xuICAgICAgICAgICAgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFVzZSB0aGUgbm9ybWFsIHBhdGhcbiAgICAgICAgICAgIC8vIHRvIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGFnYWluLlxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50IGRvZXMgbm90IGhhdmUgcGVuZGluZyB3b3JrIG1hcmtlZFxuICAgICAgICAgICAgLy8gb24gaXRcbiAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGRvIG5vdCBoYXZlIHBlbmRpbmcgd29yayB3aXRoIHN1ZmZpY2llbnRcbiAgICAgICAgICAgIC8vIHByaW9yaXR5LiBCYWlsb3V0LlxuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGUgZmFsbGJhY2sgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFNraXAgb3ZlciB0aGVcbiAgICAgICAgICAgICAgLy8gcHJpbWFyeSBjaGlsZHJlbiBhbmQgd29yayBvbiB0aGUgZmFsbGJhY2suXG4gICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm90ZTogV2UgY2FuIHJldHVybiBgbnVsbGAgaGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgY2hlY2tlZFxuICAgICAgICAgICAgICAvLyB3aGV0aGVyIHRoZXJlIHdlcmUgbmVzdGVkIGNvbnRleHQgY29uc3VtZXJzLCB2aWEgdGhlIGNhbGwgdG9cbiAgICAgICAgICAgICAgLy8gYGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmtgIGFib3ZlLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxO1xuXG4gICAgICAgIHZhciBfaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgaWYgKGRpZFN1c3BlbmRCZWZvcmUpIHtcbiAgICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBpbiBmYWxsYmFjayBzdGF0ZSBsYXN0IHRpbWUsIGFuZCB3ZSBoYXZlIGFsbCB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgY2hpbGRyZW4gdGhlbiB3ZSdyZSBzdGlsbCBpbiBwcm9ncmVzc2l2ZSBsb2FkaW5nIHN0YXRlLlxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIG1pZ2h0IGdldCB1bmJsb2NrZWQgYnkgc3RhdGUgdXBkYXRlcyBvciByZXRyaWVzIGluIHRoZVxuICAgICAgICAgICAgLy8gdHJlZSB3aGljaCB3aWxsIGFmZmVjdCB0aGUgdGFpbC4gU28gd2UgbmVlZCB0byB1c2UgdGhlIG5vcm1hbFxuICAgICAgICAgICAgLy8gcGF0aCB0byBjb21wdXRlIHRoZSBjb3JyZWN0IHRhaWwuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfSAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgLy8gdGhlbSBnb3QgcmV0cmllZCBzbyB0aGV5J2xsIHN0aWxsIGJlIGJsb2NrZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAgLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cblxuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgfSAvLyBJZiBub3RoaW5nIHN1c3BlbmRlZCBiZWZvcmUgYW5kIHdlJ3JlIHJlbmRlcmluZyB0aGUgc2FtZSBjaGlsZHJlbixcbiAgICAgICAgLy8gdGhlbiB0aGUgdGFpbCBkb2Vzbid0IG1hdHRlci4gQW55dGhpbmcgbmV3IHRoYXQgc3VzcGVuZHMgd2lsbCB3b3JrXG4gICAgICAgIC8vIGluIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSwgc28gd2UgY2FuIGNvbnRpbnVlIGZyb20gdGhlIHN0YXRlIHdlIGhhZC5cblxuXG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVzZXQgdG8gdGhlIFwidG9nZXRoZXJcIiBtb2RlIGluIGNhc2Ugd2UndmUgc3RhcnRlZCBhIGRpZmZlcmVudFxuICAgICAgICAgIC8vIHVwZGF0ZSBpbiB0aGUgcGFzdCBidXQgZGlkbid0IGNvbXBsZXRlIGl0LlxuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgdHJlZSBzdGlsbCBuZWVkcyB0byBiZSBkZWZlcnJlZC4gVGhpcyBpc1xuICAgICAgICAvLyBhbG1vc3QgaWRlbnRpY2FsIHRvIHRoZSBsb2dpYyB1c2VkIGluIHRoZSBub3JtYWwgdXBkYXRlIHBhdGgsXG4gICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAvLyBhdCB0aGUgbmV4dCBsZXZlbCBpbnN0ZWFkIG9mIHRoaXMgb25lLCBiZWNhdXNlIHRoZSBjaGlsZCBwcm9wc1xuICAgICAgICAvLyBoYXZlIG5vdCBjaGFuZ2VkLiBXaGljaCBpcyBmaW5lLlxuICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgLy8gcGF0aCBmcm9tIHRoZSBub3JtYWwgcGF0aC4gSSdtIHRlbXB0ZWQgdG8gZG8gYSBsYWJlbGVkIGJyZWFrIGhlcmVcbiAgICAgICAgLy8gYnV0IEkgd29uJ3QgOilcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9jYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICBwdXNoQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgX2NhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCAmJiBjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVzdGFydCB0aGUgYmVnaW4gcGhhc2Ugd2l0aCBhIG5ldyBmaWJlci5cbiAgICAgIHZhciBjb3BpZWRGaWJlciA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcy5rZXksIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgfHwgbnVsbCwgd29ya0luUHJvZ3Jlc3MubW9kZSwgd29ya0luUHJvZ3Jlc3MubGFuZXMpO1xuXG4gICAgICByZXR1cm4gcmVtb3VudEZpYmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBjb3BpZWRGaWJlcik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBoYXNDb250ZXh0Q2hhbmdlZCgpIHx8ICggLy8gRm9yY2UgYSByZS1yZW5kZXIgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQ6XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gY3VycmVudC50eXBlICkpIHtcbiAgICAgIC8vIElmIHByb3BzIG9yIGNvbnRleHQgY2hhbmdlZCwgbWFyayB0aGUgZmliZXIgYXMgaGF2aW5nIHBlcmZvcm1lZCB3b3JrLlxuICAgICAgLy8gVGhpcyBtYXkgYmUgdW5zZXQgaWYgdGhlIHByb3BzIGFyZSBkZXRlcm1pbmVkIHRvIGJlIGVxdWFsIGxhdGVyIChtZW1vKS5cbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIHByb3BzIG5vciBsZWdhY3kgY29udGV4dCBjaGFuZ2VzLiBDaGVjayBpZiB0aGVyZSdzIGEgcGVuZGluZ1xuICAgICAgLy8gdXBkYXRlIG9yIGNvbnRleHQgY2hhbmdlLlxuICAgICAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKCFoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQgJiYgLy8gSWYgdGhpcyBpcyB0aGUgc2Vjb25kIHBhc3Mgb2YgYW4gZXJyb3Igb3Igc3VzcGVuc2UgYm91bmRhcnksIHRoZXJlXG4gICAgICAvLyBtYXkgbm90IGJlIHdvcmsgc2NoZWR1bGVkIG9uIGBjdXJyZW50YCwgc28gd2UgY2hlY2sgZm9yIHRoaXMgZmxhZy5cbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgLy8gTm8gcGVuZGluZyB1cGRhdGVzIG9yIGNvbnRleHQuIEJhaWwgb3V0IG5vdy5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb24gdGhpcyBmaWJlciwgYnV0IHRoZXJlIGFyZSBubyBuZXcgcHJvcHNcbiAgICAgICAgLy8gbm9yIGxlZ2FjeSBjb250ZXh0LiBTZXQgdGhpcyB0byBmYWxzZS4gSWYgYW4gdXBkYXRlIHF1ZXVlIG9yIGNvbnRleHRcbiAgICAgICAgLy8gY29uc3VtZXIgcHJvZHVjZXMgYSBjaGFuZ2VkIHZhbHVlLCBpdCB3aWxsIHNldCB0aGlzIHRvIHRydWUuIE90aGVyd2lzZSxcbiAgICAgICAgLy8gdGhlIGNvbXBvbmVudCB3aWxsIGFzc3VtZSB0aGUgY2hpbGRyZW4gaGF2ZSBub3QgY2hhbmdlZCBhbmQgYmFpbCBvdXQuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaXNGb3JrZWRDaGlsZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2hpbGQgYmVsb25ncyB0byBhIGxpc3Qgb2YgbXVsaXBsZSBjaGlsZHJlbiBpblxuICAgICAgLy8gaXRzIHBhcmVudC5cbiAgICAgIC8vXG4gICAgICAvLyBJbiBhIHRydWUgbXVsdGktdGhyZWFkZWQgaW1wbGVtZW50YXRpb24sIHdlIHdvdWxkIHJlbmRlciBjaGlsZHJlbiBvblxuICAgICAgLy8gcGFyYWxsZWwgdGhyZWFkcy4gVGhpcyB3b3VsZCByZXByZXNlbnQgdGhlIGJlZ2lubmluZyBvZiBhIG5ldyByZW5kZXJcbiAgICAgIC8vIHRocmVhZCBmb3IgdGhpcyBzdWJ0cmVlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIG9ubHkgdXNlIHRoaXMgZm9yIGlkIGdlbmVyYXRpb24gZHVyaW5nIGh5ZHJhdGlvbiwgd2hpY2ggaXMgd2h5IHRoZVxuICAgICAgLy8gbG9naWMgaXMgbG9jYXRlZCBpbiB0aGlzIHNwZWNpYWwgYnJhbmNoLlxuICAgICAgdmFyIHNsb3RJbmRleCA9IHdvcmtJblByb2dyZXNzLmluZGV4O1xuICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBnZXRGb3Jrc0F0TGV2ZWwoKTtcbiAgICAgIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MsIHNsb3RJbmRleCk7XG4gICAgfVxuICB9IC8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNsZWFyIHBlbmRpbmcgdXBkYXRlIHByaW9yaXR5LlxuICAvLyBUT0RPOiBUaGlzIGFzc3VtZXMgdGhhdCB3ZSdyZSBhYm91dCB0byBldmFsdWF0ZSB0aGUgY29tcG9uZW50IGFuZCBwcm9jZXNzXG4gIC8vIHRoZSB1cGRhdGUgcXVldWUuIEhvd2V2ZXIsIHRoZXJlJ3MgYW4gZXhjZXB0aW9uOiBTaW1wbGVNZW1vQ29tcG9uZW50XG4gIC8vIHNvbWV0aW1lcyBiYWlscyBvdXQgbGF0ZXIgaW4gdGhlIGJlZ2luIHBoYXNlLiBUaGlzIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZFxuICAvLyBtb3ZlIHRoaXMgYXNzaWdubWVudCBvdXQgb2YgdGhlIGNvbW1vbiBwYXRoIGFuZCBpbnRvIGVhY2ggYnJhbmNoLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHVucmVzb2x2ZWRQcm9wcyA7XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczQgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhfQ29tcG9uZW50LCBfdW5yZXNvbHZlZFByb3BzKTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQsIF9yZXNvbHZlZFByb3BzNCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0SG9pc3RhYmxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFNpbmdsZXRvbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHM1ID0gX3VucmVzb2x2ZWRQcm9wczIgO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBfcmVzb2x2ZWRQcm9wczUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgTW9kZTpcbiAgICAgIHJldHVybiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3R5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFJlc29sdmUgb3V0ZXIgcHJvcHMgZmlyc3QsIHRoZW4gcmVzb2x2ZSBpbm5lciBwcm9wcy5cblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHM2ID0gX3VucmVzb2x2ZWRQcm9wczMgO1xuXG4gICAgICAgIF9yZXNvbHZlZFByb3BzNiA9IF9yZXNvbHZlZFByb3BzNiA7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZSwgX3Jlc29sdmVkUHJvcHM2LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVDYWNoZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcmVuZGVyZXJDdXJzb3JERVY7XG5cbntcbiAgcmVuZGVyZXJDdXJzb3JERVYgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG59XG5cbnZhciByZW5kZXJlcjJDdXJzb3JERVY7XG5cbntcbiAgcmVuZGVyZXIyQ3Vyc29yREVWID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xufVxuXG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xudmFyIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG52YXIgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcbnZhciBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBSZWFjdCB5aWVsZHMgZXhlY3V0aW9uLCB0byBlbnN1cmUgYHJlYWRDb250ZXh0YFxuICAvLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xuXG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gIGlmIChpc1ByaW1hcnlSZW5kZXJlcikge1xuICAgIHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSwgcHJvdmlkZXJGaWJlcik7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlO1xuXG4gICAge1xuICAgICAgcHVzaChyZW5kZXJlckN1cnNvckRFViwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyLCBwcm92aWRlckZpYmVyKTtcblxuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsIHByb3ZpZGVyRmliZXIpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBwdXNoKHJlbmRlcmVyMkN1cnNvckRFViwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiwgcHJvdmlkZXJGaWJlcik7XG5cbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQsIHByb3ZpZGVyRmliZXIpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG5cbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuXG4gICAge1xuICAgICAgdmFyIGN1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyQ3Vyc29yREVWLmN1cnJlbnQ7XG4gICAgICBwb3AocmVuZGVyZXJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gY3VycmVudFJlbmRlcmVyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlO1xuXG4gICAge1xuICAgICAgdmFyIGN1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlcjJDdXJzb3JERVYuY3VycmVudDtcbiAgICAgIHBvcChyZW5kZXJlcjJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IGN1cnJlbnRSZW5kZXJlcjI7XG4gICAgfVxuICB9XG5cbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgocGFyZW50LCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KSB7XG4gIC8vIFVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMgb2YgYWxsIHRoZSBhbmNlc3RvcnMsIGluY2x1ZGluZyB0aGUgYWx0ZXJuYXRlcy5cbiAgdmFyIG5vZGUgPSBwYXJlbnQ7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG5cbiAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhub2RlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgbm9kZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhub2RlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAhaXNTdWJzZXRPZkxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSA7XG5cbiAgICBpZiAobm9kZSA9PT0gcHJvcGFnYXRpb25Sb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKG5vZGUgIT09IHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByb3BhZ2F0aW9uIHJvb3Qgd2hlbiBzY2hlZHVsaW5nIGNvbnRleHQgd29yay4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcykge1xuXG4gIHZhciBmaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgIGZpYmVyLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG5cbiAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgdmFyIG5leHRGaWJlciA9IHZvaWQgMDsgLy8gVmlzaXQgdGhpcyBmaWJlci5cblxuICAgIHZhciBsaXN0ID0gZmliZXIuZGVwZW5kZW5jaWVzO1xuXG4gICAgaWYgKGxpc3QgIT09IG51bGwpIHtcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBsaXN0LmZpcnN0Q29udGV4dDtcblxuICAgICAgd2hpbGUgKGRlcGVuZGVuY3kgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRleHQgbWF0Y2hlcy5cbiAgICAgICAgaWYgKGRlcGVuZGVuY3kuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cbiAgICAgICAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBmb3JjZSB1cGRhdGUgb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MuXG4gICAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7IC8vIFRPRE86IEJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHdvcmstaW4tcHJvZ3Jlc3MsIHRoaXMgd2lsbCBhZGQgdGhlXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgZmliZXIsIHRvbywgd2hpY2ggbWVhbnMgaXQgd2lsbCBwZXJzaXN0IGV2ZW4gaWZcbiAgICAgICAgICAgIC8vIHRoaXMgcmVuZGVyIGlzIHRocm93biBhd2F5LiBTaW5jZSBpdCdzIGEgcmFjZSBjb25kaXRpb24sIG5vdCBzdXJlIGl0J3NcbiAgICAgICAgICAgIC8vIHdvcnRoIGZpeGluZy5cbiAgICAgICAgICAgIC8vIElubGluZWQgYGVucXVldWVVcGRhdGVgIHRvIHJlbW92ZSBpbnRlcmxlYXZlZCB1cGRhdGUgY2hlY2tcblxuICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICAgICAgICAgICAgICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cbiAgICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICAgICAgICAgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgICAgICAgICAgICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2hhcmVkUXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTsgLy8gTWFyayB0aGUgdXBkYXRlZCBsYW5lcyBvbiB0aGUgbGlzdCwgdG9vLlxuXG4gICAgICAgICAgbGlzdC5sYW5lcyA9IG1lcmdlTGFuZXMobGlzdC5sYW5lcywgcmVuZGVyTGFuZXMpOyAvLyBTaW5jZSB3ZSBhbHJlYWR5IGZvdW5kIGEgbWF0Y2gsIHdlIGNhbiBzdG9wIHRyYXZlcnNpbmcgdGhlXG4gICAgICAgICAgLy8gZGVwZW5kZW5jeSBsaXN0LlxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jeS5uZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDb250ZXh0UHJvdmlkZXIpIHtcbiAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIGlmIHRoaXMgaXMgYSBtYXRjaGluZyBwcm92aWRlclxuICAgICAgbmV4dEZpYmVyID0gZmliZXIudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MudHlwZSA/IG51bGwgOiBmaWJlci5jaGlsZDtcbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgaXMgaW4gdGhpcyBzdWJ0cmVlLCB3ZSBkb24ndCBrbm93XG4gICAgICAvLyBpZiBpdCB3aWxsIGhhdmUgYW55IGNvbnRleHQgY29uc3VtZXJzIGluIGl0LiBUaGUgYmVzdCB3ZSBjYW4gZG8gaXNcbiAgICAgIC8vIG1hcmsgaXQgYXMgaGF2aW5nIHVwZGF0ZXMuXG4gICAgICB2YXIgcGFyZW50U3VzcGVuc2UgPSBmaWJlci5yZXR1cm47XG5cbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudFN1c3BlbnNlLmxhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnRTdXNwZW5zZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIF9hbHRlcm5hdGUgPSBwYXJlbnRTdXNwZW5zZS5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIF9hbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKF9hbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHBhc3NpbmcgdGhpcyBmaWJlciBhcyB0aGUgcGFyZW50XG4gICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8gc2NoZWR1bGUgdGhpcyBmaWJlciBhcyBoYXZpbmcgd29ya1xuICAgICAgLy8gb24gaXRzIGNoaWxkcmVuLiBXZSdsbCB1c2UgdGhlIGNoaWxkTGFuZXMgb25cbiAgICAgIC8vIHRoaXMgZmliZXIgdG8gaW5kaWNhdGUgdGhhdCBhIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cblxuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnRTdXNwZW5zZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnNpYmxpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuXG4gICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuXG5cbiAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHZhciBmaXJzdENvbnRleHQgPSBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuXG4gICAgICBpZiAoZmlyc3RDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgICAgLy8gQ29udGV4dCBsaXN0IGhhcyBhIHBlbmRpbmcgdXBkYXRlLiBNYXJrIHRoYXQgdGhpcyBmaWJlciBwZXJmb3JtZWQgd29yay5cbiAgICAgICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgICAgICB9IC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcblxuXG4gICAgICAgIGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICB7XG4gICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbiAgICAvLyBVbmxpa2UgdGhlIGNsYXNzIGNoZWNrIGJlbG93LCBpdCdzIG5vdCBlbmZvcmNlZCBpbiBwcm9kdWN0aW9uIGZvciBwZXJmLlxuICAgIGlmIChpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihjb25zdW1lciwgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID09PSBudWxsKSB7XG4gICAgcHJlcGFyZVRvUmVhZENvbnRleHQoY29uc3VtZXIsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCkge1xuICB2YXIgdmFsdWUgPSBpc1ByaW1hcnlSZW5kZXJlciA/IGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG5cbiAgaWYgKGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9PT0gY29udGV4dCkgOyBlbHNlIHtcbiAgICB2YXIgY29udGV4dEl0ZW0gPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgbWVtb2l6ZWRWYWx1ZTogdmFsdWUsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0Q29udGV4dERlcGVuZGVuY3kgPT09IG51bGwpIHtcbiAgICAgIGlmIChjb25zdW1lciA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO1xuICAgICAgfSAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkZXBlbmRlbmN5IGZvciB0aGlzIGNvbXBvbmVudC4gQ3JlYXRlIGEgbmV3IGxpc3QuXG5cblxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY29udGV4dEl0ZW07XG4gICAgICBjb25zdW1lci5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBmaXJzdENvbnRleHQ6IGNvbnRleHRJdGVtXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgYSBuZXcgY29udGV4dCBpdGVtLlxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0SXRlbTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHJlcGxhY2UgaXQgd2l0aCBhIGxpZ2h0d2VpZ2h0IHNoaW0gdGhhdCBvbmx5IGhhcyB0aGUgZmVhdHVyZXMgd2UgdXNlLlxuXG52YXIgQWJvcnRDb250cm9sbGVyTG9jYWwgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJyA/IEFib3J0Q29udHJvbGxlciA6IC8vICRGbG93Rml4TWVbbWlzc2luZy10aGlzLWFubm90XVxuLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5mdW5jdGlvbiBBYm9ydENvbnRyb2xsZXJTaGltKCkge1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBzaWduYWwgPSB0aGlzLnNpZ25hbCA9IHtcbiAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzaWduYWwuYWJvcnRlZCA9IHRydWU7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICB9KTtcbiAgfTtcbn0gOyAvLyBJbnRlbnRpb25hbGx5IG5vdCBuYW1lZCBpbXBvcnRzIGJlY2F1c2UgUm9sbHVwIHdvdWxkXG4vLyB1c2UgZHluYW1pYyBkaXNwYXRjaCBmb3IgQ29tbW9uSlMgaW50ZXJvcCBuYW1lZCBpbXBvcnRzLlxuXG52YXIgc2NoZWR1bGVDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gICAgTm9ybWFsUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHk7XG52YXIgQ2FjaGVDb250ZXh0ID0ge1xuICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAvLyBXZSBkb24ndCB1c2UgQ29uc3VtZXIvUHJvdmlkZXIgZm9yIENhY2hlIGNvbXBvbmVudHMuIFNvIHdlJ2xsIGNoZWF0LlxuICBDb25zdW1lcjogbnVsbCxcbiAgUHJvdmlkZXI6IG51bGwsXG4gIC8vIFdlJ2xsIGluaXRpYWxpemUgdGhlc2UgYXQgdGhlIHJvb3QuXG4gIF9jdXJyZW50VmFsdWU6IG51bGwsXG4gIF9jdXJyZW50VmFsdWUyOiBudWxsLFxuICBfdGhyZWFkQ291bnQ6IDBcbn0gO1xuXG57XG4gIENhY2hlQ29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgQ2FjaGVDb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbn0gLy8gQ3JlYXRlcyBhIG5ldyBlbXB0eSBDYWNoZSBpbnN0YW5jZSB3aXRoIGEgcmVmLWNvdW50IG9mIDAuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGVcbi8vIGZvciByZXRhaW5pbmcgdGhlIGNhY2hlIG9uY2UgaXQgaXMgaW4gdXNlIChyZXRhaW5DYWNoZSksIGFuZCByZWxlYXNpbmcgdGhlIGNhY2hlXG4vLyBvbmNlIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgKHJlbGVhc2VDYWNoZSkuXG5cblxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cbiAgdmFyIGNhY2hlID0ge1xuICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXJMb2NhbCgpLFxuICAgIGRhdGE6IG5ldyBNYXAoKSxcbiAgICByZWZDb3VudDogMFxuICB9O1xuICByZXR1cm4gY2FjaGU7XG59XG5mdW5jdGlvbiByZXRhaW5DYWNoZShjYWNoZSkge1xuXG4gIHtcbiAgICBpZiAoY2FjaGUuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgd2FybignQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmV0YWluZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuICcgKyAnVGhpcyBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlLnJlZkNvdW50Kys7XG59IC8vIENsZWFudXAgYSBjYWNoZSBpbnN0YW5jZSwgcG90ZW50aWFsbHkgZnJlZWluZyBpdCBpZiB0aGVyZSBhcmUgbm8gbW9yZSByZWZlcmVuY2VzXG5cbmZ1bmN0aW9uIHJlbGVhc2VDYWNoZShjYWNoZSkge1xuXG4gIGNhY2hlLnJlZkNvdW50LS07XG5cbiAge1xuICAgIGlmIChjYWNoZS5yZWZDb3VudCA8IDApIHtcbiAgICAgIHdhcm4oJ0EgY2FjaGUgaW5zdGFuY2Ugd2FzIHJlbGVhc2VkIGFmdGVyIGl0IHdhcyBhbHJlYWR5IGZyZWVkLiAnICsgJ1RoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY2FjaGUucmVmQ291bnQgPT09IDApIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhY2hlLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcHVzaENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNhY2hlKSB7XG5cbiAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIGNhY2hlKTtcbn1cbmZ1bmN0aW9uIHBvcENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNhY2hlKSB7XG5cbiAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG59XG5cbi8vIHRoZSBzaGFyZWQgaW50ZXJuYWxzIG9iamVjdC4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBpc29tb3JwaGljIGltcGxlbWVudGF0aW9uIG9mXG4vLyBzdGFydFRyYW5zaXRpb24gdG8gY29tcG9zZSBhbGwgdGhlIHN0YXJ0VHJhbnNpdGlvbnMgdG9nZXRoZXIuXG4vL1xuLy8gICBmdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oZm4pIHtcbi8vICAgICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uRE9NKCgpID0+IHtcbi8vICAgICAgIHJldHVybiBzdGFydFRyYW5zaXRpb25BUlQoKCkgPT4ge1xuLy8gICAgICAgICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uVGhyZWVGaWJlcigoKSA9PiB7XG4vLyAgICAgICAgICAgLy8gYW5kIHNvIG9uLi4uXG4vLyAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgfSk7XG4vLyAgICAgfSk7XG4vLyAgIH1cbi8vXG4vLyBDdXJyZW50bHkgd2Ugb25seSBjb21wb3NlIHRvZ2V0aGVyIHRoZSBjb2RlIHRoYXQgcnVucyBhdCB0aGUgZW5kIG9mIGVhY2hcbi8vIHN0YXJ0VHJhbnNpdGlvbiwgYmVjYXVzZSBmb3Igbm93IHRoYXQncyBzdWZmaWNpZW50IOKAlCB0aGUgcGFydCB0aGF0IHNldHNcbi8vIGlzVHJhbnNpdGlvbj10cnVlIG9uIHRoZSBzdGFjayB1c2VzIGEgc2VwYXJhdGUgc2hhcmVkIGludGVybmFsIGZpZWxkLiBCdXRcbi8vIHJlYWxseSB3ZSBzaG91bGQgZGVsZXRlIHRoZSBzaGFyZWQgZmllbGQgYW5kIHRyYWNrIGlzVHJhbnNpdGlvbiBwZXJcbi8vIHJlY29uY2lsZXIuIExlYXZpbmcgdGhpcyBmb3IgYSBmdXR1cmUgUFIuXG5cbnZhciBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuXG5SZWFjdFNoYXJlZEludGVybmFscy5TID0gZnVuY3Rpb24gb25TdGFydFRyYW5zaXRpb25GaW5pc2hGb3JSZWNvbmNpbGVyKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdvYmplY3QnICYmIHJldHVyblZhbHVlICE9PSBudWxsICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBhc3luYyBhY3Rpb25cbiAgICB2YXIgdGhlbmFibGUgPSByZXR1cm5WYWx1ZTtcbiAgICBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHRoZW5hYmxlKTtcbiAgfVxuXG4gIGlmIChwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggIT09IG51bGwpIHtcbiAgICBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2godHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5UO1xufSAvLyBXaGVuIHJldHJ5aW5nIGEgU3VzcGVuc2UvT2Zmc2NyZWVuIGJvdW5kYXJ5LCB3ZSByZXN0b3JlIHRoZSBjYWNoZSB0aGF0IHdhc1xuLy8gdXNlZCBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlciBieSBwbGFjaW5nIGl0IGhlcmUsIG9uIHRoZSBzdGFjay5cblxudmFyIHJlc3VtZWRDYWNoZSA9IGNyZWF0ZUN1cnNvcihudWxsKTsgLy8gRHVyaW5nIHRoZSByZW5kZXIvc3luY2hyb25vdXMgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBhY3R1YWxseSBwcm9jZXNzIHRoZVxuXG5mdW5jdGlvbiBwZWVrQ2FjaGVGcm9tUG9vbCgpIHtcbiAgLy8gSWYgd2UncmUgcmVuZGVyaW5nIGluc2lkZSBhIFN1c3BlbnNlIGJvdW5kYXJ5IHRoYXQgaXMgY3VycmVudGx5IGhpZGRlbixcbiAgLy8gd2Ugc2hvdWxkIHVzZSB0aGUgc2FtZSBjYWNoZSB0aGF0IHdlIHVzZWQgZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIsIGlmXG4gIC8vIG9uZSBleGlzdHMuXG5cblxuICB2YXIgY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyID0gcmVzdW1lZENhY2hlLmN1cnJlbnQ7XG5cbiAgaWYgKGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiBjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXI7XG4gIH0gLy8gT3RoZXJ3aXNlLCBjaGVjayB0aGUgcm9vdCdzIGNhY2hlIHBvb2wuXG5cblxuICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuICB2YXIgY2FjaGVGcm9tUm9vdENhY2hlUG9vbCA9IHJvb3QucG9vbGVkQ2FjaGU7XG4gIHJldHVybiBjYWNoZUZyb21Sb290Q2FjaGVQb29sO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0Q2FjaGVGcm9tUG9vbChyZW5kZXJMYW5lcykge1xuICAvLyBTaW1pbGFyIHRvIHByZXZpb3VzIGZ1bmN0aW9uLCBleGNlcHQgaWYgdGhlcmUncyBub3QgYWxyZWFkeSBhIGNhY2hlIGluIHRoZVxuICAvLyBwb29sLCB3ZSBhbGxvY2F0ZSBhIG5ldyBvbmUuXG4gIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcblxuICBpZiAoY2FjaGVGcm9tUG9vbCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBjYWNoZUZyb21Qb29sO1xuICB9IC8vIENyZWF0ZSBhIGZyZXNoIGNhY2hlIGFuZCBhZGQgaXQgdG8gdGhlIHJvb3QgY2FjaGUgcG9vbC4gQSBjYWNoZSBjYW4gaGF2ZVxuICAvLyBtdWx0aXBsZSBvd25lcnM6XG4gIC8vIC0gQSBjYWNoZSBwb29sIHRoYXQgbGl2ZXMgb24gdGhlIEZpYmVyUm9vdC4gVGhpcyBpcyB3aGVyZSBhbGwgZnJlc2ggY2FjaGVzXG4gIC8vICAgYXJlIG9yaWdpbmFsbHkgY3JlYXRlZCAoVE9ETzogZXhjZXB0IGR1cmluZyByZWZyZXNoZXMsIHVudGlsIHdlIGltcGxlbWVudFxuICAvLyAgIHRoaXMgY29ycmVjdGx5KS4gVGhlIHJvb3QgdGFrZXMgb3duZXJzaGlwIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGNhY2hlIGlzXG4gIC8vICAgY3JlYXRlZC4gQ29uY2VwdHVhbGx5LCByb290LnBvb2xlZENhY2hlIGlzIGFuIE9wdGlvbjxBcmM8Q2FjaGU+PiAob3duZWQpLFxuICAvLyAgIGFuZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gaXMgYSAmQXJjPENhY2hlPiAoYm9ycm93ZWQpLlxuICAvLyAtIE9uZSBvZiBzZXZlcmFsIGZpYmVyIHR5cGVzOiBob3N0IHJvb3QsIGNhY2hlIGJvdW5kYXJ5LCBzdXNwZW5zZVxuICAvLyAgIGNvbXBvbmVudC4gVGhlc2UgcmV0YWluIGFuZCByZWxlYXNlIGluIHRoZSBjb21taXQgcGhhc2UuXG5cblxuICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuICB2YXIgZnJlc2hDYWNoZSA9IGNyZWF0ZUNhY2hlKCk7XG4gIHJvb3QucG9vbGVkQ2FjaGUgPSBmcmVzaENhY2hlO1xuICByZXRhaW5DYWNoZShmcmVzaENhY2hlKTtcblxuICBpZiAoZnJlc2hDYWNoZSAhPT0gbnVsbCkge1xuICAgIHJvb3QucG9vbGVkQ2FjaGVMYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgfVxuXG4gIHJldHVybiBmcmVzaENhY2hlO1xufVxuZnVuY3Rpb24gcHVzaFRyYW5zaXRpb24ob2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MsIHByZXZDYWNoZVBvb2wsIG5ld1RyYW5zaXRpb25zKSB7XG4gIHtcbiAgICBpZiAocHJldkNhY2hlUG9vbCA9PT0gbnVsbCkge1xuICAgICAgcHVzaChyZXN1bWVkQ2FjaGUsIHJlc3VtZWRDYWNoZS5jdXJyZW50LCBvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocmVzdW1lZENhY2hlLCBwcmV2Q2FjaGVQb29sLnBvb2wsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvcFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcblxuICAgIHtcbiAgICAgIHBvcChyZXN1bWVkQ2FjaGUsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1c3BlbmRlZENhY2hlKCkge1xuICAvLyBjYWNoZSB0aGF0IHdvdWxkIGhhdmUgYmVlbiB1c2VkIHRvIHJlbmRlciBmcmVzaCBkYXRhIGR1cmluZyB0aGlzIHJlbmRlcixcbiAgLy8gaWYgdGhlcmUgd2FzIGFueSwgc28gdGhhdCB3ZSBjYW4gcmVzdW1lIHJlbmRlcmluZyB3aXRoIHRoZSBzYW1lIGNhY2hlIHdoZW5cbiAgLy8gd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG5cblxuICB2YXIgY2FjaGVGcm9tUG9vbCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG5cbiAgaWYgKGNhY2hlRnJvbVBvb2wgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gV2UgbXVzdCBhbHNvIHNhdmUgdGhlIHBhcmVudCwgc28gdGhhdCB3aGVuIHdlIHJlc3VtZSB3ZSBjYW4gZGV0ZWN0XG4gICAgLy8gYSByZWZyZXNoLlxuICAgIHBhcmVudDogaXNQcmltYXJ5UmVuZGVyZXIgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICBwb29sOiBjYWNoZUZyb21Qb29sXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPZmZzY3JlZW5EZWZlcnJlZENhY2hlKCkge1xuXG4gIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcblxuICBpZiAoY2FjaGVGcm9tUG9vbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBXZSBtdXN0IGFsc28gc3RvcmUgdGhlIHBhcmVudCwgc28gdGhhdCB3aGVuIHdlIHJlc3VtZSB3ZSBjYW4gZGV0ZWN0XG4gICAgLy8gYSByZWZyZXNoLlxuICAgIHBhcmVudDogaXNQcmltYXJ5UmVuZGVyZXIgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICBwb29sOiBjYWNoZUZyb21Qb29sXG4gIH07XG59XG5cbi8qKlxuICogVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICogYSBQbGFjZW1lbnRBbmRVcGRhdGUuXG4gKi9cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG59XG4vKipcbiAqIEluIHBlcnNpc3RlbnQgbW9kZSwgcmV0dXJuIHdoZXRoZXIgdGhpcyB1cGRhdGUgbmVlZHMgdG8gY2xvbmUgdGhlIHN1YnRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmspIHtcbiAgdmFyIGRpZEJhaWxvdXQgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgaWYgKGRpZEJhaWxvdXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBDaGlsZERlbGV0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVE9ETzogSWYgd2UgbW92ZSB0aGUgYGRvZXNSZXF1aXJlQ2xvbmVgIGNhbGwgYWZ0ZXIgYGJ1YmJsZVByb3BlcnRpZXNgXG4gIC8vIHRoZW4gd2Ugb25seSBoYXZlIHRvIGNoZWNrIHRoZSBgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3NgLlxuXG5cbiAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBpZiAoKGNoaWxkLmZsYWdzICYgTXV0YXRpb25NYXNrKSAhPT0gTm9GbGFncyQxIHx8IChjaGlsZC5zdWJ0cmVlRmxhZ3MgJiBNdXRhdGlvbk1hc2spICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCB8fCAoc3VwcG9ydHNTaW5nbGV0b25zID8gbm9kZS50YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIDsgZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgX25vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgIHdoaWxlIChfbm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKF9ub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHByb3BzID0gX25vZGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgdHlwZSA9IF9ub2RlLnR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKF9ub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgdmFyIF9pbnN0YW5jZSA9IF9ub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG4gICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICB2YXIgdGV4dCA9IF9ub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgX2luc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoX2luc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIF9pbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKF9ub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIGlmIChfbm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBfbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZHJlbiBpbiB0aGlzIGJvdW5kYXJ5IGFyZSBoaWRkZW4uIFRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG4gICAgICAgIHZhciBjaGlsZCA9IF9ub2RlLmNoaWxkO1xuXG4gICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkLnJldHVybiA9IF9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCBfbm9kZSxcbiAgICAgICAgLyogbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICovXG4gICAgICAgIHRydWUsXG4gICAgICAgIC8qIGlzSGlkZGVuICovXG4gICAgICAgIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChfbm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBfbm9kZS5jaGlsZC5yZXR1cm4gPSBfbm9kZTtcbiAgICAgICAgX25vZGUgPSBfbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICB3aGlsZSAoX25vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgaWYgKF9ub2RlLnJldHVybiA9PT0gbnVsbCB8fCBfbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX25vZGUgPSBfbm9kZS5yZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIF9ub2RlLnNpYmxpbmcucmV0dXJuID0gX25vZGUucmV0dXJuO1xuICAgICAgX25vZGUgPSBfbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxufSAvLyBBbiB1bmZvcnR1bmF0ZSBmb3JrIG9mIGFwcGVuZEFsbENoaWxkcmVuIGJlY2F1c2Ugd2UgaGF2ZSB0d28gZGlmZmVyZW50IHBhcmVudCB0eXBlcy5cblxuXG5mdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG4gICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICB2YXIgcHJvcHMgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHRleHQgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgX2luc3RhbmNlMiA9IGNsb25lSGlkZGVuVGV4dEluc3RhbmNlKF9pbnN0YW5jZTIsIHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBfaW5zdGFuY2UyKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSBpZiAobm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIGNoaWxkcmVuIGluIHRoaXMgYm91bmRhcnkgYXJlIGhpZGRlbi4gVG9nZ2xlIHRoZWlyIHZpc2liaWxpdHlcbiAgICAgICAgLy8gYmVmb3JlIGFwcGVuZGluZy5cbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBjaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICB9IC8vIElmIE9mZnNjcmVlbiBpcyBub3QgaW4gbWFudWFsIG1vZGUsIGRldGFjaGVkIHRyZWUgaXMgaGlkZGVuIGZyb20gdXNlciBzcGFjZS5cblxuXG4gICAgICAgIHZhciBfbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gIWlzT2Zmc2NyZWVuTWFudWFsKG5vZGUpO1xuXG4gICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUsXG4gICAgICAgIC8qIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAqL1xuICAgICAgICBfbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLFxuICAgICAgICAvKiBpc0hpZGRlbiAqL1xuICAgICAgICB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGU7XG5cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICBpZiAoZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICB2YXIgbmV3Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldCgpOyAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzLFxuICAgICAgLyogbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICovXG4gICAgICBmYWxzZSxcbiAgICAgIC8qIGlzSGlkZGVuICovXG4gICAgICBmYWxzZSk7XG4gICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7IC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY29udGFpbmVyIHRvIHN3YXAgb3V0IHRoZSBjb250YWluZXIuXG5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICB2YXIgX29sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzOyAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG5cbiAgICB2YXIgcmVxdWlyZXNDbG9uZSA9IGRvZXNSZXF1aXJlQ2xvbmUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKCFyZXF1aXJlc0Nsb25lICYmIF9vbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgIHZhciBuZXdDaGlsZFNldCA9IG51bGw7XG5cbiAgICBpZiAocmVxdWlyZXNDbG9uZSAmJiBwYXNzQ2hpbGRyZW5XaGVuQ2xvbmluZ1BlcnNpc3RlZE5vZGVzKSB7XG4gICAgICBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KCk7IC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cblxuICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAvKiBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgKi9cbiAgICAgIGZhbHNlLFxuICAgICAgLyogaXNIaWRkZW4gKi9cbiAgICAgIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3SW5zdGFuY2UgPSBjbG9uZUluc3RhbmNlKGN1cnJlbnRJbnN0YW5jZSwgdHlwZSwgX29sZFByb3BzLCBuZXdQcm9wcywgIXJlcXVpcmVzQ2xvbmUsIG5ld0NoaWxkU2V0KTtcblxuICAgIGlmIChuZXdJbnN0YW5jZSA9PT0gY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIHN1cHBvcnRzIGF1dG8tZm9jdXMgZm9yIGNlcnRhaW4gZWxlbWVudHMpLlxuICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG5cbiAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBjdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcblxuICAgIGlmICghcmVxdWlyZXNDbG9uZSkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIC8qIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAqL1xuICAgICAgZmFsc2UsXG4gICAgICAvKiBpc0hpZGRlbiAqL1xuICAgICAgZmFsc2UpO1xuICAgIH1cbiAgfVxufSAvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UsIGJlY2F1c2Vcbi8vIGl0IG1pZ2h0IHRocm93IHRvIHN1c3BlbmQsIGFuZCBpZiB0aGUgcmVzb3VyY2UgaW1tZWRpYXRlbHkgbG9hZHMsIHRoZSB3b3JrXG4vLyBsb29wIHdpbGwgcmVzdW1lIHJlbmRlcmluZyBhcyBpZiB0aGUgd29yay1pbi1wcm9ncmVzcyBjb21wbGV0ZWQuIFNvIGl0IG11c3Rcbi8vIGZ1bGx5IGNvbXBsZXRlLlxuLy8gVE9ETzogVGhpcyBzaG91bGQgaWRlYWxseSBtb3ZlIHRvIGJlZ2luIHBoYXNlLCBidXQgY3VycmVudGx5IHRoZSBpbnN0YW5jZSBpc1xuLy8gbm90IGNyZWF0ZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBGb3Igb3VyIGV4aXN0aW5nIHVzZSBjYXNlcywgaG9zdCBub2Rlc1xuLy8gdGhhdCBzdXNwZW5kIGRvbid0IGhhdmUgY2hpbGRyZW4sIHNvIGl0IGRvZXNuJ3QgbWF0dGVyLiBCdXQgdGhhdCBtaWdodCBub3Rcbi8vIGFsd2F5cyBiZSB0cnVlIGluIHRoZSBmdXR1cmUuXG5cblxuZnVuY3Rpb24gcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKCFtYXlTdXNwZW5kQ29tbWl0KHR5cGUsIHByb3BzKSkge1xuICAgIC8vIElmIHRoaXMgZmxhZyB3YXMgc2V0IHByZXZpb3VzbHksIHdlIGNhbiByZW1vdmUgaXQuIFRoZSBmbGFnXG4gICAgLy8gcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgcGFydGljdWxhciBzZXQgb2YgcHJvcHMgbWlnaHQgZXZlciBuZWVkIHRvXG4gICAgLy8gc3VzcGVuZC4gVGhlIHNhZmVzdCB0aGluZyB0byBkbyBpcyBmb3IgbWF5U3VzcGVuZENvbW1pdCB0byBhbHdheXNcbiAgICAvLyByZXR1cm4gdHJ1ZSwgYnV0IGlmIHRoZSByZW5kZXJlciBpcyByZWFzb25hYmx5IGNvbmZpZGVudCB0aGF0IHRoZVxuICAgIC8vIHVuZGVybHlpbmcgcmVzb3VyY2Ugd29uJ3QgYmUgZXZpY3RlZCwgaXQgY2FuIHJldHVybiBmYWxzZSBhcyBhXG4gICAgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5NYXlTdXNwZW5kQ29tbWl0O1xuICAgIHJldHVybjtcbiAgfSAvLyBNYXJrIHRoaXMgZmliZXIgd2l0aCBhIGZsYWcuIFRoaXMgZ2V0cyBzZXQgb24gYWxsIGhvc3QgaW5zdGFuY2VzXG4gIC8vIHRoYXQgbWlnaHQgcG9zc2libHkgc3VzcGVuZCwgZXZlbiBpZiB0aGV5IGRvbid0IG5lZWQgdG8gc3VzcGVuZFxuICAvLyBjdXJyZW50bHkuIFdlIHVzZSB0aGlzIHdoZW4gcmV2ZWFsaW5nIGEgcHJlcmVuZGVyZWQgdHJlZSwgYmVjYXVzZVxuICAvLyBldmVuIHRob3VnaCB0aGUgdHJlZSBoYXMgXCJtb3VudGVkXCIsIGl0cyByZXNvdXJjZXMgbWlnaHQgbm90IGhhdmVcbiAgLy8gbG9hZGVkIHlldC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IE1heVN1c3BlbmRDb21taXQ7IC8vIHByZWxvYWQgdGhlIGluc3RhbmNlIGlmIG5lY2Vzc2FyeS4gRXZlbiBpZiB0aGlzIGlzIGFuIHVyZ2VudCByZW5kZXIgdGhlcmVcbiAgLy8gY291bGQgYmUgYmVuZWZpdHMgdG8gcHJlbG9hZGluZyBlYXJseS5cbiAgLy8gQFRPRE8gd2Ugc2hvdWxkIHByb2JhYmx5IGRvIHRoZSBwcmVsb2FkIGluIGJlZ2luIHdvcmtcblxuICB2YXIgaXNSZWFkeSA9IHByZWxvYWRJbnN0YW5jZSh0eXBlLCBwcm9wcyk7XG5cbiAgaWYgKCFpc1JlYWR5KSB7XG4gICAgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkU3VzcGVuZENvbW1pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuZENvbW1pdCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHJlc291cmNlLCB0eXBlLCBwcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkLCBidXQgZm9yIHJlc291cmNlcy5cbiAgaWYgKCFtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQocmVzb3VyY2UpKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfk1heVN1c3BlbmRDb21taXQ7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gTWF5U3VzcGVuZENvbW1pdDtcbiAgdmFyIGlzUmVhZHkgPSBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpO1xuXG4gIGlmICghaXNSZWFkeSkge1xuICAgIGlmIChzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZFN1c3BlbmRDb21taXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbmRDb21taXQoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmV0cnlRdWV1ZSkge1xuICB2YXIgd2FrZWFibGVzID0gcmV0cnlRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGF0dGFjaCBhIHJldHJ5IGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlLlxuICAgIC8vIFRPRE86IE1vdmUgdG8gcGFzc2l2ZSBwaGFzZVxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IHN1c3BlbmRlZCwgYnV0IG5vIHdha2VhYmxlcyB3ZXJlIGFkZGVkIHRvIHRoZSByZXRyeVxuICAgIC8vIHF1ZXVlLiBDaGVjayBpZiB0aGUgcmVuZGVyZXIgc3VzcGVuZGVkIGNvbW1pdC4gSWYgc28sIHRoaXMgbWVhbnNcbiAgICAvLyB0aGF0IG9uY2UgdGhlIGZhbGxiYWNrIGlzIGNvbW1pdHRlZCwgd2UgY2FuIGltbWVkaWF0ZWx5IHJldHJ5XG4gICAgLy8gcmVuZGVyaW5nIGFnYWluLCBiZWNhdXNlIHJlbmRlcmluZyB3YXNuJ3QgYWN0dWFsbHkgYmxvY2tlZC4gT25seVxuICAgIC8vIHRoZSBjb21taXQgcGhhc2UuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgYSBtb2RlbCB3aGVyZSB3ZSBhbHdheXMgc2NoZWR1bGUgYW4gaW1tZWRpYXRlIHJldHJ5LCBldmVuXG4gICAgLy8gZm9yIG5vcm1hbCBTdXNwZW5zZS4gVGhhdCB3YXkgdGhlIHJldHJ5IGNhbiBwYXJ0aWFsbHkgcmVuZGVyIHVwIHRvIHRoZVxuICAgIC8vIGZpcnN0IHRoaW5nIHRoYXQgc3VzcGVuZHMuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgU2NoZWR1bGVSZXRyeSkge1xuICAgICAgdmFyIHJldHJ5TGFuZSA9IC8vIFRPRE86IFRoaXMgY2hlY2sgc2hvdWxkIHByb2JhYmx5IGJlIG1vdmVkIGludG8gY2xhaW1OZXh0UmV0cnlMYW5lXG4gICAgICAvLyBJIGFsc28gc3VzcGVjdCB0aGF0IHdlIG5lZWQgc29tZSBmdXJ0aGVyIGNvbnNvbGlkYXRpb24gb2Ygb2Zmc2NyZWVuXG4gICAgICAvLyBhbmQgcmV0cnkgbGFuZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgIT09IE9mZnNjcmVlbkNvbXBvbmVudCA/IGNsYWltTmV4dFJldHJ5TGFuZSgpIDogT2Zmc2NyZWVuTGFuZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgcmV0cnlMYW5lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7IC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG4gICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cblxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjaykge1xuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIC8vIElmIHdlJ3JlIGh5ZHJhdGluZywgd2Ugc2hvdWxkIGNvbnN1bWUgYXMgbWFueSBpdGVtcyBhcyB3ZSBjYW5cbiAgICAvLyBzbyB3ZSBkb24ndCBsZWF2ZSBhbnkgYmVoaW5kLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAocmVuZGVyU3RhdGUudGFpbE1vZGUpIHtcbiAgICBjYXNlICdoaWRkZW4nOlxuICAgICAge1xuICAgICAgICAvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbiAgICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbiAgICAgICAgLy8gdGhlcmUgYXJlIGFueS5cbiAgICAgICAgdmFyIHRhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHRhaWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdFRhaWxOb2RlID0gdGFpbE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5zaWJsaW5nO1xuICAgICAgICB9IC8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbiAgICAgICAgLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuXG5cbiAgICAgICAgaWYgKGxhc3RUYWlsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdjb2xsYXBzZWQnOlxuICAgICAge1xuICAgICAgICAvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbiAgICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbiAgICAgICAgLy8gdGhlcmUgYXJlIGFueS5cbiAgICAgICAgdmFyIF90YWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIHZhciBfbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoX3RhaWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKF90YWlsTm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9sYXN0VGFpbE5vZGUgPSBfdGFpbE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RhaWxOb2RlID0gX3RhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAoX2xhc3RUYWlsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG4gICAgICAgICAgaWYgKCFoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgJiYgcmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2Ugc3VzcGVuZGVkIGR1cmluZyB0aGUgaGVhZC4gV2Ugd2FudCB0byBzaG93IGF0IGxlYXN0IG9uZVxuICAgICAgICAgICAgLy8gcm93IGF0IHRoZSB0YWlsLiBTbyB3ZSdsbCBrZWVwIG9uIGFuZCBjdXQgb2ZmIHRoZSByZXN0LlxuICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbC5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuICAgICAgICAgIC8vIGluc2VydGVkLlxuICAgICAgICAgIF9sYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWJibGVQcm9wZXJ0aWVzKGNvbXBsZXRlZFdvcmspIHtcbiAgdmFyIGRpZEJhaWxvdXQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZS5jaGlsZCA9PT0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgc3VidHJlZUZsYWdzID0gTm9GbGFncyQxO1xuXG4gIGlmICghZGlkQmFpbG91dCkge1xuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIHByb2ZpbGluZyBtb2RlLCByZXNldENoaWxkRXhwaXJhdGlvblRpbWUgaXMgYWxzbyB1c2VkIHRvIHJlc2V0XG4gICAgICAvLyBwcm9maWxlciBkdXJhdGlvbnMuXG4gICAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgdmFyIHRyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb247XG4gICAgICB2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhjaGlsZC5sYW5lcywgY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuc3VidHJlZUZsYWdzO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuZmxhZ3M7IC8vIFdoZW4gYSBmaWJlciBpcyBjbG9uZWQsIGl0cyBhY3R1YWxEdXJhdGlvbiBpcyByZXNldCB0byAwLiBUaGlzIHZhbHVlIHdpbGxcbiAgICAgICAgLy8gb25seSBiZSB1cGRhdGVkIGlmIHdvcmsgaXMgZG9uZSBvbiB0aGUgZmliZXIgKGkuZS4gaXQgZG9lc24ndCBiYWlsb3V0KS5cbiAgICAgICAgLy8gV2hlbiB3b3JrIGlzIGRvbmUsIGl0IHNob3VsZCBidWJibGUgdG8gdGhlIHBhcmVudCdzIGFjdHVhbER1cmF0aW9uLiBJZlxuICAgICAgICAvLyB0aGUgZmliZXIgaGFzIG5vdCBiZWVuIGNsb25lZCB0aG91Z2gsIChtZWFuaW5nIG5vIHdvcmsgd2FzIGRvbmUpLCB0aGVuXG4gICAgICAgIC8vIHRoaXMgdmFsdWUgd2lsbCByZWZsZWN0IHRoZSBhbW91bnQgb2YgdGltZSBzcGVudCB3b3JraW5nIG9uIGEgcHJldmlvdXNcbiAgICAgICAgLy8gcmVuZGVyLiBJbiB0aGF0IGNhc2UgaXQgc2hvdWxkIG5vdCBidWJibGUuIFdlIGRldGVybWluZSB3aGV0aGVyIGl0IHdhc1xuICAgICAgICAvLyBjbG9uZWQgYnkgY29tcGFyaW5nIHRoZSBjaGlsZCBwb2ludGVyLlxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gYWRkaXRpb24gd2l0aCBwb3NzaWJsZSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuXG4gICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uOyAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gYWRkaXRpb24gd2l0aCBwb3NzaWJsZSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuXG4gICAgICAgIHRyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSB0cmVlQmFzZUR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZC5sYW5lcywgX2NoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZC5zdWJ0cmVlRmxhZ3M7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQuZmxhZ3M7IC8vIFVwZGF0ZSB0aGUgcmV0dXJuIHBvaW50ZXIgc28gdGhlIHRyZWUgaXMgY29uc2lzdGVudC4gVGhpcyBpcyBhIGNvZGVcbiAgICAgICAgLy8gc21lbGwgYmVjYXVzZSBpdCBhc3N1bWVzIHRoZSBjb21taXQgcGhhc2UgaXMgbmV2ZXIgY29uY3VycmVudCB3aXRoXG4gICAgICAgIC8vIHRoZSByZW5kZXIgcGhhc2UuIFdpbGwgYWRkcmVzcyBkdXJpbmcgcmVmYWN0b3IgdG8gYWx0ZXJuYXRlIG1vZGVsLlxuXG4gICAgICAgIF9jaGlsZC5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFncyB8PSBzdWJ0cmVlRmxhZ3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG4gICAgaWYgKChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICAgIHZhciBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHZhciBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZDIgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhfY2hpbGQyLmxhbmVzLCBfY2hpbGQyLmNoaWxkTGFuZXMpKTsgLy8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4gICAgICAgIC8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGlnbm9yZSB0aGVtLlxuXG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgU3RhdGljTWFzazsgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIGFkZGl0aW9uIHdpdGggcG9zc2libGUgbnVsbC91bmRlZmluZWQgdmFsdWVcblxuICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiArPSBfY2hpbGQyLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIF9jaGlsZDIgPSBfY2hpbGQyLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NoaWxkMyA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQzICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkMy5sYW5lcywgX2NoaWxkMy5jaGlsZExhbmVzKSk7IC8vIFwiU3RhdGljXCIgZmxhZ3Mgc2hhcmUgdGhlIGxpZmV0aW1lIG9mIHRoZSBmaWJlci9ob29rIHRoZXkgYmVsb25nIHRvLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgYnViYmxlIHRob3NlIHVwIGV2ZW4gZHVyaW5nIGEgYmFpbG91dC4gQWxsIHRoZSBvdGhlclxuICAgICAgICAvLyBmbGFncyBoYXZlIGEgbGlmZXRpbWUgb25seSBvZiBhIHNpbmdsZSByZW5kZXIgKyBjb21taXQsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBpZ25vcmUgdGhlbS5cblxuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMy5zdWJ0cmVlRmxhZ3MgJiBTdGF0aWNNYXNrO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMy5mbGFncyAmIFN0YXRpY01hc2s7IC8vIFVwZGF0ZSB0aGUgcmV0dXJuIHBvaW50ZXIgc28gdGhlIHRyZWUgaXMgY29uc2lzdGVudC4gVGhpcyBpcyBhIGNvZGVcbiAgICAgICAgLy8gc21lbGwgYmVjYXVzZSBpdCBhc3N1bWVzIHRoZSBjb21taXQgcGhhc2UgaXMgbmV2ZXIgY29uY3VycmVudCB3aXRoXG4gICAgICAgIC8vIHRoZSByZW5kZXIgcGhhc2UuIFdpbGwgYWRkcmVzcyBkdXJpbmcgcmVmYWN0b3IgdG8gYWx0ZXJuYXRlIG1vZGVsLlxuXG4gICAgICAgIF9jaGlsZDMucmV0dXJuID0gY29tcGxldGVkV29yaztcbiAgICAgICAgX2NoaWxkMyA9IF9jaGlsZDMuc2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFncyB8PSBzdWJ0cmVlRmxhZ3M7XG4gIH1cblxuICBjb21wbGV0ZWRXb3JrLmNoaWxkTGFuZXMgPSBuZXdDaGlsZExhbmVzO1xuICByZXR1cm4gZGlkQmFpbG91dDtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAobmV4dFN0YXRlICE9PSBudWxsICYmIG5leHRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgLy8gV2UgbWlnaHQgYmUgaW5zaWRlIGEgaHlkcmF0aW9uIHN0YXRlIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIHBpY2tpbmcgdXAgdGhpc1xuICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCBhbmQgYWxzbyBhZnRlciB3ZSd2ZSByZWVudGVyZWQgaXQgZm9yIGZ1cnRoZXIgaHlkcmF0aW9uLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdhc0h5ZHJhdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudCB3YXMgY29tcGxldGVkIHdpdGhvdXQgYSBoeWRyYXRlZCBub2RlLiAnICsgJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAge1xuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgIHZhciBpc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbiAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgICAgICAgICBpZiAocHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYXJpdGhtZXRpY10gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCk7IC8vIFdlIG1pZ2h0IGhhdmUgcmVlbnRlcmVkIHRoaXMgYm91bmRhcnkgdG8gaHlkcmF0ZSBpdC4gSWYgc28sIHdlIG5lZWQgdG8gcmVzZXQgdGhlIGh5ZHJhdGlvblxuICAgICAgLy8gc3RhdGUgc2luY2Ugd2UncmUgbm93IGV4aXRpbmcgb3V0IG9mIGl0LiBwb3BIeWRyYXRpb25TdGF0ZSBkb2Vzbid0IGRvIHRoYXQgZm9yIHVzLlxuXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cbiAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIFRoaXMgYm91bmRhcnkgZGlkIG5vdCBzdXNwZW5kIHNvIGl0J3Mgbm93IGh5ZHJhdGVkIGFuZCB1bnN1c3BlbmRlZC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBtYXJrIHRoaXMgYm91bmRhcnlcbiAgICAgIC8vIGFzIGhhdmluZyBoeWRyYXRlZCBzbyBldmVudHMga25vdyB0aGF0IHRoZXkncmUgZnJlZSB0byBiZSBpbnZva2VkLlxuICAgICAgLy8gSXQncyBhbHNvIGEgc2lnbmFsIHRvIHJlcGxheSBldmVudHMgYW5kIHRoZSBzdXNwZW5zZSBjYWxsYmFjay5cbiAgICAgIC8vIElmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggcmV0cnkgbGlzdGVuZXJzLlxuICAgICAgLy8gU28gd2UgbWlnaHQgYXMgd2VsbCBhbHdheXMgbWFyayB0aGlzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgdmFyIF9pc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoX2lzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgIGlmIChfcHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYXJpdGhtZXRpY10gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gX3ByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB0aGlzIHRyZWUuIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsXG4gICAgLy8gdGhlcmUgbWF5IGhhdmUgYmVlbiByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvblxuICAgIC8vIGF0dGVtcHQuIElmIHNvLCBhZGQgdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGVcbiAgICAvLyBjb21taXQgcGhhc2UuXG4gICAgdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTsgLy8gRmFsbCB0aHJvdWdoIHRvIG5vcm1hbCBTdXNwZW5zZSBwYXRoXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsgLy8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4gIC8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuICAvLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4gIC8vIGZvciBoeWRyYXRpb24uXG5cbiAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBGYWxsdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgY2FzZSBNb2RlOlxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzQ2FjaGUgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByZXZpb3VzQ2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNhY2hlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcblxuICAgICAgICAgIGlmIChjYWNoZSAhPT0gcHJldmlvdXNDYWNoZSkge1xuICAgICAgICAgICAgLy8gUnVuIHBhc3NpdmUgZWZmZWN0cyB0byByZXRhaW4vcmVsZWFzZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQYXNzaXZlJDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9wQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKTsgLy8gSWYgd2UgaHlkcmF0ZWQsIHRoZW4gd2UnbGwgbmVlZCB0byBzY2hlZHVsZSBhbiB1cGRhdGUgZm9yXG4gICAgICAgICAgICAvLyB0aGUgY29tbWl0IHNpZGUtZWZmZWN0cyBvbiB0aGUgcm9vdC5cblxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKCAvLyBDaGVjayBpZiB0aGlzIGlzIGEgY2xpZW50IHJvb3RcbiAgICAgICAgICAgICAgIXByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQgfHwgLy8gQ2hlY2sgaWYgd2UgcmV2ZXJ0ZWQgdG8gY2xpZW50IHJlbmRlcmluZyAoZS5nLiBkdWUgdG8gYW4gZXJyb3IpXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmNlQ2xpZW50UmVuZGVyKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGNsZWFyIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0IGNvbW1pdC4gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGFcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZXIgd2l0aCBwcmV2aW91cyBjaGlsZHJlbi4gSXQncyBhbHNvIHNhZmUgdG8gZG8gZm9yXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGwgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgcmVuZGVyIHdhcyBudWxsIChzbyB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBiZSBlbXB0eSkuXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7IC8vIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsIHRoZXJlIG1heSBoYXZlIGJlZW5cbiAgICAgICAgICAgICAgICAvLyByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvbiBhdHRlbXB0LiBJZiBzbywgYWRkXG4gICAgICAgICAgICAgICAgLy8gdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGUgY29tbWl0IHBoYXNlLlxuXG4gICAgICAgICAgICAgICAgdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgLy8gVGhlIGJyYW5jaGluZyBoZXJlIGlzIG1vcmUgY29tcGxpY2F0ZWQgdGhhbiB5b3UgbWlnaHQgZXhwZWN0IGJlY2F1c2VcbiAgICAgICAgICAvLyBhIEhvc3RIb2lzdGFibGUgc29tZXRpbWVzIGNvcnJlc3BvbmRzIHRvIGEgUmVzb3VyY2UgYW5kIHNvbWV0aW1lc1xuICAgICAgICAgIC8vIGNvcnJlc3BvbmRzIHRvIGFuIEluc3RhbmNlLiBJdCBjYW4gYWxzbyBzd2l0Y2ggZHVyaW5nIGFuIHVwZGF0ZS5cbiAgICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgdmFyIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIG1vdW50aW5nIGFuZCBtdXN0IFVwZGF0ZSB0aGlzIEhvaXN0YWJsZSBpbiB0aGlzIGNvbW1pdFxuICAgICAgICAgICAgLy8gQFRPRE8gcmVmYWN0b3IgdGhpcyBibG9jayB0byBjcmVhdGUgdGhlIGluc3RhbmNlIGhlcmUgaW4gY29tcGxldGVcbiAgICAgICAgICAgIC8vIHBoYXNlIGlmIHdlIGFyZSBub3QgaHlkcmF0aW5nLlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0UmVzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIEhvaXN0YWJsZSBSZXNvdXJjZVxuICAgICAgICAgICAgICAvLyBUaGlzIG11c3QgY29tZSBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGNvbXBsZXRlIHBoYXNlLlxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCBuZXh0UmVzb3VyY2UpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBIb2lzdGFibGUgSW5zdGFuY2VcbiAgICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGNvbWUgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBjb21wbGV0ZSBwaGFzZS5cbiAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgICAgICAgICBpZiAobmV4dFJlc291cmNlKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBSZXNvdXJjZVxuICAgICAgICAgICAgICBpZiAobmV4dFJlc291cmNlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgbmV3IFJlc291cmNlLiB3ZSBuZWVkIHRvIHVwZGF0ZVxuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpOyAvLyBUaGlzIG11c3QgY29tZSBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGNvbXBsZXRlIHBoYXNlLlxuXG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgbXVzdCBjb21lIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UsIGJlY2F1c2UgaXQgbWlnaHRcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyB0byBzdXNwZW5kLCBhbmQgaWYgdGhlIHJlc291cmNlIGltbWVkaWF0ZWx5IGxvYWRzLCB0aGUgd29yayBsb29wXG4gICAgICAgICAgICAgICAgLy8gd2lsbCByZXN1bWUgcmVuZGVyaW5nIGFzIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIGNvbXBsZXRlZC4gU28gaXQgbXVzdFxuICAgICAgICAgICAgICAgIC8vIGZ1bGx5IGNvbXBsZXRlLlxuXG4gICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCBuZXh0UmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBjb21lIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UuXG4gICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfk1heVN1c3BlbmRDb21taXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gSW5zdGFuY2VcbiAgICAgICAgICAgICAgLy8gV2UgbWF5IGhhdmUgcHJvcHMgdG8gdXBkYXRlIG9uIHRoZSBIb2lzdGFibGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgdXBkYXRlSG9zdENvbXBvbmVudCBwYXRoIGJlY3Vhc2UgaXQgcHJvZHVjZXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXBkYXRlIHF1ZXVlIHdlIG5lZWQgZm9yIEhvaXN0YWJsZXMuXG4gICAgICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMpO1xuICAgICAgICAgICAgICB9IC8vIFRoaXMgbXVzdCBjb21lIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UuXG5cblxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciBfdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgdmFyIF9vbGRQcm9wczIgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG5cbiAgICAgICAgICAgICAgaWYgKF9vbGRQcm9wczIgIT09IG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF90eXBlLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cblxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2U7XG5cbiAgICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaWdub3JlIHRoZSBib29sZWFuIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gdXBkYXRlUXVldWUgYmVjYXVzZVxuICAgICAgICAgICAgICAvLyBpdCBpcyB1c2VkIG9ubHkgdG8gc2V0IHRleHQgY2hpbGRyZW4gYW5kIEhvc3RTaW5nbGV0b25zIGRvIG5vdFxuICAgICAgICAgICAgICAvLyB1c2UgdGhlbS5cbiAgICAgICAgICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudEhvc3RDb250ZXh0KTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YW5jZSA9IHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShfdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIF90eXBlMiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZTIsIG5ld1Byb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gYWRkIHRoZW0gdG9wLT5kb3duIG9yXG4gICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuXG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkMiA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBfY3VycmVudEhvc3RDb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlMyA9IGNyZWF0ZUluc3RhbmNlKF90eXBlMiwgbmV3UHJvcHMsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTsgLy8gVE9ETzogRm9yIHBlcnNpc3RlbnQgcmVuZGVyZXJzLCB3ZSBzaG91bGQgcGFzcyBjaGlsZHJlbiBhcyBwYXJ0XG4gICAgICAgICAgICAvLyBvZiB0aGUgaW5pdGlhbCBpbnN0YW5jZSBjcmVhdGlvblxuXG5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKF9pbnN0YW5jZTMsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlMzsgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlMywgX3R5cGUyLCBuZXdQcm9wcywgX2N1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgbXVzdCBjb21lIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UsIGJlY2F1c2UgaXQgbWlnaHRcbiAgICAgICAgLy8gdGhyb3cgdG8gc3VzcGVuZCwgYW5kIGlmIHRoZSByZXNvdXJjZSBpbW1lZGlhdGVseSBsb2FkcywgdGhlIHdvcmsgbG9vcFxuICAgICAgICAvLyB3aWxsIHJlc3VtZSByZW5kZXJpbmcgYXMgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgY29tcGxldGVkLiBTbyBpdCBtdXN0XG4gICAgICAgIC8vIGZ1bGx5IGNvbXBsZXRlLlxuXG4gICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UyID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcblxuICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkMyA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQzKSB7XG4gICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlMiwgX2N1cnJlbnRIb3N0Q29udGV4dDIsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTsgLy8gU3BlY2lhbCBwYXRoIGZvciBkZWh5ZHJhdGVkIGJvdW5kYXJpZXMuIFdlIG1heSBldmVudHVhbGx5IG1vdmUgdGhpc1xuICAgICAgICAvLyB0byBpdHMgb3duIGZpYmVyIHR5cGUgc28gdGhhdCB3ZSBjYW4gYWRkIG90aGVyIGtpbmRzIG9mIGh5ZHJhdGlvblxuICAgICAgICAvLyBib3VuZGFyaWVzIHRoYXQgYXJlbid0IGFzc29jaWF0ZWQgd2l0aCBhIFN1c3BlbnNlIHRyZWUuIEluIGFudGljaXBhdGlvblxuICAgICAgICAvLyBvZiBzdWNoIGEgcmVmYWN0b3IsIGFsbCB0aGUgaHlkcmF0aW9uIGxvZ2ljIGlzIGNvbnRhaW5lZCBpblxuICAgICAgICAvLyB0aGlzIGJyYW5jaC5cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZmFsbHRocm91Z2hUb05vcm1hbFN1c3BlbnNlUGF0aCA9IGNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSk7XG5cbiAgICAgICAgICBpZiAoIWZhbGx0aHJvdWdoVG9Ob3JtYWxTdXNwZW5zZVBhdGgpIHtcbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmNlQ2xpZW50UmVuZGVyKSB7XG4gICAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7IC8vIFNwZWNpYWwgY2FzZS4gVGhlcmUgd2VyZSByZW1haW5pbmcgdW5oeWRyYXRlZCBub2Rlcy4gV2UgdHJlYXRcbiAgICAgICAgICAgICAgLy8gdGhpcyBhcyBhIG1pc21hdGNoLiBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cblxuICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpOyAvLyBEaWQgbm90IGZpbmlzaCBoeWRyYXRpbmcsIGVpdGhlciBiZWNhdXNlIHRoaXMgaXMgdGhlIGluaXRpYWxcbiAgICAgICAgICAgICAgLy8gcmVuZGVyIG9yIGJlY2F1c2Ugc29tZXRoaW5nIHN1c3BlbmRlZC5cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIENvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCBTdXNwZW5zZSBwYXRoLlxuXG4gICAgICAgIH1cblxuICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZC4gUmUtcmVuZGVyIHdpdGggdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7IC8vIERvIG5vdCByZXNldCB0aGUgZWZmZWN0IGxpc3QuXG5cbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0RGlkVGltZW91dCA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgICAgdmFyIG9mZnNjcmVlbkZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgdmFyIF9wcmV2aW91c0NhY2hlID0gbnVsbDtcblxuICAgICAgICAgIGlmIChvZmZzY3JlZW5GaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgb2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgb2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfcHJldmlvdXNDYWNoZSA9IG9mZnNjcmVlbkZpYmVyLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfY2FjaGUgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKG9mZnNjcmVlbkZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgb2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9jYWNoZSA9IG9mZnNjcmVlbkZpYmVyLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jYWNoZSAhPT0gX3ByZXZpb3VzQ2FjaGUpIHtcbiAgICAgICAgICAgIC8vIFJ1biBwYXNzaXZlIGVmZmVjdHMgdG8gcmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlLlxuICAgICAgICAgICAgb2Zmc2NyZWVuRmliZXIuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiB0aGUgc3VzcGVuZGVkIHN0YXRlIG9mIHRoZSBib3VuZGFyeSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIHNjaGVkdWxlXG4gICAgICAgIC8vIGEgcGFzc2l2ZSBlZmZlY3QsIHdoaWNoIGlzIHdoZW4gd2UgcHJvY2VzcyB0aGUgdHJhbnNpdGlvbnNcblxuXG4gICAgICAgIGlmIChuZXh0RGlkVGltZW91dCAhPT0gcHJldkRpZFRpbWVvdXQpIHtcbiAgICAgICAgICAvLyBhbiBlZmZlY3QgdG8gdG9nZ2xlIHRoZSBzdWJ0cmVlJ3MgdmlzaWJpbGl0eS4gV2hlbiB3ZSBzd2l0Y2ggZnJvbVxuICAgICAgICAgIC8vIGZhbGxiYWNrIC0+IHByaW1hcnksIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgc2NoZWR1bGVzIHRoaXMgZWZmZWN0XG4gICAgICAgICAgLy8gYXMgcGFydCBvZiBpdHMgbm9ybWFsIGNvbXBsZXRlIHBoYXNlLiBCdXQgd2hlbiB3ZSBzd2l0Y2ggZnJvbVxuICAgICAgICAgIC8vIHByaW1hcnkgLT4gZmFsbGJhY2ssIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgZG9lcyBub3QgaGF2ZSBhIGNvbXBsZXRlXG4gICAgICAgICAgLy8gcGhhc2UuIFNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgaXRzIGVmZmVjdCBoZXJlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gV2UgYWxzbyB1c2UgdGhpcyBmbGFnIHRvIGNvbm5lY3QvZGlzY29ubmVjdCB0aGUgZWZmZWN0cywgYnV0IHRoZSBzYW1lXG4gICAgICAgICAgLy8gbG9naWMgYXBwbGllczogd2hlbiByZS1jb25uZWN0aW5nLCB0aGUgT2Zmc2NyZWVuIGZpYmVyJ3MgY29tcGxldGVcbiAgICAgICAgICAvLyBwaGFzZSB3aWxsIGhhbmRsZSBzY2hlZHVsaW5nIHRoZSBlZmZlY3QuIEl0J3Mgb25seSB3aGVuIHRoZSBmYWxsYmFja1xuICAgICAgICAgIC8vIGlzIGFjdGl2ZSB0aGF0IHdlIGhhdmUgdG8gZG8gYW55dGhpbmcgc3BlY2lhbC5cblxuXG4gICAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgICAgICB2YXIgX29mZnNjcmVlbkZpYmVyMiA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgX29mZnNjcmVlbkZpYmVyMi5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXRyeVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJldHJ5UXVldWUpO1xuXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICBpZiAocHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hcml0aG1ldGljXSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3JcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHByZXBhcmVQb3J0YWxNb3VudCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICB9XG5cbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIC8vIFBvcCBwcm92aWRlciBmaWJlclxuICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgIHtcbiAgICAgICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB9XG5cbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIFNhbWUgYXMgY2xhc3MgY29tcG9uZW50IGNhc2UuIEkgcHV0IGl0IGRvd24gaGVyZSBzbyB0aGF0IHRoZSB0YWdzIGFyZVxuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlTGlzdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGRlZmF1bHQsIFwiaW5kZXBlbmRlbnRcIiBtb2RlLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIGluIHRoaXMgbW9kZS5cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWRTdXNwZW5kQWxyZWFkeSA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzJDE7XG4gICAgICAgIHZhciByZW5kZXJlZFRhaWwgPSByZW5kZXJTdGF0ZS5yZW5kZXJpbmc7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGp1c3QgcmVuZGVyZWQgdGhlIGhlYWQuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG4gICAgICAgICAgICAvLyBzdXNwZW5kZWQgaW4gdGhlIHJlbmRlcmVkIHNldC5cbiAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50IHVuc3VzcGVuZGVkLCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGNvbnRlbnQgdGhhdFxuICAgICAgICAgICAgLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG4gICAgICAgICAgICAvLyB0byBrZWVwIHNob3dpbmcgdGhlaXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmUgc3VzcGVuZGVkIGlmIHNvbWV0aGluZyBpbiB0aGlzIHJlbmRlciBwYXNzIHN1c3BlbmRlZCwgb3JcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIGNoYW5jZSBzbyB3ZSBjYW4gc2tpcCB0aGUgZXhwZW5zaXZlIGNhbGwgdG9cbiAgICAgICAgICAgIC8vIGZpbmRGaXJzdFN1c3BlbmRlZC5cbiAgICAgICAgICAgIHZhciBjYW5ub3RCZVN1c3BlbmRlZCA9IHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpICYmIChjdXJyZW50ID09PSBudWxsIHx8IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MkMSk7XG5cbiAgICAgICAgICAgIGlmICghY2Fubm90QmVTdXNwZW5kZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHJvdyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIElmIHRoaXMgaXMgYSBuZXdseSBzdXNwZW5kZWQgdHJlZSwgaXQgbWlnaHQgbm90IGdldCBjb21taXR0ZWQgYXNcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIHNlY29uZCBwYXNzLiBJbiB0aGF0IGNhc2Ugbm90aGluZyB3aWxsIHN1YnNjcmliZSB0b1xuICAgICAgICAgICAgICAgICAgLy8gaXRzIHRoZW5hYmxlcy4gSW5zdGVhZCwgd2UnbGwgdHJhbnNmZXIgaXRzIHRoZW5hYmxlcyB0byB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIFN1c3BlbnNlTGlzdCBzbyB0aGF0IGl0IGNhbiByZXRyeSBpZiB0aGV5IHJlc29sdmUuXG4gICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSBvZiB0aGVzZSBpbiB0aGUgbGlzdCBidXQgc2luY2Ugd2UncmVcbiAgICAgICAgICAgICAgICAgIC8vIGdvaW5nIHRvIHdhaXQgZm9yIGFsbCBvZiB0aGVtIGFueXdheSwgaXQgZG9lc24ndCByZWFsbHkgbWF0dGVyXG4gICAgICAgICAgICAgICAgICAvLyB3aGljaCBvbmVzIGdldHMgdG8gcGluZy4gSW4gdGhlb3J5IHdlIGNvdWxkIGdldCBjbGV2ZXIgYW5kIGtlZXBcbiAgICAgICAgICAgICAgICAgIC8vIHRyYWNrIG9mIGhvdyBtYW55IGRlcGVuZGVuY2llcyByZW1haW4gYnV0IGl0IGdldHMgdHJpY2t5IGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBtZWFudGltZSwgd2UgY2FuIGFkZC9yZW1vdmUvY2hhbmdlIGl0ZW1zIGFuZCBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAgICAgICAvLyBXZSBtaWdodCBiYWlsIG91dCBvZiB0aGUgbG9vcCBiZWZvcmUgZmluZGluZyBhbnkgYnV0IHRoYXRcbiAgICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbWF0dGVyIHNpbmNlIHRoYXQgbWVhbnMgdGhhdCB0aGUgb3RoZXIgYm91bmRhcmllcyB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyB3ZSBkaWQgZmluZCBhbHJlYWR5IGhhcyB0aGVpciBsaXN0ZW5lcnMgYXR0YWNoZWQuXG5cbiAgICAgICAgICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZSA9IHN1c3BlbmRlZC51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gX3JldHJ5UXVldWU7XG4gICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBfcmV0cnlRdWV1ZSk7IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJlZm9yZSBkb2luZyB0aGUgc2Vjb25kIHBhc3Mgc2luY2UgdGhhdCdzIG5vdyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncyQxO1xuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIExpc3QgQ29udGV4dCB0byBmb3JjZSBzdXNwZW5zZSBhbmRcbiAgICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlcmVuZGVyIHRoZSBjaGlsZHJlbi5cblxuICAgICAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlTGlzdENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSk7IC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsICYmIG5vdyQxKCkgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGJ1dCB3ZSBzdGlsbCBoYXZlIHJvd3NcbiAgICAgICAgICAgICAgLy8gbGVmdCBpbiB0aGUgdGFpbC4gV2UnbGwganVzdCBnaXZlIHVwIGZ1cnRoZXIgYXR0ZW1wdHMgdG8gcmVuZGVyXG4gICAgICAgICAgICAgIC8vIHRoZSBtYWluIGNvbnRlbnQgYW5kIG9ubHkgcmVuZGVyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGUgdGFpbC5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVuZGVyZWQgcm93IHRvIHRoZSBjaGlsZCBsaXN0LlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHZhciBfc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJlbmRlcmVkVGFpbCk7XG5cbiAgICAgICAgICAgIGlmIChfc3VzcGVuZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTsgLy8gRW5zdXJlIHdlIHRyYW5zZmVyIHRoZSB1cGRhdGUgcXVldWUgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gZ2V0IGxvc3QgaWYgdGhpcyByb3cgZW5kcyB1cCBkcm9wcGVkIGR1cmluZyBhIHNlY29uZCBwYXNzLlxuXG4gICAgICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZTIgPSBfc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IF9yZXRyeVF1ZXVlMjtcbiAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgX3JldHJ5UXVldWUyKTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCB0cnVlKTsgLy8gVGhpcyBtaWdodCBoYXZlIGJlZW4gbW9kaWZpZWQuXG5cbiAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgPT09IG51bGwgJiYgcmVuZGVyU3RhdGUudGFpbE1vZGUgPT09ICdoaWRkZW4nICYmICFyZW5kZXJlZFRhaWwuYWx0ZXJuYXRlICYmICFnZXRJc0h5ZHJhdGluZygpIC8vIFdlIGRvbid0IGN1dCBpdCBpZiB3ZSdyZSBoeWRyYXRpbmcuXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZS5cbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggLy8gVGhlIHRpbWUgaXQgdG9vayB0byByZW5kZXIgbGFzdCByb3cgaXMgZ3JlYXRlciB0aGFuIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAgIC8vIHRpbWUgd2UgaGF2ZSB0byByZW5kZXIuIFNvIHJlbmRlcmluZyBvbmUgbW9yZSByb3cgd291bGQgbGlrZWx5XG4gICAgICAgICAgICAvLyBleGNlZWQgaXQuXG4gICAgICAgICAgICBub3ckMSgpICogMiAtIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSAmJiByZW5kZXJMYW5lcyAhPT0gT2Zmc2NyZWVuTGFuZSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIG5vdyBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBhbmQgd2UnbGwganVzdCBnaXZlIHVwIGZ1cnRoZXJcbiAgICAgICAgICAgICAgLy8gYXR0ZW1wdHMgdG8gcmVuZGVyIHRoZSBtYWluIGNvbnRlbnQgYW5kIG9ubHkgcmVuZGVyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgICAgLy8gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCB0aGlzIGlzIHVzdWFsbHkgZmFzdGVyLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcykge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdCBsaXN0IG9mIHRoZSBiYWNrd2FyZHMgdGFpbCB3aWxsIGhhdmUgYmVlbiBhZGRlZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGVuZC4gVGhpcyBicmVha3MgdGhlIGd1YXJhbnRlZSB0aGF0IGxpZmUtY3ljbGVzIGZpcmUgaW5cbiAgICAgICAgICAgIC8vIHNpYmxpbmcgb3JkZXIgYnV0IHRoYXQgaXNuJ3QgYSBzdHJvbmcgZ3VhcmFudGVlIHByb21pc2VkIGJ5IFJlYWN0LlxuICAgICAgICAgICAgLy8gRXNwZWNpYWxseSBzaW5jZSB0aGVzZSBtaWdodCBhbHNvIGp1c3QgcG9wIGluIGR1cmluZyBmdXR1cmUgY29tbWl0cy5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuICAgICAgICAgICAgcmVuZGVyZWRUYWlsLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gcmVuZGVyU3RhdGUubGFzdDtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcuc2libGluZyA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0ID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2Ugc3RpbGwgaGF2ZSB0YWlsIHJvd3MgdG8gcmVuZGVyLlxuICAgICAgICAgIC8vIFBvcCBhIHJvdy5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbmV4dDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbmV4dC5zaWJsaW5nO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdyQxKCk7XG4gICAgICAgICAgbmV4dC5zaWJsaW5nID0gbnVsbDsgLy8gUmVzdG9yZSB0aGUgY29udGV4dC5cbiAgICAgICAgICAvLyBUT0RPOiBXZSBjYW4gcHJvYmFibHkganVzdCBhdm9pZCBwb3BwaW5nIGl0IGluc3RlYWQgYW5kIG9ubHlcbiAgICAgICAgICAvLyBzZXR0aW5nIGl0IHRoZSBmaXJzdCB0aW1lIHdlIGdvIGZyb20gbm90IHN1c3BlbmRlZCB0byBzdXNwZW5kZWQuXG5cbiAgICAgICAgICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuXG4gICAgICAgICAgaWYgKGRpZFN1c3BlbmRBbHJlYWR5KSB7XG4gICAgICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZUNvbnRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHB1c2hTdXNwZW5zZUxpc3RDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpOyAvLyBEbyBhIHBhc3Mgb3ZlciB0aGUgbmV4dCByb3cuXG4gICAgICAgICAgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgX25leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBuZXh0SXNIaWRkZW4gPSBfbmV4dFN0YXRlICE9PSBudWxsOyAvLyBTY2hlZHVsZSBhIFZpc2liaWxpdHkgZWZmZWN0IGlmIHRoZSB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkXG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3ByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBwcmV2SXNIaWRkZW4gPSBfcHJldlN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgICBpZiAocHJldklzSGlkZGVuICE9PSBuZXh0SXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT24gaW5pdGlhbCBtb3VudCwgd2Ugb25seSBuZWVkIGEgVmlzaWJpbGl0eSBlZmZlY3QgaWYgdGhlIHRyZWVcbiAgICAgICAgICAgIC8vIGlzIGhpZGRlbi5cbiAgICAgICAgICAgIGlmIChuZXh0SXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5leHRJc0hpZGRlbiB8fCAhZGlzYWJsZUxlZ2FjeU1vZGUgKSB7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgZm9yIGhpZGRlbiBjaGlsZHJlbiB1bmxlc3Mgd2UncmUgcmVuZGVyaW5nXG4gICAgICAgICAgLy8gYXQgb2Zmc2NyZWVuIHByaW9yaXR5LlxuICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSAmJiAvLyBBbHNvIGRvbid0IGJ1YmJsZSBpZiB0aGUgdHJlZSBzdXNwZW5kZWRcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9MYW5lcykge1xuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7IC8vIENoZWNrIGlmIHRoZXJlIHdhcyBhbiBpbnNlcnRpb24gb3IgdXBkYXRlIGluIHRoZSBoaWRkZW4gc3VidHJlZS5cbiAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBuZWVkIHRvIGhpZGUgdGhvc2Ugbm9kZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSwgc29cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgdmlzaWJpbGl0eSBlZmZlY3QuXG5cbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgJiAoUGxhY2VtZW50IHwgVXBkYXRlKSkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzY3JlZW5RdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5RdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZTMgPSBvZmZzY3JlZW5RdWV1ZS5yZXRyeVF1ZXVlO1xuICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIF9yZXRyeVF1ZXVlMyk7XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wcmV2aW91c0NhY2hlMiA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX3ByZXZpb3VzQ2FjaGUyID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfY2FjaGUyID0gbnVsbDtcblxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfY2FjaGUyID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NhY2hlMiAhPT0gX3ByZXZpb3VzQ2FjaGUyKSB7XG4gICAgICAgICAgICAvLyBSdW4gcGFzc2l2ZSBlZmZlY3RzIHRvIHJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBhc3NpdmUkMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwb3BUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wcmV2aW91c0NhY2hlMyA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX3ByZXZpb3VzQ2FjaGUzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfY2FjaGUzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcblxuICAgICAgICAgIGlmIChfY2FjaGUzICE9PSBfcHJldmlvdXNDYWNoZTMpIHtcbiAgICAgICAgICAgIC8vIFJ1biBwYXNzaXZlIGVmZmVjdHMgdG8gcmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG5mdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cbiAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICB2YXIgZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoZmxhZ3MgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBmbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcblxuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG5cbiAgICAgICAge1xuICAgICAgICAgIHBvcENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgX2ZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKChfZmxhZ3MgJiBTaG91bGRDYXB0dXJlKSAhPT0gTm9GbGFncyQxICYmIChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgLy8gVGhlcmUgd2FzIGFuIGVycm9yIGR1cmluZyByZW5kZXIgdGhhdCB3YXNuJ3QgY2FwdHVyZWQgYnkgYSBzdXNwZW5zZVxuICAgICAgICAgIC8vIGJvdW5kYXJ5LiBEbyBhIHNlY29uZCBwYXNzIG9uIHRoZSByb290IHRvIHVubW91bnQgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gX2ZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfSAvLyBXZSB1bndvdW5kIHRvIHRoZSByb290IHdpdGhvdXQgY29tcGxldGluZyBpdC4gRXhpdC5cblxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IHBvcEh5ZHJhdGlvblN0YXRlXG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaHJldyBpbiBuZXdseSBtb3VudGVkIGRlaHlkcmF0ZWQgY29tcG9uZW50LiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiAnICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2ZsYWdzMiA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChfZmxhZ3MyICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gX2ZsYWdzMiAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTsgLy8gQ2FwdHVyZWQgYSBzdXNwZW5zZSBlZmZlY3QuIFJlLXJlbmRlciB0aGUgYm91bmRhcnkuXG5cbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VMaXN0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7IC8vIFN1c3BlbnNlTGlzdCBkb2Vzbid0IGFjdHVhbGx5IGNhdGNoIGFueXRoaW5nLiBJdCBzaG91bGQndmUgYmVlblxuICAgICAgICAvLyBjYXVnaHQgYnkgYSBuZXN0ZWQgYm91bmRhcnkuIElmIG5vdCwgaXQgc2hvdWxkIGJ1YmJsZSB0aHJvdWdoLlxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgIHtcbiAgICAgICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB9XG5cbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgdmFyIF9mbGFnczMgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczMgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrLCByZW5kZXJMYW5lcykge1xuICAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cbiAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcblxuICBzd2l0Y2ggKGludGVycnVwdGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcblxuICAgICAgICB7XG4gICAgICAgICAgcG9wQ2FjaGVQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICB9XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICBwb3BTdXNwZW5zZUxpc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgIHtcbiAgICAgICAgY29udGV4dCA9IGludGVycnVwdGVkV29yay50eXBlO1xuICAgICAgfVxuXG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgcG9wSGlkZGVuQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgcG9wVHJhbnNpdGlvbihpbnRlcnJ1cHRlZFdvcmssIGN1cnJlbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BDYWNoZVByb3ZpZGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG5cbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59IC8vIFVzZWQgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgdG8gdHJhY2sgdGhlIHN0YXRlIG9mIHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHN0YWNrLlxuLy8gQWxsb3dzIHVzIHRvIGF2b2lkIHRyYXZlcnNpbmcgdGhlIHJldHVybiBwYXRoIHRvIGZpbmQgdGhlIG5lYXJlc3QgT2Zmc2NyZWVuIGFuY2VzdG9yLlxuXG5cbnZhciBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBmYWxzZTtcbnZhciBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gZmFsc2U7IC8vIFVzZWQgdG8gdHJhY2sgaWYgYSBmb3JtIG5lZWRzIHRvIGJlIHJlc2V0IGF0IHRoZSBlbmQgb2YgdGhlIG11dGF0aW9uIHBoYXNlLlxuXG52YXIgbmVlZHNGb3JtUmVzZXQgPSBmYWxzZTtcbnZhciBQb3NzaWJseVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtTZXQgOiBTZXQ7XG52YXIgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFVzZWQgZm9yIFByb2ZpbGluZyBidWlsZHMgdG8gdHJhY2sgdXBkYXRlcnMuXG5cbnZhciBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xudmFyIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcblxuZnVuY3Rpb24gc2hvdWxkUHJvZmlsZShjdXJyZW50KSB7XG4gIHJldHVybiAoY3VycmVudC5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUgJiYgKGdldEV4ZWN1dGlvbkNvbnRleHQoKSAmIENvbW1pdENvbnRleHQpICE9PSBOb0NvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lcihjdXJyZW50LCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5wcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKGN1cnJlbnQudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzKTtcbiAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpIHtcbiAgICB0cnkge1xuICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gIH1cbn0gLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpIHtcbiAgdHJ5IHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIoY3VycmVudCwgaW5zdGFuY2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufSAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlBdHRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB0cnkge1xuICAgIGNvbW1pdEF0dGFjaFJlZihjdXJyZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICB2YXIgcmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWZDbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICByZWZDbGVhbnVwKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZDbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIGByZWZDbGVhbnVwYCBoYXMgYmVlbiBjYWxsZWQuIE51bGxpZnkgYWxsIHJlZmVyZW5jZXMgdG8gaXQgdG8gcHJldmVudCBkb3VibGUgaW52b2NhdGlvbi5cbiAgICAgICAgY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbDtcbiAgICAgICAgdmFyIGZpbmlzaGVkV29yayA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgIGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgcmVmKG51bGwpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gdW5hYmxlIHRvIG5hcnJvdyB0eXBlIHRvIFJlZk9iamVjdFxuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsRGVzdHJveShjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KSB7XG4gIHRyeSB7XG4gICAgZGVzdHJveSgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxudmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQpIHtcbiAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcbiAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCk7IC8vIFdlIG5vIGxvbmdlciBuZWVkIHRvIHRyYWNrIHRoZSBhY3RpdmUgaW5zdGFuY2UgZmliZXJcblxuICB2YXIgc2hvdWxkRmlyZSA9IHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG4gIHJldHVybiBzaG91bGRGaXJlO1xufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfYmVnaW4oKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDsgLy8gVGhpcyBwaGFzZSBpcyBvbmx5IHVzZWQgZm9yIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ci5cblxuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKChmaWJlci5zdWJ0cmVlRmxhZ3MgJiBCZWZvcmVNdXRhdGlvbk1hc2spICE9PSBOb0ZsYWdzJDEgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnJldHVybiA9IGZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIsIGZpYmVyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKCFmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgJiYgISgncmVmJyBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc25hcHNob3QgPSBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShyZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSwgcHJldlByb3BzKSwgcHJldlN0YXRlKTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZGlkV2FyblNldCA9IGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuXG4gICAgICAgICAgICAgIGlmIChzbmFwc2hvdCA9PT0gdW5kZWZpbmVkICYmICFkaWRXYXJuU2V0LmhhcyhmaW5pc2hlZFdvcmsudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBkaWRXYXJuU2V0LmFkZChmaW5pc2hlZFdvcmsudHlwZSk7XG5cbiAgICAgICAgICAgICAgICBlcnJvcignJXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKTogQSBzbmFwc2hvdCB2YWx1ZSAob3IgbnVsbCkgJyArICdtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAoKGZsYWdzICYgU25hcHNob3QpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoZmxhZ3MsIGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiBmbGFncykgPT09IGZsYWdzKSB7XG4gICAgICAgIC8vIFVubW91bnRcbiAgICAgICAgdmFyIGluc3QgPSBlZmZlY3QuaW5zdDtcbiAgICAgICAgdmFyIGRlc3Ryb3kgPSBpbnN0LmRlc3Ryb3k7XG5cbiAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluc3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoZmxhZ3MsIGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiBmbGFncykgPT09IGZsYWdzKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE1vdW50XG5cblxuICAgICAgICB2YXIgY3JlYXRlID0gZWZmZWN0LmNyZWF0ZTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdCh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5zdCA9IGVmZmVjdC5pbnN0O1xuICAgICAgICB2YXIgZGVzdHJveSA9IGNyZWF0ZSgpO1xuICAgICAgICBpbnN0LmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgaG9va05hbWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICgoZWZmZWN0LnRhZyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZWZmZWN0LnRhZyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlRWZmZWN0JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVzdHJveSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gJyArICd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICdcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSAnICsgaG9va05hbWUgKyAnKGFzeW5jICgpID0+IC4uLikgb3IgcmV0dXJuZWQgYSBQcm9taXNlLiAnICsgJ0luc3RlYWQsIHdyaXRlIHRoZSBhc3luYyBmdW5jdGlvbiBpbnNpZGUgeW91ciBlZmZlY3QgJyArICdhbmQgY2FsbCBpdCBpbW1lZGlhdGVseTpcXG5cXG4nICsgaG9va05hbWUgKyAnKCgpID0+IHtcXG4nICsgJyAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbicgKyAnICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbicgKyAnICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbicgKyAnICAgIC8vIC4uLlxcbicgKyAnICB9XFxuJyArICcgIGZldGNoRGF0YSgpO1xcbicgKyBcIn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcblwiICsgJ0xlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0LmRldi9saW5rL2hvb2tzLWRhdGEtZmV0Y2hpbmcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkZW5kdW0gPSAnIFlvdSByZXR1cm5lZDogJyArIGRlc3Ryb3k7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yKCclcyBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCAnICsgJ3doaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzJywgaG9va05hbWUsIGFkZGVuZHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZUVmZmVjdER1cmF0aW9ucyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuICBpZiAoZ2V0RXhlY3V0aW9uQ29udGV4dCgpICYgQ29tbWl0Q29udGV4dCkge1xuICAgIC8vIE9ubHkgUHJvZmlsZXJzIHdpdGggd29yayBpbiB0aGVpciBzdWJ0cmVlIHdpbGwgaGF2ZSBhbiBVcGRhdGUgZWZmZWN0IHNjaGVkdWxlZC5cbiAgICBpZiAoKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgIGlkID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLmlkLFxuICAgICAgICAgICAgICAgIG9uUG9zdENvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5vblBvc3RDb21taXQ7IC8vIFRoaXMgdmFsdWUgd2lsbCBzdGlsbCByZWZsZWN0IHRoZSBwcmV2aW91cyBjb21taXQgcGhhc2UuXG4gICAgICAgICAgICAvLyBJdCBkb2VzIG5vdCBnZXQgcmVzZXQgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGNvbW1pdCBwaGFzZS5cblxuICAgICAgICAgICAgdmFyIGNvbW1pdFRpbWUgPSBnZXRDb21taXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgcGhhc2UgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHBoYXNlID0gJ25lc3RlZC11cGRhdGUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Qb3N0Q29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG9uUG9zdENvbW1pdChpZCwgcGhhc2UsIHBhc3NpdmVFZmZlY3REdXJhdGlvbiwgY29tbWl0VGltZSk7XG4gICAgICAgICAgICB9IC8vIEJ1YmJsZSB0aW1lcyB0byB0aGUgbmV4dCBuZWFyZXN0IGFuY2VzdG9yIFByb2ZpbGVyLlxuICAgICAgICAgICAgLy8gQWZ0ZXIgd2UgcHJvY2VzcyB0aGF0IFByb2ZpbGVyLCB3ZSdsbCBidWJibGUgZnVydGhlciB1cC5cblxuXG4gICAgICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBmaW5pc2hlZFdvcmsucmV0dXJuO1xuXG4gICAgICAgICAgICBvdXRlcjogd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgcm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gcGFzc2l2ZUVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIHBhcmVudFN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gcGFzc2l2ZUVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICAvLyBBdCB0aGlzIHBvaW50IGxheW91dCBlZmZlY3RzIGhhdmUgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCAoZHVyaW5nIG11dGF0aW9uIHBoYXNlKS5cbiAgLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG4gIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICB0cnkge1xuICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cblxuICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Q2xhc3NMYXlvdXRMaWZlY3ljbGVzKGZpbmlzaGVkV29yaywgY3VycmVudCkge1xuICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbiAgICB7XG4gICAgICBpZiAoIWZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyAmJiAhKCdyZWYnIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZE1vdW50LiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzKTtcbiAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAge1xuICAgICAgaWYgKCFmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgJiYgISgncmVmJyBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgaWYgKCFmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgJiYgISgncmVmJyBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9zdENvbXBvbmVudE1vdW50KGZpbmlzaGVkV29yaykge1xuICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICB0cnkge1xuICAgIGNvbW1pdE1vdW50KGluc3RhbmNlLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQcm9maWxlclVwZGF0ZShmaW5pc2hlZFdvcmssIGN1cnJlbnQpIHtcbiAgaWYgKGdldEV4ZWN1dGlvbkNvbnRleHQoKSAmIENvbW1pdENvbnRleHQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICBvbkNvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Db21taXQsXG4gICAgICAgICAgb25SZW5kZXIgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uUmVuZGVyO1xuICAgICAgdmFyIGVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbjtcbiAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuICAgICAgdmFyIHBoYXNlID0gY3VycmVudCA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJztcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyTmVzdGVkVXBkYXRlUGhhc2UpIHtcbiAgICAgICAgaWYgKGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpKSB7XG4gICAgICAgICAgcGhhc2UgPSAnbmVzdGVkLXVwZGF0ZSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvblJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgcGhhc2UsIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbiwgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsIGNvbW1pdFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcykge1xuICAgICAgICBpZiAodHlwZW9mIG9uQ29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25Db21taXQoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBlZmZlY3REdXJhdGlvbiwgY29tbWl0VGltZSk7XG4gICAgICAgIH0gLy8gU2NoZWR1bGUgYSBwYXNzaXZlIGVmZmVjdCBmb3IgdGhpcyBQcm9maWxlciB0byBjYWxsIG9uUG9zdENvbW1pdCBob29rcy5cbiAgICAgICAgLy8gVGhpcyBlZmZlY3Qgc2hvdWxkIGJlIHNjaGVkdWxlZCBldmVuIGlmIHRoZXJlIGlzIG5vIG9uUG9zdENvbW1pdCBjYWxsYmFjayBmb3IgdGhpcyBQcm9maWxlcixcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgZWZmZWN0IGlzIGFsc28gd2hlcmUgdGltZXMgYnViYmxlIHRvIHBhcmVudCBQcm9maWxlcnMuXG5cblxuICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaW5pc2hlZFdvcmspOyAvLyBQcm9wYWdhdGUgbGF5b3V0IGVmZmVjdCBkdXJhdGlvbnMgdG8gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3Rvci5cbiAgICAgICAgLy8gRG8gbm90IHJlc2V0IHRoZXNlIHZhbHVlcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgc28gRGV2VG9vbHMgaGFzIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSBmaXJzdC5cblxuICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBmaW5pc2hlZFdvcmsucmV0dXJuO1xuXG4gICAgICAgIG91dGVyOiB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG4gICAgICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICAvLyBXaGVuIHVwZGF0aW5nIHRoaXMgZnVuY3Rpb24sIGFsc28gdXBkYXRlIHJlYXBwZWFyTGF5b3V0RWZmZWN0cywgd2hpY2ggZG9lc1xuICAvLyBtb3N0IG9mIHRoZSBzYW1lIHRoaW5ncyB3aGVuIGFuIG9mZnNjcmVlbiB0cmVlIGdvZXMgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZS5cbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCB8IEhhc0VmZmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcyk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0Q2xhc3NMYXlvdXRMaWZlY3ljbGVzKGZpbmlzaGVkV29yaywgY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBDYWxsYmFjaykge1xuICAgICAgICAgIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBDYWxsYmFjaykge1xuICAgICAgICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpO1xuXG4gICAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKTsgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRIb3N0Q29tcG9uZW50TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpOyAvLyBUT0RPOiBTaG91bGQgdGhpcyBmaXJlIGluc2lkZSBhbiBvZmZzY3JlZW4gdHJlZT8gT3Igc2hvdWxkIGl0IHdhaXQgdG9cbiAgICAgICAgLy8gZmlyZSB3aGVuIHRoZSB0cmVlIGJlY29tZXMgdmlzaWJsZSBhZ2Fpbi5cblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRQcm9maWxlclVwZGF0ZShmaW5pc2hlZFdvcmssIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpc01vZGVyblJvb3QgPSBkaXNhYmxlTGVnYWN5TW9kZSA7XG5cbiAgICAgICAgaWYgKGlzTW9kZXJuUm9vdCkge1xuICAgICAgICAgIHZhciBpc0hpZGRlbiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIHZhciBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBpc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG5cbiAgICAgICAgICBpZiAobmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuKSA7IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIE9mZnNjcmVlbiB0cmVlIGlzIHZpc2libGUuXG4gICAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgICB2YXIgbmV3T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHdhc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gbmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG5cbiAgICAgICAgICAgIGlmIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuICYmICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByb290IG9mIGEgcmVhcHBlYXJpbmcgYm91bmRhcnkuIEFzIHdlIGNvbnRpbnVlXG4gICAgICAgICAgICAgIC8vIHRyYXZlcnNpbmcgdGhlIGxheW91dCBlZmZlY3RzLCB3ZSBtdXN0IGFsc28gcmUtbW91bnQgbGF5b3V0XG4gICAgICAgICAgICAgIC8vIGVmZmVjdHMgdGhhdCB3ZXJlIHVubW91bnRlZCB3aGVuIHRoZSBPZmZzY3JlZW4gc3VidHJlZSB3YXNcbiAgICAgICAgICAgICAgLy8gaGlkZGVuLiBTbyB0aGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIG5vcm1hbCBjb21taXRMYXlvdXRFZmZlY3RzLlxuICAgICAgICAgICAgICB2YXIgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MkMTtcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG5cbiAgICAgICAgICBpZiAocHJvcHMubW9kZSA9PT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pIHtcbiAgLy8gT25seSBoaWRlIG9yIHVuaGlkZSB0aGUgdG9wLW1vc3QgaG9zdCBub2Rlcy5cbiAgdmFyIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG5cbiAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCAoc3VwcG9ydHNSZXNvdXJjZXMgPyBub2RlLnRhZyA9PT0gSG9zdEhvaXN0YWJsZSA6IGZhbHNlKSB8fCAoc3VwcG9ydHNTaW5nbGV0b25zID8gbm9kZS50YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIHtcbiAgICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG5vZGU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5oaWRlSW5zdGFuY2Uobm9kZS5zdGF0ZU5vZGUsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG5vZGUpIHtcbiAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBub2RlKSB7XG4gICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgdmFyIGluc3RhbmNlVG9Vc2U7XG5cbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9IC8vIE1vdmVkIG91dHNpZGUgdG8gZW5zdXJlIERDRSB3b3JrcyB3aXRoIHRoaXMgZmxhZ1xuXG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIG1vdmUgdGhlc2Ugd2FybmluZ3MgdG8gaGFwcGVuIGR1cmluZyB0aGUgcmVuZGVyXG4gICAgICAgIC8vIHBoYXNlIChtYXJrUmVmKS5cbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3IoJ1N0cmluZyByZWZzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkLicpO1xuICAgICAgICB9IGVsc2UgaWYgKCFyZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSB1bmFibGUgdG8gbmFycm93IHR5cGUgdG8gdGhlIG5vbi1mdW5jdGlvbiBjYXNlXG5cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hGaWJlck11dGF0aW9uKGZpYmVyKSB7XG4gIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVyIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIGRldGVjdCBhbmQgd2FybiBhZ2FpbnN0IHN0YXRlIHVwZGF0ZXMgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cbiAgLy8gSXQgYWxzbyBwcmV2ZW50cyBldmVudHMgZnJvbSBidWJibGluZyBmcm9tIHdpdGhpbiBkaXNjb25uZWN0ZWQgY29tcG9uZW50cy5cbiAgLy9cbiAgLy8gSWRlYWxseSwgd2Ugc2hvdWxkIGFsc28gY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC5cbiAgLy8gVGhpcyBjaGlsZCBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAvL1xuICAvLyBOb3RlIHRoYXQgd2UgY2FuJ3QgY2xlYXIgY2hpbGQgb3Igc2libGluZyBwb2ludGVycyB5ZXQuXG4gIC8vIFRoZXkncmUgbmVlZGVkIGZvciBwYXNzaXZlIGVmZmVjdHMgYW5kIGZvciBmaW5kRE9NTm9kZS5cbiAgLy8gV2UgZGVmZXIgdGhvc2UgZmllbGRzLCBhbmQgYWxsIG90aGVyIGNsZWFudXAsIHRvIHRoZSBwYXNzaXZlIHBoYXNlIChzZWUgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMpLlxuICAvL1xuICAvLyBEb24ndCByZXNldCB0aGUgYWx0ZXJuYXRlIHlldCwgZWl0aGVyLiBXZSBuZWVkIHRoYXQgc28gd2UgY2FuIGRldGFjaCB0aGVcbiAgLy8gYWx0ZXJuYXRlJ3MgZmllbGRzIGluIHRoZSBwYXNzaXZlIHBoYXNlLiBDbGVhcmluZyB0aGUgcmV0dXJuIHBvaW50ZXIgaXNcbiAgLy8gc3VmZmljaWVudCBmb3IgZmluZERPTU5vZGUgc2VtYW50aWNzLlxuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUucmV0dXJuID0gbnVsbDtcbiAgfVxuXG4gIGZpYmVyLnJldHVybiA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGZpYmVyLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoYWx0ZXJuYXRlKTtcbiAgfSAvLyBDbGVhciBjeWNsaWNhbCBGaWJlciBmaWVsZHMuIFRoaXMgbGV2ZWwgYWxvbmUgaXMgZGVzaWduZWQgdG8gcm91Z2hseVxuICAvLyBhcHByb3hpbWF0ZSB0aGUgcGxhbm5lZCBGaWJlciByZWZhY3Rvci4gSW4gdGhhdCB3b3JsZCwgYHNldFN0YXRlYCB3aWxsIGJlXG4gIC8vIGJvdW5kIHRvIGEgc3BlY2lhbCBcImluc3RhbmNlXCIgb2JqZWN0IGluc3RlYWQgb2YgYSBGaWJlci4gVGhlIEluc3RhbmNlXG4gIC8vIG9iamVjdCB3aWxsIG5vdCBoYXZlIGFueSBvZiB0aGVzZSBmaWVsZHMuIEl0IHdpbGwgb25seSBiZSBjb25uZWN0ZWQgdG9cbiAgLy8gdGhlIGZpYmVyIHRyZWUgdmlhIGEgc2luZ2xlIGxpbmsgYXQgdGhlIHJvb3QuIFNvIGlmIHRoaXMgbGV2ZWwgYWxvbmUgaXNcbiAgLy8gc3VmZmljaWVudCB0byBmaXggbWVtb3J5IGlzc3VlcywgdGhhdCBib2RlcyB3ZWxsIGZvciBvdXIgcGxhbnMuXG5cblxuICBmaWJlci5jaGlsZCA9IG51bGw7XG4gIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gIGZpYmVyLnNpYmxpbmcgPSBudWxsOyAvLyBUaGUgYHN0YXRlTm9kZWAgaXMgY3ljbGljYWwgYmVjYXVzZSBvbiBob3N0IG5vZGVzIGl0IHBvaW50cyB0byB0aGUgaG9zdFxuICAvLyB0cmVlLCB3aGljaCBoYXMgaXRzIG93biBwb2ludGVycyB0byBjaGlsZHJlbiwgcGFyZW50cywgYW5kIHNpYmxpbmdzLlxuICAvLyBUaGUgb3RoZXIgaG9zdCBub2RlcyBhbHNvIHBvaW50IGJhY2sgdG8gZmliZXJzLCBzbyB3ZSBzaG91bGQgZGV0YWNoIHRoYXRcbiAgLy8gb25lLCB0b28uXG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoaG9zdEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2UoaG9zdEluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gIH0gLy8gVGhlb3JldGljYWxseSwgbm90aGluZyBpbiBoZXJlIHNob3VsZCBiZSBuZWNlc3NhcnksIGJlY2F1c2Ugd2UgYWxyZWFkeVxuICAvLyBkaXNjb25uZWN0ZWQgdGhlIGZpYmVyIGZyb20gdGhlIHRyZWUuIFNvIGV2ZW4gaWYgc29tZXRoaW5nIGxlYWtzIHRoaXNcbiAgLy8gcGFydGljdWxhciBmaWJlciwgaXQgd29uJ3QgbGVhayBhbnl0aGluZyBlbHNlLlxuXG5cbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbiAgZmliZXIuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsOyAvLyBUT0RPOiBNb3ZlIHRvIGBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcmAgaW5zdGVhZC5cblxuICBmaWJlci51cGRhdGVRdWV1ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpIHtcbiAgaWYgKCFzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBvcnRhbCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuICB2YXIgZW1wdHlDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KCk7XG4gIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBlbXB0eUNoaWxkU2V0KTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnICsgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxuZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCAoc3VwcG9ydHNSZXNvdXJjZXMgPyBmaWJlci50YWcgPT09IEhvc3RIb2lzdGFibGUgOiBmYWxzZSkgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyA/IGZpYmVyLnRhZyA9PT0gSG9zdFNpbmdsZXRvbiA6IGZhbHNlKSB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIC8vIFRPRE86IEZpbmQgYSBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpcy5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICBzaWJsaW5nczogd2hpbGUgKHRydWUpIHtcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IGlzSG9zdFBhcmVudChub2RlLnJldHVybikpIHtcbiAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuXG4gICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCAmJiAoIXN1cHBvcnRzU2luZ2xldG9ucyA/IHRydWUgOiBub2RlLnRhZyAhPT0gSG9zdFNpbmdsZXRvbikgJiYgbm9kZS50YWcgIT09IERlaHlkcmF0ZWRGcmFnbWVudCkge1xuICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgaWYgKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG5cblxuICAgICAgaWYgKG5vZGUuY2hpbGQgPT09IG51bGwgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgfVxuICAgIH0gLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cblxuXG4gICAgaWYgKCEobm9kZS5mbGFncyAmIFBsYWNlbWVudCkpIHtcbiAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICBpZiAoZmluaXNoZWRXb3JrLnRhZyA9PT0gSG9zdFNpbmdsZXRvbikge1xuICAgICAgLy8gU2luZ2xldG9ucyBhcmUgYWxyZWFkeSBpbiB0aGUgSG9zdCBhbmQgZG9uJ3QgbmVlZCB0byBiZSBwbGFjZWRcbiAgICAgIC8vIFNpbmNlIHRoZXkgb3BlcmF0ZSBzb21ld2hhdCBsaWtlIFBvcnRhbHMgdGhvdWdoIHRoZWlyIGNoaWxkcmVuIHdpbGxcbiAgICAgIC8vIGhhdmUgUGxhY2VtZW50IGFuZCB3aWxsIGdldCBwbGFjZWQgaW5zaWRlIHRoZW1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gLy8gUmVjdXJzaXZlbHkgaW5zZXJ0IGFsbCBob3N0IG5vZGVzIGludG8gdGhlIHBhcmVudC5cblxuXG4gIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG4gIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cblxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3BhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocGFyZW50RmliZXIuZmxhZ3MgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICAgICAgcmVzZXRUZXh0Q29udGVudChfcGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgICAgICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2JlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7IC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuXG5cbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgX2JlZm9yZSwgX3BhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGFyZW50MiA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBfYmVmb3JlMiA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihmaW5pc2hlZFdvcmssIF9iZWZvcmUyLCBfcGFyZW50Mik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgPyB0YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgdmFyIGlzSG9zdCA9IHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0O1xuXG4gIGlmIChpc0hvc3QpIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgPyB0YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGNoaWxkLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICB2YXIgc2libGluZyA9IGNoaWxkLnNpYmxpbmc7XG5cbiAgICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIFRoZXNlIGFyZSB0cmFja2VkIG9uIHRoZSBzdGFjayBhcyB3ZSByZWN1cnNpdmVseSB0cmF2ZXJzZSBhXG4vLyBkZWxldGVkIHN1YnRyZWUuXG4vLyBUT0RPOiBVcGRhdGUgdGhlc2UgZHVyaW5nIHRoZSB3aG9sZSBtdXRhdGlvbiBwaGFzZSwgbm90IGp1c3QgZHVyaW5nXG4vLyBhIGRlbGV0aW9uLlxuXG5cbnZhciBob3N0UGFyZW50ID0gbnVsbDtcbnZhciBob3N0UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpIHtcbiAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBkZWxldGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGFsbCBob3N0IG5vZGVzIGZyb20gdGhlIHBhcmVudCwgZGV0YWNoIHJlZnMsIGNsZWFuXG4gICAgLy8gdXAgbW91bnRlZCBsYXlvdXQgZWZmZWN0cywgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQuXG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIHJlbW92ZSB0aGUgdG9wbW9zdCBob3N0IGNoaWxkIGluIGVhY2ggYnJhbmNoLiBCdXQgdGhlbiB3ZVxuICAgIC8vIHN0aWxsIG5lZWQgdG8ga2VlcCB0cmF2ZXJzaW5nIHRvIHVubW91bnQgZWZmZWN0cywgcmVmcywgYW5kIGNXVS4gVE9ETzogV2VcbiAgICAvLyBjb3VsZCBzcGxpdCB0aGlzIGludG8gdHdvIHNlcGFyYXRlIHRyYXZlcnNhbHMgZnVuY3Rpb25zLCB3aGVyZSB0aGUgc2Vjb25kXG4gICAgLy8gb25lIGRvZXNuJ3QgaW5jbHVkZSBhbnkgcmVtb3ZlQ2hpbGQgbG9naWMuIFRoaXMgaXMgbWF5YmUgdGhlIHNhbWVcbiAgICAvLyBmdW5jdGlvbiBhcyBcImRpc2FwcGVhckxheW91dEVmZmVjdHNcIiAob3Igd2hhdGV2ZXIgdGhhdCB0dXJucyBpbnRvIGFmdGVyXG4gICAgLy8gdGhlIGxheW91dCBwaGFzZSBpcyByZWZhY3RvcmVkIHRvIHVzZSByZWN1cnNpb24pLlxuICAgIC8vIEJlZm9yZSBzdGFydGluZywgZmluZCB0aGUgbmVhcmVzdCBob3N0IHBhcmVudCBvbiB0aGUgc3RhY2sgc28gd2Uga25vd1xuICAgIC8vIHdoaWNoIGluc3RhbmNlL2NvbnRhaW5lciB0byByZW1vdmUgdGhlIGNoaWxkcmVuIGZyb20uXG4gICAgLy8gVE9ETzogSW5zdGVhZCBvZiBzZWFyY2hpbmcgdXAgdGhlIGZpYmVyIHJldHVybiBwYXRoIG9uIGV2ZXJ5IGRlbGV0aW9uLCB3ZVxuICAgIC8vIGNhbiB0cmFjayB0aGUgbmVhcmVzdCBob3N0IGNvbXBvbmVudCBvbiB0aGUgSlMgc3RhY2sgYXMgd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gdHJlZSBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhpcyB3b3VsZCBtYWtlIGluc2VydGlvbnMgZmFzdGVyLCB0b28uXG4gICAgdmFyIHBhcmVudCA9IHJldHVybkZpYmVyO1xuXG4gICAgZmluZFBhcmVudDogd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhvc3RQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgJyArICdhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKTtcbiAgICBob3N0UGFyZW50ID0gbnVsbDtcbiAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gIH1cblxuICBkZXRhY2hGaWJlck11dGF0aW9uKGRlbGV0ZWRGaWJlcik7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBwYXJlbnQpIHtcbiAgLy8gVE9ETzogVXNlIGEgc3RhdGljIGZsYWcgdG8gc2tpcCB0cmVlcyB0aGF0IGRvbid0IGhhdmUgdW5tb3VudCBlZmZlY3RzXG4gIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgY2hpbGQpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKSB7XG4gIG9uQ29tbWl0VW5tb3VudChkZWxldGVkRmliZXIpOyAvLyBUaGUgY2FzZXMgaW4gdGhpcyBvdXRlciBzd2l0Y2ggbW9kaWZ5IHRoZSBzdGFjayBiZWZvcmUgdGhleSB0cmF2ZXJzZVxuICAvLyBpbnRvIHRoZWlyIHN1YnRyZWUuIFRoZXJlIGFyZSBzaW1wbGVyIGNhc2VzIGluIHRoZSBpbm5lciBzd2l0Y2hcbiAgLy8gdGhhdCBkb24ndCBtb2RpZnkgdGhlIHN0YWNrLlxuXG4gIHN3aXRjaCAoZGVsZXRlZEZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgaWYgKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcblxuICAgICAgICAgIGlmIChkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgcmVsZWFzZVJlc291cmNlKGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpIHtcbiAgICAgICAgICAgIHVubW91bnRIb2lzdGFibGUoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7IC8vIE5vcm1hbGx5IHRoaXMgaXMgY2FsbGVkIGluIHBhc3NpdmUgdW5tb3VudCBlZmZlY3QgcGhhc2UgaG93ZXZlciB3aXRoXG4gICAgICAgICAgLy8gSG9zdFNpbmdsZXRvbiB3ZSB3YXJuIGlmIHlvdSBhY3F1aXJlIG9uZSB0aGF0IGlzIGFscmVhZHkgYXNzb2NpYXRlZCB0b1xuICAgICAgICAgIC8vIGEgZGlmZmVyZW50IGZpYmVyLiBUbyBpbmNyZWFzZSBvdXIgY2hhbmNlcyBvZiBhdm9pZGluZyB0aGlzLCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAvLyBpZiB5b3Uga2V5ZWQgYSBIb3N0U2luZ2xldG9uIHNvIHRoZXJlIHdpbGwgYmUgYSBkZWxldGUgZm9sbG93ZWQgYnkgYSBQbGFjZW1lbnRcbiAgICAgICAgICAvLyB3ZSB0cmVhdCBkZXRhY2ggZWFnZXJseSBoZXJlXG5cbiAgICAgICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9IC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoIHRvIG5leHQgYnJhbmNoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlIG5lYXJlc3QgaG9zdCBjaGlsZC4gU2V0IHRoZSBob3N0IHBhcmVudFxuICAgICAgICAvLyB0byBgbnVsbGAgb24gdGhlIHN0YWNrIHRvIGluZGljYXRlIHRoYXQgbmVzdGVkIGNoaWxkcmVuIGRvbid0XG4gICAgICAgIC8vIG5lZWQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IF9wcmV2SG9zdFBhcmVudDtcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcblxuICAgICAgICAgIGlmIChob3N0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBOb3cgdGhhdCBhbGwgdGhlIGNoaWxkIGVmZmVjdHMgaGF2ZSB1bm1vdW50ZWQsIHdlIGNhbiByZW1vdmUgdGhlXG4gICAgICAgICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG4gICAgICAgICAgICBpZiAoaG9zdFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNoaWxkKGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAge1xuICAgICAgICAvLyBEZWxldGUgdGhlIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgYW5kIGFsbCBvZiBpdHMgY29udGVudC5cblxuXG4gICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgaWYgKGhvc3RQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChob3N0UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcihob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgICAgdmFyIF9wcmV2SG9zdFBhcmVudDIgPSBob3N0UGFyZW50O1xuICAgICAgICAgIHZhciBfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBfcHJldkhvc3RQYXJlbnQyO1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IF9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihkZWxldGVkRmliZXIpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZGVsZXRlZEZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICAgICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gZWZmZWN0LnRhZztcbiAgICAgICAgICAgICAgICB2YXIgaW5zdCA9IGVmZmVjdC5pbnN0O1xuICAgICAgICAgICAgICAgIHZhciBkZXN0cm95ID0gaW5zdC5kZXN0cm95O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHRhZyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChkZWxldGVkRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoZGVsZXRlZEZpYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0LmRlc3Ryb3kgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcbiAgICAgICAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihkZWxldGVkRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGluc3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIElmIHRoaXMgb2Zmc2NyZWVuIGNvbXBvbmVudCBpcyBoaWRkZW4sIHdlIGFscmVhZHkgdW5tb3VudGVkIGl0LiBCZWZvcmVcbiAgICAgICAgICAvLyBkZWxldGluZyB0aGUgY2hpbGRyZW4sIHRyYWNrIHRoYXQgaXQncyBhbHJlYWR5IHVubW91bnRlZCBzbyB0aGF0IHdlXG4gICAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byB1bm1vdW50IHRoZSBlZmZlY3RzIGFnYWluLlxuICAgICAgICAgIC8vIFRPRE86IElmIHRoZSB0cmVlIGlzIGhpZGRlbiwgaW4gbW9zdCBjYXNlcyB3ZSBzaG91bGQgYmUgYWJsZSB0byBza2lwXG4gICAgICAgICAgLy8gb3ZlciB0aGUgbmVzdGVkIGNoaWxkcmVuIGVudGlyZWx5LiBBbiBleGNlcHRpb24gaXMgd2UgaGF2ZW4ndCB5ZXQgZm91bmRcbiAgICAgICAgICAvLyB0aGUgdG9wbW9zdCBob3N0IG5vZGUgdG8gZGVsZXRlLCB3aGljaCB3ZSBhbHJlYWR5IHRyYWNrIG9uIHRoZSBzdGFjay5cbiAgICAgICAgICAvLyBCdXQgdGhlIG90aGVyIGNhc2UgaXMgcG9ydGFscywgd2hpY2ggbmVlZCB0byBiZSBkZXRhY2hlZCBubyBtYXR0ZXIgaG93XG4gICAgICAgICAgLy8gZGVlcGx5IHRoZXkgYXJlIG5lc3RlZC4gV2Ugc2hvdWxkIHVzZSBhIHN1YnRyZWUgZmxhZyB0byB0cmFjayB3aGV0aGVyIGFcbiAgICAgICAgICAvLyBzdWJ0cmVlIGluY2x1ZGVzIGEgbmVzdGVkIHBvcnRhbC5cbiAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fCBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VDYWxsYmFjayhmaW5pc2hlZFdvcmspIHtcbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gcHJldlN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgICAgaWYgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuXG4gICAgICAgICAgICB2YXIgaHlkcmF0aW9uQ2FsbGJhY2tzLCBvbkh5ZHJhdGVkOyBpZiAoZW5hYmxlU3VzcGVuc2VDYWxsYmFjaykgO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspIHtcbiAgLy8gVE9ETzogVW5pZnkgdGhlIGludGVyZmFjZSBmb3IgdGhlIHJldHJ5IGNhY2hlIHNvIHdlIGRvbid0IGhhdmUgdG8gc3dpdGNoXG4gIC8vIG9uIHRoZSB0YWcgbGlrZSB0aGlzLlxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHJldHJ5Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXRyeUNhY2hlO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBfcmV0cnlDYWNoZSA9IGluc3RhbmNlLl9yZXRyeUNhY2hlO1xuXG4gICAgICAgIGlmIChfcmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIF9yZXRyeUNhY2hlID0gaW5zdGFuY2UuX3JldHJ5Q2FjaGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3JldHJ5Q2FjaGU7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFN1c3BlbnNlIGhhbmRsZXIgdGFnIChcIiArIGZpbmlzaGVkV29yay50YWcgKyBcIikuIFRoaXMgaXMgYSBcIiArICdidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoT2Zmc2NyZWVuSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIGZpYmVyID0gaW5zdGFuY2UuX2N1cnJlbnQ7XG5cbiAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIE9mZnNjcmVlbi5kZXRhY2ggYmVmb3JlIGluc3RhbmNlIGhhbmRsZSBoYXMgYmVlbiBzZXQuJyk7XG4gIH1cblxuICBpZiAoKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIE9mZnNjcmVlbkRldGFjaGVkKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgLy8gVGhlIGluc3RhbmNlIGlzIGFscmVhZHkgZGV0YWNoZWQsIHRoaXMgaXMgYSBub29wLlxuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBUaGVyZSBpcyBhbiBvcHBvcnR1bml0eSB0byBvcHRpbWlzZSB0aGlzIGJ5IG5vdCBlbnRlcmluZyBjb21taXQgcGhhc2VcbiAgLy8gYW5kIHVubW91bnRpbmcgZWZmZWN0cyBkaXJlY3RseS5cblxuXG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgfD0gT2Zmc2NyZWVuRGV0YWNoZWQ7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaE9mZnNjcmVlbkluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBmaWJlciA9IGluc3RhbmNlLl9jdXJyZW50O1xuXG4gIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyBPZmZzY3JlZW4uZGV0YWNoIGJlZm9yZSBpbnN0YW5jZSBoYW5kbGUgaGFzIGJlZW4gc2V0LicpO1xuICB9XG5cbiAgaWYgKChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiBPZmZzY3JlZW5EZXRhY2hlZCkgPT09IE5vRmxhZ3MkMSkge1xuICAgIC8vIFRoZSBpbnN0YW5jZSBpcyBhbHJlYWR5IGF0dGFjaGVkLCB0aGlzIGlzIGEgbm9vcC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5EZXRhY2hlZDtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgd2FrZWFibGVzKSB7XG4gIC8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHRoZW4gaXQgd2lsbCBoYXZlIGEgc2V0IG9mIHdha2VhYmxlcy5cbiAgLy8gRm9yIGVhY2ggd2FrZWFibGUsIGF0dGFjaCBhIGxpc3RlbmVyIHNvIHRoYXQgd2hlbiBpdCByZXNvbHZlcywgUmVhY3RcbiAgLy8gYXR0ZW1wdHMgdG8gcmUtcmVuZGVyIHRoZSBib3VuZGFyeSBpbiB0aGUgcHJpbWFyeSAocHJlLXRpbWVvdXQpIHN0YXRlLlxuICB2YXIgcmV0cnlDYWNoZSA9IGdldFJldHJ5Q2FjaGUoZmluaXNoZWRXb3JrKTtcbiAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgLy8gTWVtb2l6ZSB1c2luZyB0aGUgYm91bmRhcnkgZmliZXIgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxuICAgIHZhciByZXRyeSA9IHJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCwgZmluaXNoZWRXb3JrLCB3YWtlYWJsZSk7XG5cbiAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuXG4gICAgICB7XG4gICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAgIGlmIChpblByb2dyZXNzTGFuZXMgIT09IG51bGwgJiYgaW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCBhc3NvY2lhdGUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzIHdpdGggaXQuXG4gICAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKGluUHJvZ3Jlc3NSb290LCBpblByb2dyZXNzTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRXhwZWN0ZWQgZmluaXNoZWQgcm9vdCBhbmQgbGFuZXMgdG8gYmUgc2V0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgfVxuICB9KTtcbn0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG5mdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICBpblByb2dyZXNzTGFuZXMgPSBjb21taXR0ZWRMYW5lcztcbiAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuXG4gIHtcbiAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIsIGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICB9XG5cbiAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyLCBsYW5lcykge1xuICAvLyBEZWxldGlvbnMgZWZmZWN0cyBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlciB0eXBlLiBUaGV5IG5lZWQgdG8gaGFwcGVuXG4gIC8vIGJlZm9yZSB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYWUgZmlyZWQuXG4gIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG5cbiAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGNoaWxkVG9EZWxldGUsIHBhcmVudEZpYmVyLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIE11dGF0aW9uTWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGNoaWxkLCBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyLCBjaGlsZCwgcm9vdCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbnZhciBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IG51bGw7XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290LCBsYW5lcykge1xuICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFnczsgLy8gVGhlIGVmZmVjdCBmbGFnIHNob3VsZCBiZSBjaGVja2VkICphZnRlciogd2UgcmVmaW5lIHRoZSB0eXBlIG9mIGZpYmVyLFxuICAvLyBiZWNhdXNlIHRoZSBmaWJlciB0YWcgaXMgbW9yZSBzcGVjaWZpYy4gQW4gZXhjZXB0aW9uIGlzIGFueSBmbGFnIHJlbGF0ZWRcbiAgLy8gdG8gcmVjb25jaWxpYXRpb24sIGJlY2F1c2UgdGhvc2UgY2FuIGJlIHNldCBvbiBhbGwgZmliZXIgdHlwZXMuXG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChJbnNlcnRpb24gfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KEluc2VydGlvbiB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfSAvLyBMYXlvdXQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGR1cmluZyB0aGUgbXV0YXRpb24gcGhhc2Ugc28gdGhhdCBhbGxcbiAgICAgICAgICAvLyBkZXN0cm95IGZ1bmN0aW9ucyBmb3IgYWxsIGZpYmVycyBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgY3JlYXRlIGZ1bmN0aW9ucy5cbiAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gICAgICAgICAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cblxuXG4gICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBDYWxsYmFjayAmJiBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4pIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmVySGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIC8vIFdlIGNhc3QgYmVjYXVzZSB3ZSBhbHdheXMgc2V0IHRoZSByb290IGF0IHRoZSBSZWFjdCByb290IGFuZCBzbyBpdCBjYW5ub3QgYmVcbiAgICAgICAgICAvLyBudWxsIHdoaWxlIHdlIGFyZSBwcm9jZXNzaW5nIG11dGF0aW9uIGVmZmVjdHNcbiAgICAgICAgICB2YXIgaG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBsYW5lcyk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJlc291cmNlID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgbmV3UmVzb3VyY2UgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gV2UgYXJlIG1vdW50aW5nIGEgbmV3IEhvc3RIb2lzdGFibGUgRmliZXIuIFdlIGZvcmsgdGhlIG1vdW50XG4gICAgICAgICAgICAgIC8vIGJlaGF2aW9yIGJhc2VkIG9uIHdoZXRoZXIgdGhpcyBpbnN0YW5jZSBpcyBhIEhvaXN0YWJsZSBJbnN0YW5jZVxuICAgICAgICAgICAgICAvLyBvciBhIEhvaXN0YWJsZSBSZXNvdXJjZVxuICAgICAgICAgICAgICBpZiAobmV3UmVzb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGh5ZHJhdGVIb2lzdGFibGUoaG9pc3RhYmxlUm9vdCwgZmluaXNoZWRXb3JrLnR5cGUsIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtb3VudEhvaXN0YWJsZShob2lzdGFibGVSb290LCBmaW5pc2hlZFdvcmsudHlwZSwgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBhY3F1aXJlUmVzb3VyY2UoaG9pc3RhYmxlUm9vdCwgbmV3UmVzb3VyY2UsIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVzb3VyY2UgIT09IG5ld1Jlc291cmNlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFyZSBtb3ZpbmcgdG8gb3IgZnJvbSBIb2lzdGFibGUgUmVzb3VyY2UsIG9yIGJldHdlZW4gZGlmZmVyZW50IEhvaXN0YWJsZSBSZXNvdXJjZXNcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZXNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdW5tb3VudEhvaXN0YWJsZShjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VSZXNvdXJjZShjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG5ld1Jlc291cmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbW91bnRIb2lzdGFibGUoaG9pc3RhYmxlUm9vdCwgZmluaXNoZWRXb3JrLnR5cGUsIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjcXVpcmVSZXNvdXJjZShob2lzdGFibGVSb290LCBuZXdSZXNvdXJjZSwgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1Jlc291cmNlID09PSBudWxsICYmIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb21taXRVcGRhdGUoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSwgZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcywgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzV29yayA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1dvcmsgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHNpbmdsZXRvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBUaGlzIHdhcyBhIG5ldyBtb3VudCwgd2UgbmVlZCB0byBjbGVhciBhbmQgc2V0IGluaXRpYWwgcHJvcGVydGllc1xuXG4gICAgICAgICAgICAgIGNsZWFyU2luZ2xldG9uKHNpbmdsZXRvbik7XG4gICAgICAgICAgICAgIGFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZShmaW5pc2hlZFdvcmsudHlwZSwgcHJvcHMsIHNpbmdsZXRvbiwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAvLyBUT0RPOiBDb250ZW50UmVzZXQgZ2V0cyBjbGVhcmVkIGJ5IHRoZSBjaGlsZHJlbiBkdXJpbmcgdGhlIGNvbW1pdFxuICAgICAgICAgIC8vIHBoYXNlLiBUaGlzIGlzIGEgcmVmYWN0b3IgaGF6YXJkIGJlY2F1c2UgaXQgbWVhbnMgd2UgbXVzdCByZWFkXG4gICAgICAgICAgLy8gZmxhZ3MgdGhlIGZsYWdzIGFmdGVyIGBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHNgIGhhcyBhbHJlYWR5IHJ1bjtcbiAgICAgICAgICAvLyB0aGUgb3JkZXIgbWF0dGVycy4gV2Ugc2hvdWxkIHJlZmFjdG9yIHNvIHRoYXQgQ29udGVudFJlc2V0IGRvZXMgbm90XG4gICAgICAgICAgLy8gcmVseSBvbiBtdXRhdGluZyB0aGUgZmxhZyBkdXJpbmcgY29tbWl0LiBMaWtlIGJ5IHNldHRpbmcgYSBmbGFnXG4gICAgICAgICAgLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXNldFRleHRDb250ZW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlMiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wczsgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShfaW5zdGFuY2UyLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmxhZ3MgJiBGb3JtUmVzZXQpIHtcbiAgICAgICAgICAgIG5lZWRzRm9ybVJlc2V0ID0gdHJ1ZTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgIT09ICdmb3JtJykge1xuICAgICAgICAgICAgICAgIC8vIFBhcmFub2lkIGNvZGluZy4gSW4gY2FzZSB3ZSBhY2NpZGVudGFsbHkgc3RhcnQgdXNpbmcgdGhlXG4gICAgICAgICAgICAgICAgLy8gRm9ybVJlc2V0IGJpdCBmb3Igc29tZXRoaW5nIGVsc2UuXG4gICAgICAgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgaG9zdCBjb21wb25lbnQgdHlwZS4gRXhwZWN0ZWQgYSBmb3JtLiBUaGlzIGlzIGEgJyArICdidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnICsgJ2NhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wczsgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIHByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMoKTtcbiAgICAgICAgICB2YXIgcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IHByZXZpb3VzSG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24gJiYgc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2Um9vdFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2Um9vdFN0YXRlLmlzRGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSByb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICB2YXIgcGVuZGluZ0NoaWxkcmVuID0gcm9vdC5wZW5kaW5nQ2hpbGRyZW47XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBwZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lZWRzRm9ybVJlc2V0KSB7XG4gICAgICAgICAgLy8gQSBmb3JtIGNvbXBvbmVudCByZXF1ZXN0ZWQgdG8gYmUgcmVzZXQgZHVyaW5nIHRoaXMgY29tbWl0LiBXZSBkbyB0aGlzXG4gICAgICAgICAgLy8gYWZ0ZXIgYWxsIG11dGF0aW9ucyBpbiB0aGUgcmVzdCBvZiB0aGUgdHJlZSBzbyB0aGF0IGBkZWZhdWx0VmFsdWVgXG4gICAgICAgICAgLy8gd2lsbCBhbHJlYWR5IGJlIHVwZGF0ZWQuIFRoaXMgd2F5IHlvdSBjYW4gdXBkYXRlIGBkZWZhdWx0VmFsdWVgIHVzaW5nXG4gICAgICAgICAgLy8gZGF0YSBzZW50IGJ5IHRoZSBzZXJ2ZXIgYXMgYSByZXN1bHQgb2YgdGhlIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZW9yZXRpY2FsbHkgd2UgY291bGQgY2hlY2sgZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIEZvcm1SZXNldCxcbiAgICAgICAgICAvLyBidXQgdGhlIEZvcm1SZXNldCBiaXQgaXMgb3ZlcmxvYWRlZCB3aXRoIG90aGVyIGZsYWdzIHVzZWQgYnkgb3RoZXJcbiAgICAgICAgICAvLyBmaWJlciB0eXBlcy4gU28gdGhpcyBleHRyYSB2YXJpYWJsZSBsZXRzIHVzIHNraXAgdHJhdmVyc2luZyB0aGUgdHJlZVxuICAgICAgICAgIC8vIGV4Y2VwdCB3aGVuIGEgZm9ybSB3YXMgYWN0dWFsbHkgc3VibWl0dGVkLlxuICAgICAgICAgIG5lZWRzRm9ybVJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIHZhciBfcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IF9wcmV2aW91c0hvaXN0YWJsZVJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICB2YXIgcG9ydGFsID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBfY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgdmFyIF9wZW5kaW5nQ2hpbGRyZW4gPSBwb3J0YWwucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oX2NvbnRhaW5lckluZm8sIF9wZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7IC8vIFRPRE86IFdlIHNob3VsZCBtYXJrIGEgZmxhZyBvbiB0aGUgU3VzcGVuc2UgZmliZXIgaXRzZWxmLCByYXRoZXIgdGhhblxuICAgICAgICAvLyByZWx5aW5nIG9uIHRoZSBPZmZzY3JlZW4gZmliZXIgaGF2aW5nIGEgZmxhZyBhbHNvIGJlaW5nIG1hcmtlZC4gVGhlXG4gICAgICAgIC8vIHJlYXNvbiBpcyB0aGF0IHRoaXMgb2Zmc2NyZWVuIGZpYmVyIG1pZ2h0IG5vdCBiZSBwYXJ0IG9mIHRoZSB3b3JrLWluLVxuICAgICAgICAvLyBwcm9ncmVzcyB0cmVlISBJdCBjb3VsZCBoYXZlIGJlZW4gcmV1c2VkIGZyb20gYSBwcmV2aW91cyByZW5kZXIuIFRoaXNcbiAgICAgICAgLy8gZG9lc24ndCBsZWFkIHRvIGluY29ycmVjdCBiZWhhdmlvciBiZWNhdXNlIHdlIGRvbid0IHJlbHkgb24gdGhlIGZsYWdcbiAgICAgICAgLy8gY2hlY2sgYWxvbmU7IHdlIGFsc28gY29tcGFyZSB0aGUgc3RhdGVzIGV4cGxpY2l0bHkgYmVsb3cuIEJ1dCBmb3JcbiAgICAgICAgLy8gbW9kZWxpbmcgcHVycG9zZXMsIHdlIF9zaG91bGRfIGJlIGFibGUgdG8gcmVseSBvbiB0aGUgZmxhZyBjaGVjayBhbG9uZS5cbiAgICAgICAgLy8gU28gdGhpcyBpcyBhIGJpdCBmcmFnaWxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbHNvLCBhbGwgdGhpcyBsb2dpYyBjb3VsZC9zaG91bGQgbW92ZSB0byB0aGUgcGFzc2l2ZSBwaGFzZSBzbyBpdFxuICAgICAgICAvLyBkb2Vzbid0IGJsb2NrIHBhaW50LlxuXG4gICAgICAgIHZhciBvZmZzY3JlZW5GaWJlciA9IGZpbmlzaGVkV29yay5jaGlsZDtcblxuICAgICAgICBpZiAob2Zmc2NyZWVuRmliZXIuZmxhZ3MgJiBWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgLy8gVGhyb3R0bGUgdGhlIGFwcGVhcmFuY2UgYW5kIGRpc2FwcGVhcmFuY2Ugb2YgU3VzcGVuc2UgZmFsbGJhY2tzLlxuICAgICAgICAgIHZhciBpc1Nob3dpbmdGYWxsYmFjayA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIHZhciB3YXNTaG93aW5nRmFsbGJhY2sgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc1Nob3dpbmdGYWxsYmFjayAhPT0gd2FzU2hvd2luZ0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIC8vIEEgZmFsbGJhY2sgaXMgZWl0aGVyIGFwcGVhcmluZyBvciBkaXNhcHBlYXJpbmcuXG4gICAgICAgICAgICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUNhbGxiYWNrKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXRyeVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKHJldHJ5UXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgcmV0cnlRdWV1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXdTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHdhc0hpZGRlbiA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBCZWZvcmUgY29tbWl0dGluZyB0aGUgY2hpbGRyZW4sIHRyYWNrIG9uIHRoZSBzdGFjayB3aGV0aGVyIHRoaXNcbiAgICAgICAgICAvLyBvZmZzY3JlZW4gc3VidHJlZSB3YXMgYWxyZWFkeSBoaWRkZW4sIHNvIHRoYXQgd2UgZG9uJ3QgdW5tb3VudCB0aGVcbiAgICAgICAgICAvLyBlZmZlY3RzIGFnYWluLlxuICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBpc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHwgd2FzSGlkZGVuO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBsYW5lcyk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgdmFyIG9mZnNjcmVlbkluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gVE9ETzogQWRkIGV4cGxpY2l0IGVmZmVjdCBmbGFnIHRvIHNldCBfY3VycmVudC5cblxuICAgICAgICBvZmZzY3JlZW5JbnN0YW5jZS5fY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gT2Zmc2NyZWVuIHN0b3JlcyBwZW5kaW5nIGNoYW5nZXMgdG8gdmlzaWJpbGl0eSBpbiBgX3BlbmRpbmdWaXNpYmlsaXR5YC4gVGhpcyBpc1xuICAgICAgICAvLyB0byBzdXBwb3J0IGJhdGNoaW5nIG9mIGBhdHRhY2hgIGFuZCBgZGV0YWNoYCBjYWxscy5cblxuICAgICAgICBvZmZzY3JlZW5JbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSB+T2Zmc2NyZWVuRGV0YWNoZWQ7XG4gICAgICAgIG9mZnNjcmVlbkluc3RhbmNlLl92aXNpYmlsaXR5IHw9IG9mZnNjcmVlbkluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIE9mZnNjcmVlbkRldGFjaGVkO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAvLyBUcmFjayB0aGUgY3VycmVudCBzdGF0ZSBvbiB0aGUgT2Zmc2NyZWVuIGluc3RhbmNlIHNvIHdlIGNhblxuICAgICAgICAgIC8vIHJlYWQgaXQgZHVyaW5nIGFuIGV2ZW50XG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICBvZmZzY3JlZW5JbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSB+T2Zmc2NyZWVuVmlzaWJsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2NyZWVuSW5zdGFuY2UuX3Zpc2liaWxpdHkgfD0gT2Zmc2NyZWVuVmlzaWJsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHZhciBpc1VwZGF0ZSA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICAgICB2YXIgd2FzSGlkZGVuQnlBbmNlc3Rvck9mZnNjcmVlbiA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuOyAvLyBPbmx5IHRyaWdnZXIgZGlzYXBwZXIgbGF5b3V0IGVmZmVjdHMgaWY6XG4gICAgICAgICAgICAvLyAgIC0gVGhpcyBpcyBhbiB1cGRhdGUsIG5vdCBmaXJzdCBtb3VudC5cbiAgICAgICAgICAgIC8vICAgLSBUaGlzIE9mZnNjcmVlbiB3YXMgbm90IGhpZGRlbiBiZWZvcmUuXG4gICAgICAgICAgICAvLyAgIC0gQW5jZXN0b3IgT2Zmc2NyZWVuIHdhcyBub3QgaGlkZGVuIGluIHByZXZpb3VzIGNvbW1pdC5cblxuICAgICAgICAgICAgaWYgKGlzVXBkYXRlICYmICF3YXNIaWRkZW4gJiYgIXdhc0hpZGRlbkJ5QW5jZXN0b3JPZmZzY3JlZW4pIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIERpc2FwcGVhciB0aGUgbGF5b3V0IGVmZmVjdHMgb2YgYWxsIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIE9mZnNjcmVlbiB3aXRoIG1hbnVhbCBtb2RlIG1hbmFnZXMgdmlzaWJpbGl0eSBtYW51YWxseS5cblxuXG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24gJiYgIWlzT2Zmc2NyZWVuTWFudWFsKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgbmVlZHMgdG8gcnVuIHdoZW5ldmVyIHRoZXJlJ3MgYW4gaW5zZXJ0aW9uIG9yIHVwZGF0ZVxuICAgICAgICAgICAgLy8gaW5zaWRlIGEgaGlkZGVuIE9mZnNjcmVlbiB0cmVlLlxuICAgICAgICAgICAgaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLCBpc0hpZGRlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRPRE86IE1vdmUgdG8gcGFzc2l2ZSBwaGFzZVxuXG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdmFyIG9mZnNjcmVlblF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKG9mZnNjcmVlblF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3JldHJ5UXVldWUgPSBvZmZzY3JlZW5RdWV1ZS5yZXRyeVF1ZXVlO1xuXG4gICAgICAgICAgICBpZiAoX3JldHJ5UXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgb2Zmc2NyZWVuUXVldWUucmV0cnlRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBfcmV0cnlRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBsYW5lcyk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZTIgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAoX3JldHJ5UXVldWUyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIF9yZXRyeVF1ZXVlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgLy8gUGxhY2VtZW50IGVmZmVjdHMgKGluc2VydGlvbnMsIHJlb3JkZXJzKSBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlclxuICAvLyB0eXBlLiBUaGV5IG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYXZlIGZpcmVkLCBidXRcbiAgLy8gYmVmb3JlIHRoZSBlZmZlY3RzIG9uIHRoaXMgZmliZXIgaGF2ZSBmaXJlZC5cbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIGlmIChmbGFncyAmIFBsYWNlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfSAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpc1xuICAgIC8vIGluc2VydGVkLCBiZWZvcmUgYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgLy8gVE9ETzogZmluZERPTU5vZGUgZG9lc24ndCByZWx5IG9uIHRoaXMgYW55IG1vcmUgYnV0IGlzTW91bnRlZCBkb2VzXG4gICAgLy8gYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBraWxsIHRoaXMuXG5cblxuICAgIGZpbmlzaGVkV29yay5mbGFncyAmPSB+UGxhY2VtZW50O1xuICB9XG5cbiAgaWYgKGZsYWdzICYgSHlkcmF0aW5nKSB7XG4gICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5IeWRyYXRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlSZXNldEZvcm1zKHBhcmVudEZpYmVyKSB7XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBGb3JtUmVzZXQpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgcmVzZXRGb3JtT25GaWJlcihjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Rm9ybU9uRmliZXIoZmliZXIpIHtcbiAgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50ICYmIGZpYmVyLmZsYWdzICYgRm9ybVJlc2V0KSB7XG4gICAgdmFyIGZvcm1JbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICByZXNldEZvcm1JbnN0YW5jZShmb3JtSW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICBpblByb2dyZXNzTGFuZXMgPSBjb21taXR0ZWRMYW5lcztcbiAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG5cbiAge1xuICAgIHJ1bldpdGhGaWJlckluREVWKGZpbmlzaGVkV29yaywgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlciwgcm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcyk7XG4gIH1cblxuICBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICBpblByb2dyZXNzUm9vdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyLCBsYW5lcykge1xuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGNoaWxkLmFsdGVybmF0ZTtcblxuICAgICAge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihjaGlsZCwgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlciwgcm9vdCwgY3VycmVudCwgY2hpbGQsIGxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIExheW91dFN0YXRpY1xuICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgUmVmU3RhdGljXG4gICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIFJlZlN0YXRpY1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBSZWZTdGF0aWNcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikgOyBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIChSZWZTdGF0aWMgfCBMYXlvdXRTdGF0aWMpXG4gIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHMoY2hpbGQpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBjdXJyZW50LCBmaW5pc2hlZFdvcmssIC8vIFRoaXMgZnVuY3Rpb24gdmlzaXRzIGJvdGggbmV3bHkgZmluaXNoZWQgd29yayBhbmQgbm9kZXMgdGhhdCB3ZXJlIHJlLXVzZWRcbi8vIGZyb20gYSBwcmV2aW91c2x5IGNvbW1pdHRlZCB0cmVlLiBXZSBjYW5ub3QgY2hlY2sgbm9uLXN0YXRpYyBmbGFncyBpZiB0aGVcbi8vIG5vZGUgd2FzIHJldXNlZC5cbmluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpIHtcbiAgLy8gVHVybiBvbiBsYXlvdXQgZWZmZWN0cyBpbiBhIHRyZWUgdGhhdCBwcmV2aW91c2x5IGRpc2FwcGVhcmVkLlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTsgLy8gVE9ETzogQ2hlY2sgZmxhZ3MgJiBMYXlvdXRTdGF0aWNcblxuICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7IC8vIFRPRE86IENoZWNrIGZvciBMYXlvdXRTdGF0aWMgZmxhZ1xuXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ29tbWl0IGFueSBjYWxsYmFja3MgdGhhdCB3b3VsZCBoYXZlIGZpcmVkIHdoaWxlIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gd2FzIGhpZGRlbi5cblxuXG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXRIaWRkZW5DYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgfSAvLyBJZiB0aGlzIGlzIG5ld2x5IGZpbmlzaGVkIHdvcmssIGNoZWNrIGZvciBzZXRTdGF0ZSBjYWxsYmFja3NcblxuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgQ2FsbGJhY2spIHtcbiAgICAgICAgICBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IC8vIFRPRE86IENoZWNrIGZsYWdzICYgUmVmU3RhdGljXG5cblxuICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gVW5saWtlIGNvbW1pdExheW91dEVmZmVjdHNPbkZpYmVyLCB3ZSBkb24ndCBuZWVkIHRvIGhhbmRsZSBIb3N0Um9vdFxuICAgIC8vIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBvbmx5IHZpc2l0cyBub2RlcyB0aGF0IGFyZSBpbnNpZGUgYW5cbiAgICAvLyBPZmZzY3JlZW4gZmliZXIuXG4gICAgLy8gY2FzZSBIb3N0Um9vdDoge1xuICAgIC8vICAuLi5cbiAgICAvLyB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7IC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGN1cnJlbnQgPT09IG51bGwgJiYgZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRIb3N0Q29tcG9uZW50TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSAvLyBUT0RPOiBDaGVjayBmbGFncyAmIFJlZlxuXG5cbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7IC8vIFRPRE86IEZpZ3VyZSBvdXQgaG93IFByb2ZpbGVyIHVwZGF0ZXMgc2hvdWxkIHdvcmsgd2l0aCBPZmZzY3JlZW5cblxuICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdFByb2ZpbGVyVXBkYXRlKGZpbmlzaGVkV29yaywgY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpOyAvLyBUT0RPOiBGaWd1cmUgb3V0IGhvdyBTdXNwZW5zZSBoeWRyYXRpb24gY2FsbGJhY2tzIHNob3VsZCB3b3JrXG4gICAgICAgIC8vIHdpdGggT2Zmc2NyZWVuLlxuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG9mZnNjcmVlblN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IG9mZnNjcmVlblN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikgOyBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICAgICAgfSAvLyBUT0RPOiBDaGVjayBmbGFncyAmIFJlZlxuXG5cbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBwYXJlbnRGaWJlciwgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHZpc2l0cyBib3RoIG5ld2x5IGZpbmlzaGVkIHdvcmsgYW5kIG5vZGVzIHRoYXQgd2VyZSByZS11c2VkXG4gIC8vIGZyb20gYSBwcmV2aW91c2x5IGNvbW1pdHRlZCB0cmVlLiBXZSBjYW5ub3QgY2hlY2sgbm9uLXN0YXRpYyBmbGFncyBpZiB0aGVcbiAgLy8gbm9kZSB3YXMgcmV1c2VkLlxuICB2YXIgY2hpbGRTaG91bGRJbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID0gaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MkMTsgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiAoUmVmU3RhdGljIHwgTGF5b3V0U3RhdGljKVxuXG4gIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gY2hpbGQuYWx0ZXJuYXRlO1xuXG4gICAge1xuICAgICAgcnVuV2l0aEZpYmVySW5ERVYoY2hpbGQsIHJlYXBwZWFyTGF5b3V0RWZmZWN0cywgZmluaXNoZWRSb290LCBjdXJyZW50LCBjaGlsZCwgY2hpbGRTaG91bGRJbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBob29rRmxhZ3MpIHtcbiAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG5cbiAgICB0cnkge1xuICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cblxuICAgIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoY3VycmVudCwgZmluaXNoZWRXb3JrLCBpbnN0YW5jZSkge1xuICB7XG4gICAgdmFyIHByZXZpb3VzQ2FjaGUgPSBudWxsO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgIHByZXZpb3VzQ2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDYWNoZSA9IG51bGw7XG5cbiAgICBpZiAoZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q2FjaGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICB9IC8vIFJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZSB1c2VkIGZvciBwZW5kaW5nIChzdXNwZW5kZWQpIG5vZGVzLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgcmVhY2hlZCBpbiB0aGUgbm9uLXN1c3BlbmRlZC92aXNpYmxlIGNhc2U6XG4gICAgLy8gd2hlbiB0aGUgY29udGVudCBpcyBzdXNwZW5kZWQvaGlkZGVuLCB0aGUgcmV0YWluL3JlbGVhc2Ugb2NjdXJzXG4gICAgLy8gdmlhIHRoZSBwYXJlbnQgU3VzcGVuc2UgY29tcG9uZW50IChzZWUgY2FzZSBhYm92ZSkuXG5cblxuICAgIGlmIChuZXh0Q2FjaGUgIT09IHByZXZpb3VzQ2FjaGUpIHtcbiAgICAgIGlmIChuZXh0Q2FjaGUgIT0gbnVsbCkge1xuICAgICAgICByZXRhaW5DYWNoZShuZXh0Q2FjaGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldmlvdXNDYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHJlbGVhc2VDYWNoZShwcmV2aW91c0NhY2hlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gIHtcbiAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG5cbiAgICBpZiAoZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNDYWNoZSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENhY2hlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGU7IC8vIFJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZS4gSW4gdGhlb3J5IHRoZSBjYWNoZSBjb21wb25lbnRcbiAgICAvLyBjb3VsZCBiZSBcImJvcnJvd2luZ1wiIGEgY2FjaGUgaW5zdGFuY2Ugb3duZWQgYnkgc29tZSBwYXJlbnQsXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBjb3VsZCBhdm9pZCByZXRhaW5pbmcvcmVsZWFzaW5nLiBCdXQgaXRcbiAgICAvLyBpcyBub24tdHJpdmlhbCB0byBkZXRlcm1pbmUgd2hlbiB0aGF0IGlzIHRoZSBjYXNlLCBzbyB3ZVxuICAgIC8vIGFsd2F5cyByZXRhaW4vcmVsZWFzZS5cblxuICAgIGlmIChuZXh0Q2FjaGUgIT09IHByZXZpb3VzQ2FjaGUpIHtcbiAgICAgIHJldGFpbkNhY2hlKG5leHRDYWNoZSk7XG5cbiAgICAgIGlmIChwcmV2aW91c0NhY2hlICE9IG51bGwpIHtcbiAgICAgICAgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIHtcbiAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIsIHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhyb290LCBwYXJlbnRGaWJlciwgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGNoaWxkLCBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyLCByb290LCBjaGlsZCwgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgLy8gV2hlbiB1cGRhdGluZyB0aGlzIGZ1bmN0aW9uLCBhbHNvIHVwZGF0ZSByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cywgd2hpY2ggZG9lc1xuICAvLyBtb3N0IG9mIHRoZSBzYW1lIHRoaW5ncyB3aGVuIGFuIG9mZnNjcmVlbiB0cmVlIGdvZXMgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZSxcbiAgLy8gb3Igd2hlbiB0b2dnbGluZyBlZmZlY3RzIGluc2lkZSBhIGhpZGRlbiB0cmVlLlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIFBhc3NpdmUgfCBIYXNFZmZlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHByZXZpb3VzQ2FjaGUgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0Q2FjaGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZTsgLy8gUmV0YWluL3JlbGVhc2UgdGhlIHJvb3QgY2FjaGUuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgb24gaW5pdGlhbCBtb3VudCwgcHJldmlvdXNDYWNoZSBhbmQgbmV4dENhY2hlIHdpbGwgYmUgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIGFuZCB0aGlzIHJldGFpbiB3b24ndCBvY2N1ci4gVG8gY291bnRlciB0aGlzLCB3ZSBpbnN0ZWFkIHJldGFpbiB0aGUgSG9zdFJvb3Qnc1xuICAgICAgICAgICAgLy8gaW5pdGlhbCBjYWNoZSB3aGVuIGNyZWF0aW5nIHRoZSByb290IGl0c2VsZiAoc2VlIGNyZWF0ZUZpYmVyUm9vdCgpIGluXG4gICAgICAgICAgICAvLyBSZWFjdEZpYmVyUm9vdC5qcykuIFN1YnNlcXVlbnQgdXBkYXRlcyB0aGF0IGNoYW5nZSB0aGUgY2FjaGUgYXJlIHJlZmxlY3RlZFxuICAgICAgICAgICAgLy8gaGVyZSwgc3VjaCB0aGF0IHByZXZpb3VzL25leHQgY2FjaGVzIGFyZSByZXRhaW5lZCBjb3JyZWN0bHkuXG5cbiAgICAgICAgICAgIGlmIChuZXh0Q2FjaGUgIT09IHByZXZpb3VzQ2FjaGUpIHtcbiAgICAgICAgICAgICAgcmV0YWluQ2FjaGUobmV4dENhY2hlKTtcblxuICAgICAgICAgICAgICBpZiAocHJldmlvdXNDYWNoZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIHZhciBfaW5zdGFuY2UzID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgaWYgKF9pbnN0YW5jZTMuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQuIFVwZGF0ZSB0aGVtLlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBkaXNjb25uZWN0ZWQuIFNpbmNlIHRoZSB0cmVlIGlzIGhpZGRlbixcbiAgICAgICAgICAgICAgLy8gZG9uJ3QgY29ubmVjdCB0aGVtLiBUaGlzIGFsc28gYXBwbGllcyB0byB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBcIkF0b21pY1wiIGVmZmVjdHMgYXJlIG9uZXMgdGhhdCBuZWVkIHRvIGZpcmUgb24gZXZlcnkgY29tbWl0LFxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gZHVyaW5nIHByZS1yZW5kZXJpbmcuIEFuIGV4YW1wbGUgaXMgdXBkYXRpbmcgdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIC8vIGNvdW50IG9uIGNhY2hlIGluc3RhbmNlcy5cbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVHJlZSBpcyB2aXNpYmxlXG4gICAgICAgICAgaWYgKF9pbnN0YW5jZTMuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQuIFVwZGF0ZSB0aGVtLlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgZGlzY29ubmVjdGVkLiBSZWNvbm5lY3QgdGhlbSwgd2hpbGUgYWxzb1xuICAgICAgICAgICAgLy8gZmlyaW5nIGVmZmVjdHMgaW5zaWRlIG5ld2x5IG1vdW50ZWQgdHJlZXMuIFRoaXMgYWxzbyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAvLyB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICAgICAgICBfaW5zdGFuY2UzLl92aXNpYmlsaXR5IHw9IE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkO1xuICAgICAgICAgICAgdmFyIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyQxO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIHZhciBfY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhfY3VycmVudCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhciBfY3VycmVudDIgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KF9jdXJyZW50MiwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIHBhcmVudEZpYmVyLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB2aXNpdHMgYm90aCBuZXdseSBmaW5pc2hlZCB3b3JrIGFuZCBub2RlcyB0aGF0IHdlcmUgcmUtdXNlZFxuICAvLyBmcm9tIGEgcHJldmlvdXNseSBjb21taXR0ZWQgdHJlZS4gV2UgY2Fubm90IGNoZWNrIG5vbi1zdGF0aWMgZmxhZ3MgaWYgdGhlXG4gIC8vIG5vZGUgd2FzIHJldXNlZC5cbiAgdmFyIGNoaWxkU2hvdWxkSW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9IGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyQxOyAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIChSZWZTdGF0aWMgfCBMYXlvdXRTdGF0aWMpXG5cbiAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgcnVuV2l0aEZpYmVySW5ERVYoY2hpbGQsIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzLCBmaW5pc2hlZFJvb3QsIGNoaWxkLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGNoaWxkU2hvdWxkSW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIC8vIFRoaXMgZnVuY3Rpb24gdmlzaXRzIGJvdGggbmV3bHkgZmluaXNoZWQgd29yayBhbmQgbm9kZXMgdGhhdCB3ZXJlIHJlLXVzZWRcbi8vIGZyb20gYSBwcmV2aW91c2x5IGNvbW1pdHRlZCB0cmVlLiBXZSBjYW5ub3QgY2hlY2sgbm9uLXN0YXRpYyBmbGFncyBpZiB0aGVcbi8vIG5vZGUgd2FzIHJldXNlZC5cbmluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpIHtcbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpOyAvLyBUT0RPOiBDaGVjayBmb3IgUGFzc2l2ZVN0YXRpYyBmbGFnXG5cbiAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gVW5saWtlIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIsIHdlIGRvbid0IG5lZWQgdG8gaGFuZGxlIEhvc3RSb290XG4gICAgLy8gYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgdmlzaXRzIG5vZGVzIHRoYXQgYXJlIGluc2lkZSBhblxuICAgIC8vIE9mZnNjcmVlbiBmaWJlci5cbiAgICAvLyBjYXNlIEhvc3RSb290OiB7XG4gICAgLy8gIC4uLlxuICAgIC8vIH1cblxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfaW5zdGFuY2U0ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgaWYgKF9pbnN0YW5jZTQuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQuIFVwZGF0ZSB0aGVtLlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgZGlzY29ubmVjdGVkLiBTaW5jZSB0aGUgdHJlZSBpcyBoaWRkZW4sXG4gICAgICAgICAgICAgIC8vIGRvbid0IGNvbm5lY3QgdGhlbS4gVGhpcyBhbHNvIGFwcGxpZXMgdG8gdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gXCJBdG9taWNcIiBlZmZlY3RzIGFyZSBvbmVzIHRoYXQgbmVlZCB0byBmaXJlIG9uIGV2ZXJ5IGNvbW1pdCxcbiAgICAgICAgICAgICAgICAvLyBldmVuIGR1cmluZyBwcmUtcmVuZGVyaW5nLiBBbiBleGFtcGxlIGlzIHVwZGF0aW5nIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAvLyBjb3VudCBvbiBjYWNoZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRyZWUgaXMgdmlzaWJsZVxuICAgICAgICAgIC8vIFNpbmNlIHdlJ3JlIGFscmVhZHkgaW5zaWRlIGEgcmVjb25uZWN0aW5nIHRyZWUsIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgLy8gd2hldGhlciB0aGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGNvbm5lY3RlZC4gSW4gZWl0aGVyIGNhc2UsIHdlJ2xsXG4gICAgICAgICAgLy8gY29udGludWUgdHJhdmVyc2luZyB0aGUgdHJlZSBhbmQgZmlyaW5nIGFsbCB0aGUgZWZmZWN0cy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdlIGRvIG5lZWQgdG8gc2V0IHRoZSBcImNvbm5lY3RlZFwiIGZsYWcgb24gdGhlIGluc3RhbmNlLCB0aG91Z2guXG4gICAgICAgICAgX2luc3RhbmNlNC5fdmlzaWJpbGl0eSB8PSBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YXIgX2N1cnJlbnQzID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKF9jdXJyZW50MywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhciBfY3VycmVudDQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KF9jdXJyZW50NCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBwYXJlbnRGaWJlciwgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIC8vIFwiQXRvbWljXCIgZWZmZWN0cyBhcmUgb25lcyB0aGF0IG5lZWQgdG8gZmlyZSBvbiBldmVyeSBjb21taXQsIGV2ZW4gZHVyaW5nXG4gIC8vIHByZS1yZW5kZXJpbmcuIFdlIGNhbGwgdGhpcyBmdW5jdGlvbiB3aGVuIHRyYXZlcnNpbmcgYSBoaWRkZW4gdHJlZSB3aG9zZVxuICAvLyByZWd1bGFyIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBkaXNjb25uZWN0ZWQuXG4gIC8vIFRPRE86IEFkZCBzcGVjaWFsIGZsYWcgZm9yIGF0b21pYyBlZmZlY3RzXG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGNoaWxkLCBjb21taXRBdG9taWNQYXNzaXZlRWZmZWN0cywgZmluaXNoZWRSb290LCBjaGlsZCwgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIC8vIFwiQXRvbWljXCIgZWZmZWN0cyBhcmUgb25lcyB0aGF0IG5lZWQgdG8gZmlyZSBvbiBldmVyeSBjb21taXQsIGV2ZW4gZHVyaW5nXG4gIC8vIHByZS1yZW5kZXJpbmcuIFdlIGNhbGwgdGhpcyBmdW5jdGlvbiB3aGVuIHRyYXZlcnNpbmcgYSBoaWRkZW4gdHJlZSB3aG9zZVxuICAvLyByZWd1bGFyIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBkaXNjb25uZWN0ZWQuXG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhjdXJyZW50LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhciBfY3VycmVudDUgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KF9jdXJyZW50NSwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gIHtcbiAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciwgZmluaXNoZWRXb3JrKTtcbiAgfVxufSAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBicmFuZCBuZXcgdHJlZSwgb3IgYSB0cmVlIHRoYXQgd2FzIGFscmVhZHkgdmlzaWJsZSwgdGhlbiB3ZVxuLy8gc2hvdWxkIG9ubHkgc3VzcGVuZCBob3N0IGNvbXBvbmVudHMgdGhhdCBoYXZlIGEgU2hvdWxkU3VzcGVuZENvbW1pdCBmbGFnLlxuLy8gQ29tcG9uZW50cyB3aXRob3V0IGl0IGhhdmVuJ3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBjb21taXQsIHNvIHdlIGNhbiBza2lwXG4vLyBvdmVyIHRob3NlLlxuLy9cbi8vIFdoZW4gd2UgZW50ZXIgYSB0cmVlIHRoYXQgaXMgYmVpbmcgcmV2ZWFsZWQgKGdvaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUpLFxuLy8gd2UgbmVlZCB0byBzdXNwZW5kIF9hbnlfIGNvbXBvbmVudCB0aGF0IF9tYXlfIHN1c3BlbmQuIEV2ZW4gaWYgdGhleSdyZVxuLy8gYWxyZWFkeSBpbiB0aGUgXCJjdXJyZW50XCIgdHJlZS4gQmVjYXVzZSB0aGVpciB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLCB0aGVcbi8vIGJyb3dzZXIgbWF5IG5vdCBoYXZlIHByZXJlbmRlcmVkIHRoZW0geWV0LiBTbyB3ZSBjaGVjayB0aGUgTWF5U3VzcGVuZENvbW1pdFxuLy8gZmxhZyBpbnN0ZWFkLlxuXG52YXIgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IFNob3VsZFN1c3BlbmRDb21taXQ7XG5mdW5jdGlvbiBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpbmlzaGVkV29yaykge1xuICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaW5pc2hlZFdvcmspO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQocGFyZW50RmliZXIpIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoY2hpbGQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcblxuICAgICAgICBpZiAoZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKSB7XG4gICAgICAgICAgaWYgKGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1c3BlbmRSZXNvdXJjZSggLy8gVGhpcyBzaG91bGQgYWx3YXlzIGJlIHNldCBieSB2aXNpdGluZyBIb3N0Um9vdCBmaXJzdFxuICAgICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QsIGZpYmVyLm1lbW9pemVkU3RhdGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgc3VzcGVuZEluc3RhbmNlKHR5cGUsIHByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcblxuICAgICAgICBpZiAoZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKSB7XG4gICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBzdXNwZW5kSW5zdGFuY2UoX3R5cGUsIF9wcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChjb250YWluZXIpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBwcmV2aW91c0hvaXN0YWJsZVJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSA7IGVsc2Uge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIHZhciB3YXNIaWRkZW4gPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIGlmICh3YXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIFRoaXMgdHJlZSBpcyBiZWluZyByZXZlYWxlZC4gVmlzaXQgYWxsIG5ld2x5IHZpc2libGUgc3VzcGVuc2V5XG4gICAgICAgICAgICAvLyBpbnN0YW5jZXMsIGV2ZW4gaWYgdGhleSdyZSBpbiB0aGUgY3VycmVudCB0cmVlLlxuICAgICAgICAgICAgdmFyIHByZXZGbGFncyA9IHN1c3BlbnNleUNvbW1pdEZsYWc7XG4gICAgICAgICAgICBzdXNwZW5zZXlDb21taXRGbGFnID0gTWF5U3VzcGVuZENvbW1pdDtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgICBzdXNwZW5zZXlDb21taXRGbGFnID0gcHJldkZsYWdzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcikge1xuICAvLyBBIGZpYmVyIHdhcyBkZWxldGVkIGZyb20gdGhpcyBwYXJlbnQgZmliZXIsIGJ1dCBpdCdzIHN0aWxsIHBhcnQgb2YgdGhlXG4gIC8vIHByZXZpb3VzIChhbHRlcm5hdGUpIHBhcmVudCBmaWJlcidzIGxpc3Qgb2YgY2hpbGRyZW4uIEJlY2F1c2UgY2hpbGRyZW5cbiAgLy8gYXJlIGEgbGlua2VkIGxpc3QsIGFuIGVhcmxpZXIgc2libGluZyB0aGF0J3Mgc3RpbGwgYWxpdmUgd2lsbCBiZVxuICAvLyBjb25uZWN0ZWQgdG8gdGhlIGRlbGV0ZWQgZmliZXIgdmlhIGl0cyBgYWx0ZXJuYXRlYDpcbiAgLy9cbiAgLy8gICBsaXZlIGZpYmVyIC0tYWx0ZXJuYXRlLS0+IHByZXZpb3VzIGxpdmUgZmliZXIgLS1zaWJsaW5nLS0+IGRlbGV0ZWRcbiAgLy8gICBmaWJlclxuICAvL1xuICAvLyBXZSBjYW4ndCBkaXNjb25uZWN0IGBhbHRlcm5hdGVgIG9uIG5vZGVzIHRoYXQgaGF2ZW4ndCBiZWVuIGRlbGV0ZWQgeWV0LFxuICAvLyBidXQgd2UgY2FuIGRpc2Nvbm5lY3QgdGhlIGBzaWJsaW5nYCBhbmQgYGNoaWxkYCBwb2ludGVycy5cbiAgdmFyIHByZXZpb3VzRmliZXIgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKHByZXZpb3VzRmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgZGV0YWNoZWRDaGlsZCA9IHByZXZpb3VzRmliZXIuY2hpbGQ7XG5cbiAgICBpZiAoZGV0YWNoZWRDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNGaWJlci5jaGlsZCA9IG51bGw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIHZhciBkZXRhY2hlZFNpYmxpbmcgPSBkZXRhY2hlZENoaWxkLnNpYmxpbmc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgICAgIGRldGFjaGVkQ2hpbGQuc2libGluZyA9IG51bGw7XG4gICAgICAgIGRldGFjaGVkQ2hpbGQgPSBkZXRhY2hlZFNpYmxpbmc7XG4gICAgICB9IHdoaWxlIChkZXRhY2hlZENoaWxkICE9PSBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGhvb2tGbGFncykge1xuICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcbiAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICB9IGVsc2Uge1xuICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAvLyBEZWxldGlvbnMgZWZmZWN0cyBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlciB0eXBlLiBUaGV5IG5lZWQgdG8gaGFwcGVuXG4gIC8vIGJlZm9yZSB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYXZlIGZpcmVkLlxuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuXG4gIGlmICgocGFyZW50RmliZXIuZmxhZ3MgJiBDaGlsZERlbGV0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07IC8vIFRPRE86IENvbnZlcnQgdGhpcyB0byB1c2UgcmVjdXJzaW9uXG5cbiAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oY2hpbGRUb0RlbGV0ZSwgcGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgfSAvLyBUT0RPOiBTcGxpdCBQYXNzaXZlTWFzayBpbnRvIHNlcGFyYXRlIG1hc2tzIGZvciBtb3VudCBhbmQgdW5tb3VudD9cblxuXG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKGNoaWxkLCBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgUGFzc2l2ZSB8IEhhc0VmZmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNIaWRkZW4gJiYgaW5zdGFuY2UuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCAmJiAoIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgZG9uJ3QgdW5tb3VudCB3aGVuIGEgdHJlZSBzdXNwZW5kcy4gSW5cbiAgICAgICAgLy8gdGhlIGZ1dHVyZSB3ZSBtYXkgY2hhbmdlIHRoaXMgdG8gdW5tb3VudCBhZnRlciBhIGRlbGF5LlxuICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuID09PSBudWxsIHx8IGZpbmlzaGVkV29yay5yZXR1cm4udGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkpIHtcbiAgICAgICAgICAvLyBUaGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGNvbm5lY3RlZC4gRGlzY29ubmVjdCB0aGVtLlxuICAgICAgICAgIC8vIFRPRE86IEFkZCBvcHRpb24gb3IgaGV1cmlzdGljIHRvIGRlbGF5IGJlZm9yZSBkaXNjb25uZWN0aW5nIHRoZVxuICAgICAgICAgIC8vIGVmZmVjdHMuIFRoZW4gaWYgdGhlIHRyZWUgcmVhcHBlYXJzIGJlZm9yZSB0aGUgZGVsYXkgaGFzIGVsYXBzZWQsIHdlXG4gICAgICAgICAgLy8gY2FuIHNraXAgdG9nZ2xpbmcgdGhlIGVmZmVjdHMgZW50aXJlbHkuXG4gICAgICAgICAgaW5zdGFuY2UuX3Zpc2liaWxpdHkgJj0gfk9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAvLyBEZWxldGlvbnMgZWZmZWN0cyBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlciB0eXBlLiBUaGV5IG5lZWQgdG8gaGFwcGVuXG4gIC8vIGJlZm9yZSB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYXZlIGZpcmVkLlxuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuXG4gIGlmICgocGFyZW50RmliZXIuZmxhZ3MgJiBDaGlsZERlbGV0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07IC8vIFRPRE86IENvbnZlcnQgdGhpcyB0byB1c2UgcmVjdXJzaW9uXG5cbiAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oY2hpbGRUb0RlbGV0ZSwgcGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgfSAvLyBUT0RPOiBDaGVjayBQYXNzaXZlU3RhdGljIGZsYWdcblxuXG4gIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHJ1bldpdGhGaWJlckluREVWKGNoaWxkLCBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdCwgY2hpbGQpO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBDaGVjayBQYXNzaXZlU3RhdGljIGZsYWdcbiAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIFBhc3NpdmUpOyAvLyBXaGVuIGRpc2Nvbm5lY3RpbmcgcGFzc2l2ZSBlZmZlY3RzLCB3ZSBmaXJlIHRoZSBlZmZlY3RzIGluIHRoZSBzYW1lXG4gICAgICAgIC8vIG9yZGVyIGFzIGR1cmluZyBhIGRlbGV0aW9uZzogcGFyZW50IGJlZm9yZSBjaGlsZFxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCkge1xuICAgICAgICAgIGluc3RhbmNlLl92aXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihkZWxldGVkU3VidHJlZVJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0OyAvLyBEZWxldGlvbiBlZmZlY3RzIGZpcmUgaW4gcGFyZW50IC0+IGNoaWxkIG9yZGVyXG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgZmliZXIgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnXG5cbiAgICB7XG4gICAgICBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIsIGZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDsgLy8gVE9ETzogT25seSB0cmF2ZXJzZSBzdWJ0cmVlIGlmIGl0IGhhcyBhIFBhc3NpdmVTdGF0aWMgZmxhZy5cblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGQucmV0dXJuID0gZmliZXI7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZShkZWxldGVkU3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBmaWJlci5yZXR1cm47IC8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRoZSBlbnRpcmUgZGVsZXRlZCB0cmVlIGFuZCBjbGVhbiB1cCBmaWJlciBmaWVsZHMuXG4gICAgLy8gVGhpcyBpcyBtb3JlIGFnZ3Jlc3NpdmUgdGhhbiBpZGVhbCwgYW5kIHRoZSBsb25nIHRlcm0gZ29hbCBpcyB0byBvbmx5XG4gICAgLy8gaGF2ZSB0byBkZXRhY2ggdGhlIGRlbGV0ZWQgdHJlZSBhdCB0aGUgcm9vdC5cblxuICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKTtcblxuICAgIGlmIChmaWJlciA9PT0gZGVsZXRlZFN1YnRyZWVSb290KSB7XG4gICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2libGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSByZXR1cm5GaWJlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgUGFzc2l2ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIFRPRE86IHJ1biBwYXNzaXZlIHVubW91bnQgZWZmZWN0cyB3aGVuIHVubW91bnRpbmcgYSByb290LlxuICAgIC8vIEJlY2F1c2UgcGFzc2l2ZSB1bm1vdW50IGVmZmVjdHMgYXJlIG5vdCBjdXJyZW50bHkgcnVuLFxuICAgIC8vIHRoZSBjYWNoZSBpbnN0YW5jZSBvd25lZCBieSB0aGUgcm9vdCB3aWxsIG5ldmVyIGJlIGZyZWVkLlxuICAgIC8vIFdoZW4gZWZmZWN0cyBhcmUgcnVuLCB0aGUgY2FjaGUgc2hvdWxkIGJlIGZyZWVkIGhlcmU6XG4gICAgLy8gY2FzZSBIb3N0Um9vdDoge1xuICAgIC8vICAgaWYgKGVuYWJsZUNhY2hlKSB7XG4gICAgLy8gICAgIGNvbnN0IGNhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgIC8vICAgICByZWxlYXNlQ2FjaGUoY2FjaGUpO1xuICAgIC8vICAgfVxuICAgIC8vICAgYnJlYWs7XG4gICAgLy8gfVxuXG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDsgLy8gUmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlIHVzZWQgZm9yIHBlbmRpbmcgKHN1c3BlbmRlZCkgbm9kZXMuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IHJlYWNoZWQgaW4gdGhlIG5vbi1zdXNwZW5kZWQvdmlzaWJsZSBjYXNlOlxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgY29udGVudCBpcyBzdXNwZW5kZWQvaGlkZGVuLCB0aGUgcmV0YWluL3JlbGVhc2Ugb2NjdXJzXG4gICAgICAgICAgICAvLyB2aWEgdGhlIHBhcmVudCBTdXNwZW5zZSBjb21wb25lbnQgKHNlZSBjYXNlIGFib3ZlKS5cblxuICAgICAgICAgICAgaWYgKGNhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0YWluQ2FjaGUoY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgICAgIHJlbGVhc2VDYWNoZShfY2FjaGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGVGb3JUeXBlKHJlc291cmNlVHlwZSkge1xuXG4gIHZhciBjYWNoZSA9IHJlYWRDb250ZXh0KENhY2hlQ29udGV4dCk7XG4gIHZhciBjYWNoZUZvclR5cGUgPSBjYWNoZS5kYXRhLmdldChyZXNvdXJjZVR5cGUpO1xuXG4gIGlmIChjYWNoZUZvclR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlRm9yVHlwZSA9IHJlc291cmNlVHlwZSgpO1xuICAgIGNhY2hlLmRhdGEuc2V0KHJlc291cmNlVHlwZSwgY2FjaGVGb3JUeXBlKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZUZvclR5cGU7XG59XG5cbnZhciBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICBnZXRDYWNoZUZvclR5cGU6IGdldENhY2hlRm9yVHlwZVxufTtcblxue1xuICBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyLmdldE93bmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9O1xufVxuXG52YXIgQ09NUE9ORU5UX1RZUEUgPSAwO1xudmFyIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDE7XG52YXIgUk9MRV9UWVBFID0gMjtcbnZhciBURVNUX05BTUVfVFlQRSA9IDM7XG52YXIgVEVYVF9UWVBFID0gNDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3MnKTtcbiAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci5yb2xlJyk7XG4gIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IudGV4dCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRTZWxlY3Rvcihjb21wb25lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogQ09NUE9ORU5UX1RZUEUsXG4gICAgdmFsdWU6IGNvbXBvbmVudFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvcihzZWxlY3RvcnMpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogSEFTX1BTRVVET19DTEFTU19UWVBFLFxuICAgIHZhbHVlOiBzZWxlY3RvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvbGVTZWxlY3Rvcihyb2xlKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJPTEVfVFlQRSxcbiAgICB2YWx1ZTogcm9sZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFNlbGVjdG9yKHRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogVEVYVF9UWVBFLFxuICAgIHZhbHVlOiB0ZXh0XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUZXN0TmFtZVNlbGVjdG9yKGlkKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFRFU1RfTkFNRV9UWVBFLFxuICAgIHZhbHVlOiBpZFxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpIHtcbiAgdmFyIG1heWJlRmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGhvc3RSb290KTtcblxuICBpZiAobWF5YmVGaWJlciAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBtYXliZUZpYmVyLm1lbW9pemVkUHJvcHNbJ2RhdGEtdGVzdG5hbWUnXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHJvb3Qgc3BlY2lmaWVkLiBTaG91bGQgYmUgZWl0aGVyIGEgUmVhY3QgY29udGFpbmVyIG9yIGEgbm9kZSB3aXRoIGEgdGVzdG5hbWUgYXR0cmlidXRlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZUZpYmVyO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaWJlclJvb3QgPSBmaW5kRmliZXJSb290KGhvc3RSb290KTtcblxuICAgIGlmIChmaWJlclJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgUmVhY3QgY29udGFpbmVyIHdpdGhpbiBzcGVjaWZpZWQgaG9zdCBzdWJ0cmVlLicpO1xuICAgIH0gLy8gVGhlIEZsb3cgdHlwZSBmb3IgRmliZXJSb290IGlzIGEgbGl0dGxlIGZ1bmt5LlxuICAgIC8vIGNyZWF0ZUZpYmVyUm9vdCgpIGNoZWF0cyB0aGlzIGJ5IHRyZWF0aW5nIHRoZSByb290IGFzIDphbnkgYW5kIGFkZGluZyBzdGF0ZU5vZGUgbGF6aWx5LlxuXG5cbiAgICByZXR1cm4gZmliZXJSb290LnN0YXRlTm9kZS5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSB7XG4gIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICBpZiAoZmliZXIudHlwZSA9PT0gc2VsZWN0b3IudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIQVNfUFNFVURPX0NMQVNTX1RZUEU6XG4gICAgICByZXR1cm4gaGFzTWF0Y2hpbmdQYXRocyhmaWJlciwgc2VsZWN0b3IudmFsdWUpO1xuXG4gICAgY2FzZSBST0xFX1RZUEU6XG4gICAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG1hdGNoQWNjZXNzaWJpbGl0eVJvbGUobm9kZSwgc2VsZWN0b3IudmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSB7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGZpYmVyKTtcblxuICAgICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwgJiYgdGV4dENvbnRlbnQuaW5kZXhPZihzZWxlY3Rvci52YWx1ZSkgPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikge1xuICAgICAgICB2YXIgZGF0YVRlc3RJRCA9IGZpYmVyLm1lbW9pemVkUHJvcHNbJ2RhdGEtdGVzdG5hbWUnXTtcblxuICAgICAgICBpZiAodHlwZW9mIGRhdGFUZXN0SUQgPT09ICdzdHJpbmcnICYmIGRhdGFUZXN0SUQudG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0b3IudmFsdWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC4nKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0b3JUb1N0cmluZyhzZWxlY3Rvcikge1xuICBzd2l0Y2ggKHNlbGVjdG9yLiQkdHlwZW9mKSB7XG4gICAgY2FzZSBDT01QT05FTlRfVFlQRTpcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShzZWxlY3Rvci52YWx1ZSkgfHwgJ1Vua25vd24nO1xuICAgICAgcmV0dXJuIFwiPFwiICsgZGlzcGxheU5hbWUgKyBcIj5cIjtcblxuICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgcmV0dXJuIFwiOmhhcyhcIiArIChzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSB8fCAnJykgKyBcIilcIjtcblxuICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgcmV0dXJuIFwiW3JvbGU9XFxcIlwiICsgc2VsZWN0b3IudmFsdWUgKyBcIlxcXCJdXCI7XG5cbiAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgIHJldHVybiBcIlxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXCI7XG5cbiAgICBjYXNlIFRFU1RfTkFNRV9UWVBFOlxuICAgICAgcmV0dXJuIFwiW2RhdGEtdGVzdG5hbWU9XFxcIlwiICsgc2VsZWN0b3IudmFsdWUgKyBcIlxcXCJdXCI7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHR5cGUgc3BlY2lmaWVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQYXRocyhyb290LCBzZWxlY3RvcnMpIHtcbiAgdmFyIG1hdGNoaW5nRmliZXJzID0gW107XG4gIHZhciBzdGFjayA9IFtyb290LCAwXTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuICAgIHZhciBzZWxlY3RvckluZGV4ID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuXG4gICAgaWYgKCh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChzZWxlY3RvciAhPSBudWxsICYmIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSkge1xuICAgICAgICBzZWxlY3RvckluZGV4Kys7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RvckluZGV4ID09PSBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBtYXRjaGluZ0ZpYmVycy5wdXNoKGZpYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGluZ0ZpYmVycztcbn0gLy8gU2FtZSBhcyBmaW5kUGF0aHMgYnV0IHdpdGggZWFnZXIgYmFpbG91dCBvbiBmaXJzdCBtYXRjaFxuXG5cbmZ1bmN0aW9uIGhhc01hdGNoaW5nUGF0aHMocm9vdCwgc2VsZWN0b3JzKSB7XG4gIHZhciBzdGFjayA9IFtyb290LCAwXTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuICAgIHZhciBzZWxlY3RvckluZGV4ID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuXG4gICAgaWYgKCh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChzZWxlY3RvciAhPSBudWxsICYmIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSkge1xuICAgICAgICBzZWxlY3RvckluZGV4Kys7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RvckluZGV4ID09PSBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgdmFyIG1hdGNoaW5nRmliZXJzID0gZmluZFBhdGhzKHJvb3QsIHNlbGVjdG9ycyk7XG4gIHZhciBpbnN0YW5jZVJvb3RzID0gW107XG4gIHZhciBzdGFjayA9IEFycmF5LmZyb20obWF0Y2hpbmdGaWJlcnMpO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBub2RlID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSB7XG4gICAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZVJvb3RzLnB1c2gobm9kZS5zdGF0ZU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2VSb290cztcbn1cbmZ1bmN0aW9uIGdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbihob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXhTZWxlY3RvckluZGV4ID0gMDtcbiAgdmFyIG1hdGNoZWROYW1lcyA9IFtdOyAvLyBUaGUgbG9naWMgb2YgdGhpcyBsb29wIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCBmaW5kUGF0aHMoKVxuXG4gIHZhciBzdGFjayA9IFtyb290LCAwXTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuICAgIHZhciBzZWxlY3RvckluZGV4ID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuXG4gICAgaWYgKCh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgIG1hdGNoZWROYW1lcy5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpKTtcbiAgICAgIHNlbGVjdG9ySW5kZXgrKztcblxuICAgICAgaWYgKHNlbGVjdG9ySW5kZXggPiBtYXhTZWxlY3RvckluZGV4KSB7XG4gICAgICAgIG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgIHZhciB1bm1hdGNoZWROYW1lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IG1heFNlbGVjdG9ySW5kZXg7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcnNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ2ZpbmRBbGxOb2RlcyB3YXMgYWJsZSB0byBtYXRjaCBwYXJ0IG9mIHRoZSBzZWxlY3RvcjpcXG4nICsgKFwiICBcIiArIG1hdGNoZWROYW1lcy5qb2luKCcgPiAnKSArIFwiXFxuXFxuXCIpICsgJ05vIG1hdGNoaW5nIGNvbXBvbmVudCB3YXMgZm91bmQgZm9yOlxcbicgKyAoXCIgIFwiICsgdW5tYXRjaGVkTmFtZXMuam9pbignID4gJykpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQm91bmRpbmdSZWN0cyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIGJvdW5kaW5nUmVjdHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlUm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICBib3VuZGluZ1JlY3RzLnB1c2goZ2V0Qm91bmRpbmdSZWN0KGluc3RhbmNlUm9vdHNbaV0pKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gYm91bmRpbmdSZWN0cy5sZW5ndGggLSAxOyBfaSA+IDA7IF9pLS0pIHtcbiAgICB2YXIgdGFyZ2V0UmVjdCA9IGJvdW5kaW5nUmVjdHNbX2ldO1xuICAgIHZhciB0YXJnZXRMZWZ0ID0gdGFyZ2V0UmVjdC54O1xuICAgIHZhciB0YXJnZXRSaWdodCA9IHRhcmdldExlZnQgKyB0YXJnZXRSZWN0LndpZHRoO1xuICAgIHZhciB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0Lnk7XG4gICAgdmFyIHRhcmdldEJvdHRvbSA9IHRhcmdldFRvcCArIHRhcmdldFJlY3QuaGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaiA9IF9pIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChfaSAhPT0gaikge1xuICAgICAgICB2YXIgb3RoZXJSZWN0ID0gYm91bmRpbmdSZWN0c1tqXTtcbiAgICAgICAgdmFyIG90aGVyTGVmdCA9IG90aGVyUmVjdC54O1xuICAgICAgICB2YXIgb3RoZXJSaWdodCA9IG90aGVyTGVmdCArIG90aGVyUmVjdC53aWR0aDtcbiAgICAgICAgdmFyIG90aGVyVG9wID0gb3RoZXJSZWN0Lnk7XG4gICAgICAgIHZhciBvdGhlckJvdHRvbSA9IG90aGVyVG9wICsgb3RoZXJSZWN0LmhlaWdodDsgLy8gTWVyZ2luZyBhbGwgcmVjdHMgdG8gdGhlIG1pbmltdW1zIHNldCB3b3VsZCBiZSBjb21wbGljYXRlZCxcbiAgICAgICAgLy8gYnV0IHdlIGNhbiBoYW5kbGUgdGhlIG1vc3QgY29tbW9uIGNhc2VzOlxuICAgICAgICAvLyAxLiBjb21wbGV0ZWx5IG92ZXJsYXBwaW5nIHJlY3RzXG4gICAgICAgIC8vIDIuIGFkamFjZW50IHJlY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHdpZHRoIG9yIGhlaWdodCAoZS5nLiBpdGVtcyBpbiBhIGxpc3QpXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV2ZW4gZ2l2ZW4gdGhlIGFib3ZlIGNvbnN0cmFpbnRzLFxuICAgICAgICAvLyB3ZSBzdGlsbCB3b24ndCBlbmQgdXAgd2l0aCB0aGUgZmV3ZXN0IHBvc3NpYmxlIHJlY3RzIHdpdGhvdXQgZG9pbmcgbXVsdGlwbGUgcGFzc2VzLFxuICAgICAgICAvLyBidXQgaXQncyBnb29kIGVub3VnaCBmb3IgdGhpcyBwdXJwb3NlLlxuXG4gICAgICAgIGlmICh0YXJnZXRMZWZ0ID49IG90aGVyTGVmdCAmJiB0YXJnZXRUb3AgPj0gb3RoZXJUb3AgJiYgdGFyZ2V0UmlnaHQgPD0gb3RoZXJSaWdodCAmJiB0YXJnZXRCb3R0b20gPD0gb3RoZXJCb3R0b20pIHtcbiAgICAgICAgICAvLyBDb21wbGV0ZSBvdmVybGFwcGluZyByZWN0czsgcmVtb3ZlIHRoZSBpbm5lciBvbmUuXG4gICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldExlZnQgPT09IG90aGVyTGVmdCAmJiB0YXJnZXRSZWN0LndpZHRoID09PSBvdGhlclJlY3Qud2lkdGggJiYgIShvdGhlckJvdHRvbSA8IHRhcmdldFRvcCkgJiYgIShvdGhlclRvcCA+IHRhcmdldEJvdHRvbSkpIHtcbiAgICAgICAgICAvLyBBZGphY2VudCB2ZXJ0aWNhbCByZWN0czsgbWVyZ2UgdGhlbS5cbiAgICAgICAgICBpZiAob3RoZXJUb3AgPiB0YXJnZXRUb3ApIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgKz0gb3RoZXJUb3AgLSB0YXJnZXRUb3A7XG4gICAgICAgICAgICBvdGhlclJlY3QueSA9IHRhcmdldFRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXJCb3R0b20gPCB0YXJnZXRCb3R0b20pIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3VuZGluZ1JlY3RzLnNwbGljZShfaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VG9wID09PSBvdGhlclRvcCAmJiB0YXJnZXRSZWN0LmhlaWdodCA9PT0gb3RoZXJSZWN0LmhlaWdodCAmJiAhKG90aGVyUmlnaHQgPCB0YXJnZXRMZWZ0KSAmJiAhKG90aGVyTGVmdCA+IHRhcmdldFJpZ2h0KSkge1xuICAgICAgICAgIC8vIEFkamFjZW50IGhvcml6b250YWwgcmVjdHM7IG1lcmdlIHRoZW0uXG4gICAgICAgICAgaWYgKG90aGVyTGVmdCA+IHRhcmdldExlZnQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCArPSBvdGhlckxlZnQgLSB0YXJnZXRMZWZ0O1xuICAgICAgICAgICAgb3RoZXJSZWN0LnggPSB0YXJnZXRMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdGhlclJpZ2h0IDwgdGFyZ2V0UmlnaHQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCA9IHRhcmdldFJpZ2h0IC0gb3RoZXJMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kaW5nUmVjdHMuc3BsaWNlKF9pLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZGluZ1JlY3RzO1xufVxuZnVuY3Rpb24gZm9jdXNXaXRoaW4oaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIHN0YWNrID0gQXJyYXkuZnJvbShtYXRjaGluZ0ZpYmVycyk7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcblxuICAgIGlmIChpc0hpZGRlblN1YnRyZWUoZmliZXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pIHtcbiAgICAgIHZhciBub2RlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoc2V0Rm9jdXNJZkZvY3VzYWJsZShub2RlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3RhY2sucHVzaChjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIGNvbW1pdEhvb2tzID0gW107XG5mdW5jdGlvbiBvbkNvbW1pdFJvb3QoKSB7XG4gIGlmIChzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpIHtcbiAgICBjb21taXRIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21taXRIb29rKSB7XG4gICAgICByZXR1cm4gY29tbWl0SG9vaygpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBvYnNlcnZlVmlzaWJsZVJlY3RzKGhvc3RSb290LCBzZWxlY3RvcnMsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcblxuICB2YXIgX3NldHVwSW50ZXJzZWN0aW9uT2JzID0gc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcihpbnN0YW5jZVJvb3RzLCBjYWxsYmFjaywgb3B0aW9ucyksXG4gICAgICBkaXNjb25uZWN0ID0gX3NldHVwSW50ZXJzZWN0aW9uT2JzLmRpc2Nvbm5lY3QsXG4gICAgICBvYnNlcnZlID0gX3NldHVwSW50ZXJzZWN0aW9uT2JzLm9ic2VydmUsXG4gICAgICB1bm9ic2VydmUgPSBfc2V0dXBJbnRlcnNlY3Rpb25PYnMudW5vYnNlcnZlOyAvLyBXaGVuIFJlYWN0IG11dGF0ZXMgdGhlIGhvc3QgZW52aXJvbm1lbnQsIHdlIG1heSBuZWVkIHRvIGNoYW5nZSB3aGF0IHdlJ3JlIGxpc3RlbmluZyB0by5cblxuXG4gIHZhciBjb21taXRIb29rID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXh0SW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICBpbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKG5leHRJbnN0YW5jZVJvb3RzLmluZGV4T2YodGFyZ2V0KSA8IDApIHtcbiAgICAgICAgdW5vYnNlcnZlKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbmV4dEluc3RhbmNlUm9vdHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoaW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgIG9ic2VydmUodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb21taXRIb29rcy5wdXNoKGNvbW1pdEhvb2spO1xuICByZXR1cm4ge1xuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFN0b3AgbGlzdGVuaW5nIGZvciBSZWFjdCBtdXRhdGlvbnM6XG4gICAgICB2YXIgaW5kZXggPSBjb21taXRIb29rcy5pbmRleE9mKGNvbW1pdEhvb2spO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBjb21taXRIb29rcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfSAvLyBEaXNjb25uZWN0IHRoZSBob3N0IG9ic2VydmVyOlxuXG5cbiAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkge1xuICB7XG4gICAgdmFyIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCA9IC8vICRGbG93Rml4TWVbY2Fubm90LXJlc29sdmUtbmFtZV0gRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIGdsb2JhbFxuICAgIHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgIT09ICd1bmRlZmluZWQnID8gLy8gJEZsb3dGaXhNZVtjYW5ub3QtcmVzb2x2ZS1uYW1lXVxuICAgIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsICYmIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJbmNsdWRlIGxpbmsgdG8gcmVsZXZhbnQgZG9jdW1lbnRhdGlvbiBwYWdlLlxuICAgICAgZXJyb3IoJ1RoZSBjdXJyZW50IHRlc3RpbmcgZW52aXJvbm1lbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCAnICsgJ2FjdCguLi4pJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbDtcbiAgfVxufVxuXG52YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xudmFyIE5vQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAqL1xuMDtcbnZhciBCYXRjaGVkQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICovXG4xO1xudmFyIFJlbmRlckNvbnRleHQgPVxuLyogICAgICAgICAqL1xuMjtcbnZhciBDb21taXRDb250ZXh0ID1cbi8qICAgICAgICAgKi9cbjQ7XG52YXIgUm9vdEluUHJvZ3Jlc3MgPSAwO1xudmFyIFJvb3RGYXRhbEVycm9yZWQgPSAxO1xudmFyIFJvb3RFcnJvcmVkID0gMjtcbnZhciBSb290U3VzcGVuZGVkID0gMztcbnZhciBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNDtcbnZhciBSb290Q29tcGxldGVkID0gNTtcbnZhciBSb290RGlkTm90Q29tcGxldGUgPSA2OyAvLyBEZXNjcmliZXMgd2hlcmUgd2UgYXJlIGluIHRoZSBSZWFjdCBleGVjdXRpb24gc3RhY2tcblxudmFyIGV4ZWN1dGlvbkNvbnRleHQgPSBOb0NvbnRleHQ7IC8vIFRoZSByb290IHdlJ3JlIHdvcmtpbmcgb25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7IC8vIFRoZSBmaWJlciB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7IC8vIFRoZSBsYW5lcyB3ZSdyZSByZW5kZXJpbmdcblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbnZhciBOb3RTdXNwZW5kZWQgPSAwO1xudmFyIFN1c3BlbmRlZE9uRXJyb3IgPSAxO1xudmFyIFN1c3BlbmRlZE9uRGF0YSA9IDI7XG52YXIgU3VzcGVuZGVkT25JbW1lZGlhdGUgPSAzO1xudmFyIFN1c3BlbmRlZE9uSW5zdGFuY2UgPSA0O1xudmFyIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWUgPSA1O1xudmFyIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSA9IDY7XG52YXIgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlID0gNztcbnZhciBTdXNwZW5kZWRPbkh5ZHJhdGlvbiA9IDg7IC8vIFdoZW4gdGhpcyBpcyB0cnVlLCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlciBqdXN0IHN1c3BlbmRlZCAob3IgZXJyb3JlZCkgYW5kXG4vLyB3ZSd2ZSB5ZXQgdG8gdW53aW5kIHRoZSBzdGFjay4gSW4gc29tZSBjYXNlcywgd2UgbWF5IHlpZWxkIHRvIHRoZSBtYWluIHRocmVhZFxuLy8gYWZ0ZXIgdGhpcyBoYXBwZW5zLiBJZiB0aGUgZmliZXIgaXMgcGluZ2VkIGJlZm9yZSB3ZSByZXN1bWUsIHdlIGNhbiByZXRyeVxuLy8gaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB1bndpbmRpbmcgdGhlIHN0YWNrLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG52YXIgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7IC8vIFdoZXRoZXIgYSBwaW5nIGxpc3RlbmVyIHdhcyBhdHRhY2hlZCBkdXJpbmcgdGhpcyByZW5kZXIuIFRoaXMgaXMgc2xpZ2h0bHlcbi8vIGRpZmZlcmVudCB0aGF0IHdoZXRoZXIgc29tZXRoaW5nIHN1c3BlbmRlZCwgYmVjYXVzZSB3ZSBkb24ndCBhZGQgbXVsdGlwbGVcbi8vIGxpc3RlbmVycyB0byBhIHByb21pc2Ugd2UndmUgYWxyZWFkeSBzZWVuIChwZXIgcm9vdCBhbmQgbGFuZSkuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSBmYWxzZTsgLy8gQSBjb250ZXh0dWFsIHZlcnNpb24gb2Ygd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuIEl0IGlzIGEgc3VwZXJzZXQgb2Zcbi8vIHRoZSBsYW5lcyB0aGF0IHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gV2hlbiB3ZSBlbnRlciBhIHN1YnRyZWVcbi8vIHRoYXQgaXMgY3VycmVudGx5IGhpZGRlbiwgd2UgYWRkIHRoZSBsYW5lcyB0aGF0IHdvdWxkIGhhdmUgY29tbWl0dGVkIGlmXG4vLyB0aGUgaGlkZGVuIHRyZWUgaGFkbid0IGJlZW4gZGVmZXJyZWQuIFRoaXMgaXMgbW9kaWZpZWQgYnkgdGhlXG4vLyBIaWRkZW5Db250ZXh0IG1vZHVsZS5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBlbnRhbmdsZWRSZW5kZXJMYW5lcy5cblxudmFyIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSAoKm5vdCogYW4gaW50ZXJsZWF2ZWQgZXZlbnQpLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzOyAvLyBJZiB0aGlzIGxhbmUgc2NoZWR1bGVkIGRlZmVycmVkIHdvcmssIHRoaXMgaXMgdGhlIGxhbmUgb2YgdGhlIGRlZmVycmVkIHRhc2suXG5cbnZhciB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9IE5vTGFuZTsgLy8gRXJyb3JzIHRoYXQgYXJlIHRocm93biBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBudWxsOyAvLyBUaGVzZSBhcmUgZXJyb3JzIHRoYXQgd2UgcmVjb3ZlcmVkIGZyb20gd2l0aG91dCBzdXJmYWNpbmcgdGhlbSB0byB0aGUgVUkuXG4vLyBXZSB3aWxsIGxvZyB0aGVtIG9uY2UgdGhlIHRyZWUgY29tbWl0cy5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDsgLy8gVHJhY2tzIHdoZW4gYW4gdXBkYXRlIG9jY3VycyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSBmYWxzZTsgLy8gVGhhY2tzIHdoZW4gYW4gdXBkYXRlIG9jY3VycyBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gSXQncyBhIHNlcGFyYXRlXG4vLyB2YXJpYWJsZSBmcm9tIHRoZSBvbmUgZm9yIHJlbmRlcnMgYmVjYXVzZSB0aGUgY29tbWl0IHBoYXNlIG1heSBydW5cbi8vIGNvbmN1cnJlbnRseSB0byBhIHJlbmRlciBwaGFzZS5cblxudmFyIGRpZEluY2x1ZGVDb21taXRQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBUaGUgbW9zdCByZWNlbnQgdGltZSB3ZSBlaXRoZXIgY29tbWl0dGVkIGEgZmFsbGJhY2ssIG9yIHdoZW4gYSBmYWxsYmFjayB3YXNcbi8vIGZpbGxlZCBpbiB3aXRoIHRoZSByZXNvbHZlZCBVSS4gVGhpcyBsZXRzIHVzIHRocm90dGxlIHRoZSBhcHBlYXJhbmNlIG9mIG5ld1xuLy8gY29udGVudCBhcyBpdCBzdHJlYW1zIGluLCB0byBtaW5pbWl6ZSBqYW5rLlxuLy8gVE9ETzogVGhpbmsgb2YgYSBiZXR0ZXIgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZT9cblxudmFyIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSAwO1xudmFyIEZBTExCQUNLX1RIUk9UVExFX01TID0gMzAwOyAvLyBUaGUgYWJzb2x1dGUgdGltZSBmb3Igd2hlbiB3ZSBzaG91bGQgc3RhcnQgZ2l2aW5nIHVwIG9uIHJlbmRlcmluZ1xuLy8gbW9yZSBhbmQgcHJlZmVyIENQVSBzdXNwZW5zZSBoZXVyaXN0aWNzIGluc3RlYWQuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gSW5maW5pdHk7IC8vIEhvdyBsb25nIGEgcmVuZGVyIGlzIHN1cHBvc2VkIHRvIHRha2UgYmVmb3JlIHdlIHN0YXJ0IGZvbGxvd2luZyBDUFVcbi8vIHN1c3BlbnNlIGhldXJpc3RpY3MgYW5kIG9wdCBvdXQgb2YgcmVuZGVyaW5nIG1vcmUgY29udGVudC5cblxudmFyIFJFTkRFUl9USU1FT1VUX01TID0gNTAwO1xudmFyIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuXG5mdW5jdGlvbiByZXNldFJlbmRlclRpbWVyKCkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TO1xufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZTtcbn1cbnZhciBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGw7XG52YXIgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG52YXIgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xudmFyIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzID0gW107XG52YXIgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSBOb0xhbmVzO1xudmFyIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsOyAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG5cbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG52YXIgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG59XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcygpIHtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xufVxuZnVuY3Rpb24gaXNXb3JrTG9vcFN1c3BlbmRlZE9uRGF0YSgpIHtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGE7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiYgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gVGhlc2UgYXJlIG5vdCBvZmZpY2lhbGx5IHN1cHBvcnRlZC4gVGhlXG4gICAgLy8gb2xkIGJlaGF2aW9yIGlzIHRvIGdpdmUgdGhpcyB0aGUgc2FtZSBcInRocmVhZFwiIChsYW5lcykgYXNcbiAgICAvLyB3aGF0ZXZlciBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLiBTbyBpZiB5b3UgY2FsbCBgc2V0U3RhdGVgIG9uIGEgY29tcG9uZW50XG4gICAgLy8gdGhhdCBoYXBwZW5zIGxhdGVyIGluIHRoZSBzYW1lIHJlbmRlciwgaXQgd2lsbCBmbHVzaC4gSWRlYWxseSwgd2Ugd2FudCB0b1xuICAgIC8vIHJlbW92ZSB0aGUgc3BlY2lhbCBjYXNlIGFuZCB0cmVhdCB0aGVtIGFzIGlmIHRoZXkgY2FtZSBmcm9tIGFuXG4gICAgLy8gaW50ZXJsZWF2ZWQgZXZlbnQuIFJlZ2FyZGxlc3MsIHRoaXMgcGF0dGVybiBpcyBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuXG4gICAgLy8gVGhpcyBiZWhhdmlvciBpcyBvbmx5IGEgZmFsbGJhY2suIFRoZSBmbGFnIG9ubHkgZXhpc3RzIHVudGlsIHdlIGNhbiByb2xsXG4gICAgLy8gb3V0IHRoZSBzZXRTdGF0ZSB3YXJuaW5nLCBzaW5jZSBleGlzdGluZyBjb2RlIG1pZ2h0IGFjY2lkZW50YWxseSByZWx5IG9uXG4gICAgLy8gdGhlIGN1cnJlbnQgYmVoYXZpb3IuXG4gICAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCk7XG5cbiAgaWYgKHRyYW5zaXRpb24gIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpZiAoIXRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb25TY29wZUxhbmUgPSBwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSgpO1xuICAgIHJldHVybiBhY3Rpb25TY29wZUxhbmUgIT09IE5vTGFuZSA/IC8vIFdlJ3JlIGluc2lkZSBhbiBhc3luYyBhY3Rpb24gc2NvcGUuIFJldXNlIHRoZSBzYW1lIGxhbmUuXG4gICAgYWN0aW9uU2NvcGVMYW5lIDogLy8gV2UgbWF5IG9yIG1heSBub3QgYmUgaW5zaWRlIGFuIGFzeW5jIGFjdGlvbiBzY29wZS4gSWYgd2UgYXJlLCB0aGlzXG4gICAgLy8gaXMgdGhlIGZpcnN0IHVwZGF0ZSBpbiB0aGF0IHNjb3BlLiBFaXRoZXIgd2F5LCB3ZSBuZWVkIHRvIGdldCBhXG4gICAgLy8gZnJlc2ggdHJhbnNpdGlvbiBsYW5lLlxuICAgIHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50UHJpb3JpdHlUb0xhbmUocmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCkpO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0UmV0cnlMYW5lKGZpYmVyKSB7XG5cbiAgcmV0dXJuIGNsYWltTmV4dFJldHJ5TGFuZSgpO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0RGVmZXJyZWRMYW5lKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPT09IE5vTGFuZSkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB1c2VEZWZlcnJlZFZhbHVlIGhvb2tzIGluIHRoZSBzYW1lIHJlbmRlciwgdGhlXG4gICAgLy8gdGFza3MgdGhhdCB0aGV5IHNwYXduIHNob3VsZCBhbGwgYmUgYmF0Y2hlZCB0b2dldGhlciwgc28gdGhleSBzaG91bGQgYWxsXG4gICAgLy8gcmVjZWl2ZSB0aGUgc2FtZSBsYW5lLlxuICAgIC8vIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgY3VycmVudCByZW5kZXIgdG8gZGVjaWRlIHRoZSBwcmlvcml0eSBvZiB0aGVcbiAgICAvLyBkZWZlcnJlZCB0YXNrLlxuICAgIC8vIE9mZnNjcmVlbkxhbmUgaXMgdXNlZCBmb3IgcHJlcmVuZGVyaW5nLCBidXQgd2UgYWxzbyB1c2UgT2Zmc2NyZWVuTGFuZVxuICAgIC8vIGZvciBpbmNyZW1lbnRhbCBoeWRyYXRpb24uIEl0J3MgZ2l2ZW4gdGhlIGxvd2VzdCBwcmlvcml0eSBiZWNhdXNlIHRoZVxuICAgIC8vIGluaXRpYWwgSFRNTCBpcyB0aGUgc2FtZSBhcyB0aGUgZmluYWwgVUkuIEJ1dCB1c2VEZWZlcnJlZFZhbHVlIGR1cmluZ1xuICAgIC8vIGh5ZHJhdGlvbiBpcyBhbiBleGNlcHRpb24g4oCUIHdlIG5lZWQgdG8gdXBncmFkZSB0aGUgVUkgdG8gdGhlIGZpbmFsXG4gICAgLy8gdmFsdWUuIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHdlIHRyZWF0IGl0IGxpa2UgYSB0cmFuc2l0aW9uLlxuICAgIHZhciBpc1ByZXJlbmRlcmluZyA9IGluY2x1ZGVzU29tZUxhbmUod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpICYmICFnZXRJc0h5ZHJhdGluZygpO1xuXG4gICAgaWYgKGlzUHJlcmVuZGVyaW5nKSB7XG4gICAgICAvLyBUaGVyZSdzIG9ubHkgb25lIE9mZnNjcmVlbkxhbmUsIHNvIGlmIGl0IGNvbnRhaW5zIGRlZmVycmVkIHdvcmssIHdlXG4gICAgICAvLyBzaG91bGQganVzdCByZXNjaGVkdWxlIHVzaW5nIHRoZSBzYW1lIGxhbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9IE9mZnNjcmVlbkxhbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBzcGF3bmVkIGFzIGEgdHJhbnNpdGlvbi5cbiAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICB9XG4gIH0gLy8gTWFyayB0aGUgcGFyZW50IFN1c3BlbnNlIGJvdW5kYXJ5IHNvIGl0IGtub3dzIHRvIHNwYXduIHRoZSBkZWZlcnJlZCBsYW5lLlxuXG5cbiAgdmFyIHN1c3BlbnNlSGFuZGxlciA9IGdldFN1c3BlbnNlSGFuZGxlcigpO1xuXG4gIGlmIChzdXNwZW5zZUhhbmRsZXIgIT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBBcyBhbiBvcHRpbWl6YXRpb24sIHdlIHNob3VsZG4ndCBlbnRhbmdsZSB0aGUgbGFuZXMgYXQgdGhlIHJvb3Q7IHdlXG4gICAgLy8gY2FuIGVudGFuZ2xlIHRoZW0gdXNpbmcgdGhlIGJhc2VMYW5lcyBvZiB0aGUgU3VzcGVuc2UgYm91bmRhcnkgaW5zdGVhZC5cbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gZG8gc29tZXRoaW5nIHNwZWNpYWwgaWYgdGhlcmUncyBubyBTdXNwZW5zZSBib3VuZGFyeS5cbiAgICBzdXNwZW5zZUhhbmRsZXIuZmxhZ3MgfD0gRGlkRGVmZXI7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmU7XG59XG5mdW5jdGlvbiBwZWVrRGVmZXJyZWRMYW5lKCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmU7XG59XG5mdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QpIHtcbiAgICAgIGVycm9yKCd1c2VJbnNlcnRpb25FZmZlY3QgbXVzdCBub3Qgc2NoZWR1bGUgdXBkYXRlcy4nKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cykge1xuICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgfVxuICB9IC8vIENoZWNrIGlmIHRoZSB3b3JrIGxvb3AgaXMgY3VycmVudGx5IHN1c3BlbmRlZCBhbmQgd2FpdGluZyBmb3IgZGF0YSB0b1xuICAvLyBmaW5pc2ggbG9hZGluZy5cblxuXG4gIGlmICggLy8gU3VzcGVuZGVkIHJlbmRlciBwaGFzZVxuICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiYgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSB8fCAvLyBTdXNwZW5kZWQgY29tbWl0IHBoYXNlXG4gIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSBpbmNvbWluZyB1cGRhdGUgbWlnaHQgdW5ibG9jayB0aGUgY3VycmVudCByZW5kZXIuIEludGVycnVwdCB0aGVcbiAgICAvLyBjdXJyZW50IGF0dGVtcHQgYW5kIHJlc3RhcnQgZnJvbSB0aGUgdG9wLlxuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gIH0gLy8gTWFyayB0aGF0IHRoZSByb290IGhhcyBhIHBlbmRpbmcgdXBkYXRlLlxuXG5cbiAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIGxhbmUpO1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0xhbmVzICYmIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFRoaXMgdXBkYXRlIHdhcyBkaXNwYXRjaGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGlzIGlzIGEgbWlzdGFrZVxuICAgIC8vIGlmIHRoZSB1cGRhdGUgb3JpZ2luYXRlcyBmcm9tIHVzZXIgc3BhY2UgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBsb2NhbFxuICAgIC8vIGhvb2sgdXBkYXRlcywgd2hpY2ggYXJlIGhhbmRsZWQgZGlmZmVyZW50bHkgYW5kIGRvbid0IHJlYWNoIHRoaXNcbiAgICAvLyBmdW5jdGlvbiksIGJ1dCB0aGVyZSBhcmUgc29tZSBpbnRlcm5hbCBSZWFjdCBmZWF0dXJlcyB0aGF0IHVzZSB0aGlzIGFzXG4gICAgLy8gYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLCBsaWtlIHNlbGVjdGl2ZSBoeWRyYXRpb24uXG4gICAgd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpOyAvLyBUcmFjayBsYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBub3JtYWwgdXBkYXRlLCBzY2hlZHVsZWQgZnJvbSBvdXRzaWRlIHRoZSByZW5kZXIgcGhhc2UuIEZvclxuICAgIC8vIGV4YW1wbGUsIGR1cmluZyBhbiBpbnB1dCBldmVudC5cbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpO1xuXG4gICAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgICAgLy8gUmVjZWl2ZWQgYW4gdXBkYXRlIHRvIGEgdHJlZSB0aGF0J3MgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcuIE1hcmtcbiAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC5cbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpIHtcbiAgICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgICAvLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcbiAgICAgICAgLy8gc3VzcGVuZGVkIG5vdywgcmlnaHQgYmVmb3JlIG1hcmtpbmcgdGhlIGluY29taW5nIHVwZGF0ZS4gVGhpcyBoYXMgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuICAgICAgICAvLyBhbHJlYWR5IHN0YXJ0ZWQgcmVuZGVyaW5nLlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcblxuICAgIGlmIChsYW5lID09PSBTeW5jTGFuZSAmJiBleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQgJiYgIWRpc2FibGVMZWdhY3lNb2RlICYmIChmaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5pc0JhdGNoaW5nTGVnYWN5KSA7IGVsc2Uge1xuICAgICAgICAvLyBGbHVzaCB0aGUgc3luY2hyb25vdXMgd29yayBub3csIHVubGVzcyB3ZSdyZSBhbHJlYWR5IHdvcmtpbmcgb3IgaW5zaWRlXG4gICAgICAgIC8vIGEgYmF0Y2guIFRoaXMgaXMgaW50ZW50aW9uYWxseSBpbnNpZGUgc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gc2NoZWR1bGVDYWxsYmFja0ZvckZpYmVyIHRvIHByZXNlcnZlIHRoZSBhYmlsaXR5IHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgLy8gd2l0aG91dCBpbW1lZGlhdGVseSBmbHVzaGluZyBpdC4gV2Ugb25seSBkbyB0aGlzIGZvciB1c2VyLWluaXRpYXRlZFxuICAgICAgICAvLyB1cGRhdGVzLCB0byBwcmVzZXJ2ZSBoaXN0b3JpY2FsIGJlaGF2aW9yIG9mIGxlZ2FjeSBtb2RlLlxuICAgICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzY2hlZHVsZUluaXRpYWxIeWRyYXRpb25PblJvb3Qocm9vdCwgbGFuZSkge1xuICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBmb3JrIG9mIHNjaGVkdWxlVXBkYXRlT25GaWJlciB0aGF0IGlzIG9ubHkgdXNlZCB0b1xuICAvLyBzY2hlZHVsZSB0aGUgaW5pdGlhbCBoeWRyYXRpb24gb2YgYSByb290IHRoYXQgaGFzIGp1c3QgYmVlbiBjcmVhdGVkLiBNb3N0XG4gIC8vIG9mIHRoZSBzdHVmZiBpbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgY2FuIGJlIHNraXBwZWQuXG4gIC8vXG4gIC8vIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBzZXBhcmF0ZSBwYXRoLCB0aG91Z2gsIGlzIHRvIGRpc3Rpbmd1aXNoIHRoZVxuICAvLyBpbml0aWFsIGNoaWxkcmVuIGZyb20gc3Vic2VxdWVudCB1cGRhdGVzLiBJbiBmdWxseSBjbGllbnQtcmVuZGVyZWQgcm9vdHNcbiAgLy8gKGNyZWF0ZVJvb3QgaW5zdGVhZCBvZiBoeWRyYXRlUm9vdCksIGFsbCB0b3AtbGV2ZWwgcmVuZGVycyBhcmUgbW9kZWxlZCBhc1xuICAvLyB1cGRhdGVzLCBidXQgaHlkcmF0aW9uIHJvb3RzIGFyZSBzcGVjaWFsIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3RcbiAgLy8gbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gIGN1cnJlbnQubGFuZXMgPSBsYW5lO1xuICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSk7XG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbn1cbmZ1bmN0aW9uIGlzVW5zYWZlQ2xhc3NSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gT25seSBjYWxsZWQgYnkgY2xhc3MgY29tcG9uZW50cyxcbiAgLy8gd2hpY2ggc3BlY2lhbCAoZGVwcmVjYXRlZCkgYmVoYXZpb3IgZm9yIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZSBwcm9wcy5cbiAgcmV0dXJuIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dDtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuXG5mdW5jdGlvbiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3Qocm9vdCwgZGlkVGltZW91dCkge1xuICB7XG4gICAgcmVzZXROZXN0ZWRVcGRhdGVGbGFnKCk7XG4gIH1cblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfSAvLyBGbHVzaCBhbnkgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYmVmb3JlIGRlY2lkaW5nIHdoaWNoIGxhbmVzIHRvIHdvcmsgb24sXG4gIC8vIGluIGNhc2UgdGhleSBzY2hlZHVsZSBhZGRpdGlvbmFsIHdvcmsuXG5cblxuICB2YXIgb3JpZ2luYWxDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgdmFyIGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG5cbiAgaWYgKGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBTb21ldGhpbmcgaW4gdGhlIHBhc3NpdmUgZWZmZWN0IHBoYXNlIG1heSBoYXZlIGNhbmNlbGVkIHRoZSBjdXJyZW50IHRhc2suXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRhc2sgbm9kZSBmb3IgdGhpcyByb290IHdhcyBjaGFuZ2VkLlxuICAgIGlmIChyb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRhc2sgd2FzIGNhbmNlbGVkLiBFeGl0LiBXZSBkb24ndCBuZWVkIHRvIGNhbGxcbiAgICAgIC8vIGBlbnN1cmVSb290SXNTY2hlZHVsZWRgIGJlY2F1c2UgdGhlIGNoZWNrIGFib3ZlIGltcGxpZXMgZWl0aGVyIHRoYXRcbiAgICAgIC8vIHRoZXJlJ3MgYSBuZXcgdGFzaywgb3IgdGhhdCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbiAgLy8gb24gdGhlIHJvb3QuXG4gIC8vIFRPRE86IFRoaXMgd2FzIGFscmVhZHkgY29tcHV0ZWQgaW4gdGhlIGNhbGxlci4gUGFzcyBpdCBhcyBhbiBhcmd1bWVudC5cblxuXG4gIHZhciBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIERlZmVuc2l2ZSBjb2RpbmcuIFRoaXMgaXMgbmV2ZXIgZXhwZWN0ZWQgdG8gaGFwcGVuLlxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFdlIGRpc2FibGUgdGltZS1zbGljaW5nIGluIHNvbWUgY2FzZXM6IGlmIHRoZSB3b3JrIGhhcyBiZWVuIENQVS1ib3VuZFxuICAvLyBmb3IgdG9vIGxvbmcgKFwiZXhwaXJlZFwiIHdvcmssIHRvIHByZXZlbnQgc3RhcnZhdGlvbiksIG9yIHdlJ3JlIGluXG4gIC8vIHN5bmMtdXBkYXRlcy1ieS1kZWZhdWx0IG1vZGUuXG4gIC8vIFRPRE86IFdlIG9ubHkgY2hlY2sgYGRpZFRpbWVvdXRgIGRlZmVuc2l2ZWx5LCB0byBhY2NvdW50IGZvciBhIFNjaGVkdWxlclxuICAvLyBidWcgd2UncmUgc3RpbGwgaW52ZXN0aWdhdGluZy4gT25jZSB0aGUgYnVnIGluIFNjaGVkdWxlciBpcyBmaXhlZCxcbiAgLy8gd2UgY2FuIHJlbW92ZSB0aGlzLCBzaW5jZSB3ZSB0cmFjayBleHBpcmF0aW9uIG91cnNlbHZlcy5cblxuXG4gIHZhciBzaG91bGRUaW1lU2xpY2UgPSAhaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgbGFuZXMpICYmICFpbmNsdWRlc0V4cGlyZWRMYW5lKHJvb3QsIGxhbmVzKSAmJiAoIWRpZFRpbWVvdXQpO1xuICB2YXIgZXhpdFN0YXR1cyA9IHNob3VsZFRpbWVTbGljZSA/IHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSA6IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuICBpZiAoZXhpdFN0YXR1cyAhPT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVuZGVyV2FzQ29uY3VycmVudCA9IHNob3VsZFRpbWVTbGljZTtcblxuICAgIGRvIHtcbiAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RGlkTm90Q29tcGxldGUpIHtcbiAgICAgICAgLy8gVGhlIHJlbmRlciB1bndvdW5kIHdpdGhvdXQgY29tcGxldGluZyB0aGUgdHJlZS4gVGhpcyBoYXBwZW5zIGluIHNwZWNpYWxcbiAgICAgICAgLy8gY2FzZXMgd2hlcmUgbmVlZCB0byBleGl0IHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHByb2R1Y2luZyBhXG4gICAgICAgIC8vIGNvbnNpc3RlbnQgdHJlZSBvciBjb21taXR0aW5nLlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgTm9MYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSByZW5kZXIgY29tcGxldGVkLlxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHJlbmRlciBtYXkgaGF2ZSB5aWVsZGVkIHRvIGEgY29uY3VycmVudCBldmVudCwgYW5kIGlmIHNvLFxuICAgICAgICAvLyBjb25maXJtIHRoYXQgYW55IG5ld2x5IHJlbmRlcmVkIHN0b3JlcyBhcmUgY29uc2lzdGVudC5cbiAgICAgICAgLy8gVE9ETzogSXQncyBwb3NzaWJsZSB0aGF0IGV2ZW4gYSBjb25jdXJyZW50IHJlbmRlciBtYXkgbmV2ZXIgaGF2ZSB5aWVsZGVkXG4gICAgICAgIC8vIHRvIHRoZSBtYWluIHRocmVhZCwgaWYgaXQgd2FzIGZhc3QgZW5vdWdoLCBvciBpZiBpdCBleHBpcmVkLiBXZSBjb3VsZFxuICAgICAgICAvLyBza2lwIHRoZSBjb25zaXN0ZW5jeSBjaGVjayBpbiB0aGF0IGNhc2UsIHRvby5cbiAgICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlcldhc0NvbmN1cnJlbnQgJiYgIWlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyhmaW5pc2hlZFdvcmspKSB7XG4gICAgICAgICAgLy8gQSBzdG9yZSB3YXMgbXV0YXRlZCBpbiBhbiBpbnRlcmxlYXZlZCBldmVudC4gUmVuZGVyIGFnYWluLFxuICAgICAgICAgIC8vIHN5bmNocm9ub3VzbHksIHRvIGJsb2NrIGZ1cnRoZXIgbXV0YXRpb25zLlxuICAgICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7IC8vIFdlIGFzc3VtZSB0aGUgdHJlZSBpcyBub3cgY29uc2lzdGVudCBiZWNhdXNlIHdlIGRpZG4ndCB5aWVsZCB0byBhbnlcbiAgICAgICAgICAvLyBjb25jdXJyZW50IGV2ZW50cy5cblxuICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBmYWxzZTsgLy8gTmVlZCB0byBjaGVjayB0aGUgZXhpdCBzdGF0dXMgYWdhaW4uXG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBDaGVjayBpZiBzb21ldGhpbmcgdGhyZXdcblxuXG4gICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgIHZhciBsYW5lc1RoYXRKdXN0RXJyb3JlZCA9IGxhbmVzO1xuICAgICAgICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290LCBsYW5lc1RoYXRKdXN0RXJyb3JlZCk7XG5cbiAgICAgICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgICAgICBsYW5lcyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBsYW5lc1RoYXRKdXN0RXJyb3JlZCwgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBmYWxzZTsgLy8gTmVlZCB0byBjaGVjayB0aGUgZXhpdCBzdGF0dXMgYWdhaW4uXG5cbiAgICAgICAgICAgIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgICAvLyBUaGUgcm9vdCBkaWQgbm90IGVycm9yIHRoaXMgdGltZS4gUmVzdGFydCB0aGUgZXhpdCBhbGdvcml0aG1cbiAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGUgZXhpdCBhbGdvcml0aG0gdG8gYmUgbGVzcyBjb25mdXNpbmcuIE1heWJlXG4gICAgICAgICAgICAgIC8vIG1vcmUgYnJhbmNoZXMgKyByZWN1cnNpb24gaW5zdGVhZCBvZiBhIGxvb3AuIEkgdGhpbmsgdGhlIG9ubHlcbiAgICAgICAgICAgICAgLy8gdGhpbmcgdGhhdCBjYXVzZXMgaXQgdG8gYmUgYSBsb29wIGlzIHRoZSBSb290RGlkTm90Q29tcGxldGVcbiAgICAgICAgICAgICAgLy8gY2hlY2suIElmIHRoYXQncyB0cnVlLCB0aGVuIHdlIGRvbid0IG5lZWQgYSBsb29wL3JlY3Vyc2lvblxuICAgICAgICAgICAgICAvLyBhdCBhbGwuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIE5vTGFuZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIFRoZSBuZXh0IHN0ZXAgaXMgZWl0aGVyIHRvIGNvbW1pdCBpdCxcbiAgICAgICAgLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cblxuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICAgICAgICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgICAgICAgZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gIHJldHVybiBnZXRDb250aW51YXRpb25Gb3JSb290KHJvb3QsIG9yaWdpbmFsQ2FsbGJhY2tOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzLCBlcnJvclJldHJ5TGFuZXMpIHtcbiAgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbiwgZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGxcbiAgLy8gYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG4gIC8vIEJlZm9yZSByZW5kZXJpbmcgYWdhaW4sIHNhdmUgdGhlIGVycm9ycyBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LlxuICB2YXIgZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdCA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7XG4gIHZhciB3YXNSb290RGVoeWRyYXRlZCA9IHN1cHBvcnRzSHlkcmF0aW9uICYmIGlzUm9vdERlaHlkcmF0ZWQocm9vdCk7XG5cbiAgaWYgKHdhc1Jvb3REZWh5ZHJhdGVkKSB7XG4gICAgLy8gVGhlIHNoZWxsIGZhaWxlZCB0byBoeWRyYXRlLiBTZXQgYSBmbGFnIHRvIGZvcmNlIGEgY2xpZW50IHJlbmRlcmluZ1xuICAgIC8vIGR1cmluZyB0aGUgbmV4dCBhdHRlbXB0LiBUbyBkbyB0aGlzLCB3ZSBjYWxsIHByZXBhcmVGcmVzaFN0YWNrIG5vd1xuICAgIC8vIHRvIGNyZWF0ZSB0aGUgcm9vdCB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBUaGlzIGlzIGEgYml0IHdlaXJkIGluIHRlcm1zXG4gICAgLy8gb2YgZmFjdG9yaW5nLCBiZWNhdXNlIGl0IHJlbGllcyBvbiByZW5kZXJSb290U3luYyBub3QgY2FsbGluZ1xuICAgIC8vIHByZXBhcmVGcmVzaFN0YWNrIGFnYWluIGluIHRoZSBjYWxsIGJlbG93LCB3aGljaCBoYXBwZW5zIGJlY2F1c2UgdGhlXG4gICAgLy8gcm9vdCBhbmQgbGFuZXMgaGF2ZW4ndCBjaGFuZ2VkLlxuICAgIC8vXG4gICAgLy8gVE9ETzogSSB0aGluayB3aGF0IHdlIHNob3VsZCBkbyBpcyBzZXQgRm9yY2VDbGllbnRSZW5kZXIgaW5zaWRlXG4gICAgLy8gdGhyb3dFeGNlcHRpb24sIGxpa2Ugd2UgZG8gZm9yIG5lc3RlZCBTdXNwZW5zZSBib3VuZGFyaWVzLiBUaGUgcmVhc29uXG4gICAgLy8gaXQncyBoZXJlIGluc3RlYWQgaXMgc28gd2UgY2FuIHN3aXRjaCB0byB0aGUgc3luY2hyb25vdXMgd29yayBsb29wLCB0b28uXG4gICAgLy8gU29tZXRoaW5nIHRvIGNvbnNpZGVyIGZvciBhIGZ1dHVyZSByZWZhY3Rvci5cbiAgICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICByb290V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXI7XG4gIH1cblxuICB2YXIgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG5cbiAgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RFcnJvcmVkKSB7XG4gICAgLy8gU3VjY2Vzc2Z1bGx5IGZpbmlzaGVkIHJlbmRlcmluZyBvbiByZXRyeVxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgJiYgIXdhc1Jvb3REZWh5ZHJhdGVkKSB7XG4gICAgICAvLyBEdXJpbmcgdGhlIHN5bmNocm9ub3VzIHJlbmRlciwgd2UgYXR0YWNoZWQgYWRkaXRpb25hbCBwaW5nIGxpc3RlbmVycy5cbiAgICAgIC8vIFRoaXMgaXMgaGlnaGx5IHN1Z2dlc3RpdmUgb2YgYW4gdW5jYWNoZWQgcHJvbWlzZSAodGhvdWdoIGl0J3Mgbm90IHRoZVxuICAgICAgLy8gb25seSByZWFzb24gdGhpcyB3b3VsZCBoYXBwZW4pLiBJZiBpdCB3YXMgYW4gdW5jYWNoZWQgcHJvbWlzZSwgdGhlblxuICAgICAgLy8gaXQgbWF5IGhhdmUgbWFza2VkIGEgZG93bnN0cmVhbSBlcnJvciBmcm9tIG9jdXJyaW5nIHdpdGhvdXQgYWN0dWFsbHlcbiAgICAgIC8vIGZpeGluZyBpdC4gRXhhbXBsZTpcbiAgICAgIC8vXG4gICAgICAvLyAgICB1c2UoUHJvbWlzZS5yZXNvbHZlKCd1bmNhY2hlZCcpKVxuICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKCdPb3BzIScpXG4gICAgICAvL1xuICAgICAgLy8gV2hlbiB0aGlzIGhhcHBlbnMsIHRoZXJlJ3MgYSBjb25mbGljdCBiZXR3ZWVuIGJsb2NraW5nIHBvdGVudGlhbFxuICAgICAgLy8gY29uY3VycmVudCBkYXRhIHJhY2VzIGFuZCB1bndyYXBwaW5nIHVuY2FjaGVkIHByb21pc2UgdmFsdWVzLiBXZVxuICAgICAgLy8gaGF2ZSB0byBjaG9vc2Ugb25lIG9yIHRoZSBvdGhlci4gQmVjYXVzZSB0aGUgZGF0YSByYWNlIHJlY292ZXJ5IGlzXG4gICAgICAvLyBhIGxhc3QgZGl0Y2ggZWZmb3J0LCB3ZSdsbCBkaXNhYmxlIGl0LlxuICAgICAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyA9IG1lcmdlTGFuZXMocm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcywgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzKTsgLy8gTWFyayB0aGUgY3VycmVudCByZW5kZXIgYXMgc3VzcGVuZGVkIGFuZCBmb3JjZSBpdCB0byByZXN0YXJ0LiBPbmNlXG4gICAgICAvLyB0aGVzZSBsYW5lcyBmaW5pc2ggc3VjY2Vzc2Z1bGx5LCB3ZSdsbCByZS1lbmFibGUgdGhlIGVycm9yIHJlY292ZXJ5XG4gICAgICAvLyBtZWNoYW5pc20gZm9yIHN1YnNlcXVlbnQgdXBkYXRlcy5cblxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgfD0gb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzO1xuICAgICAgcmV0dXJuIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gICAgfSAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIGZhaWxlZCBmaXJzdCBhdHRlbXB0IGhhdmUgYmVlbiByZWNvdmVyZWQuIEFkZFxuICAgIC8vIHRoZW0gdG8gdGhlIGNvbGxlY3Rpb24gb2YgcmVjb3ZlcmFibGUgZXJyb3JzLiBXZSdsbCBsb2cgdGhlbSBpbiB0aGVcbiAgICAvLyBjb21taXQgcGhhc2UuXG5cblxuICAgIHZhciBlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCA9IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdDsgLy8gVGhlIGVycm9ycyBmcm9tIHRoZSBzZWNvbmQgYXR0ZW1wdCBzaG91bGQgYmUgcXVldWVkIGFmdGVyIHRoZSBlcnJvcnNcbiAgICAvLyBmcm9tIHRoZSBmaXJzdCBhdHRlbXB0LCB0byBwcmVzZXJ2ZSB0aGUgY2F1c2FsIHNlcXVlbmNlLlxuXG4gICAgaWYgKGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0ICE9PSBudWxsKSB7XG4gICAgICBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhpdFN0YXR1cztcbn1cblxuZnVuY3Rpb24gcXVldWVSZWNvdmVyYWJsZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnM7XG4gIH0gZWxzZSB7XG4gICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLnB1c2guYXBwbHkod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBmaW5pc2hlZFdvcmssIGxhbmVzKSB7XG4gIC8vIFRPRE86IFRoZSBmYWN0IHRoYXQgbW9zdCBvZiB0aGVzZSBicmFuY2hlcyBhcmUgaWRlbnRpY2FsIHN1Z2dlc3RzIHRoYXQgc29tZVxuICAvLyBvZiB0aGUgZXhpdCBzdGF0dXNlcyBhcmUgbm90IGJlc3QgbW9kZWxlZCBhcyBleGl0IHN0YXR1c2VzIGFuZCBzaG91bGQgYmVcbiAgLy8gdHJhY2tlZCBvcnRob2dvbmFsbHkuXG4gIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuICAgIGNhc2UgUm9vdEluUHJvZ3Jlc3M6XG4gICAgY2FzZSBSb290RmF0YWxFcnJvcmVkOlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdFN1c3BlbmRlZFdpdGhEZWxheTpcbiAgICAgIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSB0cmFuc2l0aW9uLCBzbyB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IGNvbW1pdHRpbmcgYVxuICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIGFuZCB3aXRob3V0IHNjaGVkdWxpbmcgYSB0aW1lb3V0LiBEZWxheSBpbmRlZmluaXRlbHlcbiAgICAgICAgICAvLyB1bnRpbCB3ZSByZWNlaXZlIG1vcmUgZGF0YS5cbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDb21taXQgdGhlIHBsYWNlaG9sZGVyLlxuXG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RFcnJvcmVkOlxuICAgICAge1xuICAgICAgICAvLyBUaGlzIHJlbmRlciBlcnJvcmVkLiBJZ25vcmUgYW55IHJlY292ZXJhYmxlIGVycm9ycyBiZWNhdXNlIHdlIHdlcmVuJ3QgYWN0dWFsbHlcbiAgICAgICAgLy8gYWJsZSB0byByZWNvdmVyLiBJbnN0ZWFkLCB3aGF0ZXZlciB0aGUgZmluYWwgZXJyb3JzIHdlcmUgaXMgdGhlIG9uZXMgd2UgbG9nLlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBvbmx5IGxvZyB0aGUgYWN0dWFsIGNsaWVudCBzaWRlIGVycm9yIGlmIGl0J3MganVzdCBhIHBsYWluXG4gICAgICAgIC8vIGVycm9yIHRocm93biBmcm9tIGEgY29tcG9uZW50IG9uIHRoZSBzZXJ2ZXIgYW5kIHRoZSBjbGllbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgY2FzZSBSb290Q29tcGxldGVkOlxuICAgICAge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biByb290IGV4aXQgc3RhdHVzLicpO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgLy8gV2UncmUgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLiBDb21taXQgaW1tZWRpYXRlbHkuXG4gICAgY29tbWl0Um9vdChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucywgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSwgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSAmJiAoYWx3YXlzVGhyb3R0bGVSZXRyaWVzICkpIHtcbiAgICAgIC8vIFRoaXMgcmVuZGVyIG9ubHkgaW5jbHVkZWQgcmV0cmllcywgbm8gdXBkYXRlcy4gVGhyb3R0bGUgY29tbWl0dGluZ1xuICAgICAgLy8gcmV0cmllcyBzbyB0aGF0IHdlIGRvbid0IHNob3cgdG9vIG1hbnkgbG9hZGluZyBzdGF0ZXMgdG9vIHF1aWNrbHkuXG4gICAgICB2YXIgbXNVbnRpbFRpbWVvdXQgPSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICsgRkFMTEJBQ0tfVEhST1RUTEVfTVMgLSBub3ckMSgpOyAvLyBEb24ndCBib3RoZXIgd2l0aCBhIHZlcnkgc2hvcnQgc3VzcGVuc2UgdGltZS5cblxuICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgICAgICAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcblxuICAgICAgICBpZiAobmV4dExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgd2UgY2FuIGRvIG9uIHRoaXMgcm9vdC4gV2UgbWlnaHQgYXMgd2VsbFxuICAgICAgICAgIC8vIGF0dGVtcHQgdG8gd29yayBvbiB0aGF0IHdoaWxlIHdlJ3JlIHN1c3BlbmRlZC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVGhlIHJlbmRlciBpcyBzdXNwZW5kZWQsIGl0IGhhc24ndCB0aW1lZCBvdXQsIGFuZCB0aGVyZSdzIG5vXG4gICAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHdvcmsgdG8gZG8uIEluc3RlYWQgb2YgY29tbWl0dGluZyB0aGUgZmFsbGJhY2tcbiAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG4gICAgICAgIC8vIFRPRE86IENvbWJpbmUgcmV0cnkgdGhyb3R0bGluZyB3aXRoIFN1c3BlbnNleSBjb21taXRzLiBSaWdodCBub3cgdGhleVxuICAgICAgICAvLyBydW4gb25lIGFmdGVyIHRoZSBvdGhlci5cblxuXG4gICAgICAgIHJvb3QudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChjb21taXRSb290V2hlblJlYWR5LmJpbmQobnVsbCwgcm9vdCwgZmluaXNoZWRXb3JrLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucywgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSwgbGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKSwgbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tbWl0Um9vdFdoZW5SZWFkeShyb290LCBmaW5pc2hlZFdvcmssIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLCB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLCBsYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3RXaGVuUmVhZHkocm9vdCwgZmluaXNoZWRXb3JrLCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSwgbGFuZXMsIHNwYXduZWRMYW5lKSB7XG4gIC8vIFRPRE86IENvbWJpbmUgcmV0cnkgdGhyb3R0bGluZyB3aXRoIFN1c3BlbnNleSBjb21taXRzLiBSaWdodCBub3cgdGhleSBydW5cbiAgLy8gb25lIGFmdGVyIHRoZSBvdGhlci5cbiAgdmFyIEJvdGhWaXNpYmlsaXR5QW5kTWF5U3VzcGVuZENvbW1pdCA9IFZpc2liaWxpdHkgfCBNYXlTdXNwZW5kQ29tbWl0O1xuICB2YXIgc3VidHJlZUZsYWdzID0gZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncztcblxuICBpZiAoc3VidHJlZUZsYWdzICYgU2hvdWxkU3VzcGVuZENvbW1pdCB8fCAoc3VidHJlZUZsYWdzICYgQm90aFZpc2liaWxpdHlBbmRNYXlTdXNwZW5kQ29tbWl0KSA9PT0gQm90aFZpc2liaWxpdHlBbmRNYXlTdXNwZW5kQ29tbWl0KSB7XG4gICAgLy8gQmVmb3JlIGNvbW1pdHRpbmcsIGFzayB0aGUgcmVuZGVyZXIgd2hldGhlciB0aGUgaG9zdCB0cmVlIGlzIHJlYWR5LlxuICAgIC8vIElmIGl0J3Mgbm90LCB3ZSdsbCB3YWl0IHVudGlsIGl0IG5vdGlmaWVzIHVzLlxuICAgIHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCgpOyAvLyBUaGlzIHdpbGwgd2FsayB0aGUgY29tcGxldGVkIGZpYmVyIHRyZWUgYW5kIGF0dGFjaCBsaXN0ZW5lcnMgdG8gYWxsXG4gICAgLy8gdGhlIHN1c3BlbnNleSByZXNvdXJjZXMuIFRoZSByZW5kZXJlciBpcyByZXNwb25zaWJsZSBmb3IgYWNjdW11bGF0aW5nXG4gICAgLy8gYWxsIHRoZSBsb2FkIGV2ZW50cy4gVGhpcyBhbGwgaGFwcGVucyBpbiBhIHNpbmdsZSBzeW5jaHJvbm91c1xuICAgIC8vIHRyYW5zYWN0aW9uLCBzbyBpdCB0cmFjayBzdGF0ZSBpbiBpdHMgb3duIG1vZHVsZSBzY29wZS5cblxuICAgIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmluaXNoZWRXb3JrKTsgLy8gQXQgdGhlIGVuZCwgYXNrIHRoZSByZW5kZXJlciBpZiBpdCdzIHJlYWR5IHRvIGNvbW1pdCwgb3IgaWYgd2Ugc2hvdWxkXG4gICAgLy8gc3VzcGVuZC4gSWYgaXQncyBub3QgcmVhZHksIGl0IHdpbGwgcmV0dXJuIGEgY2FsbGJhY2sgdG8gc3Vic2NyaWJlIHRvXG4gICAgLy8gYSByZWFkeSBldmVudC5cblxuICAgIHZhciBzY2hlZHVsZVBlbmRpbmdDb21taXQgPSB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5KCk7XG5cbiAgICBpZiAoc2NoZWR1bGVQZW5kaW5nQ29tbWl0ICE9PSBudWxsKSB7XG4gICAgICAvLyBOT1RFOiB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5IHJldHVybnMgYSBzdWJzY3JpYmUgZnVuY3Rpb24gc28gdGhhdCB3ZVxuICAgICAgLy8gb25seSBhbGxvY2F0ZSBhIGZ1bmN0aW9uIGlmIHRoZSBjb21taXQgaXNuJ3QgcmVhZHkgeWV0LiBUaGUgb3RoZXJcbiAgICAgIC8vIHBhdHRlcm4gd291bGQgYmUgdG8gYWx3YXlzIHBhc3MgYSBjYWxsYmFjayB0byB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5LlxuICAgICAgLy8gTm90IHlldCByZWFkeSB0byBjb21taXQuIERlbGF5IHRoZSBjb21taXQgdW50aWwgdGhlIHJlbmRlcmVyIG5vdGlmaWVzXG4gICAgICAvLyB1cyB0aGF0IGl0J3MgcmVhZHkuIFRoaXMgd2lsbCBiZSBjYW5jZWxlZCBpZiB3ZSBzdGFydCB3b3JrIG9uIHRoZVxuICAgICAgLy8gcm9vdCBhZ2Fpbi5cbiAgICAgIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IHNjaGVkdWxlUGVuZGluZ0NvbW1pdChjb21taXRSb290LmJpbmQobnVsbCwgcm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zLCBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpKTtcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCBzcGF3bmVkTGFuZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIE90aGVyd2lzZSwgY29tbWl0IGltbWVkaWF0ZWx5LlxuXG5cbiAgY29tbWl0Um9vdChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSwgc3Bhd25lZExhbmUpO1xufVxuXG5mdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFNlYXJjaCB0aGUgcmVuZGVyZWQgdHJlZSBmb3IgZXh0ZXJuYWwgc3RvcmUgcmVhZHMsIGFuZCBjaGVjayB3aGV0aGVyIHRoZVxuICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkIGluIGEgY29uY3VycmVudCBldmVudC4gSW50ZW50aW9uYWxseSB1c2luZyBhbiBpdGVyYXRpdmVcbiAgLy8gbG9vcCBpbnN0ZWFkIG9mIHJlY3Vyc2lvbiBzbyB3ZSBjYW4gZXhpdCBlYXJseS5cbiAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS5mbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kpIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IG5vZGUudXBkYXRlUXVldWU7XG5cbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gdXBkYXRlUXVldWUuc3RvcmVzO1xuXG4gICAgICAgIGlmIChjaGVja3MgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gY2hlY2tzW2ldO1xuICAgICAgICAgICAgdmFyIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRWYWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIHJlbmRlcmVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gaW5jb25zaXN0ZW50IHN0b3JlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYGdldFNuYXBzaG90YCB0aHJvd3MsIHJldHVybiBgZmFsc2VgLiBUaGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgICAgICAgICAgLy8gYSByZS1yZW5kZXIsIGFuZCB0aGUgZXJyb3Igd2lsbCBiZSByZXRocm93biBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9IC8vIEZsb3cgZG9lc24ndCBrbm93IHRoaXMgaXMgdW5yZWFjaGFibGUsIGJ1dCBlc2xpbnQgZG9lc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcblxuXG4gIHJldHVybiB0cnVlO1xufSAvLyBUaGUgZXh0cmEgaW5kaXJlY3Rpb25zIGFyb3VuZCBtYXJrUm9vdFVwZGF0ZWQgYW5kIG1hcmtSb290U3VzcGVuZGVkIGlzXG4vLyBuZWVkZWQgdG8gYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gdGhpcyBtb2R1bGUgYW5kXG4vLyBSZWFjdEZpYmVyTGFuZS4gVGhlcmUncyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gc3BsaXQgdXAgdGhlc2UgbW9kdWxlcyBhbmRcbi8vIGF2b2lkIHRoaXMgcHJvYmxlbS4gUGVyaGFwcyBhbGwgdGhlIHJvb3QtbWFya2luZyBmdW5jdGlvbnMgc2hvdWxkIG1vdmUgaW50b1xuLy8gdGhlIHdvcmsgbG9vcC5cblxuXG5mdW5jdGlvbiBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgdXBkYXRlZExhbmVzKSB7XG4gIG1hcmtSb290VXBkYXRlZCQxKHJvb3QsIHVwZGF0ZWRMYW5lcyk7XG5cbiAge1xuICAgIC8vIENoZWNrIGZvciByZWN1cnNpdmUgdXBkYXRlc1xuICAgIGlmIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChleGVjdXRpb25Db250ZXh0ICYgQ29tbWl0Q29udGV4dCkge1xuICAgICAgZGlkSW5jbHVkZUNvbW1pdFBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aHJvd0lmSW5maW5pdGVVcGRhdGVMb29wRGV0ZWN0ZWQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZChyb290LCBwaW5nZWRMYW5lcykge1xuICBtYXJrUm9vdFBpbmdlZCQxKHJvb3QsIHBpbmdlZExhbmVzKTtcblxuICB7XG4gICAgLy8gQ2hlY2sgZm9yIHJlY3Vyc2l2ZSBwaW5ncy4gUGluZ3MgYXJlIGNvbmNlcHR1YWxseSBkaWZmZXJlbnQgZnJvbSB1cGRhdGVzIGluXG4gICAgLy8gb3RoZXIgY29udGV4dHMgYnV0IHdlIGNhbGwgaXQgYW4gXCJ1cGRhdGVcIiBpbiB0aGlzIGNvbnRleHQgYmVjYXVzZVxuICAgIC8vIHJlcGVhdGVkbHkgcGluZ2luZyBhIHN1c3BlbmRlZCByZW5kZXIgY2FuIGNhdXNlIGEgcmVjdXJzaXZlIHJlbmRlciBsb29wLlxuICAgIC8vIFRoZSByZWxldmFudCBwcm9wZXJ0eSBpcyB0aGF0IGl0IGNhbiByZXN1bHQgaW4gYSBuZXcgcmVuZGVyIGF0dGVtcHRcbiAgICAvLyBiZWluZyBzY2hlZHVsZWQuXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGV4ZWN1dGlvbkNvbnRleHQgJiBDb21taXRDb250ZXh0KSB7XG4gICAgICBkaWRJbmNsdWRlQ29tbWl0UGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRocm93SWZJbmZpbml0ZVVwZGF0ZUxvb3BEZXRlY3RlZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZExhbmVzLCBzcGF3bmVkTGFuZSkge1xuICAvLyBXaGVuIHN1c3BlbmRpbmcsIHdlIHNob3VsZCBhbHdheXMgZXhjbHVkZSBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIG9yIChtb3JlXG4gIC8vIHJhcmVseSwgc2luY2Ugd2UgdHJ5IHRvIGF2b2lkIGl0KSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyk7XG4gIHN1c3BlbmRlZExhbmVzID0gcmVtb3ZlTGFuZXMoc3VzcGVuZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKTtcblxuICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzLCBzcGF3bmVkTGFuZSk7XG59IC8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IGdvXG4vLyB0aHJvdWdoIFNjaGVkdWxlclxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBsYW5lcykge1xuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIHZhciBkaWRGbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXG4gIGlmIChkaWRGbHVzaFBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gSWYgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgZmx1c2hlZCwgZXhpdCB0byB0aGUgb3V0ZXIgd29yayBsb29wIGluIHRoZSByb290XG4gICAgLy8gc2NoZWR1bGVyLCBzbyB3ZSBjYW4gcmVjb21wdXRlIHRoZSBwcmlvcml0eS5cbiAgICAvLyBUT0RPOiBXZSBkb24ndCBhY3R1YWxseSBuZWVkIHRoaXMgYGVuc3VyZVJvb3RJc1NjaGVkdWxlZGAgY2FsbCBiZWNhdXNlXG4gICAgLy8gdGhpcyBwYXRoIGlzIG9ubHkgcmVhY2hhYmxlIGlmIHRoZSByb290IGlzIGFscmVhZHkgcGFydCBvZiB0aGUgc2NoZWR1bGUuXG4gICAgLy8gSSdtIGluY2x1ZGluZyBpdCBvbmx5IGZvciBjb25zaXN0ZW5jeSB3aXRoIHRoZSBvdGhlciBleGl0IHBvaW50cyBmcm9tXG4gICAgLy8gdGhpcyBmdW5jdGlvbi4gQ2FuIGFkZHJlc3MgaW4gYSBzdWJzZXF1ZW50IHJlZmFjdG9yLlxuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBzeW5jTmVzdGVkVXBkYXRlRmxhZygpO1xuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuICAgIC8vIHN5bmNocm9ub3VzbHkgdG8gYmxvY2sgY29uY3VycmVudCBkYXRhIG11dGF0aW9ucywgYW5kIHdlJ2xsIGluY2x1ZGVzXG4gICAgLy8gYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyIHRoZSBzZWNvbmRcbiAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgIHZhciBvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXMgPSBsYW5lcztcbiAgICB2YXIgZXJyb3JSZXRyeUxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCwgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzKTtcblxuICAgIGlmIChlcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIG9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcywgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCBOb0xhbmUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChleGl0U3RhdHVzID09PSBSb290RGlkTm90Q29tcGxldGUpIHtcbiAgICAvLyBUaGUgcmVuZGVyIHVud291bmQgd2l0aG91dCBjb21wbGV0aW5nIHRoZSB0cmVlLiBUaGlzIGhhcHBlbnMgaW4gc3BlY2lhbFxuICAgIC8vIGNhc2VzIHdoZXJlIG5lZWQgdG8gZXhpdCB0aGUgY3VycmVudCByZW5kZXIgd2l0aG91dCBwcm9kdWNpbmcgYVxuICAgIC8vIGNvbnNpc3RlbnQgdHJlZSBvciBjb21taXR0aW5nLlxuICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBCZWNhdXNlIHRoaXMgaXMgYSBzeW5jIHJlbmRlciwgd2VcbiAgLy8gd2lsbCBjb21taXQgaXQgZXZlbiBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLlxuXG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgY29tbWl0Um9vdChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucywgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSwgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpOyAvLyBCZWZvcmUgZXhpdGluZywgbWFrZSBzdXJlIHRoZXJlJ3MgYSBjYWxsYmFjayBzY2hlZHVsZWQgZm9yIHRoZSBuZXh0XG4gIC8vIHBlbmRpbmcgbGV2ZWwuXG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZsdXNoUm9vdChyb290LCBsYW5lcykge1xuICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICB1cGdyYWRlUGVuZGluZ0xhbmVzVG9TeW5jKHJvb3QsIGxhbmVzKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG5cbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7IC8vIFRPRE86IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMgdGhpcyBmbHVzaGVzIGFsbCBzeW5jIHdvcmsgYWNyb3NzIGFsbFxuICAgICAgLy8gcm9vdHMuIEl0IHNob3VsZG4ndCByZWFsbHkgbWF0dGVyIGVpdGhlciB3YXksIGJ1dCB3ZSBjb3VsZCBjaGFuZ2UgdGhpc1xuICAgICAgLy8gdG8gb25seSBmbHVzaCB0aGUgZ2l2ZW4gcm9vdC5cblxuICAgICAgZmx1c2hTeW5jV29ya09uQWxsUm9vdHMoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV4ZWN1dGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiBleGVjdXRpb25Db250ZXh0O1xufVxuZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGVmYXVsdEV2ZW50UHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gIHtcbiAgICAvLyBiYXRjaGVkVXBkYXRlcyBpcyBhIG5vLW9wIG5vdywgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBpbnRlcm5hbCByZWFjdC1kb21cbiAgICAvLyBjb2RlIGNhbGxpbmcgaXQsIHRoYXQgd2UgY2FuJ3QgcmVtb3ZlIHVudGlsIHdlIHJlbW92ZSBsZWdhY3kgbW9kZS5cbiAgICByZXR1cm4gZm4oYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyhmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gIHRyeSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgcmV0dXJuIGZuKGEsIGIsIGMsIGQpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgfVxuICB9XG59IC8vIE92ZXJsb2FkIHRoZSBkZWZpbml0aW9uIHRvIHRoZSB0d28gdmFsaWQgc2lnbmF0dXJlcy5cbi8vIFdhcm5pbmcsIHRoaXMgb3B0cy1vdXQgb2YgY2hlY2tpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIoZm4pIHtcbiAgLy8gSW4gbGVnYWN5IG1vZGUsIHdlIGZsdXNoIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gIC8vIG5leHQgZXZlbnQsIG5vdCBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyBvbmUuXG4gIGlmIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCAmJiAhZGlzYWJsZUxlZ2FjeU1vZGUgJiYgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMudGFnID09PSBMZWdhY3lSb290ICYmIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcblxuICAgIGlmIChmbikge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgaGFwcGVuIGV2ZW4gaWYgYmF0Y2hlZFVwZGF0ZXMgaXMgaGlnaGVyIHVwXG4gICAgLy8gdGhlIHN0YWNrLlxuXG4gICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgZmx1c2hTeW5jV29ya09uQWxsUm9vdHMoKTtcbiAgICB9XG4gIH1cbn0gLy8gSWYgY2FsbGVkIG91dHNpZGUgb2YgYSByZW5kZXIgb3IgY29tbWl0IHdpbGwgZmx1c2ggYWxsIHN5bmMgd29yayBvbiBhbGwgcm9vdHNcbi8vIFJldHVybnMgd2hldGhlciB0aGUgdGhlIGNhbGwgd2FzIGR1cmluZyBhIHJlbmRlciBvciBub3RcblxuZnVuY3Rpb24gZmx1c2hTeW5jV29yaygpIHtcbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0FscmVhZHlSZW5kZXJpbmcoKSB7XG4gIC8vIFVzZWQgYnkgdGhlIHJlbmRlcmVyIHRvIHByaW50IGEgd2FybmluZyBpZiBjZXJ0YWluIEFQSXMgYXJlIGNhbGxlZCBmcm9tXG4gIC8vIHRoZSB3cm9uZyBjb250ZXh0LlxuICByZXR1cm4gKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0O1xufVxuLy8gaGlkZGVuIHN1YnRyZWUuIFRoZSBzdGFjayBsb2dpYyBpcyBtYW5hZ2VkIHRoZXJlIGJlY2F1c2UgdGhhdCdzIHRoZSBvbmx5XG4vLyBwbGFjZSB0aGF0IGV2ZXIgbW9kaWZpZXMgaXQuIFdoaWNoIG1vZHVsZSBpdCBsaXZlcyBpbiBkb2Vzbid0IG1hdHRlciBmb3Jcbi8vIHBlcmZvcm1hbmNlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiB3aWxsIGdldCBpbmxpbmVkIHJlZ2FyZGxlc3NcblxuZnVuY3Rpb24gc2V0RW50YW5nbGVkUmVuZGVyTGFuZXMobmV3RW50YW5nbGVkUmVuZGVyTGFuZXMpIHtcbiAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBuZXdFbnRhbmdsZWRSZW5kZXJMYW5lcztcbn1cbmZ1bmN0aW9uIGdldEVudGFuZ2xlZFJlbmRlckxhbmVzKCkge1xuICByZXR1cm4gZW50YW5nbGVkUmVuZGVyTGFuZXM7XG59XG5cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSByZXR1cm47XG4gIHZhciBpbnRlcnJ1cHRlZFdvcms7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBOb3RTdXNwZW5kZWQpIHtcbiAgICAvLyBOb3JtYWwgY2FzZS4gV29yay1pbi1wcm9ncmVzcyBoYXNuJ3Qgc3RhcnRlZCB5ZXQuIFVud2luZCBhbGxcbiAgICAvLyBpdHMgcGFyZW50cy5cbiAgICBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgLy8gV29yay1pbi1wcm9ncmVzcyBpcyBpbiBzdXNwZW5kZWQgc3RhdGUuIFJlc2V0IHRoZSB3b3JrIGxvb3AgYW5kIHVud2luZFxuICAgIC8vIGJvdGggdGhlIHN1c3BlbmRlZCBmaWJlciBhbmQgYWxsIGl0cyBwYXJlbnRzLlxuICAgIHJlc2V0U3VzcGVuZGVkV29ya0xvb3BPblVud2luZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICB3aGlsZSAoaW50ZXJydXB0ZWRXb3JrICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBpbnRlcnJ1cHRlZFdvcmsuYWx0ZXJuYXRlO1xuICAgIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgIGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm47XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKSB7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcbiAgdmFyIHRpbWVvdXRIYW5kbGUgPSByb290LnRpbWVvdXRIYW5kbGU7XG5cbiAgaWYgKHRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dCkge1xuICAgIC8vIFRoZSByb290IHByZXZpb3VzIHN1c3BlbmRlZCBhbmQgc2NoZWR1bGVkIGEgdGltZW91dCB0byBjb21taXQgYSBmYWxsYmFja1xuICAgIC8vIHN0YXRlLiBOb3cgdGhhdCB3ZSBoYXZlIGFkZGl0aW9uYWwgd29yaywgY2FuY2VsIHRoZSB0aW1lb3V0LlxuICAgIHJvb3QudGltZW91dEhhbmRsZSA9IG5vVGltZW91dDsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF0gQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG5cbiAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICB9XG5cbiAgdmFyIGNhbmNlbFBlbmRpbmdDb21taXQgPSByb290LmNhbmNlbFBlbmRpbmdDb21taXQ7XG5cbiAgaWYgKGNhbmNlbFBlbmRpbmdDb21taXQgIT09IG51bGwpIHtcbiAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICAgIGNhbmNlbFBlbmRpbmdDb21taXQoKTtcbiAgfVxuXG4gIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LCBudWxsKTtcbiAgd29ya0luUHJvZ3Jlc3MgPSByb290V29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gbGFuZXM7XG4gIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gZmFsc2U7XG4gIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gTm9MYW5lO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gZmFsc2U7IC8vIEdldCB0aGUgbGFuZXMgdGhhdCBhcmUgZW50YW5nbGVkIHdpdGggd2hhdGV2ZXIgd2UncmUgYWJvdXQgdG8gcmVuZGVyLiBXZVxuICAvLyB0cmFjayB0aGVzZSBzZXBhcmF0ZWx5IHNvIHdlIGNhbiBkaXN0aW5ndWlzaCB0aGUgcHJpb3JpdHkgb2YgdGhlIHJlbmRlclxuICAvLyB0YXNrIGZyb20gdGhlIHByaW9yaXR5IG9mIHRoZSBsYW5lcyBpdCBpcyBlbnRhbmdsZWQgd2l0aC4gRm9yIGV4YW1wbGUsIGFcbiAgLy8gdHJhbnNpdGlvbiBtYXkgbm90IGJlIGFsbG93ZWQgdG8gZmluaXNoIHVubGVzcyBpdCBpbmNsdWRlcyB0aGUgU3luYyBsYW5lLFxuICAvLyB3aGljaCBpcyBjdXJyZW50bHkgc3VzcGVuZGVkLiBXZSBzaG91bGQgYmUgYWJsZSB0byByZW5kZXIgdGhlIFRyYW5zaXRpb25cbiAgLy8gYW5kIFN5bmMgbGFuZSBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGF0IFRyYW5zaXRpb24gcHJpb3JpdHksIGJlY2F1c2UgdGhlXG4gIC8vIFN5bmMgbGFuZSBhbHJlYWR5IHN1c3BlbmRlZC5cblxuICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGdldEVudGFuZ2xlZExhbmVzKHJvb3QsIGxhbmVzKTtcbiAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gIH1cblxuICByZXR1cm4gcm9vdFdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiByZXNldFN1c3BlbmRlZFdvcmtMb29wT25VbndpbmQoZmliZXIpIHtcbiAgLy8gUmVzZXQgbW9kdWxlLWxldmVsIHN0YXRlIHRoYXQgd2FzIHNldCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gIHJlc2V0SG9va3NPblVud2luZChmaWJlcik7XG4gIHJlc2V0Q2hpbGRSZWNvbmNpbGVyT25VbndpbmQoKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUpIHtcbiAgLy8gQSBjb21wb25lbnQgdGhyZXcgYW4gZXhjZXB0aW9uLiBVc3VhbGx5IHRoaXMgaXMgYmVjYXVzZSBpdCBzdXNwZW5kZWQsIGJ1dFxuICAvLyBpdCBhbHNvIGluY2x1ZGVzIHJlZ3VsYXIgcHJvZ3JhbSBlcnJvcnMuXG4gIC8vXG4gIC8vIFdlJ3JlIGVpdGhlciBnb2luZyB0byB1bndpbmQgdGhlIHN0YWNrIHRvIHNob3cgYSBTdXNwZW5zZSBvciBlcnJvclxuICAvLyBib3VuZGFyeSwgb3Igd2UncmUgZ29pbmcgdG8gcmVwbGF5IHRoZSBjb21wb25lbnQgYWdhaW4uIExpa2UgYWZ0ZXIgYVxuICAvLyBwcm9taXNlIHJlc29sdmVzLlxuICAvL1xuICAvLyBVbnRpbCB3ZSBkZWNpZGUgd2hldGhlciB3ZSdyZSBnb2luZyB0byB1bndpbmQgb3IgcmVwbGF5LCB3ZSBzaG91bGQgcHJlc2VydmVcbiAgLy8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHdvcmsgbG9vcCB3aXRob3V0IHJlc2V0dGluZyBhbnl0aGluZy5cbiAgLy9cbiAgLy8gSWYgd2UgZG8gZGVjaWRlIHRvIHVud2luZCB0aGUgc3RhY2ssIG1vZHVsZS1sZXZlbCB2YXJpYWJsZXMgd2lsbCBiZSByZXNldFxuICAvLyBpbiByZXNldFN1c3BlbmRlZFdvcmtMb29wT25VbndpbmQuXG4gIC8vIFRoZXNlIHNob3VsZCBiZSByZXNldCBpbW1lZGlhdGVseSBiZWNhdXNlIHRoZXkncmUgb25seSBzdXBwb3NlZCB0byBiZSBzZXRcbiAgLy8gd2hlbiBSZWFjdCBpcyBleGVjdXRpbmcgdXNlciBjb2RlLlxuICByZXNldEhvb2tzQWZ0ZXJUaHJvdygpO1xuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG5cbiAgaWYgKHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvbikge1xuICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIHR5cGUgb2YgZXhjZXB0aW9uIHVzZWQgZm9yIFN1c3BlbnNlLiBGb3IgaGlzdG9yaWNhbFxuICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd24gdmFsdWVcbiAgICAvLyB0byBiZSBhIHRoZW5hYmxlLCBiZWNhdXNlIGJlZm9yZSBgdXNlYCBleGlzdGVkIHRoYXQgd2FzIHRoZSAodW5zdGFibGUpXG4gICAgLy8gQVBJIGZvciBzdXNwZW5kaW5nLiBUaGlzIGltcGxlbWVudGF0aW9uIGRldGFpbCBjYW4gY2hhbmdlIGxhdGVyLCBvbmNlIHdlXG4gICAgLy8gZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgIHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKTtcbiAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSAmJiAvLyBDaGVjayBpZiB0aGVyZSBhcmUgb3RoZXIgcGVuZGluZyB1cGRhdGVzIHRoYXQgbWlnaHQgcG9zc2libHkgdW5ibG9jayB0aGlzXG4gICAgLy8gY29tcG9uZW50IGZyb20gc3VzcGVuZGluZy4gVGhpcyBtaXJyb3JzIHRoZSBjaGVjayBpblxuICAgIC8vIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUuIFdlIHNob3VsZCBhdHRlbXB0IHRvIHVuaWZ5IHRoZW0gc29tZWhvdy5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bndpbmRpbmcgaW1tZWRpYXRlbHksIHVzaW5nIHRoZVxuICAgIC8vIFN1c3BlbmRlZE9uSHlkcmF0aW9uIG1lY2hhbmlzbS5cbiAgICAhaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpICYmICFpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKSA/IC8vIFN1c3BlbmQgd29yayBsb29wIHVudGlsIGRhdGEgcmVzb2x2ZXNcbiAgICBTdXNwZW5kZWRPbkRhdGEgOiAvLyBEb24ndCBzdXNwZW5kIHdvcmsgbG9vcCwgZXhjZXB0IHRvIGNoZWNrIGlmIHRoZSBkYXRhIGhhc1xuICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmVkIChpLmUuIGluIGEgbWljcm90YXNrKS4gT3RoZXJ3aXNlLCB0cmlnZ2VyIHRoZVxuICAgIC8vIG5lYXJlc3QgU3VzcGVuc2UgZmFsbGJhY2suXG4gICAgU3VzcGVuZGVkT25JbW1lZGlhdGU7XG4gIH0gZWxzZSBpZiAodGhyb3duVmFsdWUgPT09IFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbikge1xuICAgIHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKTtcbiAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSW5zdGFuY2U7XG4gIH0gZWxzZSBpZiAodGhyb3duVmFsdWUgPT09IFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbikge1xuICAgIC8vIEFuIHVwZGF0ZSBmbG93ZWQgaW50byBhIGRlaHlkcmF0ZWQgYm91bmRhcnkuIEJlZm9yZSB3ZSBjYW4gYXBwbHkgdGhlXG4gICAgLy8gdXBkYXRlLCB3ZSBuZWVkIHRvIGZpbmlzaCBoeWRyYXRpbmcuIEludGVycnVwdCB0aGUgd29yay1pbi1wcm9ncmVzc1xuICAgIC8vIHJlbmRlciBzbyB3ZSBjYW4gcmVzdGFydCBhdCB0aGUgaHlkcmF0aW9uIGxhbmUuXG4gICAgLy9cbiAgICAvLyBUaGUgaWRlYWwgaW1wbGVtZW50YXRpb24gd291bGQgYmUgYWJsZSB0byBzd2l0Y2ggY29udGV4dHMgd2l0aG91dFxuICAgIC8vIHVud2luZGluZyB0aGUgY3VycmVudCBzdGFjay5cbiAgICAvL1xuICAgIC8vIFdlIGNvdWxkIG5hbWUgdGhpcyBzb21ldGhpbmcgbW9yZSBnZW5lcmFsIGJ1dCBhcyBvZiBub3cgaXQncyB0aGUgb25seVxuICAgIC8vIGNhc2Ugd2hlcmUgd2UgdGhpbmsgdGhpcyBzaG91bGQgaGFwcGVuLlxuICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25IeWRyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlZ3VsYXIgZXJyb3IuXG4gICAgdmFyIGlzV2FrZWFibGUgPSB0aHJvd25WYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xuICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gaXNXYWtlYWJsZSA/IC8vIEEgd2FrZWFibGUgb2JqZWN0IHdhcyB0aHJvd24gYnkgYSBsZWdhY3kgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24uXG4gICAgLy8gVGhpcyBoYXMgc2xpZ2h0bHkgZGlmZmVyZW50IGJlaGF2aW9yIHRoYW4gc3VzcGVuZGluZyB3aXRoIGB1c2VgLlxuICAgIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSA6IC8vIFRoaXMgaXMgYSByZWd1bGFyIGVycm9yLiBJZiBzb21ldGhpbmcgZWFybGllciBpbiB0aGUgY29tcG9uZW50IGFscmVhZHlcbiAgICAvLyBzdXNwZW5kZWQsIHdlIG11c3QgY2xlYXIgdGhlIHRoZW5hYmxlIHN0YXRlIHRvIHVuYmxvY2sgdGhlIHdvcmsgbG9vcC5cbiAgICBTdXNwZW5kZWRPbkVycm9yO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IHRocm93blZhbHVlO1xuICB2YXIgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcblxuICBpZiAoZXJyb3JlZFdvcmsgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgZmF0YWwgZXJyb3JcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICBsb2dVbmNhdWdodEVycm9yKHJvb3QsIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXJyb3JlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgLy8gUmVjb3JkIHRoZSB0aW1lIHNwZW50IHJlbmRlcmluZyBiZWZvcmUgYW4gZXJyb3Igd2FzIHRocm93bi4gVGhpc1xuICAgIC8vIGF2b2lkcyBpbmFjY3VyYXRlIFByb2ZpbGVyIGR1cmF0aW9ucyBpbiB0aGUgY2FzZSBvZiBhXG4gICAgLy8gc3VzcGVuZGVkIHJlbmRlci5cbiAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGVycm9yZWRXb3JrLCB0cnVlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikge1xuICAgICAgY2FzZSBTdXNwZW5kZWRPbkVycm9yOlxuICAgICAgICB7XG4gICAgICAgICAgbWFya0NvbXBvbmVudEVycm9yZWQoZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB3YWtlYWJsZSA9IHRocm93blZhbHVlO1xuICAgICAgICAgIG1hcmtDb21wb25lbnRTdXNwZW5kZWQoZXJyb3JlZFdvcmssIHdha2VhYmxlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpIHtcbiAgLy8gVGhpcyBpcyBhc2tpbmcgd2hldGhlciBpdCdzIGJldHRlciB0byBzdXNwZW5kIHRoZSB0cmFuc2l0aW9uIGFuZCByZW1haW5cbiAgLy8gb24gdGhlIHByZXZpb3VzIHNjcmVlbiwgdmVyc3VzIHNob3dpbmcgYSBmYWxsYmFjayBhcyBzb29uIGFzIHBvc3NpYmxlLiBJdFxuICAvLyB0YWtlcyBpbnRvIGFjY291bnQgYm90aCB0aGUgcHJpb3JpdHkgb2YgcmVuZGVyIGFuZCBhbHNvIHdoZXRoZXIgc2hvd2luZyBhXG4gIC8vIGZhbGxiYWNrIHdvdWxkIHByb2R1Y2UgYSBkZXNpcmFibGUgdXNlciBleHBlcmllbmNlLlxuICB2YXIgaGFuZGxlciA9IGdldFN1c3BlbnNlSGFuZGxlcigpO1xuXG4gIGlmIChoYW5kbGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBubyBTdXNwZW5zZSBib3VuZGFyeSB0aGF0IGNhbiBwcm92aWRlIGEgZmFsbGJhY2suIFdlIGhhdmUgbm9cbiAgICAvLyBjaG9pY2UgYnV0IHRvIHJlbWFpbiBvbiB0aGUgcHJldmlvdXMgc2NyZWVuLlxuICAgIC8vIE5PVEU6IFdlIGRvIHRoaXMgZXZlbiBmb3Igc3luYyB1cGRhdGVzLCBmb3IgbGFjayBvZiBhbnkgYmV0dGVyIG9wdGlvbi4gSW5cbiAgICAvLyB0aGUgZnV0dXJlLCB3ZSBtYXkgY2hhbmdlIGhvdyB3ZSBoYW5kbGUgdGhpcywgbGlrZSBieSBwdXR0aW5nIHRoZSB3aG9sZVxuICAgIC8vIHJvb3QgaW50byBhIFwiZGV0YWNoZWRcIiBtb2RlLlxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFRPRE86IE9uY2UgYHVzZWAgaGFzIGZ1bGx5IHJlcGxhY2VkIHRoZSBgdGhyb3cgcHJvbWlzZWAgcGF0dGVybiwgd2Ugc2hvdWxkXG4gIC8vIGJlIGFibGUgdG8gcmVtb3ZlIHRoZSBlcXVpdmFsZW50IGNoZWNrIGluIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIsIGFuZCByZWx5XG4gIC8vIGp1c3Qgb24gdGhpcyBvbmUuXG5cblxuICBpZiAoaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpKSB7XG4gICAgaWYgKGdldFNoZWxsQm91bmRhcnkoKSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgcmVuZGVyaW5nIGluc2lkZSB0aGUgXCJzaGVsbFwiIG9mIHRoZSBhcHAuIEFjdGl2YXRpbmcgdGhlIG5lYXJlc3RcbiAgICAgIC8vIGZhbGxiYWNrIHdvdWxkIGNhdXNlIHZpc2libGUgY29udGVudCB0byBkaXNhcHBlYXIuIEl0J3MgYmV0dGVyIHRvXG4gICAgICAvLyBzdXNwZW5kIHRoZSB0cmFuc2l0aW9uIGFuZCByZW1haW4gb24gdGhlIHByZXZpb3VzIHNjcmVlbi5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSdyZSByZW5kZXJpbmcgY29udGVudCB0aGF0IHdhc24ndCBwYXJ0IG9mIHRoZSBwcmV2aW91cyBzY3JlZW4uXG4gICAgICAvLyBSYXRoZXIgdGhhbiBibG9jayB0aGUgdHJhbnNpdGlvbiwgaXQncyBiZXR0ZXIgdG8gc2hvdyBhIGZhbGxiYWNrIGFzXG4gICAgICAvLyBzb29uIGFzIHBvc3NpYmxlLiBUaGUgYXBwZWFyYW5jZSBvZiBhbnkgbmVzdGVkIGZhbGxiYWNrcyB3aWxsIGJlXG4gICAgICAvLyB0aHJvdHRsZWQgdG8gYXZvaWQgamFuay5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgfHwgLy8gSW4gdGhpcyBjb250ZXh0LCBhbiBPZmZzY3JlZW5MYW5lIGNvdW50cyBhcyBhIFJldHJ5XG4gIC8vIFRPRE86IEl0J3MgYmVjb21lIGluY3JlYXNpbmdseSBjbGVhciB0aGF0IFJldHJpZXMgYW5kIE9mZnNjcmVlbiBhcmVcbiAgLy8gZGVlcGx5IGNvbm5lY3RlZC4gVGhleSBwcm9iYWJseSBjYW4gYmUgdW5pZmllZCBmdXJ0aGVyLlxuICBpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSkge1xuICAgIC8vIER1cmluZyBhIHJldHJ5LCB3ZSBjYW4gc3VzcGVuZCByZW5kZXJpbmcgaWYgdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnlcbiAgICAvLyBpcyB0aGUgYm91bmRhcnkgb2YgdGhlIFwic2hlbGxcIiwgYmVjYXVzZSB3ZSdyZSBndWFyYW50ZWVkIG5vdCB0byBibG9ja1xuICAgIC8vIGFueSBuZXcgY29udGVudCBmcm9tIGFwcGVhcmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSByZWFzb24gd2UgbXVzdCBjaGVjayBpZiB0aGlzIGlzIGEgcmV0cnkgaXMgYmVjYXVzZSBpdCBndWFyYW50ZWVzXG4gICAgLy8gdGhhdCBzdXNwZW5kaW5nIHRoZSB3b3JrIGxvb3Agd29uJ3QgYmxvY2sgYW4gYWN0dWFsIHVwZGF0ZSwgYmVjYXVzZVxuICAgIC8vIHJldHJpZXMgZG9uJ3QgXCJ1cGRhdGVcIiBhbnl0aGluZzsgdGhleSBmaWxsIGluIGZhbGxiYWNrcyB0aGF0IHdlcmUgbGVmdFxuICAgIC8vIGJlaGluZCBieSBhIHByZXZpb3VzIHRyYW5zaXRpb24uXG4gICAgcmV0dXJuIGhhbmRsZXIgPT09IGdldFNoZWxsQm91bmRhcnkoKTtcbiAgfSAvLyBGb3IgYWxsIG90aGVyIExhbmVzIGJlc2lkZXMgVHJhbnNpdGlvbnMgYW5kIFJldHJpZXMsIHdlIHNob3VsZCBub3Qgd2FpdFxuICAvLyBmb3IgdGhlIGRhdGEgdG8gbG9hZC5cblxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoY29udGFpbmVyKSB7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gcHVzaEFzeW5jRGlzcGF0Y2hlcigpIHtcbiAge1xuICAgIHZhciBwcmV2QXN5bmNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgICByZXR1cm4gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BBc3luY0Rpc3BhdGNoZXIocHJldkFzeW5jRGlzcGF0Y2hlcikge1xuICB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrKCkge1xuICBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gbm93JDEoKTtcbn1cbmZ1bmN0aW9uIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobGFuZSkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBtZXJnZUxhbmVzKGxhbmUsIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyk7XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZDtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7IC8vIENoZWNrIGlmIHRoZXJlIGFyZSB1cGRhdGVzIHRoYXQgd2Ugc2tpcHBlZCB0cmVlIHRoYXQgbWlnaHQgaGF2ZSB1bmJsb2NrZWRcbiAgLy8gdGhpcyByZW5kZXIuXG5cbiAgaWYgKChpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcykgfHwgaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcykpICYmIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gbnVsbCkge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyIGFzIHN1c3BlbmRlZCBzbyB0aGF0IHdlIHN3aXRjaCB0byB3b3JraW5nIG9uXG4gICAgLy8gdGhlIHVwZGF0ZXMgdGhhdCB3ZXJlIHNraXBwZWQuIFVzdWFsbHkgd2Ugb25seSBzdXNwZW5kIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBhbHdheXMgbWFyayB0aGUgcm9vdCBhcyBzdXNwZW5kZWQgaW1tZWRpYXRlbHlcbiAgICAvLyAoaW5zaWRlIHRoaXMgZnVuY3Rpb24pLCBzaW5jZSBieSBzdXNwZW5kaW5nIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlclxuICAgIC8vIHBoYXNlIGludHJvZHVjZXMgYSBwb3RlbnRpYWwgbWlzdGFrZSB3aGVyZSB3ZSBzdXNwZW5kIGxhbmVzIHRoYXQgd2VyZVxuICAgIC8vIHBpbmdlZCBvciB1cGRhdGVkIHdoaWxlIHdlIHdlcmUgcmVuZGVyaW5nLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVud2luZGluZyBpbW1lZGlhdGVseSwgdXNpbmcgdGhlXG4gICAgLy8gU3VzcGVuZGVkT25IeWRyYXRpb24gbWVjaGFuaXNtLlxuICAgIG1hcmtSb290U3VzcGVuZGVkKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkRXJyb3IoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5KSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RFcnJvcmVkO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZUNvbmN1cnJlbnRFcnJvcihlcnJvcikge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBbZXJyb3JdO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMucHVzaChlcnJvcik7XG4gIH1cbn0gLy8gQ2FsbGVkIGR1cmluZyByZW5kZXIgdG8gZGV0ZXJtaW5lIGlmIGFueXRoaW5nIGhhcyBzdXNwZW5kZWQuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHdlJ3JlIG5vdCBzdXJlLlxuXG5mdW5jdGlvbiByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSB7XG4gIC8vIElmIHNvbWV0aGluZyBlcnJvcmVkIG9yIGNvbXBsZXRlZCwgd2UgY2FuJ3QgcmVhbGx5IGJlIHN1cmUsXG4gIC8vIHNvIHRob3NlIGFyZSBmYWxzZS5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzO1xufSAvLyBUT0RPOiBPdmVyIHRpbWUsIHRoaXMgZnVuY3Rpb24gYW5kIHJlbmRlclJvb3RDb25jdXJyZW50IGhhdmUgYmVjb21lIG1vcmVcbi8vIGFuZCBtb3JlIHNpbWlsYXIuIE5vdCBzdXJlIGl0IG1ha2VzIHNlbnNlIHRvIG1haW50YWluIGZvcmtlZCBwYXRocy4gQ29uc2lkZXJcbi8vIHVuaWZ5aW5nIHRoZW0gYWdhaW4uXG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTtcbiAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuXG4gICAgICAgIGlmIChtZW1vaXplZFVwZGF0ZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgICAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIG1vdmUgRmliZXJzIHRoYXQgc2NoZWR1bGVkIHRoZSB1cGNvbWluZyB3b3JrIGZyb20gdGhlIE1hcCB0byB0aGUgU2V0LlxuICAgICAgICAvLyBJZiB3ZSBiYWlsb3V0IG9uIHRoaXMgd29yaywgd2UnbGwgbW92ZSB0aGVtIGJhY2sgKGxpa2UgYWJvdmUpLlxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBtb3ZlIHRoZW0gbm93IGluIGNhc2UgdGhlIHdvcmsgc3Bhd25zIG1vcmUgd29yayBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoIGRpZmZlcmVudCB1cGRhdGVycy5cbiAgICAgICAgLy8gVGhhdCB3YXkgd2UgY2FuIGtlZXAgdGhlIGN1cnJlbnQgdXBkYXRlIGFuZCBmdXR1cmUgdXBkYXRlcyBzZXBhcmF0ZS5cblxuXG4gICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IGdldFRyYW5zaXRpb25zRm9yTGFuZXMoKTtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgdmFyIGRpZFN1c3BlbmRJblNoZWxsID0gZmFsc2U7XG5cbiAgb3V0ZXI6IGRvIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBOb3RTdXNwZW5kZWQgJiYgd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIHdvcmsgbG9vcCBpcyBzdXNwZW5kZWQuIER1cmluZyBhIHN5bmNocm9ub3VzIHJlbmRlciwgd2UgZG9uJ3RcbiAgICAgICAgLy8geWllbGQgdG8gdGhlIG1haW4gdGhyZWFkLiBJbW1lZGlhdGVseSB1bndpbmQgdGhlIHN0YWNrLiBUaGlzIHdpbGxcbiAgICAgICAgLy8gdHJpZ2dlciBlaXRoZXIgYSBmYWxsYmFjayBvciBhbiBlcnJvciBib3VuZGFyeS5cbiAgICAgICAgLy8gVE9ETzogRm9yIGRpc2NyZXRlIGFuZCBcImRlZmF1bHRcIiB1cGRhdGVzIChhbnl0aGluZyB0aGF0J3Mgbm90XG4gICAgICAgIC8vIGZsdXNoU3luYyksIHdlIHdhbnQgdG8gd2FpdCBmb3IgdGhlIG1pY3JvdGFza3MgdGhlIGZsdXNoIGJlZm9yZVxuICAgICAgICAvLyB1bndpbmRpbmcuIFdpbGwgcHJvYmFibHkgaW1wbGVtZW50IHRoaXMgdXNpbmcgcmVuZGVyUm9vdENvbmN1cnJlbnQsXG4gICAgICAgIC8vIG9yIG1lcmdlIHJlbmRlclJvb3RTeW5jIGFuZCByZW5kZXJSb290Q29uY3VycmVudCBpbnRvIHRoZSBzYW1lXG4gICAgICAgIC8vIGZ1bmN0aW9uIGFuZCBmb3JrIHRoZSBiZWhhdmlvciBzb21lIG90aGVyIHdheS5cbiAgICAgICAgdmFyIHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgdmFyIHRocm93blZhbHVlID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZTtcblxuICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gU2VsZWN0aXZlIGh5ZHJhdGlvbi4gQW4gdXBkYXRlIGZsb3dlZCBpbnRvIGEgZGVoeWRyYXRlZCB0cmVlLlxuICAgICAgICAgICAgICAvLyBJbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyIHNvIHRoZSB3b3JrIGxvb3AgY2FuIHN3aXRjaCB0byB0aGVcbiAgICAgICAgICAgICAgLy8gaHlkcmF0aW9uIGxhbmUuXG4gICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghZGlkU3VzcGVuZEluU2hlbGwgJiYgZ2V0U3VzcGVuc2VIYW5kbGVyKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaWRTdXNwZW5kSW5TaGVsbCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gLy8gSW50ZW50aW9uYWwgZmFsbHRocm91Z2hcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVW53aW5kIHRoZW4gY29udGludWUgd2l0aCB0aGUgbm9ybWFsIHdvcmsgbG9vcC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd29ya0xvb3BTeW5jKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7IC8vIENoZWNrIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQgaW4gdGhlIHNoZWxsLiBXZSB1c2UgdGhpcyB0byBkZXRlY3QgYW5cbiAgLy8gaW5maW5pdGUgcGluZyBsb29wIGNhdXNlZCBieSBhbiB1bmNhY2hlZCBwcm9taXNlLlxuICAvL1xuICAvLyBPbmx5IGluY3JlbWVudCB0aGlzIGNvdW50ZXIgb25jZSBwZXIgc3luY2hyb25vdXMgcmVuZGVyIGF0dGVtcHQgYWNyb3NzIHRoZVxuICAvLyB3aG9sZSB0cmVlLiBFdmVuIGlmIHRoZXJlIGFyZSBtYW55IHNpYmxpbmcgY29tcG9uZW50cyB0aGF0IHN1c3BlbmQsIHRoaXNcbiAgLy8gY291bnRlciBvbmx5IGdldHMgaW5jcmVtZW50ZWQgb25jZS5cblxuXG4gIGlmIChkaWRTdXNwZW5kSW5TaGVsbCkge1xuICAgIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlcisrO1xuICB9XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG4gIHBvcEFzeW5jRGlzcGF0Y2hlcihwcmV2QXN5bmNEaXNwYXRjaGVyKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHdlIHNob3VsZCBoYXZlIGZpbmlzaGVkIHRoZSB3aG9sZSB0cmVlLlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCBhbiBpbmNvbXBsZXRlIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhICcgKyAnYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICB9IC8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhlcmUncyBubyBpbi1wcm9ncmVzcyByZW5kZXIuXG5cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIEl0J3Mgc2FmZSB0byBwcm9jZXNzIHRoZSBxdWV1ZSBub3cgdGhhdCB0aGUgcmVuZGVyIHBoYXNlIGlzIGNvbXBsZXRlLlxuXG4gIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG59IC8vIFRoZSB3b3JrIGxvb3AgaXMgYW4gZXh0cmVtZWx5IGhvdCBwYXRoLiBUZWxsIENsb3N1cmUgbm90IHRvIGlubGluZSBpdC5cblxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wU3luYygpIHtcbiAgLy8gUGVyZm9ybSB3b3JrIHdpdGhvdXQgY2hlY2tpbmcgaWYgd2UgbmVlZCB0byB5aWVsZCBiZXR3ZWVuIGZpYmVyLlxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZW5kZXJDb250ZXh0O1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpO1xuICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IHB1c2hBc3luY0Rpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gZ2V0VHJhbnNpdGlvbnNGb3JMYW5lcygpO1xuICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgb3V0ZXI6IGRvIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBOb3RTdXNwZW5kZWQgJiYgd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIHdvcmsgbG9vcCBpcyBzdXNwZW5kZWQuIFdlIG5lZWQgdG8gZWl0aGVyIHVud2luZCB0aGUgc3RhY2sgb3JcbiAgICAgICAgLy8gcmVwbGF5IHRoZSBzdXNwZW5kZWQgY29tcG9uZW50LlxuICAgICAgICB2YXIgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB2YXIgdGhyb3duVmFsdWUgPSB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlO1xuXG4gICAgICAgIHJlc3VtZU9yVW53aW5kOiBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkVycm9yOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBVbndpbmQgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgd29yayBsb29wLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgdGhlbmFibGUgPSB0aHJvd25WYWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoaXNUaGVuYWJsZVJlc29sdmVkKHRoZW5hYmxlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkYXRhIHJlc29sdmVkLiBUcnkgcmVuZGVyaW5nIHRoZSBjb21wb25lbnQgYWdhaW4uXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSAvLyBUaGUgd29yayBsb29wIGlzIHN1c3BlbmRlZCBvbiBkYXRhLiBXZSBzaG91bGQgd2FpdCBmb3IgaXQgdG9cbiAgICAgICAgICAgICAgLy8gcmVzb2x2ZSBiZWZvcmUgY29udGludWluZyB0byByZW5kZXIuXG4gICAgICAgICAgICAgIC8vIFRPRE86IEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgcHJvbWlzZSByZXNvbHZlcyBzeW5jaHJvbm91c2x5LlxuICAgICAgICAgICAgICAvLyBVc3VhbGx5IHRoaXMgaXMgaGFuZGxlZCB3aGVuIHdlIGluc3RydW1lbnQgdGhlIHByb21pc2UgdG8gYWRkIGFcbiAgICAgICAgICAgICAgLy8gYHN0YXR1c2AgZmllbGQsIGJ1dCBpZiB0aGUgcHJvbWlzZSBhbHJlYWR5IGhhcyBhIHN0YXR1cywgd2Ugd29uJ3RcbiAgICAgICAgICAgICAgLy8gaGF2ZSBhZGRlZCBhIGxpc3RlbmVyIHVudGlsIHJpZ2h0IGhlcmUuXG5cblxuICAgICAgICAgICAgICB2YXIgb25SZXNvbHV0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByb290IGlzIHN0aWxsIHN1c3BlbmRlZCBvbiB0aGlzIHByb21pc2UuXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEgJiYgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSByb290IGFzIHJlYWR5IHRvIGNvbnRpbnVlIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gLy8gRW5zdXJlIHRoZSByb290IGlzIHNjaGVkdWxlZC4gV2Ugc2hvdWxkIGRvIHRoaXMgZXZlbiBpZiB3ZSdyZVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSB3b3JraW5nIG9uIGEgZGlmZmVyZW50IHJvb3QsIHNvIHRoYXQgd2UgcmVzdW1lXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGxhdGVyLlxuXG5cbiAgICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgdGhlbmFibGUudGhlbihvblJlc29sdXRpb24sIG9uUmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmaWJlciBqdXN0IHN1c3BlbmRlZCwgaXQncyBwb3NzaWJsZSB0aGUgZGF0YSBpcyBhbHJlYWR5XG4gICAgICAgICAgICAgIC8vIGNhY2hlZC4gWWllbGQgdG8gdGhlIG1haW4gdGhyZWFkIHRvIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGluZy4gSWZcbiAgICAgICAgICAgICAgLy8gaXQgZG9lcywgd2UgY2FuIHJldHJ5IGltbWVkaWF0ZWx5IHdpdGhvdXQgdW53aW5kaW5nIHRoZSBzdGFjay5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkluc3RhbmNlOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfdGhlbmFibGUgPSB0aHJvd25WYWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoaXNUaGVuYWJsZVJlc29sdmVkKF90aGVuYWJsZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGF0YSByZXNvbHZlZC4gVHJ5IHJlbmRlcmluZyB0aGUgY29tcG9uZW50IGFnYWluLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1bndpbmQgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgd29yayBsb29wLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnRlbnRpb25hbCBmYWxsdGhyb3VnaFxuXG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVmb3JlIHVud2luZGluZyB0aGUgc3RhY2ssIGNoZWNrIG9uZSBtb3JlIHRpbWUgaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlIGlzIHJlYWR5LiBJdCBtYXkgaGF2ZSBsb2FkZWQgd2hlbiBSZWFjdCB5aWVsZGVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtYWluIHRocmVhZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyBGbG93IGtub3dzIHRoZSBiaW5kaW5nIHdvbid0XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIG11dGF0ZWQgYnkgYHByZWxvYWRJbnN0YW5jZWAuXG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0RmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBob3N0RmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0gaG9zdEZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUmVhZHkgPSByZXNvdXJjZSA/IHByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkgOiBwcmVsb2FkSW5zdGFuY2UodHlwZSwgcHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRhdGEgcmVzb2x2ZWQuIFJlc3VtZSB0aGUgd29yayBsb29wIGFzIGlmIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdXNwZW5kZWQuIFVubGlrZSB3aGVuIGEgdXNlciBjb21wb25lbnQgc3VzcGVuZHMsIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byByZXBsYXkgYW55dGhpbmcgYmVjYXVzZSB0aGUgaG9zdCBmaWJlclxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgY29tcGxldGVkLlxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gaG9zdEZpYmVyLnNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBob3N0RmliZXIucmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVVbml0T2ZXb3JrKHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhayByZXN1bWVPclVud2luZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGZhaWwgZ3JhY2VmdWxseSBidXQgaXQncyBub3QgY29ycmVjdCwgc28gbG9nIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FybmluZyBpbiBkZXYuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgdHlwZSBvZiBmaWJlciB0cmlnZ2VyZWQgYSBzdXNwZW5zZXkgY29tbWl0LiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBPdGhlcndpc2UsIHVud2luZCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBTdXNwZW5kZWQgYnkgYW4gb2xkIGltcGxlbWVudGF0aW9uIHRoYXQgdXNlcyB0aGUgYHRocm93IHByb21pc2VgXG4gICAgICAgICAgICAgIC8vIHBhdHRlcm4uIFRoZSBuZXdlciByZXBsYXlpbmcgYmVoYXZpb3IgY2FuIGNhdXNlIHN1YnRsZSBpc3N1ZXNcbiAgICAgICAgICAgICAgLy8gbGlrZSBpbmZpbml0ZSBwaW5nIGxvb3BzLiBTbyB3ZSBtYWludGFpbiB0aGUgb2xkIGJlaGF2aW9yIGFuZFxuICAgICAgICAgICAgICAvLyBhbHdheXMgdW53aW5kLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFNlbGVjdGl2ZSBoeWRyYXRpb24uIEFuIHVwZGF0ZSBmbG93ZWQgaW50byBhIGRlaHlkcmF0ZWQgdHJlZS5cbiAgICAgICAgICAgICAgLy8gSW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlciBzbyB0aGUgd29yayBsb29wIGNhbiBzd2l0Y2ggdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGh5ZHJhdGlvbiBsYW5lLlxuICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgU3VzcGVuZGVkUmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cnVlICYmIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGBhY3RgIHNwZWNpYWwgY2FzZTogSWYgd2UncmUgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLCBkb24ndCBjb25zdWx0XG4gICAgICAgIC8vIGBzaG91bGRZaWVsZGAuIEFsd2F5cyBrZWVwIHdvcmtpbmcgdW50aWwgdGhlIHJlbmRlciBpcyBjb21wbGV0ZS5cbiAgICAgICAgLy8gVGhpcyBpcyBub3QganVzdCBhbiBvcHRpbWl6YXRpb246IGluIGEgdW5pdCB0ZXN0IGVudmlyb25tZW50LCB3ZVxuICAgICAgICAvLyBjYW4ndCB0cnVzdCB0aGUgcmVzdWx0IG9mIGBzaG91bGRZaWVsZGAsIGJlY2F1c2UgdGhlIGhvc3QgSS9PIGlzXG4gICAgICAgIC8vIGxpa2VseSBtb2NrZWQuXG4gICAgICAgIHdvcmtMb29wU3luYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd29ya0xvb3BDb25jdXJyZW50KCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG4gIHBvcEFzeW5jRGlzcGF0Y2hlcihwcmV2QXN5bmNEaXNwYXRjaGVyKTtcbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gU3RpbGwgd29yayByZW1haW5pbmcuXG4gICAge1xuICAgICAgbWFya1JlbmRlcllpZWxkZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUm9vdEluUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcGxldGVkIHRoZSB0cmVlLlxuICAgIHtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gSXQncyBzYWZlIHRvIHByb2Nlc3MgdGhlIHF1ZXVlIG5vdyB0aGF0IHRoZSByZW5kZXIgcGhhc2UgaXMgY29tcGxldGUuXG5cbiAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7IC8vIFJldHVybiB0aGUgZmluYWwgZXhpdCBzdGF0dXMuXG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgfVxufVxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgLy8gUGVyZm9ybSB3b3JrIHVudGlsIFNjaGVkdWxlciBhc2tzIHVzIHRvIHlpZWxkXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gIC8vIG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpbiBwcm9ncmVzcy5cbiAgdmFyIGN1cnJlbnQgPSB1bml0T2ZXb3JrLmFsdGVybmF0ZTtcbiAgdmFyIG5leHQ7XG5cbiAgaWYgKCh1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTtcblxuICAgIHtcbiAgICAgIG5leHQgPSBydW5XaXRoRmliZXJJbkRFVih1bml0T2ZXb3JrLCBiZWdpbldvcmssIGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgICB9XG5cbiAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKHVuaXRPZldvcmssIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIG5leHQgPSBydW5XaXRoRmliZXJJbkRFVih1bml0T2ZXb3JrLCBiZWdpbldvcmssIGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBwZXJmb3JtVW5pdE9mV29yayBzcGVjaWZjYWxseSBmb3IgcmVwbGF5aW5nIGEgZmliZXIgdGhhdFxuICAvLyBqdXN0IHN1c3BlbmRlZC5cbiAgdmFyIG5leHQ7XG5cbiAge1xuICAgIG5leHQgPSBydW5XaXRoRmliZXJJbkRFVih1bml0T2ZXb3JrLCByZXBsYXlCZWdpbldvcmssIHVuaXRPZldvcmspO1xuICB9IC8vIFRoZSBiZWdpbiBwaGFzZSBmaW5pc2hlZCBzdWNjZXNzZnVsbHkgd2l0aG91dCBzdXNwZW5kaW5nLiBSZXR1cm4gdG8gdGhlXG5cbiAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlCZWdpbldvcmsodW5pdE9mV29yaykge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBiZWdpbldvcmsgc3BlY2lmY2FsbHkgZm9yIHJlcGxheWluZyBhIGZpYmVyIHRoYXRcbiAgLy8ganVzdCBzdXNwZW5kZWQuXG4gIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gIHZhciBuZXh0O1xuICB2YXIgaXNQcm9maWxpbmdNb2RlID0gKHVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlO1xuXG4gIGlmIChpc1Byb2ZpbGluZ01vZGUpIHtcbiAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gIH1cblxuICBzd2l0Y2ggKHVuaXRPZldvcmsudGFnKSB7XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFJlc29sdmUgYGRlZmF1bHRQcm9wc2AuIFRoaXMgbG9naWMgaXMgY29waWVkIGZyb20gYGJlZ2luV29ya2AuXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIG1vdmluZyB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQgaW50byB0aGF0IG1vZHVsZS4gQWxzbyxcbiAgICAgICAgLy8gY291bGQgbWF5YmUgdXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gc2F5IGB1c2VgIGRvZXNuJ3Qgd29yayB3aXRoXG4gICAgICAgIC8vIGBkZWZhdWx0UHJvcHNgIDopXG4gICAgICAgIHZhciBDb21wb25lbnQgPSB1bml0T2ZXb3JrLnR5cGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSB1bnJlc29sdmVkUHJvcHMgO1xuICAgICAgICB2YXIgY29udGV4dDtcblxuICAgICAgICBuZXh0ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgdW5pdE9mV29yaywgcmVzb2x2ZWRQcm9wcywgQ29tcG9uZW50LCBjb250ZXh0LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICAvLyBSZXNvbHZlIGBkZWZhdWx0UHJvcHNgLiBUaGlzIGxvZ2ljIGlzIGNvcGllZCBmcm9tIGBiZWdpbldvcmtgLlxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBtb3ZpbmcgdGhpcyBzd2l0Y2ggc3RhdGVtZW50IGludG8gdGhhdCBtb2R1bGUuIEFsc28sXG4gICAgICAgIC8vIGNvdWxkIG1heWJlIHVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHNheSBgdXNlYCBkb2Vzbid0IHdvcmsgd2l0aFxuICAgICAgICAvLyBgZGVmYXVsdFByb3BzYCA6KVxuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHVuaXRPZldvcmsudHlwZS5yZW5kZXI7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gX3VucmVzb2x2ZWRQcm9wcyA7XG5cbiAgICAgICAgbmV4dCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHVuaXRPZldvcmssIF9yZXNvbHZlZFByb3BzLCBfQ29tcG9uZW50LCB1bml0T2ZXb3JrLnJlZiwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gU29tZSBob3N0IGNvbXBvbmVudHMgYXJlIHN0YXRlZnVsICh0aGF0J3MgaG93IHdlIGltcGxlbWVudCBmb3JtXG4gICAgICAgIC8vIGFjdGlvbnMpIGJ1dCB3ZSBkb24ndCBib3RoZXIgdG8gcmV1c2UgdGhlIG1lbW9pemVkIHN0YXRlIGJlY2F1c2UgaXQnc1xuICAgICAgICAvLyBub3Qgd29ydGggdGhlIGV4dHJhIGNvZGUuIFRoZSBtYWluIHJlYXNvbiB0byByZXVzZSB0aGUgcHJldmlvdXMgaG9va3NcbiAgICAgICAgLy8gaXMgdG8gcmV1c2UgdW5jYWNoZWQgcHJvbWlzZXMsIGJ1dCB3ZSBoYXBwZW4gdG8ga25vdyB0aGF0IHRoZSBvbmx5XG4gICAgICAgIC8vIHByb21pc2VzIHRoYXQgYSBob3N0IGNvbXBvbmVudCBtaWdodCBzdXNwZW5kIG9uIGFyZSBkZWZpbml0ZWx5IGNhY2hlZFxuICAgICAgICAvLyBiZWNhdXNlIHRoZXkgYXJlIGNvbnRyb2xsZWQgYnkgdXMuIFNvIGRvbid0IGJvdGhlci5cbiAgICAgICAgcmVzZXRIb29rc09uVW53aW5kKHVuaXRPZldvcmspOyAvLyBGYWxsdGhyb3VnaCB0byB0aGUgbmV4dCBicmFuY2guXG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICAvLyBPdGhlciB0eXBlcyBiZXNpZGVzIGZ1bmN0aW9uIGNvbXBvbmVudHMgYXJlIHJlc2V0IGNvbXBsZXRlbHkgYmVmb3JlXG4gICAgICAgIC8vIGJlaW5nIHJlcGxheWVkLiBDdXJyZW50bHkgdGhpcyBvbmx5IGhhcHBlbnMgd2hlbiBhIFVzYWJsZSB0eXBlIGlzXG4gICAgICAgIC8vIHJlY29uY2lsZWQg4oCUIHRoZSByZWNvbmNpbGVyIHdpbGwgc3VzcGVuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgcmVzZXQgdGhlIGZpYmVyIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHN0YXRlOyBob3dldmVyLCB0aGlzIGlzbid0XG4gICAgICAgIC8vIGEgZnVsbCBcInVud2luZFwiIGJlY2F1c2Ugd2UncmUgZ29pbmcgdG8gcmV1c2UgdGhlIHByb21pc2VzIHRoYXQgd2VyZVxuICAgICAgICAvLyByZWNvbmNpbGVkIHByZXZpb3VzbHkuIFNvIGl0J3MgaW50ZW50aW9uYWwgdGhhdCB3ZSBkb24ndCBjYWxsXG4gICAgICAgIC8vIHJlc2V0U3VzcGVuZGVkV29ya0xvb3BPblVud2luZCBoZXJlLlxuICAgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgdW5pdE9mV29yayk7XG4gICAgICAgIHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyA9IHJlc2V0V29ya0luUHJvZ3Jlc3ModW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpO1xuICAgICAgICBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICBpZiAoaXNQcm9maWxpbmdNb2RlKSB7XG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlKSB7XG4gIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHBlcmZvcm1Vbml0T2ZXb3JrIHNwZWNpZmNhbGx5IGZvciB1bndpbmRpbmcgYSBmaWJlclxuICAvLyB0aGF0IHRocmV3IGFuIGV4Y2VwdGlvbi5cbiAgLy9cbiAgLy8gUmV0dXJuIHRvIHRoZSBub3JtYWwgd29yayBsb29wLiBUaGlzIHdpbGwgdW53aW5kIHRoZSBzdGFjaywgYW5kIHBvdGVudGlhbGx5XG4gIC8vIHJlc3VsdCBpbiBzaG93aW5nIGEgZmFsbGJhY2suXG4gIHJlc2V0U3VzcGVuZGVkV29ya0xvb3BPblVud2luZCh1bml0T2ZXb3JrKTtcbiAgdmFyIHJldHVybkZpYmVyID0gdW5pdE9mV29yay5yZXR1cm47XG5cbiAgdHJ5IHtcbiAgICAvLyBGaW5kIGFuZCBtYXJrIHRoZSBuZWFyZXN0IFN1c3BlbnNlIG9yIGVycm9yIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZVxuICAgIC8vIHRoaXMgXCJleGNlcHRpb25cIi5cbiAgICB2YXIgZGlkRmF0YWwgPSB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcblxuICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgcGFuaWNPblJvb3RFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmcgdGhlIGVycm9yLiBBbiBleGFtcGxlIG9mIHRoaXMgaGFwcGVuaW5nIGlzXG4gICAgLy8gd2hlbiBhY2Nlc3NpbmcgdGhlIGBjb21wb25lbnREaWRDYXRjaGAgcHJvcGVydHkgb2YgYW4gZXJyb3IgYm91bmRhcnlcbiAgICAvLyB0aHJvd3MgYW4gZXJyb3IuIEEgd2VpcmQgZWRnZSBjYXNlLiBUaGVyZSdzIGEgcmVncmVzc2lvbiB0ZXN0IGZvciB0aGlzLlxuICAgIC8vIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgYnViYmxlIHRoZSBlcnJvciB1cCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhbmljT25Sb290RXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bml0T2ZXb3JrLmZsYWdzICYgSW5jb21wbGV0ZSkge1xuICAgIC8vIFVud2luZCB0aGUgc3RhY2sgdW50aWwgd2UgcmVhY2ggdGhlIG5lYXJlc3QgYm91bmRhcnkuXG4gICAgdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBbHRob3VnaCB0aGUgZmliZXIgc3VzcGVuZGVkLCB3ZSdyZSBpbnRlbnRpb25hbGx5IGdvaW5nIHRvIGNvbW1pdCBpdCBpblxuICAgIC8vIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2UgY2FuIGRvIHRoaXMgc2FmZWx5IGluIGNhc2VzIHdoZXJlIHdlIGtub3cgdGhlXG4gICAgLy8gaW5jb25zaXN0ZW50IHRyZWUgd2lsbCBiZSBoaWRkZW4uXG4gICAgLy9cbiAgICAvLyBUaGlzIGN1cnJlbnRseSBvbmx5IGFwcGxpZXMgdG8gTGVnYWN5IFN1c3BlbnNlIGltcGxlbWVudGF0aW9uLCBidXQgd2UgbWF5XG4gICAgLy8gcG9ydCBhIHZlcnNpb24gb2YgdGhpcyB0byBjb25jdXJyZW50IHJvb3RzLCB0b28sIHdoZW4gcGVyZm9ybWluZyBhXG4gICAgLy8gc3luY2hyb25vdXMgcmVuZGVyLiBCZWNhdXNlIHRoYXQgd2lsbCBhbGxvdyB1cyB0byBtdXRhdGUgdGhlIHRyZWUgYXMgd2VcbiAgICAvLyBnbyBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyBtdXRhdGlvbnMgdW50aWwgdGhlIGVuZC4gVGhvdWdoIGl0J3MgdW5jbGVhciBpZlxuICAgIC8vIHRoaXMgcGFydGljdWxhciBwYXRoIGlzIGhvdyB0aGF0IHdvdWxkIGJlIGltcGxlbWVudGVkLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYW5pY09uUm9vdEVycm9yKHJvb3QsIGVycm9yKSB7XG4gIC8vIFRoZXJlJ3Mgbm8gYW5jZXN0b3IgdGhhdCBjYW4gaGFuZGxlIHRoaXMgZXhjZXB0aW9uLiBUaGlzIHNob3VsZCBuZXZlclxuICAvLyBoYXBwZW4gYmVjYXVzZSB0aGUgcm9vdCBpcyBzdXBwb3NlZCB0byBjYXB0dXJlIGFsbCBlcnJvcnMgdGhhdCB3ZXJlbid0XG4gIC8vIGNhdWdodCBieSBhbiBlcnJvciBib3VuZGFyeS4gVGhpcyBpcyBhIGZhdGFsIGVycm9yLCBvciBwYW5pYyBjb25kaXRpb24sXG4gIC8vIGJlY2F1c2Ugd2UndmUgcnVuIG91dCBvZiB3YXlzIHRvIHJlY292ZXIuXG4gIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICBsb2dVbmNhdWdodEVycm9yKHJvb3QsIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCByb290LmN1cnJlbnQpKTsgLy8gU2V0IGB3b3JrSW5Qcm9ncmVzc2AgdG8gbnVsbC4gVGhpcyByZXByZXNlbnRzIGFkdmFuY2luZyB0byB0aGUgbmV4dFxuICAvLyBzaWJsaW5nLCBvciB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyBzaWJsaW5ncy4gQnV0IHNpbmNlIHRoZSByb290XG4gIC8vIGhhcyBubyBzaWJsaW5ncyBub3IgYSBwYXJlbnQsIHdlIHNldCBpdCB0byBudWxsLiBVc3VhbGx5IHRoaXMgaXNcbiAgLy8gaGFuZGxlZCBieSBgY29tcGxldGVVbml0T2ZXb3JrYCBvciBgdW53aW5kV29ya2AsIGJ1dCBzaW5jZSB3ZSdyZVxuICAvLyBpbnRlbnRpb25hbGx5IG5vdCBjYWxsaW5nIHRob3NlLCB3ZSBuZWVkIHNldCBpdCBoZXJlLlxuICAvLyBUT0RPOiBDb25zaWRlciBjYWxsaW5nIGB1bndpbmRXb3JrYCB0byBwb3AgdGhlIGNvbnRleHRzLlxuXG4gIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gQXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCB1bml0IG9mIHdvcmssIHRoZW4gbW92ZSB0byB0aGUgbmV4dFxuICAvLyBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZSBwYXJlbnQgZmliZXIuXG4gIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcblxuICBkbyB7XG4gICAge1xuICAgICAgaWYgKChjb21wbGV0ZWRXb3JrLmZsYWdzICYgSW5jb21wbGV0ZSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAvLyBOT1RFOiBJZiB3ZSByZS1lbmFibGUgc2libGluZyBwcmVyZW5kZXJpbmcgaW4gc29tZSBjYXNlcywgdGhpcyBicmFuY2hcbiAgICAgICAgLy8gaXMgd2hlcmUgd2Ugd291bGQgc3dpdGNoIHRvIHRoZSB1bndpbmRpbmcgcGF0aC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIFJlYWN0IGVycm9yOiBFeHBlY3RlZCB0aGlzIGZpYmVyIHRvIGJlIGNvbXBsZXRlLCBidXQgJyArIFwiaXQgaXNuJ3QuIEl0IHNob3VsZCBoYXZlIGJlZW4gdW53b3VuZC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gICAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG5cblxuICAgIHZhciBjdXJyZW50ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGU7XG4gICAgdmFyIHJldHVybkZpYmVyID0gY29tcGxldGVkV29yay5yZXR1cm47XG4gICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgICB7XG4gICAgICAgIG5leHQgPSBydW5XaXRoRmliZXJJbkRFVihjb21wbGV0ZWRXb3JrLCBjb21wbGV0ZVdvcmssIGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuXG4gICAgICB7XG4gICAgICAgIG5leHQgPSBydW5XaXRoRmliZXJJbkRFVihjb21wbGV0ZWRXb3JrLCBjb21wbGV0ZVdvcmssIGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgICAgIH0gLy8gVXBkYXRlIHJlbmRlciBkdXJhdGlvbiBhc3N1bWluZyB3ZSBkaWRuJ3QgZXJyb3IuXG5cblxuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShjb21wbGV0ZWRXb3JrLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgIC8vIENvbXBsZXRpbmcgdGhpcyBmaWJlciBzcGF3bmVkIG5ldyB3b3JrLiBXb3JrIG9uIHRoYXQgbmV4dC5cbiAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2libGluZ0ZpYmVyID0gY29tcGxldGVkV29yay5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgIHdvcmtJblByb2dyZXNzID0gc2libGluZ0ZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gT3RoZXJ3aXNlLCByZXR1cm4gdG8gdGhlIHBhcmVudFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICBjb21wbGV0ZWRXb3JrID0gcmV0dXJuRmliZXI7IC8vIFVwZGF0ZSB0aGUgbmV4dCB0aGluZyB3ZSdyZSB3b3JraW5nIG9uIGluIGNhc2Ugc29tZXRoaW5nIHRocm93cy5cblxuICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yaztcbiAgfSB3aGlsZSAoY29tcGxldGVkV29yayAhPT0gbnVsbCk7IC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdENvbXBsZXRlZDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgdmFyIGluY29tcGxldGVXb3JrID0gdW5pdE9mV29yaztcblxuICBkbyB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gICAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gaW5jb21wbGV0ZVdvcmsuYWx0ZXJuYXRlOyAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgLy8gY2FwdHVyZSB2YWx1ZXMgaWYgcG9zc2libGUuXG5cbiAgICB2YXIgbmV4dCA9IHVud2luZFdvcmsoY3VycmVudCwgaW5jb21wbGV0ZVdvcmspOyAvLyBCZWNhdXNlIHRoaXMgZmliZXIgZGlkIG5vdCBjb21wbGV0ZSwgZG9uJ3QgcmVzZXQgaXRzIGxhbmVzLlxuXG4gICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgIC8vIEZvdW5kIGEgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlIHRoaXMgZXhjZXB0aW9uLiBSZS1yZW50ZXIgdGhlXG4gICAgICAvLyBiZWdpbiBwaGFzZS4gVGhpcyBicmFuY2ggd2lsbCByZXR1cm4gdXMgdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG4gICAgICAvL1xuICAgICAgLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3RcbiAgICAgIC8vIGZyb20gdGhlIGVmZmVjdCB0YWcuXG4gICAgICBuZXh0LmZsYWdzICY9IEhvc3RFZmZlY3RNYXNrO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gS2VlcCB1bndpbmRpbmcgdW50aWwgd2UgcmVhY2ggZWl0aGVyIGEgYm91bmRhcnkgb3IgdGhlIHJvb3QuXG5cblxuICAgIGlmICgoaW5jb21wbGV0ZVdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoaW5jb21wbGV0ZVdvcmssIGZhbHNlKTsgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cblxuICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gaW5jb21wbGV0ZVdvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICB2YXIgY2hpbGQgPSBpbmNvbXBsZXRlV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBhZGRpdGlvbiB3aXRoIHBvc3NpYmxlIG51bGwvdW5kZWZpbmVkIHZhbHVlXG4gICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGluY29tcGxldGVXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgfSAvLyBUT0RPOiBPbmNlIHdlIHN0b3AgcHJlcmVuZGVyaW5nIHNpYmxpbmdzLCBpbnN0ZWFkIG9mIHJlc2V0dGluZyB0aGUgcGFyZW50XG4gICAgLy8gb2YgdGhlIG5vZGUgYmVpbmcgdW53b3VuZCwgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVzZXQgbm9kZSBpdHNlbGYgYXMgd2VcbiAgICAvLyB1bndpbmQgdGhlIHN0YWNrLiBTYXZlcyBhbiBhZGRpdGlvbmFsIG51bGwgY2hlY2suXG5cblxuICAgIHZhciByZXR1cm5GaWJlciA9IGluY29tcGxldGVXb3JrLnJldHVybjtcblxuICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBzdWJ0cmVlIGZsYWdzLlxuICAgICAgLy8gVE9ETzogT25jZSB3ZSBzdG9wIHByZXJlbmRlcmluZyBzaWJsaW5ncywgd2UgbWF5IGJlIGFibGUgdG8gZ2V0IHJpZCBvZlxuICAgICAgLy8gdGhlIEluY29tcGxldGUgZmxhZyBiZWNhdXNlIHVud2luZGluZyB0byB0aGUgbmVhcmVzdCBib3VuZGFyeSB3aWxsXG4gICAgICAvLyBoYXBwZW4gc3luY2hyb25vdXNseS5cbiAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IEluY29tcGxldGU7XG4gICAgICByZXR1cm5GaWJlci5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG4gICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgIH0gLy8gTk9URTogSWYgd2UgcmUtZW5hYmxlIHNpYmxpbmcgcHJlcmVuZGVyaW5nIGluIHNvbWUgY2FzZXMsIGhlcmUgd2VcbiAgICAvLyB3b3VsZCBzd2l0Y2ggdG8gdGhlIG5vcm1hbCBjb21wbGV0aW9uIHBhdGg6IGNoZWNrIGlmIGEgc2libGluZ1xuICAgIC8vIGV4aXN0cywgYW5kIGlmIHNvLCBiZWdpbiB3b3JrIG9uIGl0LlxuICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgaW5jb21wbGV0ZVdvcmsgPSByZXR1cm5GaWJlcjsgLy8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBpbmNvbXBsZXRlV29yaztcbiAgfSB3aGlsZSAoaW5jb21wbGV0ZVdvcmsgIT09IG51bGwpOyAvLyBXZSd2ZSB1bndvdW5kIGFsbCB0aGUgd2F5IHRvIHRoZSByb290LlxuXG5cbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRSb290KHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCB0cmFuc2l0aW9ucywgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLCBzcGF3bmVkTGFuZSkge1xuICAvLyBUT0RPOiBUaGlzIG5vIGxvbmdlciBtYWtlcyBhbnkgc2Vuc2UuIFdlIGFscmVhZHkgd3JhcCB0aGUgbXV0YXRpb24gYW5kXG4gIC8vIGxheW91dCBwaGFzZXMuIFNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZS5cbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgdmFyIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICBjb21taXRSb290SW1wbChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSwgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHksIHNwYXduZWRMYW5lKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRSb290SW1wbChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSwgcmVuZGVyUHJpb3JpdHlMZXZlbCwgc3Bhd25lZExhbmUpIHtcbiAgZG8ge1xuICAgIC8vIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCB3aWxsIGNhbGwgYGZsdXNoU3luY1VwZGF0ZVF1ZXVlYCBhdCB0aGUgZW5kLCB3aGljaFxuICAgIC8vIG1lYW5zIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCB3aWxsIHNvbWV0aW1lcyByZXN1bHQgaW4gYWRkaXRpb25hbFxuICAgIC8vIHBhc3NpdmUgZWZmZWN0cy4gU28gd2UgbmVlZCB0byBrZWVwIGZsdXNoaW5nIGluIGEgbG9vcCB1bnRpbCB0aGVyZSBhcmVcbiAgICAvLyBubyBtb3JlIHBlbmRpbmcgZWZmZWN0cy5cbiAgICAvLyBUT0RPOiBNaWdodCBiZSBiZXR0ZXIgaWYgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIGRpZCBub3QgYXV0b21hdGljYWxseVxuICAgIC8vIGZsdXNoIHN5bmNocm9ub3VzIHdvcmsgYXQgdGhlIGVuZCwgdG8gYXZvaWQgZmFjdG9yaW5nIGhhemFyZHMgbGlrZSB0aGlzLlxuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfSB3aGlsZSAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgIT09IG51bGwpO1xuXG4gIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpO1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLicpO1xuICB9XG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICB2YXIgbGFuZXMgPSByb290LmZpbmlzaGVkTGFuZXM7XG5cbiAge1xuICAgIG1hcmtDb21taXRTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIGlmIChmaW5pc2hlZFdvcmsgPT09IG51bGwpIHtcblxuICAgIHtcbiAgICAgIG1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGxhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgICAgIGVycm9yKCdyb290LmZpbmlzaGVkTGFuZXMgc2hvdWxkIG5vdCBiZSBlbXB0eSBkdXJpbmcgYSBjb21taXQuIFRoaXMgaXMgYSAnICsgJ2J1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKGZpbmlzaGVkV29yayA9PT0gcm9vdC5jdXJyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgJyArICdhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH0gLy8gY29tbWl0Um9vdCBuZXZlciByZXR1cm5zIGEgY29udGludWF0aW9uOyBpdCBhbHdheXMgZmluaXNoZXMgc3luY2hyb25vdXNseS5cbiAgLy8gU28gd2UgY2FuIGNsZWFyIHRoZXNlIG5vdyB0byBhbGxvdyBhIG5ldyBjYWxsYmFjayB0byBiZSBzY2hlZHVsZWQuXG5cblxuICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcbiAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbDsgLy8gQ2hlY2sgd2hpY2ggbGFuZXMgbm8gbG9uZ2VyIGhhdmUgYW55IHdvcmsgc2NoZWR1bGVkIG9uIHRoZW0sIGFuZCBtYXJrXG4gIC8vIHRob3NlIGFzIGZpbmlzaGVkLlxuXG4gIHZhciByZW1haW5pbmdMYW5lcyA9IG1lcmdlTGFuZXMoZmluaXNoZWRXb3JrLmxhbmVzLCBmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcyk7IC8vIE1ha2Ugc3VyZSB0byBhY2NvdW50IGZvciBsYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBieSBhIGNvbmN1cnJlbnQgZXZlbnRcbiAgLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U7IGRvbid0IG1hcmsgdGhlbSBhcyBmaW5pc2hlZC5cblxuICB2YXIgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gZ2V0Q29uY3VycmVudGx5VXBkYXRlZExhbmVzKCk7XG4gIHJlbWFpbmluZ0xhbmVzID0gbWVyZ2VMYW5lcyhyZW1haW5pbmdMYW5lcywgY29uY3VycmVudGx5VXBkYXRlZExhbmVzKTtcbiAgbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcywgc3Bhd25lZExhbmUpOyAvLyBSZXNldCB0aGlzIGJlZm9yZSBmaXJpbmcgc2lkZSBlZmZlY3RzIHNvIHdlIGNhbiBkZXRlY3QgcmVjdXJzaXZlIHVwZGF0ZXMuXG5cbiAgZGlkSW5jbHVkZUNvbW1pdFBoYXNlVXBkYXRlID0gZmFsc2U7XG5cbiAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFdlIGNhbiByZXNldCB0aGVzZSBub3cgdGhhdCB0aGV5IGFyZSBmaW5pc2hlZC5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIH0gLy8gSWYgdGhlcmUgYXJlIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvIHByb2Nlc3MgdGhlbS5cbiAgLy8gRG8gdGhpcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gaXQgaXMgcXVldWVkIGJlZm9yZSBhbnl0aGluZyBlbHNlIHRoYXRcbiAgLy8gbWlnaHQgZ2V0IHNjaGVkdWxlZCBpbiB0aGUgY29tbWl0IHBoYXNlLiAoU2VlICMxNjcxNC4pXG4gIC8vIFRPRE86IERlbGV0ZSBhbGwgb3RoZXIgcGxhY2VzIHRoYXQgc2NoZWR1bGUgdGhlIHBhc3NpdmUgZWZmZWN0IGNhbGxiYWNrXG4gIC8vIFRoZXkncmUgcmVkdW5kYW50LlxuXG5cbiAgaWYgKChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzJDEgfHwgKGZpbmlzaGVkV29yay5mbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lczsgLy8gd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyBtaWdodCBiZSBvdmVyd3JpdHRlbiwgc28gd2Ugd2FudFxuICAgICAgLy8gdG8gc3RvcmUgaXQgaW4gcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyB1bnRpbCB0aGV5IGdldCBwcm9jZXNzZWRcbiAgICAgIC8vIFdlIG5lZWQgdG8gcGFzcyB0aGlzIHRocm91Z2ggYXMgYW4gYXJndW1lbnQgdG8gY29tbWl0Um9vdFxuICAgICAgLy8gYmVjYXVzZSB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zIG1pZ2h0IGhhdmUgY2hhbmdlZCBiZXR3ZWVuXG4gICAgICAvLyB0aGUgcHJldmlvdXMgcmVuZGVyIGFuZCBjb21taXQgaWYgd2UgdGhyb3R0bGUgdGhlIGNvbW1pdFxuICAgICAgLy8gd2l0aCBzZXRUaW1lb3V0XG5cbiAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7IC8vIFRoaXMgcmVuZGVyIHRyaWdnZXJlZCBwYXNzaXZlIGVmZmVjdHM6IHJlbGVhc2UgdGhlIHJvb3QgY2FjaGUgcG9vbFxuICAgICAgICAvLyAqYWZ0ZXIqIHBhc3NpdmUgZWZmZWN0cyBmaXJlIHRvIGF2b2lkIGZyZWVpbmcgYSBjYWNoZSBwb29sIHRoYXQgbWF5XG4gICAgICAgIC8vIGJlIHJlZmVyZW5jZWQgYnkgYSBub2RlIGluIHRoZSB0cmVlIChIb3N0Um9vdCwgQ2FjaGUgYm91bmRhcnkgZXRjKVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgZWZmZWN0cyBpbiB0aGUgd2hvbGUgdHJlZS5cbiAgLy8gVE9ETzogVGhpcyBpcyBsZWZ0IG92ZXIgZnJvbSB0aGUgZWZmZWN0IGxpc3QgaW1wbGVtZW50YXRpb24sIHdoZXJlIHdlIGhhZFxuICAvLyB0byBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBgZmlyc3RFZmZlY3RgIHRvIHNhdGlzZnkgRmxvdy4gSSB0aGluayB0aGVcbiAgLy8gb25seSBvdGhlciByZWFzb24gdGhpcyBvcHRpbWl6YXRpb24gZXhpc3RzIGlzIGJlY2F1c2UgaXQgYWZmZWN0cyBwcm9maWxpbmcuXG4gIC8vIFJlY29uc2lkZXIgd2hldGhlciB0aGlzIGlzIG5lY2Vzc2FyeS5cblxuXG4gIHZhciBzdWJ0cmVlSGFzRWZmZWN0cyA9IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgKEJlZm9yZU11dGF0aW9uTWFzayB8IE11dGF0aW9uTWFzayB8IExheW91dE1hc2sgfCBQYXNzaXZlTWFzaykpICE9PSBOb0ZsYWdzJDE7XG4gIHZhciByb290SGFzRWZmZWN0ID0gKGZpbmlzaGVkV29yay5mbGFncyAmIChCZWZvcmVNdXRhdGlvbk1hc2sgfCBNdXRhdGlvbk1hc2sgfCBMYXlvdXRNYXNrIHwgUGFzc2l2ZU1hc2spKSAhPT0gTm9GbGFncyQxO1xuXG4gIGlmIChzdWJ0cmVlSGFzRWZmZWN0cyB8fCByb290SGFzRWZmZWN0KSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0OyAvLyBUaGUgY29tbWl0IHBoYXNlIGlzIGJyb2tlbiBpbnRvIHNldmVyYWwgc3ViLXBoYXNlcy4gV2UgZG8gYSBzZXBhcmF0ZSBwYXNzXG4gICAgLy8gb2YgdGhlIGVmZmVjdCBsaXN0IGZvciBlYWNoIHBoYXNlOiBhbGwgbXV0YXRpb24gZWZmZWN0cyBjb21lIGJlZm9yZSBhbGxcbiAgICAvLyBsYXlvdXQgZWZmZWN0cywgYW5kIHNvIG9uLlxuICAgIC8vIFRoZSBmaXJzdCBwaGFzZSBhIFwiYmVmb3JlIG11dGF0aW9uXCIgcGhhc2UuIFdlIHVzZSB0aGlzIHBoYXNlIHRvIHJlYWQgdGhlXG4gICAgLy8gc3RhdGUgb2YgdGhlIGhvc3QgdHJlZSByaWdodCBiZWZvcmUgd2UgbXV0YXRlIGl0LiBUaGlzIGlzIHdoZXJlXG4gICAgLy8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgaXMgY2FsbGVkLlxuXG4gICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICB7XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbiAgICAgIC8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH0gLy8gVGhlIG5leHQgcGhhc2UgaXMgdGhlIG11dGF0aW9uIHBoYXNlLCB3aGVyZSB3ZSBtdXRhdGUgdGhlIGhvc3QgdHJlZS5cblxuXG4gICAgY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBtdXRhdGlvbiBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbCBjdXJyZW50IGR1cmluZ1xuICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBsYXlvdXQgcGhhc2UsIHNvIHRoYXQgdGhlIGZpbmlzaGVkXG4gICAgLy8gd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBsYXlvdXQgcGhhc2UsIHdoZXJlIHdlIGNhbGwgZWZmZWN0cyB0aGF0IHJlYWRcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuXG4gICAgY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIHJvb3QsIGxhbmVzKTtcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH0gLy8gVGVsbCBTY2hlZHVsZXIgdG8geWllbGQgYXQgdGhlIGVuZCBvZiB0aGUgZnJhbWUsIHNvIHRoZSBicm93c2VyIGhhcyBhblxuICAgIC8vIG9wcG9ydHVuaXR5IHRvIHBhaW50LlxuXG5cbiAgICByZXF1ZXN0UGFpbnQoKTtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIFJlc2V0IHRoZSBwcmlvcml0eSB0byB0aGUgcHJldmlvdXMgbm9uLXN5bmMgdmFsdWUuXG5cbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIGVmZmVjdHMuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBNZWFzdXJlIHRoZXNlIGFueXdheSBzbyB0aGUgZmxhbWVncmFwaCBleHBsaWNpdGx5IHNob3dzIHRoYXQgdGhlcmUgd2VyZVxuICAgIC8vIG5vIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gcmVwb3J0IHRoaXMuXG5cbiAgICB7XG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMgPSByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cztcblxuICBpZiAocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBUaGlzIGNvbW1pdCBoYXMgcGFzc2l2ZSBlZmZlY3RzLiBTdGFzaCBhIHJlZmVyZW5jZSB0byB0aGVtLiBCdXQgZG9uJ3RcbiAgICAvLyBzY2hlZHVsZSBhIGNhbGxiYWNrIHVudGlsIGFmdGVyIGZsdXNoaW5nIGxheW91dCB3b3JrLlxuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290O1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gbGFuZXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUgd2VyZSBubyBwYXNzaXZlIGVmZmVjdHMsIHNvIHdlIGNhbiBpbW1lZGlhdGVseSByZWxlYXNlIHRoZSBjYWNoZVxuICAgIC8vIHBvb2wgZm9yIHRoaXMgcmVuZGVyLlxuICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuXG4gICAge1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbiAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuICAgIH1cbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGFuIGVmZmVjdCBtaWdodCBoYXZlIHVwZGF0ZWQgaXRcblxuXG4gIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7IC8vIENoZWNrIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290XG4gIC8vIFRPRE86IFRoaXMgaXMgcGFydCBvZiB0aGUgYGNvbXBvbmVudERpZENhdGNoYCBpbXBsZW1lbnRhdGlvbi4gSXRzIHB1cnBvc2VcbiAgLy8gaXMgdG8gZGV0ZWN0IHdoZXRoZXIgc29tZXRoaW5nIG1pZ2h0IGhhdmUgY2FsbGVkIHNldFN0YXRlIGluc2lkZVxuICAvLyBgY29tcG9uZW50RGlkQ2F0Y2hgLiBUaGUgbWVjaGFuaXNtIGlzIGtub3duIHRvIGJlIGZsYXdlZCBiZWNhdXNlIGBzZXRTdGF0ZWBcbiAgLy8gaW5zaWRlIGBjb21wb25lbnREaWRDYXRjaGAgaXMgaXRzZWxmIGZsYXdlZCDigJQgdGhhdCdzIHdoeSB3ZSByZWNvbW1lbmRcbiAgLy8gYGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcmAgaW5zdGVhZC4gSG93ZXZlciwgaXQgY291bGQgYmUgaW1wcm92ZWQgYnlcbiAgLy8gY2hlY2tpbmcgaWYgcmVtYWluaW5nTGFuZXMgaW5jbHVkZXMgU3luYyB3b3JrLCBpbnN0ZWFkIG9mIHdoZXRoZXIgdGhlcmUnc1xuICAvLyBhbnkgd29yayByZW1haW5pbmcgYXQgYWxsICh3aGljaCB3b3VsZCBhbHNvIGluY2x1ZGUgc3R1ZmYgbGlrZSBTdXNwZW5zZVxuICAvLyByZXRyaWVzIG9yIHRyYW5zaXRpb25zKS4gSXQncyBiZWVuIGxpa2UgdGhpcyBmb3IgYSB3aGlsZSwgdGhvdWdoLCBzbyBmaXhpbmdcbiAgLy8gaXQgcHJvYmFibHkgaXNuJ3QgdGhhdCB1cmdlbnQuXG5cbiAgaWYgKHJlbWFpbmluZ0xhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIXJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290KTtcbiAgICB9XG4gIH1cblxuICBvbkNvbW1pdFJvb3QkMShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLCByZW5kZXJQcmlvcml0eUxldmVsKTtcblxuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICByb290Lm1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgb25Db21taXRSb290KCk7XG4gIH0gLy8gQWx3YXlzIGNhbGwgdGhpcyBiZWZvcmUgZXhpdGluZyBgY29tbWl0Um9vdGAsIHRvIGVuc3VyZSB0aGF0IGFueVxuICAvLyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290IGlzIHNjaGVkdWxlZC5cblxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcblxuICBpZiAocmVjb3ZlcmFibGVFcnJvcnMgIT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSB3ZXJlIGVycm9ycyBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCByZWNvdmVyZWQgZnJvbSB0aGVtIHdpdGhvdXRcbiAgICAvLyBuZWVkaW5nIHRvIHN1cmZhY2UgaXQgdG8gdGhlIFVJLiBXZSBsb2cgdGhlbSBoZXJlLlxuICAgIHZhciBvblJlY292ZXJhYmxlRXJyb3IgPSByb290Lm9uUmVjb3ZlcmFibGVFcnJvcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb3ZlcmFibGVFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZWNvdmVyYWJsZUVycm9yID0gcmVjb3ZlcmFibGVFcnJvcnNbaV07XG4gICAgICB2YXIgZXJyb3JJbmZvID0gbWFrZUVycm9ySW5mbyhyZWNvdmVyYWJsZUVycm9yLnN0YWNrKTtcblxuICAgICAge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihyZWNvdmVyYWJsZUVycm9yLnNvdXJjZSwgb25SZWNvdmVyYWJsZUVycm9yLCByZWNvdmVyYWJsZUVycm9yLnZhbHVlLCBlcnJvckluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBJZiB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSB0aGUgcmVzdWx0IG9mIGEgZGlzY3JldGUgcmVuZGVyLCBmbHVzaCB0aGVtXG4gIC8vIHN5bmNocm9ub3VzbHkgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0YXNrIHNvIHRoYXQgdGhlIHJlc3VsdCBpc1xuICAvLyBpbW1lZGlhdGVseSBvYnNlcnZhYmxlLiBPdGhlcndpc2UsIHdlIGFzc3VtZSB0aGF0IHRoZXkgYXJlIG5vdFxuICAvLyBvcmRlci1kZXBlbmRlbnQgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIG9ic2VydmVkIGJ5IGV4dGVybmFsIHN5c3RlbXMsIHNvIHdlXG4gIC8vIGNhbiB3YWl0IHVudGlsIGFmdGVyIHBhaW50LlxuICAvLyBUT0RPOiBXZSBjYW4gb3B0aW1pemUgdGhpcyBieSBub3Qgc2NoZWR1bGluZyB0aGUgY2FsbGJhY2sgZWFybGllci4gU2luY2Ugd2VcbiAgLy8gY3VycmVudGx5IHNjaGVkdWxlIHRoZSBjYWxsYmFjayBpbiBtdWx0aXBsZSBwbGFjZXMsIHdpbGwgd2FpdCB1bnRpbCB0aG9zZVxuICAvLyBhcmUgY29uc29saWRhdGVkLlxuXG5cbiAgaWYgKGluY2x1ZGVzU3luY0xhbmUocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMpICYmIChkaXNhYmxlTGVnYWN5TW9kZSApKSB7XG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9IC8vIFJlYWQgdGhpcyBhZ2Fpbiwgc2luY2UgYSBwYXNzaXZlIGVmZmVjdCBtaWdodCBoYXZlIHVwZGF0ZWQgaXRcblxuXG4gIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7IC8vIENoZWNrIGlmIHRoaXMgcmVuZGVyIHNjaGVkdWxlZCBhIGNhc2NhZGluZyBzeW5jaHJvbm91cyB1cGRhdGUuIFRoaXMgaXMgYVxuICAvLyBoZXVyc3RpYyB0byBkZXRlY3QgaW5maW5pdGUgdXBkYXRlIGxvb3BzLiBXZSBhcmUgaW50ZW50aW9uYWxseSBleGNsdWRpbmdcbiAgLy8gaHlkcmF0aW9uIGxhbmVzIGluIHRoaXMgY2hlY2ssIGJlY2F1c2UgcmVuZGVyIHRyaWdnZXJlZCBieSBzZWxlY3RpdmVcbiAgLy8gaHlkcmF0aW9uIGlzIGNvbmNlcHR1YWxseSBub3QgYW4gdXBkYXRlLlxuXG4gIGlmICggLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVjdXJzaXZlIHVwZGF0ZSBzcGF3bmVkIGJ5IHRoaXMgcmVuZGVyLCBpbiBlaXRoZXJcbiAgLy8gdGhlIHJlbmRlciBwaGFzZSBvciB0aGUgY29tbWl0IHBoYXNlLiBXZSB0cmFjayB0aGVzZSBleHBsaWNpdGx5IGJlY2F1c2VcbiAgLy8gd2UgY2FuJ3QgaW5mZXIgZnJvbSB0aGUgcmVtYWluaW5nIGxhbmVzIGFsb25lLlxuICAoZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlIHx8IGRpZEluY2x1ZGVDb21taXRQaGFzZVVwZGF0ZSkgfHwgLy8gV2FzIHRoZSBmaW5pc2hlZCByZW5kZXIgdGhlIHJlc3VsdCBvZiBhbiB1cGRhdGUgKG5vdCBoeWRyYXRpb24pP1xuICBpbmNsdWRlc1NvbWVMYW5lKGxhbmVzLCBVcGRhdGVMYW5lcykgJiYgLy8gRGlkIGl0IHNjaGVkdWxlIGEgc3luYyB1cGRhdGU/XG4gIGluY2x1ZGVzU29tZUxhbmUocmVtYWluaW5nTGFuZXMsIFN5bmNVcGRhdGVMYW5lcykpIHtcbiAgICB7XG4gICAgICBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCk7XG4gICAgfSAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByb290IHN5bmNocm9ub3VzbHkgcmUtcmVuZGVycyB3aXRob3V0XG4gICAgLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cblxuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9IC8vIElmIGxheW91dCB3b3JrIHdhcyBzY2hlZHVsZWQsIGZsdXNoIGl0IG5vdy5cblxuXG4gIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG5cbiAge1xuICAgIG1hcmtDb21taXRTdG9wcGVkKCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWFrZUVycm9ySW5mbyhjb21wb25lbnRTdGFjaykge1xuICB2YXIgZXJyb3JJbmZvID0ge1xuICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFja1xuICB9O1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JJbmZvLCAnZGlnZXN0Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVycm9yKCdZb3UgYXJlIGFjY2Vzc2luZyBcImRpZ2VzdFwiIGZyb20gdGhlIGVycm9ySW5mbyBvYmplY3QgcGFzc2VkIHRvIG9uUmVjb3ZlcmFibGVFcnJvci4nICsgJyBUaGlzIHByb3BlcnR5IGlzIG5vIGxvbmdlciBwcm92aWRlZCBhcyBwYXJ0IG9mIGVycm9ySW5mbyBidXQgY2FuIGJlIGFjY2Vzc2VkIGFzIGEgcHJvcGVydHknICsgJyBvZiB0aGUgRXJyb3IgaW5zdGFuY2UgaXRzZWxmLicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVycm9ySW5mbztcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcykge1xuICB7XG4gICAgdmFyIHBvb2xlZENhY2hlTGFuZXMgPSByb290LnBvb2xlZENhY2hlTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG5cbiAgICBpZiAocG9vbGVkQ2FjaGVMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgICAgLy8gTm9uZSBvZiB0aGUgcmVtYWluaW5nIHdvcmsgcmVsaWVzIG9uIHRoZSBjYWNoZSBwb29sLiBDbGVhciBpdCBzb1xuICAgICAgLy8gc3Vic2VxdWVudCByZXF1ZXN0cyBnZXQgYSBuZXcgY2FjaGVcbiAgICAgIHZhciBwb29sZWRDYWNoZSA9IHJvb3QucG9vbGVkQ2FjaGU7XG5cbiAgICAgIGlmIChwb29sZWRDYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHJvb3QucG9vbGVkQ2FjaGUgPSBudWxsO1xuICAgICAgICByZWxlYXNlQ2FjaGUocG9vbGVkQ2FjaGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAvLyBSZXR1cm5zIHdoZXRoZXIgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgZmx1c2hlZC5cbiAgLy8gVE9ETzogQ29tYmluZSB0aGlzIGNoZWNrIHdpdGggdGhlIG9uZSBpbiBmbHVzaFBhc3NpdmVFRmZlY3RzSW1wbC4gV2Ugc2hvdWxkXG4gIC8vIHByb2JhYmx5IGp1c3QgY29tYmluZSB0aGUgdHdvIGZ1bmN0aW9ucy4gSSBiZWxpZXZlIHRoZXkgd2VyZSBvbmx5IHNlcGFyYXRlXG4gIC8vIGluIHRoZSBmaXJzdCBwbGFjZSBiZWNhdXNlIHdlIHVzZWQgdG8gd3JhcCBpdCB3aXRoXG4gIC8vIGBTY2hlZHVsZXIucnVuV2l0aFByaW9yaXR5YCwgd2hpY2ggYWNjZXB0cyBhIGZ1bmN0aW9uLiBCdXQgbm93IHdlIHRyYWNrIHRoZVxuICAvLyBwcmlvcml0eSB3aXRoaW4gUmVhY3QgaXRzZWxmLCBzbyB3ZSBjYW4gbXV0YXRlIHRoZSB2YXJpYWJsZSBkaXJlY3RseS5cbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKSB7XG4gICAgLy8gQ2FjaGUgdGhlIHJvb3Qgc2luY2Ugcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgaXMgY2xlYXJlZCBpblxuICAgIC8vIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsXG4gICAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0czsgLy8gQ2FjaGUgYW5kIGNsZWFyIHRoZSByZW1haW5pbmcgbGFuZXMgZmxhZzsgaXQgbXVzdCBiZSByZXNldCBzaW5jZSB0aGlzXG4gICAgLy8gbWV0aG9kIGNhbiBiZSBjYWxsZWQgZnJvbSB2YXJpb3VzIHBsYWNlcywgbm90IGFsd2F5cyBmcm9tIGNvbW1pdFJvb3RcbiAgICAvLyB3aGVyZSB0aGUgcmVtYWluaW5nIGxhbmVzIGFyZSBrbm93blxuXG4gICAgdmFyIHJlbWFpbmluZ0xhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXM7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSBOb0xhbmVzO1xuICAgIHZhciByZW5kZXJQcmlvcml0eSA9IGxhbmVzVG9FdmVudFByaW9yaXR5KHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzKTtcbiAgICB2YXIgcHJpb3JpdHkgPSBsb3dlckV2ZW50UHJpb3JpdHkoRGVmYXVsdEV2ZW50UHJpb3JpdHksIHJlbmRlclByaW9yaXR5KTtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgICB0cnkge1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByaW9yaXR5KTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgcmV0dXJuIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbjsgLy8gT25jZSBwYXNzaXZlIGVmZmVjdHMgaGF2ZSBydW4gZm9yIHRoZSB0cmVlIC0gZ2l2aW5nIGNvbXBvbmVudHMgYVxuICAgICAgLy8gY2hhbmNlIHRvIHJldGFpbiBjYWNoZSBpbnN0YW5jZXMgdGhleSB1c2UgLSByZWxlYXNlIHRoZSBwb29sZWRcbiAgICAgIC8vIGNhY2hlIGF0IHRoZSByb290IChpZiB0aGVyZSBpcyBvbmUpXG5cbiAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0KGZpYmVyKSB7XG4gIHtcbiAgICBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cy5wdXNoKGZpYmVyKTtcblxuICAgIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsKCkge1xuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQ2FjaGUgYW5kIGNsZWFyIHRoZSB0cmFuc2l0aW9ucyBmbGFnXG5cblxuICB2YXIgdHJhbnNpdGlvbnMgPSBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zO1xuICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbDtcbiAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cztcbiAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDsgLy8gVE9ETzogVGhpcyBpcyBzb21ldGltZXMgb3V0IG9mIHN5bmMgd2l0aCByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cy5cbiAgLy8gRmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gSXQncyBub3QgY2F1c2luZyBhbnkga25vd24gaXNzdWVzIChwcm9iYWJseVxuICAvLyBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZvciBwcm9maWxpbmcpLCBidXQgaXQncyBhIHJlZmFjdG9yIGhhemFyZC5cblxuICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZsdXNoIHBhc3NpdmUgZWZmZWN0cyB3aGlsZSBhbHJlYWR5IHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHtcbiAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKHJvb3QuY3VycmVudCk7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgcm9vdC5jdXJyZW50LCBsYW5lcywgdHJhbnNpdGlvbnMpOyAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuICB7XG4gICAgdmFyIHByb2ZpbGVyRWZmZWN0cyA9IHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzO1xuICAgIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2ZpbGVyRWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZpYmVyID0gcHJvZmlsZXJFZmZlY3RzW2ldO1xuICAgICAgY29tbWl0UGFzc2l2ZUVmZmVjdER1cmF0aW9ucyhyb290LCBmaWJlcik7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgfVxuXG4gIHtcbiAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCk7XG4gIH1cblxuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG5cbiAge1xuICAgIC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gICAgLy8gZXhjZWVkcyB0aGUgbGltaXQsIHdlJ2xsIGZpcmUgYSB3YXJuaW5nLlxuICAgIGlmIChkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBpZiAocm9vdCA9PT0gcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcykge1xuICAgICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG4gICAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSByb290O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgIH1cblxuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbiAgfSAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuXG4gIG9uUG9zdENvbW1pdFJvb3Qocm9vdCk7XG5cbiAge1xuICAgIHZhciBzdGF0ZU5vZGUgPSByb290LmN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkge1xuICByZXR1cm4gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgIT09IG51bGwgJiYgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcbiAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFtpbnN0YW5jZV0pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLnN0YXRlTm9kZSwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHVwZGF0ZSwgU3luY0xhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIFN5bmNMYW5lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3Ioc291cmNlRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yJDEpIHtcbiAge1xuICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7XG4gIH1cblxuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvciQxKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmliZXIgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yO1xuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChmaWJlciwgc291cmNlRmliZXIsIGVycm9yJDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIGN0b3IgPSBmaWJlci50eXBlO1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yJDEsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoU3luY0xhbmUpO1xuICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgU3luY0xhbmUpO1xuXG4gICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUodXBkYXRlLCByb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgICAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgU3luY0xhbmUpO1xuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEF0dGVtcHRlZCB0byBjYXB0dXJlIGEgY29tbWl0IHBoYXNlIGVycm9yICcgKyAnaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIFBvdGVudGlhbCAnICsgJ2NhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuICcgKyAnYWxyZWFkeS1maW5pc2hlZCB0cmVlLCBvciBhbiBpbmNvbnNpc3RlbnQgcmV0dXJuIHBvaW50ZXIuXFxuXFxuJyArICdFcnJvciBtZXNzYWdlOlxcblxcbiVzJywgZXJyb3IkMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgLy8gQXR0YWNoIGEgcGluZyBsaXN0ZW5lclxuICAvL1xuICAvLyBUaGUgZGF0YSBtaWdodCByZXNvbHZlIGJlZm9yZSB3ZSBoYXZlIGEgY2hhbmNlIHRvIGNvbW1pdCB0aGUgZmFsbGJhY2suIE9yLFxuICAvLyBpbiB0aGUgY2FzZSBvZiBhIHJlZnJlc2gsIHdlJ2xsIG5ldmVyIGNvbW1pdCBhIGZhbGxiYWNrLiBTbyB3ZSBuZWVkIHRvXG4gIC8vIGF0dGFjaCBhIGxpc3RlbmVyIG5vdy4gV2hlbiBpdCByZXNvbHZlcyAoXCJwaW5nc1wiKSwgd2UgY2FuIGRlY2lkZSB3aGV0aGVyIHRvXG4gIC8vIHRyeSByZW5kZXJpbmcgdGhlIHRyZWUgYWdhaW4uXG4gIC8vXG4gIC8vIE9ubHkgYXR0YWNoIGEgbGlzdGVuZXIgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoZSBsYW5lc1xuICAvLyB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nICh3aGljaCBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICAvL1xuICAvLyBXZSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpbiBjb25jdXJyZW50IG1vZGUuIExlZ2FjeSBTdXNwZW5zZSBhbHdheXNcbiAgLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIHZhciB0aHJlYWRJRHM7XG5cbiAgaWYgKHBpbmdDYWNoZSA9PT0gbnVsbCkge1xuICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpO1xuICB9IGVsc2Uge1xuICAgIHRocmVhZElEcyA9IHBpbmdDYWNoZS5nZXQod2FrZWFibGUpO1xuXG4gICAgaWYgKHRocmVhZElEcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgICBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGhyZWFkSURzLmhhcyhsYW5lcykpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSB0cnVlOyAvLyBNZW1vaXplIHVzaW5nIHRoZSB0aHJlYWQgSUQgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxuXG4gICAgdGhyZWFkSURzLmFkZChsYW5lcyk7XG4gICAgdmFyIHBpbmcgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcyk7XG5cbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzXG4gICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdha2VhYmxlLnRoZW4ocGluZywgcGluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3Qocm9vdCwgd2FrZWFibGUsIHBpbmdlZExhbmVzKSB7XG4gIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcblxuICBpZiAocGluZ0NhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcGluZ0NhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gIH1cblxuICBtYXJrUm9vdFBpbmdlZChyb290LCBwaW5nZWRMYW5lcyk7XG4gIHdhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWKCk7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJiBpc1N1YnNldE9mTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIHBpbmdlZExhbmVzKSkge1xuICAgIC8vIFJlY2VpdmVkIGEgcGluZyBhdCB0aGUgc2FtZSBwcmlvcml0eSBsZXZlbCBhdCB3aGljaCB3ZSdyZSBjdXJyZW50bHlcbiAgICAvLyByZW5kZXJpbmcuIFdlIG1pZ2h0IHdhbnQgdG8gcmVzdGFydCB0aGlzIHJlbmRlci4gVGhpcyBzaG91bGQgbWlycm9yXG4gICAgLy8gdGhlIGxvZ2ljIG9mIHdoZXRoZXIgb3Igbm90IGEgcm9vdCBzdXNwZW5kcyBvbmNlIGl0IGNvbXBsZXRlcy5cbiAgICAvLyBUT0RPOiBJZiB3ZSdyZSByZW5kZXJpbmcgc3luYyBlaXRoZXIgZHVlIHRvIFN5bmMsIEJhdGNoZWQgb3IgZXhwaXJlZCxcbiAgICAvLyB3ZSBzaG91bGQgcHJvYmFibHkgbmV2ZXIgcmVzdGFydC5cbiAgICAvLyBJZiB3ZSdyZSBzdXNwZW5kZWQgd2l0aCBkZWxheSwgb3IgaWYgaXQncyBhIHJldHJ5LCB3ZSdsbCBhbHdheXMgc3VzcGVuZFxuICAgIC8vIHNvIHdlIGNhbiBhbHdheXMgcmVzdGFydC5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkICYmIGluY2x1ZGVzT25seVJldHJpZXMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpICYmIG5vdyQxKCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpIHtcbiAgICAgIC8vIEZvcmNlIGEgcmVzdGFydCBmcm9tIHRoZSByb290IGJ5IHVud2luZGluZyB0aGUgc3RhY2suIFVubGVzcyB0aGlzIGlzXG4gICAgICAvLyBiZWluZyBjYWxsZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlLCBiZWNhdXNlIHRoYXQgd291bGQgY2F1c2UgYSBjcmFzaC5cbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHJlc3RhcnQgcmlnaHQgbm93LCB3ZSBtaWdodCBnZXQgYW5cbiAgICAgIC8vIG9wcG9ydHVuaXR5IGxhdGVyLiBTbyB3ZSBtYXJrIHRoaXMgcmVuZGVyIGFzIGhhdmluZyBhIHBpbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICB9XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG59XG5cbmZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgLy8gVGhlIGJvdW5kYXJ5IGZpYmVyIChhIFN1c3BlbnNlIGNvbXBvbmVudCBvciBTdXNwZW5zZUxpc3QgY29tcG9uZW50KVxuICAvLyBwcmV2aW91c2x5IHdhcyByZW5kZXJlZCBpbiBpdHMgZmFsbGJhY2sgc3RhdGUuIE9uZSBvZiB0aGUgcHJvbWlzZXMgdGhhdFxuICAvLyBzdXNwZW5kZWQgaXQgaGFzIHJlc29sdmVkLCB3aGljaCBtZWFucyBhdCBsZWFzdCBwYXJ0IG9mIHRoZSB0cmVlIHdhc1xuICAvLyBsaWtlbHkgdW5ibG9ja2VkLiBUcnkgcmVuZGVyaW5nIGFnYWluLCBhdCBhIG5ldyBsYW5lcy5cbiAgaWYgKHJldHJ5TGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgLy8gVE9ETzogQXNzaWduIHRoaXMgdG8gYHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lYD8gdG8gYXZvaWRcbiAgICAvLyB1bm5lY2Vzc2FyeSBlbnRhbmdsZW1lbnQ/XG4gICAgcmV0cnlMYW5lID0gcmVxdWVzdFJldHJ5TGFuZSgpO1xuICB9IC8vIFRPRE86IFNwZWNpYWwgY2FzZSBpZGxlIHByaW9yaXR5P1xuXG5cbiAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIG1hcmtSb290VXBkYXRlZChyb290LCByZXRyeUxhbmUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZXRyeUxhbmUgPSBOb0xhbmU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICByZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZTtcbiAgfVxuXG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJldHJ5V2FrZWFibGUoYm91bmRhcnlGaWJlciwgd2FrZWFibGUpIHtcbiAgdmFyIHJldHJ5TGFuZSA9IE5vTGFuZTsgLy8gRGVmYXVsdFxuXG4gIHZhciByZXRyeUNhY2hlO1xuXG4gIHN3aXRjaCAoYm91bmRhcnlGaWJlci50YWcpIHtcbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHJldHJ5Q2FjaGUgPSBpbnN0YW5jZS5fcmV0cnlDYWNoZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiAnICsgJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocmV0cnlDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHJldHJ5Q2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgfVxuXG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gdGhyb3dJZkluZmluaXRlVXBkYXRlTG9vcERldGVjdGVkKCkge1xuICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbiAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGlmIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCAmJiB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UncmUgaW4gdGhlIHJlbmRlciBwaGFzZS4gRGlzYWJsZSB0aGUgY29uY3VycmVudCBlcnJvciByZWNvdmVyeVxuICAgICAgICAvLyBtZWNoYW5pc20gdG8gZW5zdXJlIHRoYXQgdGhlIGVycm9yIHdlJ3JlIGFib3V0IHRvIHRocm93IGdldHMgaGFuZGxlZC5cbiAgICAgICAgLy8gV2UgbmVlZCBpdCB0byB0cmlnZ2VyIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IHNvIHRoYXQgdGhlIGluZmluaXRlXG4gICAgICAgIC8vIHVwZGF0ZSBsb29wIGlzIGJyb2tlbi5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgJ3JlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgJyArICdjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvICcgKyAncHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID4gTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7XG5cbiAgICAgIGVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJyArIFwiY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBcIiArICdoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiAnICsgJ2V2ZXJ5IHJlbmRlci4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LCBwYXJlbnRGaWJlciwgaXNJblN0cmljdE1vZGUpIHtcbiAgaWYgKChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAoUGxhY2VtZW50REVWIHwgVmlzaWJpbGl0eSkpID09PSBOb0ZsYWdzJDEpIHtcbiAgICAvLyBQYXJlbnQncyBkZXNjZW5kYW50cyBoYXZlIGFscmVhZHkgaGFkIGVmZmVjdHMgZG91YmxlIGludm9rZWQuXG4gICAgLy8gRWFybHkgZXhpdCB0byBhdm9pZCB1bm5lY2Vzc2FyeSB0cmVlIHRyYXZlcnNhbC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBkb3VibGVJbnZva2VFZmZlY3RzSW5ERVZJZk5lY2Vzc2FyeShyb290LCBjaGlsZCwgaXNJblN0cmljdE1vZGUpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufSAvLyBVbmNvbmRpdGlvbmFsbHkgZGlzY29ubmVjdHMgYW5kIGNvbm5lY3RzIHBhc3NpdmUgYW5kIGxheW91dCBlZmZlY3RzLlxuXG5cbmZ1bmN0aW9uIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyKHJvb3QsIGZpYmVyKSB7XG4gIHZhciBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG4gIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmliZXIpO1xuXG4gIGlmIChzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cykge1xuICAgIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGZpYmVyKTtcbiAgfVxuXG4gIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhyb290LCBmaWJlci5hbHRlcm5hdGUsIGZpYmVyLCBmYWxzZSk7XG5cbiAgaWYgKHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMocm9vdCwgZmliZXIsIE5vTGFuZXMsIG51bGwsIGZhbHNlKTtcbiAgfVxuXG4gIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZG91YmxlSW52b2tlRWZmZWN0c0luREVWSWZOZWNlc3Nhcnkocm9vdCwgZmliZXIsIHBhcmVudElzSW5TdHJpY3RNb2RlKSB7XG4gIHZhciBpc1N0cmljdE1vZGVGaWJlciA9IGZpYmVyLnR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gIHZhciBpc0luU3RyaWN0TW9kZSA9IHBhcmVudElzSW5TdHJpY3RNb2RlIHx8IGlzU3RyaWN0TW9kZUZpYmVyOyAvLyBGaXJzdCBjYXNlOiB0aGUgZmliZXIgKippcyBub3QqKiBvZiB0eXBlIE9mZnNjcmVlbkNvbXBvbmVudC4gTm9cbiAgLy8gc3BlY2lhbCBydWxlcyBhcHBseSB0byBkb3VibGUgaW52b2tpbmcgZWZmZWN0cy5cblxuICBpZiAoZmliZXIudGFnICE9PSBPZmZzY3JlZW5Db21wb25lbnQpIHtcbiAgICBpZiAoZmliZXIuZmxhZ3MgJiBQbGFjZW1lbnRERVYpIHtcbiAgICAgIGlmIChpc0luU3RyaWN0TW9kZSkge1xuICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIsIHJvb3QsIGZpYmVyLCAoZmliZXIubW9kZSAmIE5vU3RyaWN0UGFzc2l2ZUVmZmVjdHNNb2RlKSA9PT0gTm9Nb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LCBmaWJlciwgaXNJblN0cmljdE1vZGUpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBTZWNvbmQgY2FzZTogdGhlIGZpYmVyICoqaXMqKiBvZiB0eXBlIE9mZnNjcmVlbkNvbXBvbmVudC5cbiAgLy8gVGhpcyBicmFuY2ggY29udGFpbnMgY2FzZXMgc3BlY2lmaWMgdG8gT2Zmc2NyZWVuLlxuXG5cbiAgaWYgKGZpYmVyLm1lbW9pemVkU3RhdGUgPT09IG51bGwpIHtcbiAgICAvLyBPbmx5IGNvbnNpZGVyIE9mZnNjcmVlbiB0aGF0IGlzIHZpc2libGUuXG4gICAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBIYW5kbGUgbWFudWFsIG1vZGUuXG4gICAgaWYgKGlzSW5TdHJpY3RNb2RlICYmIGZpYmVyLmZsYWdzICYgVmlzaWJpbGl0eSkge1xuICAgICAgLy8gRG91YmxlIGludm9rZSBlZmZlY3RzIG9uIE9mZnNjcmVlbidzIHN1YnRyZWUgb25seVxuICAgICAgLy8gaWYgaXQgaXMgdmlzaWJsZSBhbmQgaXRzIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQuXG4gICAgICBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIsIHJvb3QsIGZpYmVyKTtcbiAgICB9IGVsc2UgaWYgKGZpYmVyLnN1YnRyZWVGbGFncyAmIFBsYWNlbWVudERFVikge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSBzdWJ0cmVlIGNvdWxkIGhhdmUgYmVlbiBzdXNwZW5kZWQuXG4gICAgICAvLyBXZSBuZWVkIHRvIGNvbnRpbnVlIHRyYXZlcnNhbCBhbmQgZmluZCBuZXdseSBpbnNlcnRlZCBmaWJlcnMuXG4gICAgICBydW5XaXRoRmliZXJJbkRFVihmaWJlciwgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFViwgcm9vdCwgZmliZXIsIGlzSW5TdHJpY3RNb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QsIGhhc1Bhc3NpdmVFZmZlY3RzKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgZG91YmxlSW52b2tlRWZmZWN0cyA9IHRydWU7XG5cbiAgICAgIGlmICghKHJvb3QuY3VycmVudC5tb2RlICYgKFN0cmljdExlZ2FjeU1vZGUgfCBTdHJpY3RFZmZlY3RzTW9kZSkpKSB7XG4gICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LCByb290LmN1cnJlbnQsIGRvdWJsZUludm9rZUVmZmVjdHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG51bGw7XG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBIb3N0Um9vdCAmJiB0YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIHRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgdGFnICE9PSBGb3J3YXJkUmVmICYmIHRhZyAhPT0gTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQpIHtcbiAgICAgIC8vIE9ubHkgd2FybiBmb3IgdXNlci1kZWZpbmVkIGNvbXBvbmVudHMsIG5vdCBpbnRlcm5hbCBvbmVzIGxpa2UgU3VzcGVuc2UuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4gICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnUmVhY3RDb21wb25lbnQnO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbY29tcG9uZW50TmFtZV0pO1xuICAgIH1cblxuICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlcnJvcihcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYSBjb21wb25lbnQgdGhhdCBoYXNuJ3QgbW91bnRlZCB5ZXQuIFwiICsgJ1RoaXMgaW5kaWNhdGVzIHRoYXQgeW91IGhhdmUgYSBzaWRlLWVmZmVjdCBpbiB5b3VyIHJlbmRlciBmdW5jdGlvbiB0aGF0ICcgKyAnYXN5bmNocm9ub3VzbHkgbGF0ZXIgY2FsbHMgdHJpZXMgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQuIE1vdmUgdGhpcyB3b3JrIHRvICcgKyAndXNlRWZmZWN0IGluc3RlYWQuJyk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudDtcblxue1xuICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDb21wb25lbnROYW1lID0gd29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgJyArICdkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCAnICsgJ2ZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc2V0c3RhdGUtaW4tcmVuZGVyJywgc2V0U3RhdGVDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlcikge1xuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgJyArICdmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuJyk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG4gICAgICBtZW1vaXplZFVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxpbmdGaWJlcikge1xuICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgc2NoZWR1bGluZ0ZpYmVyLCBsYW5lcyk7XG4gICAgICB9KTsgLy8gVGhpcyBmdW5jdGlvbiBpbnRlbnRpb25hbGx5IGRvZXMgbm90IGNsZWFyIG1lbW9pemVkIHVwZGF0ZXJzLlxuICAgICAgLy8gVGhvc2UgbWF5IHN0aWxsIGJlIHJlbGV2YW50IHRvIHRoZSBjdXJyZW50IGNvbW1pdFxuICAgICAgLy8gYW5kIGEgZnV0dXJlIG9uZSAoZS5nLiBTdXNwZW5zZSkuXG4gICAgfVxuICB9XG59XG52YXIgZmFrZUFjdENhbGxiYWNrTm9kZSA9IHt9OyAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spIHtcbiAge1xuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYW4gYGFjdGAgc2NvcGUsIGJ5cGFzcyBTY2hlZHVsZXIgYW5kIHB1c2ggdG9cbiAgICAvLyB0aGUgYGFjdGAgcXVldWUgaW5zdGVhZC5cbiAgICB2YXIgYWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcblxuICAgIGlmIChhY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgYWN0UXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZmFrZUFjdENhbGxiYWNrTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2skMyhwcmlvcml0eUxldmVsLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpIHtcbiAgLy8gTmV2ZXIgZm9yY2UgZmx1c2ggaW4gcHJvZHVjdGlvbi4gVGhpcyBmdW5jdGlvbiBzaG91bGQgZ2V0IHN0cmlwcGVkIG91dC5cbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpIHtcbiAge1xuICAgIHtcbiAgICAgIGlmICghaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSkge1xuICAgICAgICAvLyBOb3QgaW4gYW4gYWN0IGVudmlyb25tZW50LiBObyBuZWVkIHRvIHdhcm4uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPT09IG51bGwpIHtcbiAgICAgIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVycm9yKCdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYocm9vdCkge1xuICB7XG4gICAgaWYgKGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiYgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIHN1c3BlbmRlZCByZXNvdXJjZSBmaW5pc2hlZCBsb2FkaW5nIGluc2lkZSBhIHRlc3QsIGJ1dCB0aGUgZXZlbnQgJyArICd3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCByZXNvbHZlcyBzdXNwZW5kZWQgZGF0YSBzaG91bGQgYmUgd3JhcHBlZCAnICsgJ2ludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaW5pc2ggbG9hZGluZyBzdXNwZW5kZWQgZGF0YSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGlzUnVubmluZykge1xuICB7XG4gICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gaXNSdW5uaW5nO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXMgKi9cbi8vIFVzZWQgYnkgUmVhY3QgUmVmcmVzaCBydW50aW1lIHRocm91Z2ggRGV2VG9vbHMgR2xvYmFsIEhvb2suXG5cbnZhciByZXNvbHZlRmFtaWx5ID0gbnVsbDtcbnZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbnZhciBzZXRSZWZyZXNoSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gIHtcbiAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIC8vIE5vIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzLlxuICByZXR1cm4gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgcmVhbCBmb3J3YXJkUmVmLiBEb24ndCB3YW50IHRvIGNyYXNoIGVhcmx5LlxuICAgICAgaWYgKHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGb3J3YXJkUmVmIGlzIHNwZWNpYWwgYmVjYXVzZSBpdHMgcmVzb2x2ZWQgLnR5cGUgaXMgYW4gb2JqZWN0LFxuICAgICAgICAvLyBidXQgaXQncyBwb3NzaWJsZSB0aGF0IHdlIG9ubHkgaGF2ZSBpdHMgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGluIHRoZSBtYXAuXG4gICAgICAgIC8vIElmIHRoYXQgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCwgd2UnbGwgYnVpbGQgYSBuZXcgZm9yd2FyZFJlZiB0eXBlLlxuICAgICAgICB2YXIgY3VycmVudFJlbmRlciA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcik7XG5cbiAgICAgICAgaWYgKHR5cGUucmVuZGVyICE9PSBjdXJyZW50UmVuZGVyKSB7XG4gICAgICAgICAgdmFyIHN5bnRoZXRpY1R5cGUgPSB7XG4gICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICAgICAgICAgIHJlbmRlcjogY3VycmVudFJlbmRlclxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzeW50aGV0aWNUeXBlLmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3ludGhldGljVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHByZXZUeXBlID0gZmliZXIuZWxlbWVudFR5cGU7XG4gICAgdmFyIG5leHRUeXBlID0gZWxlbWVudC50eXBlOyAvLyBJZiB3ZSBnb3QgaGVyZSwgd2Uga25vdyB0eXBlcyBhcmVuJ3QgPT09IGVxdWFsLlxuXG4gICAgdmFyIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gZmFsc2U7XG4gICAgdmFyICQkdHlwZW9mTmV4dFR5cGUgPSB0eXBlb2YgbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIG5leHRUeXBlICE9PSBudWxsID8gbmV4dFR5cGUuJCR0eXBlb2YgOiBudWxsO1xuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgaW5uZXIgdHlwZSB5ZXQuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBhc3N1bWUgdGhhdCB0aGUgbGF6eSBpbm5lciB0eXBlIGlzIHN0YWJsZSxcbiAgICAgICAgICAgIC8vIGFuZCBzbyBpdCBpcyBzdWZmaWNpZW50IHRvIGF2b2lkIHJlY29uY2lsaW5nIGl0IGF3YXkuXG4gICAgICAgICAgICAvLyBXZSdyZSBub3QgZ29pbmcgdG8gdW53cmFwIG9yIGFjdHVhbGx5IHVzZSB0aGUgbmV3IGxhenkgdHlwZS5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgLy8gVE9ETzogaWYgaXQgd2FzIGJ1dCBjYW4gbm8gbG9uZ2VyIGJlIHNpbXBsZSxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZG4ndCBzZXQgdGhpcy5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENoZWNrIGlmIGJvdGggdHlwZXMgaGF2ZSBhIGZhbWlseSBhbmQgaXQncyB0aGUgc2FtZSBvbmUuXG5cblxuICAgIGlmIChuZWVkc0NvbXBhcmVGYW1pbGllcykge1xuICAgICAgLy8gTm90ZTogbWVtbygpIGFuZCBmb3J3YXJkUmVmKCkgd2UnbGwgY29tcGFyZSBvdXRlciByYXRoZXIgdGhhbiBpbm5lciB0eXBlLlxuICAgICAgLy8gVGhpcyBtZWFucyBib3RoIG9mIHRoZW0gbmVlZCB0byBiZSByZWdpc3RlcmVkIHRvIHByZXNlcnZlIHN0YXRlLlxuICAgICAgLy8gSWYgd2UgdW53cmFwcGVkIGFuZCBjb21wYXJlZCB0aGUgaW5uZXIgdHlwZXMgZm9yIHdyYXBwZXJzIGluc3RlYWQsXG4gICAgICAvLyB0aGVuIHdlIHdvdWxkIHJpc2sgZmFsc2VseSBzYXlpbmcgdHdvIHNlcGFyYXRlIG1lbW8oRm9vKVxuICAgICAgLy8gY2FsbHMgYXJlIGVxdWl2YWxlbnQgYmVjYXVzZSB0aGV5IHdyYXAgdGhlIHNhbWUgRm9vIGZ1bmN0aW9uLlxuICAgICAgdmFyIHByZXZGYW1pbHkgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKTsgLy8gJEZsb3dGaXhNZVtub3QtYS1mdW5jdGlvbl0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgICBpZiAocHJldkZhbWlseSAhPT0gdW5kZWZpbmVkICYmIHByZXZGYW1pbHkgPT09IHJlc29sdmVGYW1pbHkobmV4dFR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgV2Vha1NldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFdlYWtTZXQoKTtcbiAgICB9XG5cbiAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcik7XG4gIH1cbn1cbnZhciBzY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgdXBkYXRlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhbGVGYW1pbGllcyA9IHVwZGF0ZS5zdGFsZUZhbWlsaWVzLFxuICAgICAgICB1cGRhdGVkRmFtaWxpZXMgPSB1cGRhdGUudXBkYXRlZEZhbWlsaWVzO1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICBmbHVzaFN5bmNXb3JrKCk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVSb290ID0gZnVuY3Rpb24gKHJvb3QsIGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyb290LmNvbnRleHQgIT09IGVtcHR5Q29udGV4dE9iamVjdCkge1xuICAgICAgLy8gU3VwZXIgZWRnZSBjYXNlOiByb290IGhhcyBhIGxlZ2FjeSBfcmVuZGVyU3VidHJlZSBjb250ZXh0XG4gICAgICAvLyBidXQgd2UgZG9uJ3Qga25vdyB0aGUgcGFyZW50Q29tcG9uZW50IHNvIHdlIGNhbid0IHBhc3MgaXQuXG4gICAgICAvLyBKdXN0IGlnbm9yZS4gV2UnbGwgZGVsZXRlIHRoaXMgd2l0aCBfcmVuZGVyU3VidHJlZSBjb2RlIHBhdGggbGF0ZXIuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXBkYXRlQ29udGFpbmVyU3luYyhlbGVtZW50LCByb290LCBudWxsLCBudWxsKTtcbiAgICBmbHVzaFN5bmNXb3JrKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoZmliZXIsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcykge1xuICB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZHNSZW5kZXIgPSBmYWxzZTtcbiAgICB2YXIgbmVlZHNSZW1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSk7XG5cbiAgICAgIGlmIChmYW1pbHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RhbGVGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlZEZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG4gICAgICAgICAgaWYgKHRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRzUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgIGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhhbHRlcm5hdGUpKSB7XG4gICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVtb3VudCkge1xuICAgICAgZmliZXIuX2RlYnVnTmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobmVlZHNSZW1vdW50IHx8IG5lZWRzUmVuZGVyKSB7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwgJiYgIW5lZWRzUmVtb3VudCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShjaGlsZCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShzaWJsaW5nLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIGZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgaG9zdEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdHlwZXMgPSBuZXcgU2V0KGZhbWlsaWVzLm1hcChmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gICAgfSkpO1xuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICByZXR1cm4gaG9zdEluc3RhbmNlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGZpYmVyLCB0eXBlcywgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGRpZE1hdGNoID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVzLmhhcyhjYW5kaWRhdGVUeXBlKSkge1xuICAgICAgICBkaWRNYXRjaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpZE1hdGNoKSB7XG4gICAgICAvLyBXZSBoYXZlIGEgbWF0Y2guIFRoaXMgb25seSBkcmlsbHMgZG93biB0byB0aGUgY2xvc2VzdCBob3N0IGNvbXBvbmVudHMuXG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoIGRlZXBlciBiZWNhdXNlIGZvciB0aGUgcHVycG9zZSBvZiBnaXZpbmdcbiAgICAgIC8vIHZpc3VhbCBmZWVkYmFjaywgXCJmbGFzaGluZ1wiIG91dGVybW9zdCBwYXJlbnQgcmVjdGFuZ2xlcyBpcyBzdWZmaWNpZW50LlxuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWF0Y2gsIG1heWJlIHRoZXJlIHdpbGwgYmUgb25lIGZ1cnRoZXIgZG93biBpbiB0aGUgY2hpbGQgdHJlZS5cbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoY2hpbGQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG5cbiAgICBpZiAoZm91bmRIb3N0SW5zdGFuY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnkgaG9zdCBjaGlsZHJlbiwgZmFsbGJhY2sgdG8gY2xvc2VzdCBob3N0IHBhcmVudC5cblxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gcmVhY2ggcm9vdCBmaXJzdC4nKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCAoc3VwcG9ydHNTaW5nbGV0b25zID8gbm9kZS50YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbWF0Y2guXG4gICAgICAgIGZvdW5kSG9zdEluc3RhbmNlcyA9IHRydWU7XG4gICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTsgLy8gVGhlcmUgbWF5IHN0aWxsIGJlIG1vcmUsIHNvIGtlZXAgc2VhcmNoaW5nLlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLmVsZW1lbnRUeXBlID0gbnVsbDtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsOyAvLyBGaWJlclxuXG4gIHRoaXMucmV0dXJuID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuICB0aGlzLnJlZiA9IG51bGw7XG4gIHRoaXMucmVmQ2xlYW51cCA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgdGhpcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICB0aGlzLm1vZGUgPSBtb2RlOyAvLyBFZmZlY3RzXG5cbiAgdGhpcy5mbGFncyA9IE5vRmxhZ3MkMTtcbiAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG4gIHRoaXMuZGVsZXRpb25zID0gbnVsbDtcbiAgdGhpcy5sYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgLy8gTm90ZTogVGhlIGZvbGxvd2luZyBpcyBkb25lIHRvIGF2b2lkIGEgdjggcGVyZm9ybWFuY2UgY2xpZmYuXG4gICAgLy9cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGZpZWxkcyBiZWxvdyB0byBzbWlzIGFuZCBsYXRlciB1cGRhdGluZyB0aGVtIHdpdGhcbiAgICAvLyBkb3VibGUgdmFsdWVzIHdpbGwgY2F1c2UgRmliZXJzIHRvIGVuZCB1cCBoYXZpbmcgc2VwYXJhdGUgc2hhcGVzLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuICAgIC8vIEZvcnR1bmF0ZWx5IHRoaXMgb25seSBpbXBhY3RzIERFViBidWlsZHMuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBpdCBtYWtlcyBSZWFjdCB1bnVzYWJseSBzbG93IGZvciBzb21lIGFwcGxpY2F0aW9ucy5cbiAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuICAgIC8vXG4gICAgLy8gTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTg1MzhcbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IE51bWJlci5OYU47XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOOyAvLyBJdCdzIG9rYXkgdG8gcmVwbGFjZSB0aGUgaW5pdGlhbCBkb3VibGVzIHdpdGggc21pcyBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAvLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcbiAgICAvLyBhbmQgaXQgc2ltcGxpZmllcyBvdGhlciBwcm9maWxlciBjb2RlIChpbmNsdWRpbmcgRGV2VG9vbHMpLlxuXG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgLy8gVGhpcyBpc24ndCBkaXJlY3RseSB1c2VkIGJ1dCBpcyBoYW5keSBmb3IgZGVidWdnaW5nIGludGVybmFsczpcbiAgICB0aGlzLl9kZWJ1Z0luZm8gPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fZGVidWdOZWVkc1JlbW91bnQgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWJ1Z0hvb2tUeXBlcyA9IG51bGw7XG5cbiAgICBpZiAoIWhhc0JhZE1hcFBvbHlmaWxsICYmIHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG5cblxuZnVuY3Rpb24gY3JlYXRlRmliZXIodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdOiB0aGUgc2hhcGVzIGFyZSBleGFjdCBoZXJlIGJ1dCBGbG93IGRvZXNuJ3QgbGlrZSBjb25zdHJ1Y3RvcnNcbiAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmICFzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiYgdHlwZS5kZWZhdWx0UHJvcHMgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25DbGFzc0NvbXBvbmVudCh0eXBlKSB7XG4gIHJldHVybiBzaG91bGRDb25zdHJ1Y3QodHlwZSk7XG59IC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBOb0ZsYWdzJDE7IC8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgcmVzZXQsIHJhdGhlciB0aGFuIGNvcHksIGFjdHVhbER1cmF0aW9uICYgYWN0dWFsU3RhcnRUaW1lLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aW1lIGZyb20gZW5kbGVzc2x5IGFjY3VtdWxhdGluZyBpbiBuZXcgY29tbWl0cy5cbiAgICAgIC8vIFRoaXMgaGFzIHRoZSBkb3duc2lkZSBvZiByZXNldHRpbmcgdmFsdWVzIGZvciBkaWZmZXJlbnQgcHJpb3JpdHkgcmVuZGVycyxcbiAgICAgIC8vIEJ1dCB3b3JrcyBmb3IgeWllbGRpbmcgKHRoZSBjb21tb24gY2FzZSkgYW5kIHNob3VsZCBzdXBwb3J0IHJlc3VtaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgfVxuICB9IC8vIFJlc2V0IGFsbCBlZmZlY3RzIGV4Y2VwdCBzdGF0aWMgb25lcy5cbiAgLy8gU3RhdGljIGVmZmVjdHMgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlci5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzID0gY3VycmVudC5mbGFncyAmIFN0YXRpY01hc2s7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gIC8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cblxuICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICBsYW5lczogY3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxcbiAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG4gIH07IC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG5cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcbiAgd29ya0luUHJvZ3Jlc3MucmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICB9XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm8gPSBjdXJyZW50Ll9kZWJ1Z0luZm87XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufSAvLyBVc2VkIHRvIHJldXNlIGEgRmliZXIgZm9yIGEgc2Vjb25kIHBhc3MuXG5cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3Mod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgcmVzZXRzIHRoZSBGaWJlciB0byB3aGF0IGNyZWF0ZUZpYmVyIG9yIGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkXG4gIC8vIGhhdmUgc2V0IHRoZSB2YWx1ZXMgdG8gYmVmb3JlIGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSWRlYWxseSB0aGlzIHdvdWxkbid0XG4gIC8vIGJlIG5lY2Vzc2FyeSBidXQgdW5mb3J0dW5hdGVseSBtYW55IGNvZGUgcGF0aHMgcmVhZHMgZnJvbSB0aGUgd29ya0luUHJvZ3Jlc3NcbiAgLy8gd2hlbiB0aGV5IHNob3VsZCBiZSByZWFkaW5nIGZyb20gY3VycmVudCBhbmQgd3JpdGluZyB0byB3b3JrSW5Qcm9ncmVzcy5cbiAgLy8gV2UgYXNzdW1lIHBlbmRpbmdQcm9wcywgaW5kZXgsIGtleSwgcmVmLCByZXR1cm4gYXJlIHN0aWxsIHVudG91Y2hlZCB0b1xuICAvLyBhdm9pZCBkb2luZyBhbm90aGVyIHJlY29uY2lsaWF0aW9uLlxuICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuICAvLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IFN0YXRpY01hc2sgfCBQbGFjZW1lbnQ7IC8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3MkMTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgcmVzZXQgdGhlIGFjdHVhbFRpbWUgY291bnRzLiBJdCdzIHVzZWZ1bCB0byBhY2N1bXVsYXRlXG4gICAgICAvLyBhY3R1YWwgdGltZSBhY3Jvc3MgbXVsdGlwbGUgcmVuZGVyIHBhc3Nlcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlc2V0IHRvIHRoZSBjbG9uZWQgdmFsdWVzIHRoYXQgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGQndmUuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3MkMTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuICAgIC8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cblxuICAgIHZhciBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcyA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgICBsYW5lczogY3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxcbiAgICAgIGZpcnN0Q29udGV4dDogY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHRcbiAgICB9O1xuXG4gICAge1xuICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgcmVzZXQgdGhlIGFjdHVhbFRpbWUgY291bnRzLiBJdCdzIHVzZWZ1bCB0byBhY2N1bXVsYXRlXG4gICAgICAvLyBhY3R1YWwgdGltZSBhY3Jvc3MgbXVsdGlwbGUgcmVuZGVyIHBhc3Nlcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RSb290RmliZXIodGFnLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUpIHtcbiAgdmFyIG1vZGU7XG5cbiAge1xuICAgIG1vZGUgPSBDb25jdXJyZW50TW9kZTtcblxuICAgIGlmIChpc1N0cmljdE1vZGUgPT09IHRydWUpIHtcbiAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZSB8IFN0cmljdEVmZmVjdHNNb2RlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIC8vIEFsd2F5cyBjb2xsZWN0IHByb2ZpbGUgdGltaW5ncyB3aGVuIERldlRvb2xzIGFyZSBwcmVzZW50LlxuICAgIC8vIFRoaXMgZW5hYmxlcyBEZXZUb29scyB0byBzdGFydCBjYXB0dXJpbmcgdGltaW5nIGF0IGFueSBwb2ludOKAk1xuICAgIC8vIFdpdGhvdXQgc29tZSBub2RlcyBpbiB0aGUgdHJlZSBoYXZpbmcgZW1wdHkgYmFzZSB0aW1lcy5cbiAgICBtb2RlIHw9IFByb2ZpbGVNb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBudWxsLCBtb2RlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCAvLyBSZWFjdCRFbGVtZW50VHlwZVxua2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXJUYWcgPSBGdW5jdGlvbkNvbXBvbmVudDsgLy8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG5cbiAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHNob3VsZENvbnN0cnVjdCh0eXBlKSkge1xuICAgICAgZmliZXJUYWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgICAge1xuICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzICYmIHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgdmFyIGhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgIGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIGhvc3RDb250ZXh0KSA/IEhvc3RIb2lzdGFibGUgOiBpc0hvc3RTaW5nbGV0b25UeXBlKHR5cGUpID8gSG9zdFNpbmdsZXRvbiA6IEhvc3RDb21wb25lbnQ7XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgdmFyIF9ob3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG5cbiAgICAgIGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIF9ob3N0Q29udGV4dCkgPyBIb3N0SG9pc3RhYmxlIDogSG9zdENvbXBvbmVudDtcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgZmliZXJUYWcgPSBpc0hvc3RTaW5nbGV0b25UeXBlKHR5cGUpID8gSG9zdFNpbmdsZXRvbiA6IEhvc3RDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IFN0cmljdExlZ2FjeU1vZGU7XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIFN0cmljdCBlZmZlY3RzIHNob3VsZCBuZXZlciBydW4gb24gbGVnYWN5IHJvb3RzXG4gICAgICAgICAgbW9kZSB8PSBTdHJpY3RFZmZlY3RzTW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuXG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuXG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFOlxuXG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcblxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG5cbiAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0UHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRDb25zdW1lcjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gRm9yd2FyZFJlZjtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTWVtb0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBMYXp5Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lRnJvbU93bmVyKG93bmVyKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJyArICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgKyAoXCJidXQgZ290OiBcIiArIHR5cGVTdHJpbmcgKyBcIi5cIiArIGluZm8pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgZmliZXIudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBvd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcblxuICB7XG4gICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwga2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcyk7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIHBlbmRpbmdQcm9wcy5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIG9mIHR5cGUgYHN0cmluZ2AgYXMgYSBwcm9wLiBSZWNlaXZlZCB0aGUgdHlwZSBgJXNgIGluc3RlYWQuJywgdHlwZW9mIHBlbmRpbmdQcm9wcy5pZCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoUHJvZmlsZXIsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlIHwgUHJvZmlsZU1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICAgIGVmZmVjdER1cmF0aW9uOiAwLFxuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihTdXNwZW5zZUxpc3RDb21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoT2Zmc2NyZWVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHZhciBwcmltYXJ5Q2hpbGRJbnN0YW5jZSA9IHtcbiAgICBfdmlzaWJpbGl0eTogT2Zmc2NyZWVuVmlzaWJsZSxcbiAgICBfcGVuZGluZ1Zpc2liaWxpdHk6IE9mZnNjcmVlblZpc2libGUsXG4gICAgX3BlbmRpbmdNYXJrZXJzOiBudWxsLFxuICAgIF9yZXRyeUNhY2hlOiBudWxsLFxuICAgIF90cmFuc2l0aW9uczogbnVsbCxcbiAgICBfY3VycmVudDogbnVsbCxcbiAgICBkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkZXRhY2hPZmZzY3JlZW5JbnN0YW5jZShwcmltYXJ5Q2hpbGRJbnN0YW5jZSk7XG4gICAgfSxcbiAgICBhdHRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhdHRhY2hPZmZzY3JlZW5JbnN0YW5jZShwcmltYXJ5Q2hpbGRJbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICBmaWJlci5zdGF0ZU5vZGUgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChkZWh5ZHJhdGVkTm9kZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihEZWh5ZHJhdGVkRnJhZ21lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IGRlaHlkcmF0ZWROb2RlO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG50YWcsIGh5ZHJhdGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCBmb3JtU3RhdGUpIHtcbiAgdGhpcy50YWcgPSBDb25jdXJyZW50Um9vdCA7XG4gIHRoaXMuY29udGFpbmVySW5mbyA9IGNvbnRhaW5lckluZm87XG4gIHRoaXMucGVuZGluZ0NoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgdGhpcy5waW5nQ2FjaGUgPSBudWxsO1xuICB0aGlzLmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHRoaXMudGltZW91dEhhbmRsZSA9IG5vVGltZW91dDtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lO1xuICB0aGlzLmV4cGlyYXRpb25UaW1lcyA9IGNyZWF0ZUxhbmVNYXAoTm9UaW1lc3RhbXApO1xuICB0aGlzLnBlbmRpbmdMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5leHBpcmVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5zaGVsbFN1c3BlbmRDb3VudGVyID0gMDtcbiAgdGhpcy5lbnRhbmdsZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVtZW50cyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG4gIHRoaXMuaGlkZGVuVXBkYXRlcyA9IGNyZWF0ZUxhbmVNYXAobnVsbCk7XG4gIHRoaXMuaWRlbnRpZmllclByZWZpeCA9IGlkZW50aWZpZXJQcmVmaXg7XG4gIHRoaXMub25VbmNhdWdodEVycm9yID0gb25VbmNhdWdodEVycm9yO1xuICB0aGlzLm9uQ2F1Z2h0RXJyb3IgPSBvbkNhdWdodEVycm9yO1xuICB0aGlzLm9uUmVjb3ZlcmFibGVFcnJvciA9IG9uUmVjb3ZlcmFibGVFcnJvcjtcblxuICB7XG4gICAgdGhpcy5wb29sZWRDYWNoZSA9IG51bGw7XG4gICAgdGhpcy5wb29sZWRDYWNoZUxhbmVzID0gTm9MYW5lcztcbiAgfVxuXG4gIHRoaXMuZm9ybVN0YXRlID0gZm9ybVN0YXRlO1xuICB0aGlzLmluY29tcGxldGVUcmFuc2l0aW9ucyA9IG5ldyBNYXAoKTtcblxuICB7XG4gICAgdGhpcy5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAge1xuICAgIHRoaXMubWVtb2l6ZWRVcGRhdGVycyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHRoaXMucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFRvdGFsTGFuZXM7IF9pKyspIHtcbiAgICAgIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAucHVzaChuZXcgU2V0KCkpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICAvLyBUT0RPOiBUaGlzIHZhcmllcyBieSBlYWNoIHJlbmRlcmVyLlxuICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9IGh5ZHJhdGUgPyAnaHlkcmF0ZVJvb3QoKScgOiAnY3JlYXRlUm9vdCgpJztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgLy8gVE9ETzogV2UgaGF2ZSBzZXZlcmFsIG9mIHRoZXNlIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25jZXB0dWFsbHkgcGFydCBvZiB0aGVcbi8vIGhvc3QgY29uZmlnLCBidXQgYmVjYXVzZSB0aGV5IGFyZSBwYXNzZWQgaW4gYXQgcnVudGltZSwgd2UgaGF2ZSB0byB0aHJlYWRcbi8vIHRoZW0gdGhyb3VnaCB0aGUgcm9vdCBjb25zdHJ1Y3Rvci4gUGVyaGFwcyB3ZSBzaG91bGQgcHV0IHRoZW0gYWxsIGludG8gYVxuLy8gc2luZ2xlIHR5cGUsIGxpa2UgYSBEeW5hbWljSG9zdENvbmZpZyB0aGF0IGlzIGRlZmluZWQgYnkgdGhlIHJlbmRlcmVyLlxuaWRlbnRpZmllclByZWZpeCwgb25VbmNhdWdodEVycm9yLCBvbkNhdWdodEVycm9yLCBvblJlY292ZXJhYmxlRXJyb3IsIHRyYW5zaXRpb25DYWxsYmFja3MsIGZvcm1TdGF0ZSkge1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgbm8gbG9uZ2VyIHN1cHBvcnRzIGNhbGxpbmcgbmV3IG9uIGZ1bmN0aW9uc1xuICB2YXIgcm9vdCA9IG5ldyBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaWRlbnRpZmllclByZWZpeCwgb25VbmNhdWdodEVycm9yLCBvbkNhdWdodEVycm9yLCBvblJlY292ZXJhYmxlRXJyb3IsIGZvcm1TdGF0ZSk7XG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG5cblxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsIGlzU3RyaWN0TW9kZSk7XG4gIHJvb3QuY3VycmVudCA9IHVuaW5pdGlhbGl6ZWRGaWJlcjtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG5cbiAge1xuICAgIHZhciBpbml0aWFsQ2FjaGUgPSBjcmVhdGVDYWNoZSgpO1xuICAgIHJldGFpbkNhY2hlKGluaXRpYWxDYWNoZSk7IC8vIFRoZSBwb29sZWRDYWNoZSBpcyBhIGZyZXNoIGNhY2hlIGluc3RhbmNlIHRoYXQgaXMgdXNlZCB0ZW1wb3JhcmlseVxuICAgIC8vIGZvciBuZXdseSBtb3VudGVkIGJvdW5kYXJpZXMgZHVyaW5nIGEgcmVuZGVyLiBJbiBnZW5lcmFsLCB0aGVcbiAgICAvLyBwb29sZWRDYWNoZSBpcyBhbHdheXMgY2xlYXJlZCBmcm9tIHRoZSByb290IGF0IHRoZSBlbmQgb2YgYSByZW5kZXI6XG4gICAgLy8gaXQgaXMgZWl0aGVyIHJlbGVhc2VkIHdoZW4gcmVuZGVyIGNvbW1pdHMsIG9yIG1vdmVkIHRvIGFuIE9mZnNjcmVlblxuICAgIC8vIGNvbXBvbmVudCBpZiByZW5kZXJpbmcgc3VzcGVuZHMuIEJlY2F1c2UgdGhlIGxpZmV0aW1lIG9mIHRoZSBwb29sZWRcbiAgICAvLyBjYWNoZSBpcyBkaXN0aW5jdCBmcm9tIHRoZSBtYWluIG1lbW9pemVkU3RhdGUuY2FjaGUsIGl0IG11c3QgYmVcbiAgICAvLyByZXRhaW5lZCBzZXBhcmF0ZWx5LlxuXG4gICAgcm9vdC5wb29sZWRDYWNoZSA9IGluaXRpYWxDYWNoZTtcbiAgICByZXRhaW5DYWNoZShpbml0aWFsQ2FjaGUpO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSB7XG4gICAgICBlbGVtZW50OiBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBpc0RlaHlkcmF0ZWQ6IGh5ZHJhdGUsXG4gICAgICBjYWNoZTogaW5pdGlhbENhY2hlXG4gICAgfTtcbiAgICB1bmluaXRpYWxpemVkRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgfVxuXG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh1bmluaXRpYWxpemVkRmliZXIpO1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxOS4wLjAnO1xuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVySW5mbywgLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAge1xuICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oa2V5KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBNaWdodCBhZGQgUFJPRklMRSBsYXRlci5cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7XG52YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoKTtcblxuICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIHZhciBDb21wb25lbnQgPSBmaWJlci50eXBlO1xuXG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKCkpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBDb21wb25lbnQsIHBhcmVudENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlKGNvbXBvbmVudCkge1xuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKCcsJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGtleXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGhvc3RGaWJlci5zdGF0ZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcoY29tcG9uZW50LCBtZXRob2ROYW1lKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICAgIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbignLCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGtleXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaG9zdEZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoaG9zdEZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJyVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJyArICclcyB3YXMgcGFzc2VkIGFuIGluc3RhbmNlIG9mICVzIHdoaWNoIHJlbmRlcnMgU3RyaWN0TW9kZSBjaGlsZHJlbi4gJyArICdJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGhvc3RGaWJlci5zdGF0ZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCBpZGVudGlmaWVyUHJlZml4LCBvblVuY2F1Z2h0RXJyb3IsIG9uQ2F1Z2h0RXJyb3IsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcykge1xuICB2YXIgaHlkcmF0ZSA9IGZhbHNlO1xuICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcbiAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGluaXRpYWxDaGlsZHJlbiwgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzLCBudWxsKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sIC8vIFRPRE86IFJlbW92ZSBgY2FsbGJhY2tgIHdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLlxuY2FsbGJhY2ssIGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzLCBmb3JtU3RhdGUpIHtcbiAgdmFyIGh5ZHJhdGUgPSB0cnVlO1xuICB2YXIgcm9vdCA9IGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGluaXRpYWxDaGlsZHJlbiwgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzLCBmb3JtU3RhdGUpOyAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gRmliZXJSb290IGNvbnN0cnVjdG9yXG5cbiAgcm9vdC5jb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUobnVsbCk7IC8vIFNjaGVkdWxlIHRoZSBpbml0aWFsIHJlbmRlci4gSW4gYSBoeWRyYXRpb24gcm9vdCwgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbVxuICAvLyBhIHJlZ3VsYXIgdXBkYXRlIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3QgbWF0Y2ggd2FzIHdhcyByZW5kZXJlZFxuICAvLyBvbiB0aGUgc2VydmVyLlxuICAvLyBOT1RFOiBUaGlzIHVwZGF0ZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgaGF2ZSBhIHBheWxvYWQuIFdlJ3JlIG9ubHkgdXNpbmdcbiAgLy8gdGhlIHVwZGF0ZSB0byBzY2hlZHVsZSB3b3JrIG9uIHRoZSByb290IGZpYmVyIChhbmQsIGZvciBsZWdhY3kgcm9vdHMsIHRvXG4gIC8vIGVucXVldWUgdGhlIGNhbGxiYWNrIGlmIG9uZSBpcyBwcm92aWRlZCkuXG5cbiAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCk7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwgPyBjYWxsYmFjayA6IG51bGw7XG4gIGVucXVldWVVcGRhdGUoY3VycmVudCwgdXBkYXRlLCBsYW5lKTtcbiAgc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUpO1xuICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lcihlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50KTtcbiAgdXBkYXRlQ29udGFpbmVySW1wbChjdXJyZW50LCBsYW5lLCBlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lclN5bmMoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gIGlmIChjb250YWluZXIudGFnID09PSBMZWdhY3lSb290KSB7XG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcbiAgdXBkYXRlQ29udGFpbmVySW1wbChjdXJyZW50LCBTeW5jTGFuZSwgZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIFN5bmNMYW5lO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250YWluZXJJbXBsKHJvb3RGaWJlciwgbGFuZSwgZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICBvblNjaGVkdWxlUm9vdChjb250YWluZXIsIGVsZW1lbnQpO1xuICB9XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG5cbiAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICB7XG4gICAgaWYgKGlzUmVuZGVyaW5nICYmIGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgICBlcnJvcignUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50XG4gIH07XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcblxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgdXBkYXRlLCBsYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCByb290RmliZXIsIGxhbmUpO1xuICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgcm9vdEZpYmVyLCBsYW5lKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcblxuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICB9XG59XG5mdW5jdGlvbiBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB2YXIgcm9vdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNSb290RGVoeWRyYXRlZChyb290KSkge1xuICAgICAgICAgIC8vIEZsdXNoIHRoZSBmaXJzdCBzY2hlZHVsZWQgXCJ1cGRhdGVcIi5cbiAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMocm9vdCk7XG4gICAgICAgICAgZmx1c2hSb290KHJvb3QsIGxhbmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9yb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICAgICAgaWYgKF9yb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKF9yb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hTeW5jV29yaygpOyAvLyBJZiB3ZSdyZSBzdGlsbCBibG9ja2VkIGFmdGVyIHRoaXMsIHdlIG5lZWQgdG8gaW5jcmVhc2VcbiAgICAgICAgLy8gdGhlIHByaW9yaXR5IG9mIGFueSBwcm9taXNlcyByZXNvbHZpbmcgd2l0aGluIHRoaXNcbiAgICAgICAgLy8gYm91bmRhcnkgc28gdGhhdCB0aGV5IG5leHQgYXR0ZW1wdCBhbHNvIGhhcyBoaWdoZXIgcHJpLlxuXG4gICAgICAgIHZhciByZXRyeUxhbmUgPSBTeW5jTGFuZTtcbiAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgIHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lID0gaGlnaGVyUHJpb3JpdHlMYW5lKHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lLCByZXRyeUxhbmUpO1xuICB9XG59IC8vIEluY3JlYXNlcyB0aGUgcHJpb3JpdHkgb2YgdGhlbmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuXG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSkge1xuICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbiAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuICAgIC8vIFN1c3BlbnNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYW5lID0gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgfVxuXG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgb3RoZXIgdGhhbiBzeW5jaHJvbm91c2x5IGZsdXNoIGl0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICB9XG5cbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGhvc3RGaWJlci5zdGF0ZU5vZGUpO1xufVxuXG52YXIgc2hvdWxkRXJyb3JJbXBsID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkRXJyb3IoZmliZXIpIHtcbiAgcmV0dXJuIHNob3VsZEVycm9ySW1wbChmaWJlcik7XG59XG5cbnZhciBzaG91bGRTdXNwZW5kSW1wbCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRTdXNwZW5kKGZpYmVyKSB7XG4gIHJldHVybiBzaG91bGRTdXNwZW5kSW1wbChmaWJlcik7XG59XG52YXIgb3ZlcnJpZGVIb29rU3RhdGUgPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBudWxsO1xudmFyIHNjaGVkdWxlVXBkYXRlID0gbnVsbDtcbnZhciBzZXRFcnJvckhhbmRsZXIgPSBudWxsO1xudmFyIHNldFN1c3BlbnNlSGFuZGxlciA9IG51bGw7XG5cbntcbiAgdmFyIGNvcHlXaXRoRGVsZXRlSW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4KSB7XG4gICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKGlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZUltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoRGVsZXRlID0gZnVuY3Rpb24gKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBjb3B5V2l0aERlbGV0ZUltcGwob2JqLCBwYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWVJbXBsID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmIChpbmRleCArIDEgPT09IG9sZFBhdGgubGVuZ3RoKSB7XG4gICAgICB2YXIgbmV3S2V5ID0gbmV3UGF0aFtpbmRleF07IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuICAgICAgdXBkYXRlZFtuZXdLZXldID0gdXBkYXRlZFtvbGRLZXldO1xuXG4gICAgICBpZiAoaXNBcnJheSh1cGRhdGVkKSkge1xuICAgICAgICB1cGRhdGVkLnNwbGljZShvbGRLZXksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgdXBkYXRlZFtvbGRLZXldID0gY29weVdpdGhSZW5hbWVJbXBsKCAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgICBvYmpbb2xkS2V5XSwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWUgPSBmdW5jdGlvbiAob2JqLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgaWYgKG9sZFBhdGgubGVuZ3RoICE9PSBuZXdQYXRoLmxlbmd0aCkge1xuICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIG9mIHRoZSBzYW1lIGxlbmd0aCcpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3UGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKG9sZFBhdGhbaV0gIT09IG5ld1BhdGhbaV0pIHtcbiAgICAgICAgICB3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgdG8gYmUgdGhlIHNhbWUgZXhjZXB0IGZvciB0aGUgZGVlcGVzdCBrZXknKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXRJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoU2V0SW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0ID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgICByZXR1cm4gY29weVdpdGhTZXRJbXBsKG9iaiwgcGF0aCwgMCwgdmFsdWUpO1xuICB9O1xuXG4gIHZhciBmaW5kSG9vayA9IGZ1bmN0aW9uIChmaWJlciwgaWQpIHtcbiAgICAvLyBGb3Igbm93LCB0aGUgXCJpZFwiIG9mIHN0YXRlZnVsIGhvb2tzIGlzIGp1c3QgdGhlIHN0YXRlZnVsIGhvb2sgaW5kZXguXG4gICAgLy8gVGhpcyBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUgd2l0aCBlLmcuIG5lc3RlZCBob29rcy5cbiAgICB2YXIgY3VycmVudEhvb2sgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRIb29rICE9PSBudWxsICYmIGlkID4gMCkge1xuICAgICAgY3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuICAgICAgaWQtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudEhvb2s7XG4gIH07IC8vIFN1cHBvcnQgRGV2VG9vbHMgZWRpdGFibGUgdmFsdWVzIGZvciB1c2VTdGF0ZSBhbmQgdXNlUmVkdWNlci5cblxuXG4gIG92ZXJyaWRlSG9va1N0YXRlID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCwgdmFsdWUpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhTZXQoaG9vay5tZW1vaXplZFN0YXRlLCBwYXRoLCB2YWx1ZSk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhEZWxldGUoaG9vay5tZW1vaXplZFN0YXRlLCBwYXRoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBwcm9wcyBmb3IgZnVuY3Rpb24gY29tcG9uZW50cywgZm9yd2FyZFJlZiwgbWVtbywgaG9zdCBjb21wb25lbnRzLCBldGMuXG5cblxuICBvdmVycmlkZVByb3BzID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoLCB2YWx1ZSkge1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoU2V0KGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgsIHZhbHVlKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShmaWJlci5tZW1vaXplZFByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICB9XG4gIH07XG5cbiAgc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgIH1cbiAgfTtcblxuICBzZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkRXJyb3JJbXBsKSB7XG4gICAgc2hvdWxkRXJyb3JJbXBsID0gbmV3U2hvdWxkRXJyb3JJbXBsO1xuICB9O1xuXG4gIHNldFN1c3BlbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRTdXNwZW5kSW1wbCkge1xuICAgIHNob3VsZFN1c3BlbmRJbXBsID0gbmV3U2hvdWxkU3VzcGVuZEltcGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyKGZpYmVyKSB7XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbmZ1bmN0aW9uIGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG4gIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKHtcbiAgICBidW5kbGVUeXBlOiBkZXZUb29sc0NvbmZpZy5idW5kbGVUeXBlLFxuICAgIHZlcnNpb246IGRldlRvb2xzQ29uZmlnLnZlcnNpb24sXG4gICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogZGV2VG9vbHNDb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICByZW5kZXJlckNvbmZpZzogZGV2VG9vbHNDb25maWcucmVuZGVyZXJDb25maWcsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGU6IG92ZXJyaWRlSG9va1N0YXRlLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHM6IG92ZXJyaWRlUHJvcHMsXG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg6IG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOiBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCxcbiAgICBzZXRFcnJvckhhbmRsZXI6IHNldEVycm9ySGFuZGxlcixcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXI6IHNldFN1c3BlbnNlSGFuZGxlcixcbiAgICBzY2hlZHVsZVVwZGF0ZTogc2NoZWR1bGVVcGRhdGUsXG4gICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0U2hhcmVkSW50ZXJuYWxzLFxuICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcixcbiAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgfHwgZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSxcbiAgICAvLyBSZWFjdCBSZWZyZXNoXG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOiBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUmVmcmVzaDogc2NoZWR1bGVSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJvb3Q6IHNjaGVkdWxlUm9vdCAsXG4gICAgc2V0UmVmcmVzaEhhbmRsZXI6IHNldFJlZnJlc2hIYW5kbGVyICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGFwcGVuZCBvd25lciBzdGFja3MgdG8gZXJyb3IgbWVzc2FnZXMgaW4gREVWIG1vZGUuXG4gICAgZ2V0Q3VycmVudEZpYmVyOiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyAsXG4gICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBkZXRlY3QgcmVjb25jaWxlciB2ZXJzaW9uIHJhdGhlciB0aGFuIHJlbmRlcmVyIHZlcnNpb25cbiAgICAvLyB3aGljaCBtYXkgbm90IG1hdGNoIGZvciB0aGlyZCBwYXJ0eSByZW5kZXJlcnMuXG4gICAgcmVjb25jaWxlclZlcnNpb246IFJlYWN0VmVyc2lvblxuICB9KTtcbn1cblxuZXhwb3J0cy5hdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiA9IGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uO1xuZXhwb3J0cy5hdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkgPSBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHk7XG5leHBvcnRzLmF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiA9IGF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbjtcbmV4cG9ydHMuYmF0Y2hlZFVwZGF0ZXMgPSBiYXRjaGVkVXBkYXRlcztcbmV4cG9ydHMuY3JlYXRlQ29tcG9uZW50U2VsZWN0b3IgPSBjcmVhdGVDb21wb25lbnRTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlQ29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyO1xuZXhwb3J0cy5jcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yID0gY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyID0gY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBjcmVhdGVQb3J0YWw7XG5leHBvcnRzLmNyZWF0ZVJvbGVTZWxlY3RvciA9IGNyZWF0ZVJvbGVTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlVGVzdE5hbWVTZWxlY3RvciA9IGNyZWF0ZVRlc3ROYW1lU2VsZWN0b3I7XG5leHBvcnRzLmNyZWF0ZVRleHRTZWxlY3RvciA9IGNyZWF0ZVRleHRTZWxlY3RvcjtcbmV4cG9ydHMuZGVmYXVsdE9uQ2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25DYXVnaHRFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvciA9IGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3I7XG5leHBvcnRzLmRlZmF1bHRPblVuY2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25VbmNhdWdodEVycm9yO1xuZXhwb3J0cy5kZWZlcnJlZFVwZGF0ZXMgPSBkZWZlcnJlZFVwZGF0ZXM7XG5leHBvcnRzLmRpc2NyZXRlVXBkYXRlcyA9IGRpc2NyZXRlVXBkYXRlcztcbmV4cG9ydHMuZmluZEFsbE5vZGVzID0gZmluZEFsbE5vZGVzO1xuZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZpbmRCb3VuZGluZ1JlY3RzO1xuZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlID0gZmluZEhvc3RJbnN0YW5jZTtcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscztcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nO1xuZXhwb3J0cy5mbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cztcbmV4cG9ydHMuZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIgPSBmbHVzaFN5bmNGcm9tUmVjb25jaWxlcjtcbmV4cG9ydHMuZmx1c2hTeW5jV29yayA9IGZsdXNoU3luY1dvcms7XG5leHBvcnRzLmZvY3VzV2l0aGluID0gZm9jdXNXaXRoaW47XG5leHBvcnRzLmdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiA9IGdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbjtcbmV4cG9ydHMuZ2V0UHVibGljUm9vdEluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlO1xuZXhwb3J0cy5pbmplY3RJbnRvRGV2VG9vbHMgPSBpbmplY3RJbnRvRGV2VG9vbHM7XG5leHBvcnRzLmlzQWxyZWFkeVJlbmRlcmluZyA9IGlzQWxyZWFkeVJlbmRlcmluZztcbmV4cG9ydHMub2JzZXJ2ZVZpc2libGVSZWN0cyA9IG9ic2VydmVWaXNpYmxlUmVjdHM7XG5leHBvcnRzLnNob3VsZEVycm9yID0gc2hvdWxkRXJyb3I7XG5leHBvcnRzLnNob3VsZFN1c3BlbmQgPSBzaG91bGRTdXNwZW5kO1xuZXhwb3J0cy5zdGFydEhvc3RUcmFuc2l0aW9uID0gc3RhcnRIb3N0VHJhbnNpdGlvbjtcbmV4cG9ydHMudXBkYXRlQ29udGFpbmVyID0gdXBkYXRlQ29udGFpbmVyO1xuZXhwb3J0cy51cGRhdGVDb250YWluZXJTeW5jID0gdXBkYXRlQ29udGFpbmVyU3luYztcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiJCQkcmVjb25jaWxlciIsIiQkJGNvbmZpZyIsIlJlYWN0IiwicmVxdWlyZSIsIlNjaGVkdWxlciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFIiwiZmF2b3JTYWZldHlPdmVySHlkcmF0aW9uUGVyZiIsImVuYWJsZUFzeW5jQWN0aW9ucyIsImRpc2FibGVEZWZhdWx0UHJvcHNFeGNlcHRGb3JDbGFzc2VzIiwiZW5hYmxlU3VzcGVuc2VDYWxsYmFjayIsImVuYWJsZUFzeW5jSXRlcmFibGVDaGlsZHJlbiIsImVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24iLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJhbHdheXNUaHJvdHRsZVJldHJpZXMiLCJwYXNzQ2hpbGRyZW5XaGVuQ2xvbmluZ1BlcnNpc3RlZE5vZGVzIiwiZW5hYmxlT3duZXJTdGFja3MiLCJzeW5jTGFuZUV4cGlyYXRpb25NcyIsInRyYW5zaXRpb25MYW5lRXhwaXJhdGlvbk1zIiwiZGlzYWJsZUxlZ2FjeU1vZGUiLCJlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIiLCJlbmFibGVQcm9maWxlclRpbWVyIiwiZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyIsImVuYWJsZVByb2ZpbGVyTmVzdGVkVXBkYXRlUGhhc2UiLCJzdXBwcmVzc1dhcm5pbmciLCJzZXRTdXBwcmVzc1dhcm5pbmciLCJuZXdTdXBwcmVzc1dhcm5pbmciLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsImlzRXJyb3JMb2dnZXIiLCJnZXRDdXJyZW50U3RhY2siLCJzdGFjayIsImNvbmNhdCIsInVuc2hpZnQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiYXNzaWduIiwiT2JqZWN0IiwiTGVnYWN5Um9vdCIsIkNvbmN1cnJlbnRSb290IiwiZ2V0Iiwia2V5IiwiX3JlYWN0SW50ZXJuYWxzIiwic2V0IiwidmFsdWUiLCJGdW5jdGlvbkNvbXBvbmVudCIsIkNsYXNzQ29tcG9uZW50IiwiSG9zdFJvb3QiLCJIb3N0UG9ydGFsIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiRnJhZ21lbnQiLCJNb2RlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRm9yd2FyZFJlZiIsIlByb2ZpbGVyIiwiU3VzcGVuc2VDb21wb25lbnQiLCJNZW1vQ29tcG9uZW50IiwiU2ltcGxlTWVtb0NvbXBvbmVudCIsIkxhenlDb21wb25lbnQiLCJJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJEZWh5ZHJhdGVkRnJhZ21lbnQiLCJTdXNwZW5zZUxpc3RDb21wb25lbnQiLCJTY29wZUNvbXBvbmVudCIsIk9mZnNjcmVlbkNvbXBvbmVudCIsIkxlZ2FjeUhpZGRlbkNvbXBvbmVudCIsIkNhY2hlQ29tcG9uZW50IiwiVHJhY2luZ01hcmtlckNvbXBvbmVudCIsIkhvc3RIb2lzdGFibGUiLCJIb3N0U2luZ2xldG9uIiwiSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50IiwiUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlNVTUVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX1NDT1BFX1RZUEUiLCJSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIiwiUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSIsIlJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0V3JhcHBlZE5hbWUkMSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUkMSIsInR5cGUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwiJCR0eXBlb2YiLCJ0YWciLCJjb250ZXh0IiwiY29uc3VtZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiZ2V0V3JhcHBlZE5hbWUiLCJnZXRDb250ZXh0TmFtZSIsImdldENvbXBvbmVudE5hbWVGcm9tT3duZXIiLCJvd25lciIsImdldENvbXBvbmVudE5hbWVGcm9tRmliZXIiLCJmaWJlciIsIk5vRmxhZ3MkMSIsIlBlcmZvcm1lZFdvcmsiLCJQbGFjZW1lbnQiLCJEaWRDYXB0dXJlIiwiSHlkcmF0aW5nIiwiVXBkYXRlIiwiQ2hpbGREZWxldGlvbiIsIkNvbnRlbnRSZXNldCIsIkNhbGxiYWNrIiwiRm9yY2VDbGllbnRSZW5kZXIiLCJSZWYiLCJTbmFwc2hvdCIsIlBhc3NpdmUkMSIsIlZpc2liaWxpdHkiLCJTdG9yZUNvbnNpc3RlbmN5IiwiU2NoZWR1bGVSZXRyeSIsIlNob3VsZFN1c3BlbmRDb21taXQiLCJEaWREZWZlciIsIkZvcm1SZXNldCIsIkhvc3RFZmZlY3RNYXNrIiwiSW5jb21wbGV0ZSIsIlNob3VsZENhcHR1cmUiLCJGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlIiwiRm9ya2VkIiwiUmVmU3RhdGljIiwiTGF5b3V0U3RhdGljIiwiUGFzc2l2ZVN0YXRpYyIsIk1heVN1c3BlbmRDb21taXQiLCJQbGFjZW1lbnRERVYiLCJNb3VudExheW91dERldiIsIk1vdW50UGFzc2l2ZURldiIsIkJlZm9yZU11dGF0aW9uTWFzayIsIk11dGF0aW9uTWFzayIsIkxheW91dE1hc2siLCJQYXNzaXZlTWFzayIsIlN0YXRpY01hc2siLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsInByb3BzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJtYXRjaCIsInRyaW0iLCJkZXNjcmliZURlYnVnSW5mb0ZyYW1lIiwiZW52IiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAkMSIsIldlYWtNYXAiLCJNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIkgiLCJSdW5JblJvb3RGcmFtZSIsIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCIsImNvbnRyb2wiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJSZWZsZWN0IiwibWF5YmVQcm9taXNlIiwiY2F0Y2giLCJzYW1wbGUiLCJuYW1lUHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfUnVuSW5Sb290RnJhbWUkRGV0ZXIiLCJzYW1wbGVTdGFjayIsImNvbnRyb2xTdGFjayIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJzIiwiYyIsImluY2x1ZGVzIiwiX2ZyYW1lIiwicmVwbGFjZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lIiwiY3RvciIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsImNhbGxDb21wb25lbnRJbkRFViIsIkNvbXBvbmVudCIsInNlY29uZEFyZyIsInNldElzUmVuZGVyaW5nIiwicmVzdWx0IiwiY2FsbFJlbmRlckluREVWIiwiaW5zdGFuY2UiLCJjYWxsTGF6eUluaXRJbkRFViIsImxhenkiLCJkZXNjcmliZUZpYmVyIiwiZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIiwid29ya0luUHJvZ3Jlc3MiLCJub2RlIiwiZGVidWdJbmZvIiwiX2RlYnVnSW5mbyIsImkiLCJlbnRyeSIsInJldHVybiIsIm1lc3NhZ2UiLCJjdXJyZW50IiwiaXNSZW5kZXJpbmciLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwicnVuV2l0aEZpYmVySW5ERVYiLCJjYWxsYmFjayIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhcmc0IiwicHJldmlvdXNGaWJlciIsInNldEN1cnJlbnRGaWJlciIsInJlc2V0Q3VycmVudEZpYmVyIiwicmVuZGVyaW5nIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5lYXJlc3RNb3VudGVkIiwiYWx0ZXJuYXRlIiwibmV4dE5vZGUiLCJmbGFncyIsImlzTW91bnRlZCIsImNvbXBvbmVudCIsIm93bmVyRmliZXIiLCJzdGF0ZU5vZGUiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJhc3NlcnRJc01vdW50ZWQiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsImEiLCJiIiwicGFyZW50QSIsInBhcmVudEIiLCJuZXh0UGFyZW50IiwiY2hpbGQiLCJzaWJsaW5nIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJwYXJlbnQiLCJjdXJyZW50UGFyZW50IiwiZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbCIsImlzQXJyYXlJbXBsIiwiaXNBcnJheSIsImdldFB1YmxpY0luc3RhbmNlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInByZXBhcmVGb3JDb21taXQiLCJyZXNldEFmdGVyQ29tbWl0IiwiY3JlYXRlSW5zdGFuY2UiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInNob3VsZFNldFRleHRDb250ZW50IiwiY3JlYXRlVGV4dEluc3RhbmNlIiwic2NoZWR1bGVUaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsIm5vVGltZW91dCIsImlzUHJpbWFyeVJlbmRlcmVyIiwid2FybnNJZk5vdEFjdGluZyIsInN1cHBvcnRzTXV0YXRpb24iLCJzdXBwb3J0c1BlcnNpc3RlbmNlIiwic3VwcG9ydHNIeWRyYXRpb24iLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwiYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJwcmVwYXJlU2NvcGVVcGRhdGUiLCJnZXRJbnN0YW5jZUZyb21TY29wZSIsInNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSIsImdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSIsInJlc29sdmVVcGRhdGVQcmlvcml0eSIsInNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24iLCJkZXRhY2hEZWxldGVkSW5zdGFuY2UiLCJyZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2siLCJtYXlTdXNwZW5kQ29tbWl0IiwicHJlbG9hZEluc3RhbmNlIiwic3RhcnRTdXNwZW5kaW5nQ29tbWl0Iiwic3VzcGVuZEluc3RhbmNlIiwid2FpdEZvckNvbW1pdFRvQmVSZWFkeSIsIk5vdFBlbmRpbmdUcmFuc2l0aW9uIiwicmVzZXRGb3JtSW5zdGFuY2UiLCJzdXBwb3J0c01pY3JvdGFza3MiLCJzY2hlZHVsZU1pY3JvdGFzayIsInN1cHBvcnRzVGVzdFNlbGVjdG9ycyIsImZpbmRGaWJlclJvb3QiLCJnZXRCb3VuZGluZ1JlY3QiLCJnZXRUZXh0Q29udGVudCIsImlzSGlkZGVuU3VidHJlZSIsIm1hdGNoQWNjZXNzaWJpbGl0eVJvbGUiLCJzZXRGb2N1c0lmRm9jdXNhYmxlIiwic2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlciIsImFwcGVuZENoaWxkIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImNvbW1pdFRleHRVcGRhdGUiLCJjb21taXRNb3VudCIsImNvbW1pdFVwZGF0ZSIsImluc2VydEJlZm9yZSIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJyZXNldFRleHRDb250ZW50IiwiaGlkZUluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZUluc3RhbmNlIiwidW5oaWRlVGV4dEluc3RhbmNlIiwiY2xlYXJDb250YWluZXIiLCJjbG9uZUluc3RhbmNlIiwiY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQiLCJmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwiY2xvbmVIaWRkZW5JbnN0YW5jZSIsImNsb25lSGlkZGVuVGV4dEluc3RhbmNlIiwiaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyIsImlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrIiwiZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzIiwicmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkiLCJjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyIiwiaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlIiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJjbGVhclN1c3BlbnNlQm91bmRhcnkiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwic2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMiLCJkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzIiwiZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzIiwiZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyIsInZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlIiwidmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwic3VwcG9ydHNSZXNvdXJjZXMiLCJpc0hvc3RIb2lzdGFibGVUeXBlIiwiZ2V0SG9pc3RhYmxlUm9vdCIsImdldFJlc291cmNlIiwiYWNxdWlyZVJlc291cmNlIiwicmVsZWFzZVJlc291cmNlIiwiaHlkcmF0ZUhvaXN0YWJsZSIsIm1vdW50SG9pc3RhYmxlIiwidW5tb3VudEhvaXN0YWJsZSIsImNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlIiwicHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyIsIm1heVJlc291cmNlU3VzcGVuZENvbW1pdCIsInByZWxvYWRSZXNvdXJjZSIsInN1c3BlbmRSZXNvdXJjZSIsInN1cHBvcnRzU2luZ2xldG9ucyIsInJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSIsImNsZWFyU2luZ2xldG9uIiwiYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlIiwicmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlIiwiaXNIb3N0U2luZ2xldG9uVHlwZSIsInZhbHVlU3RhY2siLCJmaWJlclN0YWNrIiwiaW5kZXgiLCJjcmVhdGVDdXJzb3IiLCJkZWZhdWx0VmFsdWUiLCJwb3AiLCJjdXJzb3IiLCJwdXNoIiwiZW1wdHlDb250ZXh0T2JqZWN0IiwiZnJlZXplIiwiaGFzQ29udGV4dENoYW5nZWQiLCJpc0NvbnRleHRQcm92aWRlciIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQiLCJPZmZzY3JlZW5WaXNpYmxlIiwiT2Zmc2NyZWVuRGV0YWNoZWQiLCJPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCIsImlzT2Zmc2NyZWVuTWFudWFsIiwib2Zmc2NyZWVuRmliZXIiLCJtZW1vaXplZFByb3BzIiwibW9kZSIsIk5vTW9kZSIsIkNvbmN1cnJlbnRNb2RlIiwiUHJvZmlsZU1vZGUiLCJTdHJpY3RMZWdhY3lNb2RlIiwiU3RyaWN0RWZmZWN0c01vZGUiLCJOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSIsImNsejMyIiwiTWF0aCIsImNsejMyRmFsbGJhY2siLCJsb2ckMSIsIkxOMiIsImFzVWludCIsIlRvdGFsTGFuZXMiLCJOb0xhbmVzIiwiTm9MYW5lIiwiU3luY0h5ZHJhdGlvbkxhbmUiLCJTeW5jTGFuZSIsIlN5bmNMYW5lSW5kZXgiLCJJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIiwiSW5wdXRDb250aW51b3VzTGFuZSIsIkRlZmF1bHRIeWRyYXRpb25MYW5lIiwiRGVmYXVsdExhbmUiLCJTeW5jVXBkYXRlTGFuZXMiLCJUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSIsIlRyYW5zaXRpb25MYW5lcyIsIlRyYW5zaXRpb25MYW5lMSIsIlRyYW5zaXRpb25MYW5lMiIsIlRyYW5zaXRpb25MYW5lMyIsIlRyYW5zaXRpb25MYW5lNCIsIlRyYW5zaXRpb25MYW5lNSIsIlRyYW5zaXRpb25MYW5lNiIsIlRyYW5zaXRpb25MYW5lNyIsIlRyYW5zaXRpb25MYW5lOCIsIlRyYW5zaXRpb25MYW5lOSIsIlRyYW5zaXRpb25MYW5lMTAiLCJUcmFuc2l0aW9uTGFuZTExIiwiVHJhbnNpdGlvbkxhbmUxMiIsIlRyYW5zaXRpb25MYW5lMTMiLCJUcmFuc2l0aW9uTGFuZTE0IiwiVHJhbnNpdGlvbkxhbmUxNSIsIlJldHJ5TGFuZXMiLCJSZXRyeUxhbmUxIiwiUmV0cnlMYW5lMiIsIlJldHJ5TGFuZTMiLCJSZXRyeUxhbmU0IiwiU29tZVJldHJ5TGFuZSIsIlNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUiLCJOb25JZGxlTGFuZXMiLCJJZGxlSHlkcmF0aW9uTGFuZSIsIklkbGVMYW5lIiwiT2Zmc2NyZWVuTGFuZSIsIkRlZmVycmVkTGFuZSIsIlVwZGF0ZUxhbmVzIiwiZ2V0TGFiZWxGb3JMYW5lIiwibGFuZSIsIk5vVGltZXN0YW1wIiwibmV4dFRyYW5zaXRpb25MYW5lIiwibmV4dFJldHJ5TGFuZSIsImdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIiwibGFuZXMiLCJwZW5kaW5nU3luY0xhbmVzIiwiZ2V0SGlnaGVzdFByaW9yaXR5TGFuZSIsImdldE5leHRMYW5lcyIsInJvb3QiLCJ3aXBMYW5lcyIsInBlbmRpbmdMYW5lcyIsIm5leHRMYW5lcyIsInN1c3BlbmRlZExhbmVzIiwicGluZ2VkTGFuZXMiLCJub25JZGxlUGVuZGluZ0xhbmVzIiwibm9uSWRsZVVuYmxvY2tlZExhbmVzIiwibm9uSWRsZVBpbmdlZExhbmVzIiwidW5ibG9ja2VkTGFuZXMiLCJuZXh0TGFuZSIsIndpcExhbmUiLCJnZXRFbnRhbmdsZWRMYW5lcyIsInJlbmRlckxhbmVzIiwiZW50YW5nbGVkTGFuZXMiLCJhbGxFbnRhbmdsZWRMYW5lcyIsImVudGFuZ2xlbWVudHMiLCJwaWNrQXJiaXRyYXJ5TGFuZUluZGV4IiwiY29tcHV0ZUV4cGlyYXRpb25UaW1lIiwiY3VycmVudFRpbWUiLCJtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkIiwiZXhwaXJhdGlvblRpbWVzIiwiZXhwaXJhdGlvblRpbWUiLCJleHBpcmVkTGFuZXMiLCJnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMiLCJnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvciIsIm9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcyIsImVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzIiwiZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiIsImluY2x1ZGVzU3luY0xhbmUiLCJpbmNsdWRlc05vbklkbGVXb3JrIiwiaW5jbHVkZXNPbmx5UmV0cmllcyIsImluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzIiwiVXJnZW50TGFuZXMiLCJpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyIsImluY2x1ZGVzQmxvY2tpbmdMYW5lIiwiU3luY0RlZmF1bHRMYW5lcyIsImluY2x1ZGVzRXhwaXJlZExhbmUiLCJpc1RyYW5zaXRpb25MYW5lIiwiY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUiLCJjbGFpbU5leHRSZXRyeUxhbmUiLCJwaWNrQXJiaXRyYXJ5TGFuZSIsImxhbmVUb0luZGV4IiwiaW5jbHVkZXNTb21lTGFuZSIsImlzU3Vic2V0T2ZMYW5lcyIsInN1YnNldCIsIm1lcmdlTGFuZXMiLCJyZW1vdmVMYW5lcyIsImludGVyc2VjdExhbmVzIiwibGFuZVRvTGFuZXMiLCJoaWdoZXJQcmlvcml0eUxhbmUiLCJjcmVhdGVMYW5lTWFwIiwiaW5pdGlhbCIsImxhbmVNYXAiLCJtYXJrUm9vdFVwZGF0ZWQkMSIsInVwZGF0ZUxhbmUiLCJtYXJrUm9vdFN1c3BlbmRlZCQxIiwic3Bhd25lZExhbmUiLCJtYXJrU3Bhd25lZERlZmVycmVkTGFuZSIsIm1hcmtSb290UGluZ2VkJDEiLCJtYXJrUm9vdEZpbmlzaGVkIiwicmVtYWluaW5nTGFuZXMiLCJub0xvbmdlclBlbmRpbmdMYW5lcyIsInNoZWxsU3VzcGVuZENvdW50ZXIiLCJoaWRkZW5VcGRhdGVzIiwiaGlkZGVuVXBkYXRlc0ZvckxhbmUiLCJ1cGRhdGUiLCJzcGF3bmVkTGFuZUluZGV4IiwibWFya1Jvb3RFbnRhbmdsZWQiLCJyb290RW50YW5nbGVkTGFuZXMiLCJ1cGdyYWRlUGVuZGluZ0xhbmVUb1N5bmMiLCJ1cGdyYWRlUGVuZGluZ0xhbmVzVG9TeW5jIiwibGFuZXNUb1VwZ3JhZGUiLCJtYXJrSGlkZGVuVXBkYXRlIiwiZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbiIsInJlbmRlckxhbmUiLCJhZGRGaWJlclRvTGFuZXNNYXAiLCJpc0RldlRvb2xzUHJlc2VudCIsInBlbmRpbmdVcGRhdGVyc0xhbmVNYXAiLCJ1cGRhdGVycyIsImFkZCIsIm1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZCIsIm1lbW9pemVkVXBkYXRlcnMiLCJzaXplIiwiZm9yRWFjaCIsImhhcyIsImNsZWFyIiwiZ2V0VHJhbnNpdGlvbnNGb3JMYW5lcyIsIkRpc2NyZXRlRXZlbnRQcmlvcml0eSIsIkNvbnRpbnVvdXNFdmVudFByaW9yaXR5IiwiRGVmYXVsdEV2ZW50UHJpb3JpdHkiLCJJZGxlRXZlbnRQcmlvcml0eSIsImhpZ2hlckV2ZW50UHJpb3JpdHkiLCJsb3dlckV2ZW50UHJpb3JpdHkiLCJpc0hpZ2hlckV2ZW50UHJpb3JpdHkiLCJldmVudFByaW9yaXR5VG9MYW5lIiwidXBkYXRlUHJpb3JpdHkiLCJsYW5lc1RvRXZlbnRQcmlvcml0eSIsInNjaGVkdWxlQ2FsbGJhY2skMyIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJjYW5jZWxDYWxsYmFjayQxIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJzaG91bGRZaWVsZCIsInVuc3RhYmxlX3Nob3VsZFlpZWxkIiwicmVxdWVzdFBhaW50IiwidW5zdGFibGVfcmVxdWVzdFBhaW50Iiwibm93JDEiLCJ1bnN0YWJsZV9ub3ciLCJJbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJ1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSIsIk5vcm1hbFByaW9yaXR5JDEiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsIklkbGVQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlIiwicmVuZGVyZXJJRCIsImluamVjdGVkSG9vayIsImluamVjdGVkUHJvZmlsaW5nSG9va3MiLCJoYXNMb2dnZWRFcnJvciIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImluamVjdEludGVybmFscyIsImludGVybmFscyIsImhvb2siLCJpc0Rpc2FibGVkIiwic3VwcG9ydHNGaWJlciIsImdldExhbmVMYWJlbE1hcCIsImluamVjdFByb2ZpbGluZ0hvb2tzIiwiaW5qZWN0IiwiZXJyIiwiY2hlY2tEQ0UiLCJvblNjaGVkdWxlUm9vdCIsImNoaWxkcmVuIiwib25TY2hlZHVsZUZpYmVyUm9vdCIsIm9uQ29tbWl0Um9vdCQxIiwiZXZlbnRQcmlvcml0eSIsIm9uQ29tbWl0RmliZXJSb290IiwiZGlkRXJyb3IiLCJzY2hlZHVsZXJQcmlvcml0eSIsIm9uUG9zdENvbW1pdFJvb3QiLCJvblBvc3RDb21taXRGaWJlclJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsInNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzIiwibmV3SXNTdHJpY3RNb2RlIiwic2V0U3RyaWN0TW9kZSIsInByb2ZpbGluZ0hvb2tzIiwibGFiZWwiLCJtYXJrQ29tbWl0U3RhcnRlZCIsIm1hcmtDb21taXRTdG9wcGVkIiwibWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudEVycm9yZWQiLCJ0aHJvd25WYWx1ZSIsIm1hcmtDb21wb25lbnRTdXNwZW5kZWQiLCJ3YWtlYWJsZSIsIm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCIsIm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQiLCJtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkIiwibWFya1JlbmRlclN0YXJ0ZWQiLCJtYXJrUmVuZGVyWWllbGRlZCIsIm1hcmtSZW5kZXJTdG9wcGVkIiwibWFya1JlbmRlclNjaGVkdWxlZCIsIm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZCIsIm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCIsImlzIiwieSIsIm9iamVjdElzIiwiaXNSb290RGVoeWRyYXRlZCIsImN1cnJlbnRTdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJpc0RlaHlkcmF0ZWQiLCJDYXB0dXJlZFN0YWNrcyIsImNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyIiwic291cmNlIiwiY2FwdHVyZWRTdGFjayIsImNyZWF0ZUNhcHR1cmVkVmFsdWVGcm9tRXJyb3IiLCJmb3JrU3RhY2siLCJmb3JrU3RhY2tJbmRleCIsInRyZWVGb3JrUHJvdmlkZXIiLCJ0cmVlRm9ya0NvdW50IiwiaWRTdGFjayIsImlkU3RhY2tJbmRleCIsInRyZWVDb250ZXh0UHJvdmlkZXIiLCJ0cmVlQ29udGV4dElkIiwidHJlZUNvbnRleHRPdmVyZmxvdyIsImlzRm9ya2VkQ2hpbGQiLCJ3YXJuSWZOb3RIeWRyYXRpbmciLCJnZXRGb3Jrc0F0TGV2ZWwiLCJnZXRUcmVlSWQiLCJvdmVyZmxvdyIsImlkV2l0aExlYWRpbmdCaXQiLCJpZCIsImdldExlYWRpbmdCaXQiLCJ0b1N0cmluZyIsInB1c2hUcmVlRm9yayIsInRvdGFsQ2hpbGRyZW4iLCJwdXNoVHJlZUlkIiwiYmFzZUlkV2l0aExlYWRpbmdCaXQiLCJiYXNlT3ZlcmZsb3ciLCJiYXNlTGVuZ3RoIiwiZ2V0Qml0TGVuZ3RoIiwiYmFzZUlkIiwic2xvdCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3ciLCJyZXN0T2ZCYXNlSWQiLCJyZXN0T2ZCYXNlTGVuZ3RoIiwicmVzdE9mTGVuZ3RoIiwicmVzdE9mTmV3Qml0cyIsIm5ld0JpdHMiLCJfaWQiLCJfb3ZlcmZsb3ciLCJwdXNoTWF0ZXJpYWxpemVkVHJlZUlkIiwicmV0dXJuRmliZXIiLCJudW1iZXJPZkZvcmtzIiwic2xvdEluZGV4IiwibnVtYmVyIiwicG9wVHJlZUNvbnRleHQiLCJnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCIsInJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCIsInN1c3BlbmRlZENvbnRleHQiLCJnZXRJc0h5ZHJhdGluZyIsImNvbnRleHRTdGFja0N1cnNvciIsImNvbnRleHRGaWJlclN0YWNrQ3Vyc29yIiwicm9vdEluc3RhbmNlU3RhY2tDdXJzb3IiLCJob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yIiwiSG9zdFRyYW5zaXRpb25Db250ZXh0IiwiUHJvdmlkZXIiLCJDb25zdW1lciIsIl9jdXJyZW50VmFsdWUiLCJfY3VycmVudFZhbHVlMiIsIl90aHJlYWRDb3VudCIsInJlcXVpcmVkQ29udGV4dCIsImdldFJvb3RIb3N0Q29udGFpbmVyIiwicm9vdEluc3RhbmNlIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwibmV4dFJvb3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0Iiwic3RhdGVIb29rIiwibmV4dENvbnRleHQiLCJwb3BIb3N0Q29udGV4dCIsIm1heFJvd0xlbmd0aCIsImlkZWFsRGVwdGgiLCJmaW5kTm90YWJsZU5vZGUiLCJpbmRlbnQiLCJzZXJ2ZXJQcm9wcyIsInNlcnZlclRhaWwiLCJkaXN0YW5jZUZyb21MZWFmIiwiaW5kZW50YXRpb24iLCJyZXBlYXQiLCJhZGRlZCIsInJlbW92ZWQiLCJkZXNjcmliZUZpYmVyVHlwZSIsImN0ciIsIm5lZWRzRXNjYXBpbmciLCJkZXNjcmliZVRleHROb2RlIiwiY29udGVudCIsIm1heExlbmd0aCIsInRlc3QiLCJlbmNvZGVkIiwiSlNPTiIsInN0cmluZ2lmeSIsInNsaWNlIiwiZGVzY3JpYmVUZXh0RGlmZiIsImNsaWVudFRleHQiLCJzZXJ2ZXJUZXh0IiwiZmlyc3REaWZmIiwiY2hhckNvZGVBdCIsIm9iamVjdE5hbWUiLCJvYmplY3QiLCJtIiwicDAiLCJkZXNjcmliZVZhbHVlIiwicHJvcGVydGllcyIsInByb3BOYW1lIiwiaGFzT3duUHJvcGVydHkiLCJqc29uUHJvcE5hbWUiLCJwcm9wVmFsdWUiLCJfbmFtZSIsImRlc2NyaWJlUHJvcFZhbHVlIiwiZGVzY3JpYmVDb2xsYXBzZWRFbGVtZW50IiwiZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQiLCJyb3dQcmVmaXgiLCJyZW1haW5pbmdSb3dMZW5ndGgiLCJqb2luIiwiZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZiIsImNsaWVudE9iamVjdCIsInNlcnZlck9iamVjdCIsInJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMiLCJjbGllbnRWYWx1ZSIsImNsaWVudFByb3BWYWx1ZSIsInNlcnZlclZhbHVlIiwic2VydmVyUHJvcFZhbHVlIiwiX3Byb3BOYW1lIiwiX21heExlbmd0aCIsIl9zZXJ2ZXJWYWx1ZSIsIl9zZXJ2ZXJQcm9wVmFsdWUiLCJkZXNjcmliZUVsZW1lbnREaWZmIiwiY2xpZW50UHJvcHMiLCJzZXJ2ZXJQcm9wTmFtZXMiLCJ0b0xvd2VyQ2FzZSIsIl9wcm9wTmFtZTIiLCJzZXJ2ZXJQcm9wTmFtZSIsImRlbGV0ZSIsImtleXMiLCJpbmRleE9mIiwic2VydmVyQ2hpbGRyZW4iLCJjbGllbnRDaGlsZHJlbiIsImRlc2NyaWJlU2libGluZ0ZpYmVyIiwiZmxhdENvbnRlbnQiLCJjaGlsZEZpYmVyIiwiZGVzY3JpYmVOb2RlIiwic2tpcFRvTm9kZSIsInBhcmVudENvbnRlbnQiLCJzZXJ2ZXJDb21wb25lbnROYW1lIiwic2VsZkNvbnRlbnQiLCJwZW5kaW5nUHJvcHMiLCJjaGlsZENvbnRlbnQiLCJkaWZmSWR4IiwiY2hpbGROb2RlIiwiX2kiLCJ0YWlsTm9kZSIsImRlc2NyaWJlRGlmZiIsInJvb3ROb2RlIiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiaXNIeWRyYXRpbmciLCJkaWRTdXNwZW5kT3JFcnJvckRFViIsImh5ZHJhdGlvbkRpZmZSb290REVWIiwiaHlkcmF0aW9uRXJyb3JzIiwicm9vdE9yU2luZ2xldG9uQ29udGV4dCIsImJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUiLCJzaWJsaW5ncyIsImV4aXN0aW5nIiwibmV3Tm9kZSIsIndhcm5JZkh5ZHJhdGluZyIsIm1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWIiwiZW50ZXJIeWRyYXRpb25TdGF0ZSIsInBhcmVudEluc3RhbmNlIiwiY29udGFpbmVySW5mbyIsInJlZW50ZXJIeWRyYXRpb25TdGF0ZUZyb21EZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSIsInN1c3BlbnNlSW5zdGFuY2UiLCJ0cmVlQ29udGV4dCIsIndhcm5Ob25IeWRyYXRlZEluc3RhbmNlIiwicmVqZWN0ZWRDYW5kaWRhdGUiLCJkaWZmTm9kZSIsImRlc2NyaXB0aW9uIiwidHJ5SHlkcmF0ZUluc3RhbmNlIiwibmV4dEluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJkaWZmZXJlbmNlcyIsInRyeUh5ZHJhdGVUZXh0IiwidGV4dCIsInRleHRJbnN0YW5jZSIsInRyeUh5ZHJhdGVTdXNwZW5zZSIsInN1c3BlbnNlU3RhdGUiLCJkZWh5ZHJhdGVkIiwicmV0cnlMYW5lIiwiZGVoeWRyYXRlZEZyYWdtZW50IiwiY3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50IiwiSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24iLCJ0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2giLCJkaWZmIiwiZGlmZlJvb3QiLCJxdWV1ZUh5ZHJhdGlvbkVycm9yIiwiY2xhaW1IeWRyYXRhYmxlU2luZ2xldG9uIiwiY3VycmVudFJvb3RDb250YWluZXIiLCJjdXJyZW50SG9zdENvbnRleHQiLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsInNob3VsZEtlZXBXYXJuaW5nIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZSIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUZvcm1NYXJrZXJJbnN0YW5jZSIsIm1hcmtlckluc3RhbmNlIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSIsImRpZEh5ZHJhdGUiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInRleHRDb250ZW50Iiwic2hvdWxkV2FybklmTWlzbWF0Y2hEZXYiLCJwYXJlbnRQcm9wcyIsImRpZmZlcmVuY2UiLCJfZGlmZmVyZW5jZSIsIl9kaWZmTm9kZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSIsInNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJzaG91bGRDbGVhciIsIndhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwidXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUiLCJxdWV1ZVJlY292ZXJhYmxlRXJyb3JzIiwiZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncyIsImNvbmN1cnJlbnRRdWV1ZXMiLCJjb25jdXJyZW50UXVldWVzSW5kZXgiLCJjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMiLCJmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzIiwiZW5kSW5kZXgiLCJxdWV1ZSIsInBlbmRpbmciLCJuZXh0IiwibWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QiLCJnZXRDb25jdXJyZW50bHlVcGRhdGVkTGFuZXMiLCJlbnF1ZXVlVXBkYXRlJDEiLCJlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUiLCJjb25jdXJyZW50UXVldWUiLCJjb25jdXJyZW50VXBkYXRlIiwiZ2V0Um9vdEZvclVwZGF0ZWRGaWJlciIsImVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZUFuZEVhZ2VybHlCYWlsb3V0IiwiaXNDb25jdXJyZW50bHlSZW5kZXJpbmciLCJnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QiLCJlbnF1ZXVlQ29uY3VycmVudENsYXNzVXBkYXRlIiwiZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lIiwidW5zYWZlX21hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290Iiwic291cmNlRmliZXIiLCJpc0hpZGRlbiIsImNoaWxkTGFuZXMiLCJvZmZzY3JlZW5JbnN0YW5jZSIsIl92aXNpYmlsaXR5IiwidGhyb3dJZkluZmluaXRlVXBkYXRlTG9vcERldGVjdGVkIiwiZGV0ZWN0VXBkYXRlT25Vbm1vdW50ZWRGaWJlciIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJsYXN0U2NoZWR1bGVkUm9vdCIsImRpZFNjaGVkdWxlTWljcm90YXNrIiwiZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0IiwibWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrIiwiaXNGbHVzaGluZ1dvcmsiLCJjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSIsImVuc3VyZVJvb3RJc1NjaGVkdWxlZCIsImFjdFF1ZXVlIiwic2NoZWR1bGVJbW1lZGlhdGVUYXNrIiwicHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrIiwiZmx1c2hTeW5jV29ya09uQWxsUm9vdHMiLCJmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCIsIm9ubHlMZWdhY3kiLCJkaWRQZXJmb3JtU29tZVdvcmsiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3QiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyIsImdldFdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwicGVyZm9ybVN5bmNXb3JrT25Sb290IiwicHJldiIsInNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2siLCJleGlzdGluZ0NhbGxiYWNrTm9kZSIsImNhbGxiYWNrTm9kZSIsImlzV29ya0xvb3BTdXNwZW5kZWRPbkRhdGEiLCJjYW5jZWxQZW5kaW5nQ29tbWl0IiwiY2FuY2VsQ2FsbGJhY2siLCJjYWxsYmFja1ByaW9yaXR5IiwiZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5IiwibmV3Q2FsbGJhY2tQcmlvcml0eSIsImZha2VBY3RDYWxsYmFja05vZGUkMSIsInNjaGVkdWxlclByaW9yaXR5TGV2ZWwiLCJuZXdDYWxsYmFja05vZGUiLCJzY2hlZHVsZUNhbGxiYWNrJDIiLCJwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QiLCJiaW5kIiwiZ2V0Q29udGludWF0aW9uRm9yUm9vdCIsIm9yaWdpbmFsQ2FsbGJhY2tOb2RlIiwicHJpb3JpdHlMZXZlbCIsImNiIiwiZXhlY3V0aW9uQ29udGV4dCIsImdldEV4ZWN1dGlvbkNvbnRleHQiLCJSZW5kZXJDb250ZXh0IiwiQ29tbWl0Q29udGV4dCIsIk5vQ29udGV4dCIsInJlcXVlc3RUcmFuc2l0aW9uTGFuZSIsInRyYW5zaXRpb24iLCJjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzIiwiY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCIsImN1cnJlbnRFbnRhbmdsZWRMYW5lIiwiY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwiZW50YW5nbGVBc3luY0FjdGlvbiIsInRoZW5hYmxlIiwiZW50YW5nbGVkTGlzdGVuZXJzIiwiZW50YW5nbGVkVGhlbmFibGUiLCJzdGF0dXMiLCJ0aGVuIiwicmVzb2x2ZSIsInBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUiLCJmdWxmaWxsZWRUaGVuYWJsZSIsImxpc3RlbmVycyIsImxpc3RlbmVyIiwiY2hhaW5UaGVuYWJsZVZhbHVlIiwidGhlbmFibGVXaXRoT3ZlcnJpZGUiLCJyZWFzb24iLCJyZWplY3RlZFRoZW5hYmxlIiwicGVla0VudGFuZ2xlZEFjdGlvbkxhbmUiLCJwZWVrRW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJVcGRhdGVTdGF0ZSIsIlJlcGxhY2VTdGF0ZSIsIkZvcmNlVXBkYXRlIiwiQ2FwdHVyZVVwZGF0ZSIsImhhc0ZvcmNlVXBkYXRlIiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImluaXRpYWxpemVVcGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwic2hhcmVkIiwiaGlkZGVuQ2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwidXBkYXRlUXVldWUiLCJjbG9uZVVwZGF0ZVF1ZXVlIiwiY3VycmVudFF1ZXVlIiwiY2xvbmUiLCJjcmVhdGVVcGRhdGUiLCJlbnF1ZXVlVXBkYXRlIiwic2hhcmVkUXVldWUiLCJjb21wb25lbnROYW1lIiwiaXNVbnNhZmVDbGFzc1JlbmRlclBoYXNlVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9ucyIsInF1ZXVlTGFuZXMiLCJuZXdRdWV1ZUxhbmVzIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwibmV4dFN0YXRlIiwiZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicGFydGlhbFN0YXRlIiwiZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiIsInN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24iLCJlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsInBlbmRpbmdRdWV1ZSIsImxhc3RQZW5kaW5nVXBkYXRlIiwiZmlyc3RQZW5kaW5nVXBkYXRlIiwiY3VycmVudExhc3RCYXNlVXBkYXRlIiwibmV3U3RhdGUiLCJuZXdMYW5lcyIsIm5ld0Jhc2VTdGF0ZSIsIm5ld0ZpcnN0QmFzZVVwZGF0ZSIsIm5ld0xhc3RCYXNlVXBkYXRlIiwiaXNIaWRkZW5VcGRhdGUiLCJzaG91bGRTa2lwVXBkYXRlIiwiX2Nsb25lIiwiX2xhc3RQZW5kaW5nVXBkYXRlIiwiX2ZpcnN0UGVuZGluZ1VwZGF0ZSIsIm1hcmtTa2lwcGVkVXBkYXRlTGFuZXMiLCJjYWxsQ2FsbGJhY2siLCJyZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZyIsImNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmciLCJkZWZlckhpZGRlbkNhbGxiYWNrcyIsIm5ld0hpZGRlbkNhbGxiYWNrcyIsImV4aXN0aW5nSGlkZGVuQ2FsbGJhY2tzIiwiY29tbWl0SGlkZGVuQ2FsbGJhY2tzIiwiY29tbWl0Q2FsbGJhY2tzIiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXNCIiwiY3VycmVudEtleSIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsInJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJmaW5kU3RyaWN0Um9vdCIsIm1heWJlU3RyaWN0Um9vdCIsInNldFRvU29ydGVkU3RyaW5nIiwiYXJyYXkiLCJzb3J0IiwicGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsImRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMiLCJTZXQiLCJjb21wb25lbnRXaWxsTW91bnQiLCJfX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJzb3J0ZWROYW1lcyIsIl9zb3J0ZWROYW1lcyIsIl9zb3J0ZWROYW1lczIiLCJfc29ydGVkTmFtZXMzIiwiX3NvcnRlZE5hbWVzNCIsIl9zb3J0ZWROYW1lczUiLCJwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmciLCJkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0Iiwic3RyaWN0Um9vdCIsIndhcm5pbmdzRm9yUm9vdCIsImNvbnRleHRUeXBlcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiZ2V0Q2hpbGRDb250ZXh0IiwiZmliZXJBcnJheSIsImZpcnN0RmliZXIiLCJ1bmlxdWVOYW1lcyIsImdldFRoZW5hYmxlc0Zyb21TdGF0ZSIsInN0YXRlIiwiZGV2U3RhdGUiLCJ0aGVuYWJsZXMiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsIlN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbiIsIm5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UiLCJpc1RoZW5hYmxlUmVzb2x2ZWQiLCJub29wJDEiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJkaWRVc2VQcm9taXNlIiwidHJhY2tlZFRoZW5hYmxlcyIsInByZXZpb3VzIiwidGhlbmFibGVTdGF0ZURldiIsImZ1bGZpbGxlZFZhbHVlIiwicmVqZWN0ZWRFcnJvciIsImNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoIiwicGVuZGluZ1RoZW5hYmxlIiwiX3JlamVjdGVkRXJyb3IiLCJzdXNwZW5kZWRUaGVuYWJsZSIsIm5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWIiwic3VzcGVuZENvbW1pdCIsImdldFN1c3BlbmRlZFRoZW5hYmxlIiwiY2hlY2tJZlVzZVdyYXBwZWRJblRyeUNhdGNoIiwicmVqZWN0ZWRSZWFzb24iLCJ0aGVuYWJsZVN0YXRlJDEiLCJ0aGVuYWJsZUluZGV4Q291bnRlciQxIiwibWVyZ2VEZWJ1Z0luZm8iLCJvdXRlciIsImlubmVyIiwiZGlkV2FybkFib3V0TWFwcyIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nIiwid2FybkZvck1pc3NpbmdLZXkiLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJjb21wb25lbnRLZXkiLCJjaGlsZE93bmVyIiwiX293bmVyIiwicGFyZW50T3duZXIiLCJfZGVidWdPd25lciIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyQXBwZW5kaXgiLCJvd25lck5hbWUiLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiZWxlbWVudCIsImVycm9yZWRLZXkiLCJ1bndyYXBUaGVuYWJsZSIsImNvZXJjZVJlZiIsInJlZiIsInJlZlByb3AiLCJ0aHJvd09uSW52YWxpZE9iamVjdFR5cGUiLCJuZXdDaGlsZCIsImNoaWxkU3RyaW5nIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwiaW52YWxpZENoaWxkIiwicGFyZW50TmFtZSIsIndhcm5PblN5bWJvbFR5cGUiLCJyZXNvbHZlTGF6eSIsImxhenlUeXBlIiwiY3JlYXRlQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImRlbGV0aW9ucyIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJjcmVhdGVkIiwiY3JlYXRlRmliZXJGcm9tVGV4dCIsInVwZGF0ZUVsZW1lbnQiLCJlbGVtZW50VHlwZSIsInVwZGF0ZWQiLCJ1cGRhdGVGcmFnbWVudCIsImlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyIsInVwZGF0ZVBvcnRhbCIsInBvcnRhbCIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwiZnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImNyZWF0ZUNoaWxkIiwiX2NyZWF0ZWQiLCJfY3JlYXRlZDIiLCJyZXNvbHZlZENoaWxkIiwiX2NyZWF0ZWQzIiwicmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbiIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsIl9uZXdGaWJlciIsIl9udW1iZXJPZkZvcmtzIiwiX25ld0ZpYmVyMiIsIl9udW1iZXJPZkZvcmtzMiIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0YWJsZSIsIm5ld0NoaWxkcmVuSXRlcmFibGUiLCJpdGVyYXRvckZuIiwiaXNHZW5lcmF0b3JDb21wb25lbnQiLCJlbnRyaWVzIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsInN0ZXAiLCJkb25lIiwiX25ld0ZpYmVyMyIsIl9udW1iZXJPZkZvcmtzMyIsIl9uZXdGaWJlcjQiLCJfbnVtYmVyT2ZGb3JrczQiLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJfZXhpc3RpbmciLCJfY3JlYXRlZDQiLCJyZWNvbmNpbGVTaW5nbGVQb3J0YWwiLCJyZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwiLCJpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50IiwicmVjb25jaWxlQ2hpbGRGaWJlcnMiLCJmaXJzdENoaWxkRmliZXIiLCJtb3VudENoaWxkRmliZXJzIiwicmVzZXRDaGlsZFJlY29uY2lsZXJPblVud2luZCIsImNsb25lQ2hpbGRGaWJlcnMiLCJjdXJyZW50Q2hpbGQiLCJyZXNldENoaWxkRmliZXJzIiwicmVzZXRXb3JrSW5Qcm9ncmVzcyIsImN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IiLCJwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IiLCJwdXNoSGlkZGVuQ29udGV4dCIsInByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyIsImdldEVudGFuZ2xlZFJlbmRlckxhbmVzIiwic2V0RW50YW5nbGVkUmVuZGVyTGFuZXMiLCJiYXNlTGFuZXMiLCJyZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrIiwicG9wSGlkZGVuQ29udGV4dCIsImlzQ3VycmVudFRyZWVIaWRkZW4iLCJzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciIsInNoZWxsQm91bmRhcnkiLCJnZXRTaGVsbEJvdW5kYXJ5IiwicHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyIiwiaGFuZGxlciIsInB1c2hTdXNwZW5zZUxpc3RDb250ZXh0Iiwic2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0Iiwic3VzcGVuc2VTdGFja0N1cnNvciIsInB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIiLCJyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2siLCJwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyIiwiZ2V0U3VzcGVuc2VIYW5kbGVyIiwicG9wU3VzcGVuc2VIYW5kbGVyIiwicG9wU3VzcGVuc2VMaXN0Q29udGV4dCIsIkRlZmF1bHRTdXNwZW5zZUNvbnRleHQiLCJTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayIsIkZvcmNlU3VzcGVuc2VGYWxsYmFjayIsImhhc1N1c3BlbnNlTGlzdENvbnRleHQiLCJmbGFnIiwic2V0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQiLCJzaGFsbG93Q29udGV4dCIsIm5ld0NvbnRleHQiLCJmaW5kRmlyc3RTdXNwZW5kZWQiLCJyb3ciLCJyZXZlYWxPcmRlciIsImRpZFN1c3BlbmQiLCJOb0ZsYWdzIiwiSGFzRWZmZWN0IiwiSW5zZXJ0aW9uIiwiTGF5b3V0IiwiUGFzc2l2ZSIsImRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCIsImRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IiwiZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2giLCJkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudCIsImRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MiLCJzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViIsImxvY2FsSWRDb3VudGVyIiwidGhlbmFibGVJbmRleENvdW50ZXIiLCJnbG9iYWxDbGllbnRJZENvdW50ZXIiLCJSRV9SRU5ERVJfTElNSVQiLCJjdXJyZW50SG9va05hbWVJbkRldiIsImhvb2tUeXBlc0RldiIsImhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2IiwiaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMiLCJtb3VudEhvb2tUeXBlc0RldiIsImhvb2tOYW1lIiwidXBkYXRlSG9va1R5cGVzRGV2Iiwid2Fybk9uSG9va01pc21hdGNoSW5EZXYiLCJjaGVja0RlcHNBcmVBcnJheURldiIsImRlcHMiLCJjdXJyZW50SG9va05hbWUiLCJ0YWJsZSIsInNlY29uZENvbHVtblN0YXJ0Iiwib2xkSG9va05hbWUiLCJuZXdIb29rTmFtZSIsIndhcm5PblVzZUZvcm1TdGF0ZUluRGV2Iiwid2FybklmQXN5bmNDbGllbnRDb21wb25lbnQiLCJpc0FzeW5jRnVuY3Rpb24iLCJ0aHJvd0ludmFsaWRIb29rRXJyb3IiLCJhcmVIb29rSW5wdXRzRXF1YWwiLCJuZXh0RGVwcyIsInByZXZEZXBzIiwicmVuZGVyV2l0aEhvb2tzIiwibmV4dFJlbmRlckxhbmVzIiwiX2RlYnVnSG9va1R5cGVzIiwiSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJzaG91bGREb3VibGVSZW5kZXJERVYiLCJyZW5kZXJXaXRoSG9va3NBZ2FpbiIsImZpbmlzaFJlbmRlcmluZ0hvb2tzIiwiQ29udGV4dE9ubHlEaXNwYXRjaGVyIiwiZGlkUmVuZGVyVG9vRmV3SG9va3MiLCJyZXBsYXlTdXNwZW5kZWRDb21wb25lbnRXaXRoSG9va3MiLCJudW1iZXJPZlJlUmVuZGVycyIsIkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsInJlbmRlclRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnRXaXRoSG9va3MiLCJUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50IiwiZGlzcGF0Y2hlciIsIl9kaXNwYXRjaGVyJHVzZVN0YXRlIiwidXNlU3RhdGUiLCJtYXliZVRoZW5hYmxlIiwidXNlVGhlbmFibGUiLCJfZGlzcGF0Y2hlciR1c2VTdGF0ZTIiLCJuZXh0UmVzZXRTdGF0ZSIsInByZXZSZXNldFN0YXRlIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJiYWlsb3V0SG9va3MiLCJyZXNldEhvb2tzQWZ0ZXJUaHJvdyIsInJlc2V0SG9va3NPblVud2luZCIsIm1vdW50V29ya0luUHJvZ3Jlc3NIb29rIiwiYmFzZVF1ZXVlIiwidXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rIiwibmV4dEN1cnJlbnRIb29rIiwibmV4dFdvcmtJblByb2dyZXNzSG9vayIsImN1cnJlbnRGaWJlciIsIm5ld0hvb2siLCJjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwibGFzdEVmZmVjdCIsImV2ZW50cyIsInN0b3JlcyIsIm1lbW9DYWNoZSIsIndvcmtJblByb2dyZXNzRmliZXIiLCJ1c2UiLCJ1c2FibGUiLCJyZWFkQ29udGV4dCIsInVzZU1lbW9DYWNoZSIsImN1cnJlbnRVcGRhdGVRdWV1ZSIsImN1cnJlbnRNZW1vQ2FjaGUiLCJkYXRhIiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJhY3Rpb24iLCJtb3VudFJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwibGFzdFJlbmRlcmVkUmVkdWNlciIsImxhc3RSZW5kZXJlZFN0YXRlIiwiZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsInVwZGF0ZVJlZHVjZXJJbXBsIiwiYmFzZUZpcnN0IiwicGVuZGluZ0ZpcnN0IiwiZmlyc3QiLCJuZXdCYXNlUXVldWVGaXJzdCIsIm5ld0Jhc2VRdWV1ZUxhc3QiLCJyZXZlcnRMYW5lIiwiaGFzRWFnZXJTdGF0ZSIsImVhZ2VyU3RhdGUiLCJfY2xvbmUyIiwibWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUiLCJyZXJlbmRlclJlZHVjZXIiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJmaXJzdFJlbmRlclBoYXNlVXBkYXRlIiwibW91bnRTeW5jRXh0ZXJuYWxTdG9yZSIsInN1YnNjcmliZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJuZXh0U25hcHNob3QiLCJjYWNoZWRTbmFwc2hvdCIsInJvb3RSZW5kZXJMYW5lcyIsInB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2siLCJpbnN0IiwibW91bnRFZmZlY3QiLCJzdWJzY3JpYmVUb1N0b3JlIiwicHVzaEVmZmVjdCIsInVwZGF0ZVN0b3JlSW5zdGFuY2UiLCJjcmVhdGVFZmZlY3RJbnN0YW5jZSIsInVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlIiwicHJldlNuYXBzaG90Iiwic25hcHNob3RDaGFuZ2VkIiwidXBkYXRlRWZmZWN0IiwicmVuZGVyZWRTbmFwc2hvdCIsImNoZWNrIiwiY29tcG9uZW50VXBkYXRlUXVldWUiLCJjaGVja0lmU25hcHNob3RDaGFuZ2VkIiwiZm9yY2VTdG9yZVJlcmVuZGVyIiwiaGFuZGxlU3RvcmVDaGFuZ2UiLCJsYXRlc3RHZXRTbmFwc2hvdCIsInByZXZWYWx1ZSIsIm5leHRWYWx1ZSIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsIm1vdW50U3RhdGVJbXBsIiwiaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsInVwZGF0ZVN0YXRlIiwicmVyZW5kZXJTdGF0ZSIsIm1vdW50T3B0aW1pc3RpYyIsInBhc3N0aHJvdWdoIiwiZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUiLCJ1cGRhdGVPcHRpbWlzdGljIiwidXBkYXRlT3B0aW1pc3RpY0ltcGwiLCJyZXNvbHZlZFJlZHVjZXIiLCJyZXJlbmRlck9wdGltaXN0aWMiLCJkaXNwYXRjaEFjdGlvblN0YXRlIiwiYWN0aW9uUXVldWUiLCJzZXRQZW5kaW5nU3RhdGUiLCJzZXRTdGF0ZSIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJjdXJyZW50QWN0aW9uIiwiYWN0aW9uTm9kZSIsImlzVHJhbnNpdGlvbiIsInByZXZUcmFuc2l0aW9uIiwiVCIsImxhc3QiLCJydW5BY3Rpb25TdGF0ZUFjdGlvbiIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJyZXR1cm5WYWx1ZSIsIm9uU3RhcnRUcmFuc2l0aW9uRmluaXNoIiwiUyIsImhhbmRsZUFjdGlvblJldHVyblZhbHVlIiwib25BY3Rpb25FcnJvciIsInVwZGF0ZWRGaWJlcnNDb3VudCIsIl9yZXR1cm5WYWx1ZSIsIm9uQWN0aW9uU3VjY2VzcyIsIm5vdGlmeUFjdGlvbkxpc3RlbmVycyIsImFjdGlvblN0YXRlUmVkdWNlciIsIm9sZFN0YXRlIiwibW91bnRBY3Rpb25TdGF0ZSIsImluaXRpYWxTdGF0ZVByb3AiLCJwZXJtYWxpbmsiLCJzc3JGb3JtU3RhdGUiLCJmb3JtU3RhdGUiLCJpc01hdGNoaW5nIiwic3RhdGVRdWV1ZSIsInBlbmRpbmdTdGF0ZUhvb2siLCJhY3Rpb25RdWV1ZUhvb2siLCJ1cGRhdGVBY3Rpb25TdGF0ZSIsImN1cnJlbnRTdGF0ZUhvb2siLCJ1cGRhdGVBY3Rpb25TdGF0ZUltcGwiLCJfdXBkYXRlUmVkdWNlckltcGwiLCJhY3Rpb25SZXN1bHQiLCJfdXBkYXRlU3RhdGUiLCJpc1BlbmRpbmciLCJwcmV2QWN0aW9uIiwiYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QiLCJyZXJlbmRlckFjdGlvblN0YXRlIiwiY3JlYXRlIiwiZWZmZWN0IiwiZmlyc3RFZmZlY3QiLCJkZXN0cm95IiwibW91bnRSZWYiLCJpbml0aWFsVmFsdWUiLCJ1cGRhdGVSZWYiLCJtb3VudEVmZmVjdEltcGwiLCJmaWJlckZsYWdzIiwiaG9va0ZsYWdzIiwidXBkYXRlRWZmZWN0SW1wbCIsInByZXZFZmZlY3QiLCJtb3VudEluc2VydGlvbkVmZmVjdCIsInVwZGF0ZUluc2VydGlvbkVmZmVjdCIsIm1vdW50TGF5b3V0RWZmZWN0IiwidXBkYXRlTGF5b3V0RWZmZWN0IiwiaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdCIsInJlZkNhbGxiYWNrIiwicmVmQ2xlYW51cCIsInJlZk9iamVjdCIsIl9pbnN0IiwibW91bnRJbXBlcmF0aXZlSGFuZGxlIiwiZWZmZWN0RGVwcyIsInVwZGF0ZUltcGVyYXRpdmVIYW5kbGUiLCJtb3VudERlYnVnVmFsdWUiLCJmb3JtYXR0ZXJGbiIsInVwZGF0ZURlYnVnVmFsdWUiLCJtb3VudENhbGxiYWNrIiwidXBkYXRlQ2FsbGJhY2siLCJtb3VudE1lbW8iLCJuZXh0Q3JlYXRlIiwidXBkYXRlTWVtbyIsIm1vdW50RGVmZXJyZWRWYWx1ZSIsIm1vdW50RGVmZXJyZWRWYWx1ZUltcGwiLCJ1cGRhdGVEZWZlcnJlZFZhbHVlIiwicmVzb2x2ZWRDdXJyZW50SG9vayIsInVwZGF0ZURlZmVycmVkVmFsdWVJbXBsIiwicmVyZW5kZXJEZWZlcnJlZFZhbHVlIiwiZGVmZXJyZWRMYW5lIiwicmVxdWVzdERlZmVycmVkTGFuZSIsInJlc3VsdFZhbHVlIiwic2hvdWxkRGVmZXJWYWx1ZSIsInN0YXJ0VHJhbnNpdGlvbiIsInBlbmRpbmdTdGF0ZSIsImZpbmlzaGVkU3RhdGUiLCJvcHRpb25zIiwicHJldmlvdXNQcmlvcml0eSIsInRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSIsIm5vb3AiLCJzdGFydEhvc3RUcmFuc2l0aW9uIiwiZm9ybUZpYmVyIiwiZm9ybURhdGEiLCJlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bCIsInJlcXVlc3RGb3JtUmVzZXQiLCJleGlzdGluZ1N0YXRlSG9vayIsIm5ld1F1ZXVlIiwiaW5pdGlhbFJlc2V0U3RhdGUiLCJuZXdSZXNldFN0YXRlUXVldWUiLCJyZXNldFN0YXRlSG9vayIsInJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbiIsIm5ld1Jlc2V0U3RhdGUiLCJyZXNldFN0YXRlUXVldWUiLCJtb3VudFRyYW5zaXRpb24iLCJzdGFydCIsInVwZGF0ZVRyYW5zaXRpb24iLCJfdXBkYXRlU3RhdGUyIiwiYm9vbGVhbk9yVGhlbmFibGUiLCJyZXJlbmRlclRyYW5zaXRpb24iLCJfcmVyZW5kZXJTdGF0ZSIsInVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZ2xvYmFsQ2xpZW50SWQiLCJ1cGRhdGVJZCIsIm1vdW50UmVmcmVzaCIsInJlZnJlc2giLCJyZWZyZXNoQ2FjaGUiLCJ1cGRhdGVSZWZyZXNoIiwic2VlZEtleSIsInNlZWRWYWx1ZSIsInByb3ZpZGVyIiwicmVxdWVzdFVwZGF0ZUxhbmUiLCJyZWZyZXNoVXBkYXRlIiwic2VlZGVkQ2FjaGUiLCJjcmVhdGVDYWNoZSIsImNhY2hlIiwiZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlIiwibWFya1VwZGF0ZUluRGV2VG9vbHMiLCJwcmV2RGlzcGF0Y2hlciIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwidGhyb3dJZkR1cmluZ1JlbmRlciIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVkdWNlciIsInVzZVJlZiIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlSWQiLCJ1c2VDYWNoZVJlZnJlc2giLCJ1c2VGb3JtU3RhdGUiLCJ1c2VBY3Rpb25TdGF0ZSIsInVzZU9wdGltaXN0aWMiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsIndhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyIsIndhcm5JbnZhbGlkSG9va0FjY2VzcyIsIm5vdyIsImNvbW1pdFRpbWUiLCJsYXlvdXRFZmZlY3RTdGFydFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsInBhc3NpdmVFZmZlY3RTdGFydFRpbWUiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJpc0N1cnJlbnRVcGRhdGVOZXN0ZWQiLCJtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkIiwicmVzZXROZXN0ZWRVcGRhdGVGbGFnIiwic3luY05lc3RlZFVwZGF0ZUZsYWciLCJnZXRDb21taXRUaW1lIiwicmVjb3JkQ29tbWl0VGltZSIsInN0YXJ0UHJvZmlsZXJUaW1lciIsImFjdHVhbFN0YXJ0VGltZSIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSIsIm92ZXJyaWRlQmFzZVRpbWUiLCJlbGFwc2VkVGltZSIsImFjdHVhbER1cmF0aW9uIiwic2VsZkJhc2VEdXJhdGlvbiIsInJlY29yZExheW91dEVmZmVjdER1cmF0aW9uIiwicGFyZW50RmliZXIiLCJlZmZlY3REdXJhdGlvbiIsInBhcmVudFN0YXRlTm9kZSIsInJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInN0YXJ0TGF5b3V0RWZmZWN0VGltZXIiLCJzdGFydFBhc3NpdmVFZmZlY3RUaW1lciIsInRyYW5zZmVyQWN0dWFsRHVyYXRpb24iLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsImRpZFdhcm5PbkludmFsaWRDYWxsYmFjayIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsIndhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsImFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiZW5xdWV1ZVNldFN0YXRlIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsImVucXVldWVGb3JjZVVwZGF0ZSIsImNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsInNob3VsZFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiY2hlY2tDbGFzc0luc3RhbmNlIiwicmVuZGVyUHJlc2VudCIsImdldEluaXRpYWxTdGF0ZSIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiZ2V0RGVmYXVsdFByb3BzIiwicHJvcFR5cGVzIiwiY29udGV4dFR5cGUiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiaGFzTXV0YXRlZFByb3BzIiwiZGVmYXVsdFByb3BzIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwiaXNWYWxpZCIsImFkZGVuZHVtIiwidXBkYXRlciIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsIl9jb21wb25lbnROYW1lIiwibmV3QXBpTmFtZSIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsInJlZnMiLCJjb21wb25lbnREaWRNb3VudCIsInJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSIsInVucmVzb2x2ZWRPbGRQcm9wcyIsInJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzIiwib2xkQ29udGV4dCIsImhhc05ld0xpZmVjeWNsZXMiLCJ1bnJlc29sdmVkTmV3UHJvcHMiLCJkaWRSZWNlaXZlTmV3UHJvcHMiLCJ1cGRhdGVDbGFzc0luc3RhbmNlIiwiYmFzZVByb3BzIiwiYWxyZWFkeVJlc29sdmVkRGVmYXVsdFByb3BzIiwicmVwb3J0R2xvYmFsRXJyb3IiLCJyZXBvcnRFcnJvciIsIndpbmRvdyIsIkVycm9yRXZlbnQiLCJldmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwic2hvdWxkTG9nIiwiZGlzcGF0Y2hFdmVudCIsImVtaXQiLCJlcnJvckJvdW5kYXJ5TmFtZSIsImRlZmF1bHRPblVuY2F1Z2h0RXJyb3IiLCJlcnJvckluZm8iLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tcG9uZW50U3RhY2siLCJkZWZhdWx0T25DYXVnaHRFcnJvciIsImVycm9yJDEiLCJyZWNyZWF0ZU1lc3NhZ2UiLCJkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yIiwibG9nVW5jYXVnaHRFcnJvciIsInRocm93bkVycm9ycyIsIm9uVW5jYXVnaHRFcnJvciIsImUiLCJzZXRUaW1lb3V0IiwibG9nQ2F1Z2h0RXJyb3IiLCJib3VuZGFyeSIsIm9uQ2F1Z2h0RXJyb3IiLCJlcnJvckJvdW5kYXJ5IiwiY3JlYXRlUm9vdEVycm9yVXBkYXRlIiwiY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSIsImluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlIiwibWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmciLCJjb21wb25lbnREaWRDYXRjaCIsIm1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQiLCJtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUiLCJzdXNwZW5zZUJvdW5kYXJ5IiwidGhyb3dFeGNlcHRpb24iLCJyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzIiwicmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSIsInJlbmRlckRpZFN1c3BlbmQiLCJpc1N1c3BlbnNleVJlc291cmNlIiwicmV0cnlRdWV1ZSIsImF0dGFjaFBpbmdMaXN0ZW5lciIsIl9pc1N1c3BlbnNleVJlc291cmNlIiwib2Zmc2NyZWVuUXVldWUiLCJuZXdPZmZzY3JlZW5RdWV1ZSIsInRyYW5zaXRpb25zIiwibWFya2VySW5zdGFuY2VzIiwiX3JldHJ5UXVldWUiLCJfc3VzcGVuc2VCb3VuZGFyeSIsIl93cmFwcGVyRXJyb3IiLCJjYXVzZSIsIl93cmFwcGVyRXJyb3IyIiwiX3dvcmtJblByb2dyZXNzIiwicm9vdEVycm9ySW5mbyIsInJlbmRlckRpZEVycm9yIiwid3JhcHBlckVycm9yIiwicXVldWVDb25jdXJyZW50RXJyb3IiLCJfbGFuZSIsIl91cGRhdGUiLCJpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5IiwiX2xhbmUyIiwiX3VwZGF0ZTIiLCJTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24iLCJkaWRSZWNlaXZlVXBkYXRlIiwiZGlkV2FybkFib3V0QmFkQ2xhc3MiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsImRpZFdhcm5BYm91dFJldmVhbE9yZGVyIiwiZGlkV2FybkFib3V0VGFpbE9wdGlvbnMiLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUiLCJ1cGRhdGVGb3J3YXJkUmVmIiwicHJvcHNXaXRob3V0UmVmIiwiaGFzSWQiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50IiwiaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCIsImNvbXBhcmUiLCJyZXNvbHZlZFR5cGUiLCJyZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmciLCJ2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYiLCJ1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50IiwiY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzIiwiaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwiY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQiLCJwcmV2UHJvcHMiLCJ1cGRhdGVGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudCIsIm5leHRJc0RldGFjaGVkIiwiX3BlbmRpbmdWaXNpYmlsaXR5IiwibWFya1JlZiIsIm5leHRCYXNlTGFuZXMiLCJjdXJyZW50Q2hpbGRMYW5lcyIsImxhbmVzV2VKdXN0QXR0ZW1wdGVkIiwicmVtYWluaW5nQ2hpbGRMYW5lcyIsImRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50IiwiX25leHRCYXNlTGFuZXMiLCJfbmV4dFN0YXRlIiwiY2FjaGVQb29sIiwicHJldkNhY2hlUG9vbCIsInB1c2hUcmFuc2l0aW9uIiwiX3ByZXZDYWNoZVBvb2wiLCJnZXRPZmZzY3JlZW5EZWZlcnJlZENhY2hlIiwidXBkYXRlQ2FjaGVDb21wb25lbnQiLCJwYXJlbnRDYWNoZSIsIkNhY2hlQ29udGV4dCIsImZyZXNoQ2FjaGUiLCJyZXF1ZXN0Q2FjaGVGcm9tUG9vbCIsInB1c2hDYWNoZVByb3ZpZGVyIiwiZGVyaXZlZFN0YXRlIiwibmV4dENhY2hlIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsInVwZGF0ZU1vZGUiLCJ1cGRhdGVQcm9maWxlciIsInJlcGxheUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJzaG91bGRFcnJvciIsIl9pbnN0YW5jZSIsInRlbXBJbnN0YW5jZSIsImhhc0NvbnRleHQiLCJuZXh0VW5pdE9mV29yayIsImZpbmlzaENsYXNzQ29tcG9uZW50IiwiZGlkQ2FwdHVyZUVycm9yIiwicHVzaEhvc3RSb290Q29udGV4dCIsInVwZGF0ZUhvc3RSb290IiwicHJldkNoaWxkcmVuIiwib3ZlcnJpZGVTdGF0ZSIsIm1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nIiwicmVjb3ZlcmFibGVFcnJvciIsInVwZGF0ZUhvc3RDb21wb25lbnQkMSIsImlzRGlyZWN0VGV4dENoaWxkIiwib2xkU3RhdGVIb29rIiwidXBkYXRlSG9zdEhvaXN0YWJsZSIsInJlc291cmNlIiwidXBkYXRlSG9zdFNpbmdsZXRvbiIsInVwZGF0ZUhvc3RUZXh0JDEiLCJtb3VudExhenlDb21wb25lbnQiLCJfY3VycmVudCIsImlzRnVuY3Rpb25DbGFzc0NvbXBvbmVudCIsInJlc29sdmVkUHJvcHMiLCJyZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmciLCJfcmVzb2x2ZWRQcm9wcyIsIl9yZXNvbHZlZFByb3BzMiIsInJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nIiwiX3Jlc29sdmVkUHJvcHMzIiwiaGludCIsIl9jb21wb25lbnROYW1lMiIsIl9jb21wb25lbnROYW1lMyIsIlNVU1BFTkRFRF9NQVJLRVIiLCJtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJnZXRTdXNwZW5kZWRDYWNoZSIsInVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJwcmV2T2Zmc2NyZWVuU3RhdGUiLCJwb29sIiwic2hvdWxkUmVtYWluT25GYWxsYmFjayIsInN1c3BlbnNlQ29udGV4dCIsImdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlIiwicHJpbWFyeVRyZWVEaWREZWZlciIsInBlZWtEZWZlcnJlZExhbmUiLCJ1cGRhdGVTdXNwZW5zZUNvbXBvbmVudCIsInNob3VsZFN1c3BlbmQiLCJzaG93RmFsbGJhY2siLCJkaWRQcmltYXJ5Q2hpbGRyZW5EZWZlciIsIm1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50IiwibmV4dFByaW1hcnlDaGlsZHJlbiIsIm5leHRGYWxsYmFja0NoaWxkcmVuIiwiZmFsbGJhY2siLCJmYWxsYmFja0ZyYWdtZW50IiwibW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4iLCJwcmltYXJ5Q2hpbGRGcmFnbWVudCIsIm1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4iLCJfZGVoeWRyYXRlZCIsInVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCIsIl9uZXh0RmFsbGJhY2tDaGlsZHJlbiIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuIiwiZmFsbGJhY2tDaGlsZEZyYWdtZW50IiwidXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50MiIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuMiIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDMiLCJ1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbiIsInByaW1hcnlDaGlsZHJlbiIsInByaW1hcnlDaGlsZFByb3BzIiwibW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwiZmFsbGJhY2tDaGlsZHJlbiIsIm9mZnNjcmVlblByb3BzIiwiY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuIiwidXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlciIsImN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCIsImN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQiLCJzdWJ0cmVlRmxhZ3MiLCJyZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyIsIm1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nIiwiZmliZXJNb2RlIiwiZGlnZXN0IiwiX2dldFN1c3BlbnNlSW5zdGFuY2VGIiwiY2FwdHVyZWRWYWx1ZSIsImF0dGVtcHRIeWRyYXRpb25BdExhbmUiLCJyZXRyeSIsInJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0Iiwic2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyIiwicHJvcGFnYXRpb25Sb290Iiwic2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aCIsInByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSIsImZpcnN0Q2hpbGQiLCJmaW5kTGFzdENvbnRlbnRSb3ciLCJsYXN0Q29udGVudFJvdyIsImN1cnJlbnRSb3ciLCJ2YWxpZGF0ZVJldmVhbE9yZGVyIiwidmFsaWRhdGVUYWlsT3B0aW9ucyIsInRhaWxNb2RlIiwidmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZCIsImNoaWxkU2xvdCIsImlzQW5BcnJheSIsImlzSXRlcmFibGUiLCJ2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuIiwiY2hpbGRyZW5JdGVyYXRvciIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsImlzQmFja3dhcmRzIiwidGFpbCIsInJlbmRlclN0YXRlIiwicmVuZGVyaW5nU3RhcnRUaW1lIiwidXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50Iiwic2hvdWxkRm9yY2VGYWxsYmFjayIsImRpZFN1c3BlbmRCZWZvcmUiLCJfdGFpbCIsIm5leHRSb3ciLCJ1cGRhdGVQb3J0YWxDb21wb25lbnQiLCJoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciIsInVwZGF0ZUNvbnRleHRQcm92aWRlciIsIm5ld1ZhbHVlIiwicHVzaFByb3ZpZGVyIiwib2xkVmFsdWUiLCJ1cGRhdGVDb250ZXh0Q29uc3VtZXIiLCJjb25zdW1lclR5cGUiLCJkZXBlbmRlbmNpZXMiLCJyZW1vdW50RmliZXIiLCJvbGRXb3JrSW5Qcm9ncmVzcyIsIm5ld1dvcmtJblByb2dyZXNzIiwicHJldlNpYmxpbmciLCJ1cGRhdGVMYW5lcyIsImF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlIiwiaGFzQ2hpbGRXb3JrIiwicHJpbWFyeUNoaWxkTGFuZXMiLCJfaGFzQ2hpbGRXb3JrIiwiX2NhY2hlIiwiYmVnaW5Xb3JrIiwiX2RlYnVnTmVlZHNSZW1vdW50IiwiY29waWVkRmliZXIiLCJ1bnJlc29sdmVkUHJvcHMiLCJfQ29tcG9uZW50IiwiX3VucmVzb2x2ZWRQcm9wcyIsIl9yZXNvbHZlZFByb3BzNCIsIl91bnJlc29sdmVkUHJvcHMyIiwiX3Jlc29sdmVkUHJvcHM1IiwiX3R5cGUiLCJfdW5yZXNvbHZlZFByb3BzMyIsIl9yZXNvbHZlZFByb3BzNiIsInZhbHVlQ3Vyc29yIiwicmVuZGVyZXJDdXJzb3JERVYiLCJyZW5kZXJlcjJDdXJzb3JERVYiLCJyZW5kZXJlclNpZ2lsIiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwicHJvdmlkZXJGaWJlciIsIl9jdXJyZW50UmVuZGVyZXIiLCJfY3VycmVudFJlbmRlcmVyMiIsInBvcFByb3ZpZGVyIiwiY3VycmVudFZhbHVlIiwiY3VycmVudFJlbmRlcmVyIiwiY3VycmVudFJlbmRlcmVyMiIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIiLCJuZXh0RmliZXIiLCJsaXN0IiwiZGVwZW5kZW5jeSIsImZpcnN0Q29udGV4dCIsInBhcmVudFN1c3BlbnNlIiwiX2FsdGVybmF0ZSIsInJlYWRDb250ZXh0Rm9yQ29uc3VtZXIiLCJjb250ZXh0SXRlbSIsIm1lbW9pemVkVmFsdWUiLCJBYm9ydENvbnRyb2xsZXJMb2NhbCIsIkFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlclNoaW0iLCJzaWduYWwiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0Iiwic2NoZWR1bGVDYWxsYmFjayQxIiwiTm9ybWFsUHJpb3JpdHkiLCJjb250cm9sbGVyIiwicmVmQ291bnQiLCJyZXRhaW5DYWNoZSIsInJlbGVhc2VDYWNoZSIsInBvcENhY2hlUHJvdmlkZXIiLCJwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2giLCJvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaEZvclJlY29uY2lsZXIiLCJyZXN1bWVkQ2FjaGUiLCJwZWVrQ2FjaGVGcm9tUG9vbCIsImNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciIsImNhY2hlRnJvbVJvb3RDYWNoZVBvb2wiLCJwb29sZWRDYWNoZSIsImNhY2hlRnJvbVBvb2wiLCJwb29sZWRDYWNoZUxhbmVzIiwib2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MiLCJuZXdUcmFuc2l0aW9ucyIsInBvcFRyYW5zaXRpb24iLCJtYXJrVXBkYXRlIiwiZG9lc1JlcXVpcmVDbG9uZSIsImNvbXBsZXRlZFdvcmsiLCJkaWRCYWlsb3V0IiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJuZWVkc1Zpc2liaWxpdHlUb2dnbGUiLCJfbm9kZSIsImFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIiLCJjb250YWluZXJDaGlsZFNldCIsIl9pbnN0YW5jZTIiLCJfbmVlZHNWaXNpYmlsaXR5VG9nZ2xlIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInBvcnRhbE9yUm9vdCIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwicGVuZGluZ0NoaWxkcmVuIiwidXBkYXRlSG9zdENvbXBvbmVudCIsImN1cnJlbnRJbnN0YW5jZSIsIl9vbGRQcm9wcyIsInJlcXVpcmVzQ2xvbmUiLCJuZXdJbnN0YW5jZSIsInByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCIsImlzUmVhZHkiLCJzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuIiwicHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkIiwic2NoZWR1bGVSZXRyeUVmZmVjdCIsIndha2VhYmxlcyIsInVwZGF0ZUhvc3RUZXh0Iiwib2xkVGV4dCIsIm5ld1RleHQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJjdXRPZmZUYWlsSWZOZWVkZWQiLCJoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2siLCJsYXN0VGFpbE5vZGUiLCJfdGFpbE5vZGUiLCJfbGFzdFRhaWxOb2RlIiwiYnViYmxlUHJvcGVydGllcyIsIm5ld0NoaWxkTGFuZXMiLCJ0cmVlQmFzZUR1cmF0aW9uIiwiX3RyZWVCYXNlRHVyYXRpb24iLCJfY2hpbGQyIiwiX2NoaWxkMyIsImNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJ3YXNIeWRyYXRlZCIsImlzVGltZWRPdXRTdXNwZW5zZSIsIl9pc1RpbWVkT3V0U3VzcGVuc2UiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJjb21wbGV0ZVdvcmsiLCJmaWJlclJvb3QiLCJwcmV2aW91c0NhY2hlIiwicGVuZGluZ0NvbnRleHQiLCJuZXh0UmVzb3VyY2UiLCJfb2xkUHJvcHMyIiwiX3dhc0h5ZHJhdGVkIiwiX3R5cGUyIiwiX2N1cnJlbnRIb3N0Q29udGV4dCIsIl93YXNIeWRyYXRlZDIiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlIiwiX2luc3RhbmNlMyIsIl9yb290Q29udGFpbmVySW5zdGFuY2UyIiwiX2N1cnJlbnRIb3N0Q29udGV4dDIiLCJfd2FzSHlkcmF0ZWQzIiwiZmFsbHRocm91Z2hUb05vcm1hbFN1c3BlbnNlUGF0aCIsIm5leHREaWRUaW1lb3V0IiwicHJldkRpZFRpbWVvdXQiLCJfcHJldmlvdXNDYWNoZSIsIl9vZmZzY3JlZW5GaWJlcjIiLCJkaWRTdXNwZW5kQWxyZWFkeSIsInJlbmRlcmVkVGFpbCIsImNhbm5vdEJlU3VzcGVuZGVkIiwicmVuZGVySGFzTm90U3VzcGVuZGVkWWV0Iiwic3VzcGVuZGVkIiwiZ2V0UmVuZGVyVGFyZ2V0VGltZSIsIl9zdXNwZW5kZWQiLCJfcmV0cnlRdWV1ZTIiLCJwcmV2aW91c1NpYmxpbmciLCJuZXh0SXNIaWRkZW4iLCJfcHJldlN0YXRlIiwicHJldklzSGlkZGVuIiwiX3JldHJ5UXVldWUzIiwiX3ByZXZpb3VzQ2FjaGUyIiwiX2NhY2hlMiIsIl9wcmV2aW91c0NhY2hlMyIsIl9jYWNoZTMiLCJ1bndpbmRXb3JrIiwiX2ZsYWdzIiwiX2ZsYWdzMiIsIl9mbGFnczMiLCJ1bndpbmRJbnRlcnJ1cHRlZFdvcmsiLCJpbnRlcnJ1cHRlZFdvcmsiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIm9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJuZWVkc0Zvcm1SZXNldCIsIlBvc3NpYmx5V2Vha1NldCIsIldlYWtTZXQiLCJuZXh0RWZmZWN0IiwiaW5Qcm9ncmVzc0xhbmVzIiwiaW5Qcm9ncmVzc1Jvb3QiLCJzaG91bGRQcm9maWxlIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJuZWFyZXN0TW91bnRlZEFuY2VzdG9yIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJzYWZlbHlBdHRhY2hSZWYiLCJjb21taXRBdHRhY2hSZWYiLCJzYWZlbHlEZXRhY2hSZWYiLCJmaW5pc2hlZFdvcmsiLCJzYWZlbHlDYWxsRGVzdHJveSIsInNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbiIsInNob3VsZEZpcmUiLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfY29tcGxldGUiLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNPbkZpYmVyIiwic25hcHNob3QiLCJkaWRXYXJuU2V0IiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQiLCJzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QiLCJjb21taXRIb29rRWZmZWN0TGlzdE1vdW50IiwiY29tbWl0UGFzc2l2ZUVmZmVjdER1cmF0aW9ucyIsImZpbmlzaGVkUm9vdCIsIl9maW5pc2hlZFdvcmskbWVtb2l6ZSIsIm9uUG9zdENvbW1pdCIsInBoYXNlIiwiY29tbWl0SG9va0xheW91dEVmZmVjdHMiLCJjb21taXRDbGFzc0xheW91dExpZmVjeWNsZXMiLCJjb21taXRDbGFzc0NhbGxiYWNrcyIsImNvbW1pdEhvc3RDb21wb25lbnRNb3VudCIsImNvbW1pdFByb2ZpbGVyVXBkYXRlIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplMiIsIm9uQ29tbWl0Iiwib25SZW5kZXIiLCJlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdCIsImNvbW1pdExheW91dEVmZmVjdE9uRmliZXIiLCJjb21taXR0ZWRMYW5lcyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzIiwiY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MiLCJpc01vZGVyblJvb3QiLCJuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJ3YXNIaWRkZW4iLCJuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwicHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwiaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMiLCJoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbiIsImhvc3RTdWJ0cmVlUm9vdCIsImluc3RhbmNlVG9Vc2UiLCJkZXRhY2hGaWJlck11dGF0aW9uIiwiZGV0YWNoRmliZXJBZnRlckVmZmVjdHMiLCJob3N0SW5zdGFuY2UiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImVtcHR5Q2hpbGRTZXQiLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsImNvbW1pdFBsYWNlbWVudCIsImJlZm9yZSIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZSIsIl9wYXJlbnQiLCJfYmVmb3JlIiwiX3BhcmVudDIiLCJfYmVmb3JlMiIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIiLCJpc0hvc3QiLCJob3N0UGFyZW50IiwiaG9zdFBhcmVudElzQ29udGFpbmVyIiwiY29tbWl0RGVsZXRpb25FZmZlY3RzIiwiZGVsZXRlZEZpYmVyIiwiZmluZFBhcmVudCIsImNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzIiwicHJldkhvc3RQYXJlbnQiLCJwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyIiwiX3ByZXZIb3N0UGFyZW50IiwiX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIiLCJfcHJldkhvc3RQYXJlbnQyIiwiX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIyIiwiY29tbWl0U3VzcGVuc2VDYWxsYmFjayIsImh5ZHJhdGlvbkNhbGxiYWNrcyIsIm9uSHlkcmF0ZWQiLCJnZXRSZXRyeUNhY2hlIiwicmV0cnlDYWNoZSIsIl9yZXRyeUNhY2hlIiwiZGV0YWNoT2Zmc2NyZWVuSW5zdGFuY2UiLCJhdHRhY2hPZmZzY3JlZW5JbnN0YW5jZSIsImF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMiLCJyZXNvbHZlUmV0cnlXYWtlYWJsZSIsImNvbW1pdE11dGF0aW9uRWZmZWN0cyIsImNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzIiwiY3VycmVudEhvaXN0YWJsZVJvb3QiLCJjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMiLCJob2lzdGFibGVSb290IiwiY3VycmVudFJlc291cmNlIiwibmV3UmVzb3VyY2UiLCJwcmV2aW91c1dvcmsiLCJzaW5nbGV0b24iLCJwcmV2aW91c0hvaXN0YWJsZVJvb3QiLCJwcmV2Um9vdFN0YXRlIiwicmVjdXJzaXZlbHlSZXNldEZvcm1zIiwiX3ByZXZpb3VzSG9pc3RhYmxlUm9vdCIsIl9jb250YWluZXJJbmZvIiwiX3BlbmRpbmdDaGlsZHJlbiIsImlzU2hvd2luZ0ZhbGxiYWNrIiwid2FzU2hvd2luZ0ZhbGxiYWNrIiwibWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrIiwiaXNVcGRhdGUiLCJ3YXNIaWRkZW5CeUFuY2VzdG9yT2Zmc2NyZWVuIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMiLCJyZXNldEZvcm1PbkZpYmVyIiwiZm9ybUluc3RhbmNlIiwiY29tbWl0TGF5b3V0RWZmZWN0cyIsImRpc2FwcGVhckxheW91dEVmZmVjdHMiLCJyZWFwcGVhckxheW91dEVmZmVjdHMiLCJvZmZzY3JlZW5TdGF0ZSIsImNoaWxkU2hvdWxkSW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyIsImNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0IiwiY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdHRlZFRyYW5zaXRpb25zIiwiY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwiX2N1cnJlbnQyIiwicmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJfaW5zdGFuY2U0IiwiX2N1cnJlbnQzIiwiX2N1cnJlbnQ0IiwiY29tbWl0QXRvbWljUGFzc2l2ZUVmZmVjdHMiLCJfY3VycmVudDUiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIiLCJzdXNwZW5zZXlDb21taXRGbGFnIiwiYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdCIsImFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyIiwicmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0IiwiX3Byb3BzIiwicHJldkZsYWdzIiwiZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MiLCJkZXRhY2hlZENoaWxkIiwiZGV0YWNoZWRTaWJsaW5nIiwiY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyIsImRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0IiwiZGVsZXRlZFN1YnRyZWVSb290IiwiY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlIiwiZ2V0Q2FjaGVGb3JUeXBlIiwicmVzb3VyY2VUeXBlIiwiY2FjaGVGb3JUeXBlIiwiRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciIsImdldE93bmVyIiwiQ09NUE9ORU5UX1RZUEUiLCJIQVNfUFNFVURPX0NMQVNTX1RZUEUiLCJST0xFX1RZUEUiLCJURVNUX05BTUVfVFlQRSIsIlRFWFRfVFlQRSIsInN5bWJvbEZvciIsImNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yIiwiY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvciIsInNlbGVjdG9ycyIsImNyZWF0ZVJvbGVTZWxlY3RvciIsInJvbGUiLCJjcmVhdGVUZXh0U2VsZWN0b3IiLCJjcmVhdGVUZXN0TmFtZVNlbGVjdG9yIiwiZmluZEZpYmVyUm9vdEZvckhvc3RSb290IiwiaG9zdFJvb3QiLCJtYXliZUZpYmVyIiwibWF0Y2hTZWxlY3RvciIsInNlbGVjdG9yIiwiaGFzTWF0Y2hpbmdQYXRocyIsImRhdGFUZXN0SUQiLCJzZWxlY3RvclRvU3RyaW5nIiwiZmluZFBhdGhzIiwibWF0Y2hpbmdGaWJlcnMiLCJzZWxlY3RvckluZGV4IiwiZmluZEFsbE5vZGVzIiwiaW5zdGFuY2VSb290cyIsImZyb20iLCJnZXRGaW5kQWxsTm9kZXNGYWlsdXJlRGVzY3JpcHRpb24iLCJtYXhTZWxlY3RvckluZGV4IiwibWF0Y2hlZE5hbWVzIiwidW5tYXRjaGVkTmFtZXMiLCJmaW5kQm91bmRpbmdSZWN0cyIsImJvdW5kaW5nUmVjdHMiLCJ0YXJnZXRSZWN0IiwidGFyZ2V0TGVmdCIsInRhcmdldFJpZ2h0Iiwid2lkdGgiLCJ0YXJnZXRUb3AiLCJ0YXJnZXRCb3R0b20iLCJoZWlnaHQiLCJqIiwib3RoZXJSZWN0Iiwib3RoZXJMZWZ0Iiwib3RoZXJSaWdodCIsIm90aGVyVG9wIiwib3RoZXJCb3R0b20iLCJzcGxpY2UiLCJmb2N1c1dpdGhpbiIsImNvbW1pdEhvb2tzIiwib25Db21taXRSb290IiwiY29tbWl0SG9vayIsIm9ic2VydmVWaXNpYmxlUmVjdHMiLCJfc2V0dXBJbnRlcnNlY3Rpb25PYnMiLCJkaXNjb25uZWN0Iiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsIm5leHRJbnN0YW5jZVJvb3RzIiwidGFyZ2V0IiwiaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQiLCJpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJQb3NzaWJseVdlYWtNYXAiLCJCYXRjaGVkQ29udGV4dCIsIlJvb3RJblByb2dyZXNzIiwiUm9vdEZhdGFsRXJyb3JlZCIsIlJvb3RFcnJvcmVkIiwiUm9vdFN1c3BlbmRlZCIsIlJvb3RTdXNwZW5kZWRXaXRoRGVsYXkiLCJSb290Q29tcGxldGVkIiwiUm9vdERpZE5vdENvbXBsZXRlIiwiTm90U3VzcGVuZGVkIiwiU3VzcGVuZGVkT25FcnJvciIsIlN1c3BlbmRlZE9uRGF0YSIsIlN1c3BlbmRlZE9uSW1tZWRpYXRlIiwiU3VzcGVuZGVkT25JbnN0YW5jZSIsIlN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWUiLCJTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UiLCJTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUiLCJTdXNwZW5kZWRPbkh5ZHJhdGlvbiIsIndvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uIiwid29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSIsIndvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciIsImVudGFuZ2xlZFJlbmRlckxhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyIsIndvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSIsIndvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyIsIndvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUiLCJkaWRJbmNsdWRlQ29tbWl0UGhhc2VVcGRhdGUiLCJnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIiwiRkFMTEJBQ0tfVEhST1RUTEVfTVMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lIiwiSW5maW5pdHkiLCJSRU5ERVJfVElNRU9VVF9NUyIsIndvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMiLCJyZXNldFJlbmRlclRpbWVyIiwibGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQiLCJyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyIsInJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzIiwicGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMiLCJwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyIsInBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzIiwicGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJuZXN0ZWRVcGRhdGVDb3VudCIsInJvb3RXaXRoTmVzdGVkVXBkYXRlcyIsImlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyIsImRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMiLCJORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQiLCJuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQiLCJyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzIiwiaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0IiwiYWN0aW9uU2NvcGVMYW5lIiwicmVxdWVzdFJldHJ5TGFuZSIsImlzUHJlcmVuZGVyaW5nIiwic3VzcGVuc2VIYW5kbGVyIiwicHJlcGFyZUZyZXNoU3RhY2siLCJtYXJrUm9vdFN1c3BlbmRlZCIsIm1hcmtSb290VXBkYXRlZCIsIndhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWIiwid2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWIiwiaXNCYXRjaGluZ0xlZ2FjeSIsInNjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdCIsImRpZFRpbWVvdXQiLCJkaWRGbHVzaFBhc3NpdmVFZmZlY3RzIiwiZmx1c2hQYXNzaXZlRWZmZWN0cyIsInNob3VsZFRpbWVTbGljZSIsImV4aXRTdGF0dXMiLCJyZW5kZXJSb290Q29uY3VycmVudCIsInJlbmRlclJvb3RTeW5jIiwicmVuZGVyV2FzQ29uY3VycmVudCIsImlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyIsImxhbmVzVGhhdEp1c3RFcnJvcmVkIiwiZXJyb3JSZXRyeUxhbmVzIiwicmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3IiLCJmaW5pc2hlZExhbmVzIiwiZmluaXNoQ29uY3VycmVudFJlbmRlciIsImVycm9yc0Zyb21GaXJzdEF0dGVtcHQiLCJ3YXNSb290RGVoeWRyYXRlZCIsInJvb3RXb3JrSW5Qcm9ncmVzcyIsImVycm9yc0Zyb21TZWNvbmRBdHRlbXB0IiwiZXJyb3JzIiwic2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWIiwiY29tbWl0Um9vdCIsIm1zVW50aWxUaW1lb3V0IiwidGltZW91dEhhbmRsZSIsImNvbW1pdFJvb3RXaGVuUmVhZHkiLCJyZWNvdmVyYWJsZUVycm9ycyIsImRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSIsIkJvdGhWaXNpYmlsaXR5QW5kTWF5U3VzcGVuZENvbW1pdCIsInNjaGVkdWxlUGVuZGluZ0NvbW1pdCIsImNoZWNrcyIsInJlbmRlcmVkVmFsdWUiLCJ1cGRhdGVkTGFuZXMiLCJtYXJrUm9vdFBpbmdlZCIsImZsdXNoUm9vdCIsImRlZmVycmVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwiZGlzY3JldGVVcGRhdGVzIiwiZCIsImZsdXNoU3luY0Zyb21SZWNvbmNpbGVyIiwicHJldkV4ZWN1dGlvbkNvbnRleHQiLCJmbHVzaFN5bmNXb3JrIiwiaXNBbHJlYWR5UmVuZGVyaW5nIiwibmV3RW50YW5nbGVkUmVuZGVyTGFuZXMiLCJyZXNldFdvcmtJblByb2dyZXNzU3RhY2siLCJyZXNldFN1c3BlbmRlZFdvcmtMb29wT25VbndpbmQiLCJoYW5kbGVUaHJvdyIsImlzV2FrZWFibGUiLCJlcnJvcmVkV29yayIsInB1c2hEaXNwYXRjaGVyIiwicG9wRGlzcGF0Y2hlciIsInB1c2hBc3luY0Rpc3BhdGNoZXIiLCJwcmV2QXN5bmNEaXNwYXRjaGVyIiwiQSIsInBvcEFzeW5jRGlzcGF0Y2hlciIsImRpZFN1c3BlbmRJblNoZWxsIiwidW5pdE9mV29yayIsInRocm93QW5kVW53aW5kV29ya0xvb3AiLCJ3b3JrTG9vcFN5bmMiLCJwZXJmb3JtVW5pdE9mV29yayIsInJlc3VtZU9yVW53aW5kIiwicmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayIsIm9uUmVzb2x1dGlvbiIsIl90aGVuYWJsZSIsImhvc3RGaWJlciIsImNvbXBsZXRlVW5pdE9mV29yayIsIndvcmtMb29wQ29uY3VycmVudCIsInJlcGxheUJlZ2luV29yayIsImlzUHJvZmlsaW5nTW9kZSIsImRpZEZhdGFsIiwicGFuaWNPblJvb3RFcnJvciIsInVud2luZFVuaXRPZldvcmsiLCJzaWJsaW5nRmliZXIiLCJpbmNvbXBsZXRlV29yayIsInByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5IiwiY29tbWl0Um9vdEltcGwiLCJyZW5kZXJQcmlvcml0eUxldmVsIiwiZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWIiwic2NoZWR1bGVDYWxsYmFjayIsInN1YnRyZWVIYXNFZmZlY3RzIiwicm9vdEhhc0VmZmVjdCIsInJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMiLCJyZWxlYXNlUm9vdFBvb2xlZENhY2hlIiwiY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwib25SZWNvdmVyYWJsZUVycm9yIiwibWFrZUVycm9ySW5mbyIsInJlbmRlclByaW9yaXR5IiwicHJpb3JpdHkiLCJmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCIsInByb2ZpbGVyRWZmZWN0cyIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290Iiwicm9vdEZpYmVyIiwicGluZ0NhY2hlIiwidGhyZWFkSURzIiwicGluZyIsInBpbmdTdXNwZW5kZWRSb290Iiwid2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYiLCJyZXRyeVRpbWVkT3V0Qm91bmRhcnkiLCJib3VuZGFyeUZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFViIsImlzSW5TdHJpY3RNb2RlIiwiZG91YmxlSW52b2tlRWZmZWN0c0luREVWSWZOZWNlc3NhcnkiLCJkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlciIsInNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzIiwicGFyZW50SXNJblN0cmljdE1vZGUiLCJpc1N0cmljdE1vZGVGaWJlciIsImhhc1Bhc3NpdmVFZmZlY3RzIiwiZG91YmxlSW52b2tlRWZmZWN0cyIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciIsImRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCIsInJlbmRlcmluZ0NvbXBvbmVudE5hbWUiLCJkZWR1cGVLZXkiLCJzZXRTdGF0ZUNvbXBvbmVudE5hbWUiLCJzY2hlZHVsaW5nRmliZXIiLCJmYWtlQWN0Q2FsbGJhY2tOb2RlIiwiaXNSdW5uaW5nIiwicmVzb2x2ZUZhbWlseSIsImZhaWxlZEJvdW5kYXJpZXMiLCJzZXRSZWZyZXNoSGFuZGxlciIsImZhbWlseSIsImN1cnJlbnRSZW5kZXIiLCJzeW50aGV0aWNUeXBlIiwicHJldlR5cGUiLCJuZXh0VHlwZSIsIm5lZWRzQ29tcGFyZUZhbWlsaWVzIiwiJCR0eXBlb2ZOZXh0VHlwZSIsInByZXZGYW1pbHkiLCJzY2hlZHVsZVJlZnJlc2giLCJzdGFsZUZhbWlsaWVzIiwidXBkYXRlZEZhbWlsaWVzIiwic2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseSIsInNjaGVkdWxlUm9vdCIsInVwZGF0ZUNvbnRhaW5lclN5bmMiLCJjYW5kaWRhdGVUeXBlIiwibmVlZHNSZW5kZXIiLCJuZWVkc1JlbW91bnQiLCJmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2giLCJmYW1pbGllcyIsImhvc3RJbnN0YW5jZXMiLCJ0eXBlcyIsImZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseSIsImRpZE1hdGNoIiwiZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImZvdW5kSG9zdEluc3RhbmNlcyIsImZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwiRmliZXJOb2RlIiwiTnVtYmVyIiwiTmFOIiwiY3JlYXRlRmliZXIiLCJzaG91bGRDb25zdHJ1Y3QiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3VycmVudERlcGVuZGVuY2llcyIsImNyZWF0ZUhvc3RSb290RmliZXIiLCJpc1N0cmljdE1vZGUiLCJjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlIiwiZmliZXJUYWciLCJfaG9zdENvbnRleHQiLCJnZXRUYWciLCJjcmVhdGVGaWJlckZyb21Qcm9maWxlciIsImNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlIiwiY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0IiwidHlwZVN0cmluZyIsImVsZW1lbnRzIiwicHJpbWFyeUNoaWxkSW5zdGFuY2UiLCJfcGVuZGluZ01hcmtlcnMiLCJfdHJhbnNpdGlvbnMiLCJkZXRhY2giLCJhdHRhY2giLCJkZWh5ZHJhdGVkTm9kZSIsIkZpYmVyUm9vdE5vZGUiLCJoeWRyYXRlIiwiaW5jb21wbGV0ZVRyYW5zaXRpb25zIiwiX2RlYnVnUm9vdFR5cGUiLCJjcmVhdGVGaWJlclJvb3QiLCJpbml0aWFsQ2hpbGRyZW4iLCJ0cmFuc2l0aW9uQ2FsbGJhY2tzIiwidW5pbml0aWFsaXplZEZpYmVyIiwiaW5pdGlhbENhY2hlIiwiUmVhY3RWZXJzaW9uIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJjcmVhdGVQb3J0YWwiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsImZpbmRIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiY3JlYXRlQ29udGFpbmVyIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwidXBkYXRlQ29udGFpbmVyIiwidXBkYXRlQ29udGFpbmVySW1wbCIsImdldFB1YmxpY1Jvb3RJbnN0YW5jZSIsImNvbnRhaW5lckZpYmVyIiwiYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uIiwiX3Jvb3QiLCJtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZCIsIm1hcmtSZXRyeUxhbmVJbXBsIiwiYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24iLCJhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkiLCJmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyIsInNob3VsZEVycm9ySW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2V0RXJyb3JIYW5kbGVyIiwic2V0U3VzcGVuc2VIYW5kbGVyIiwiY29weVdpdGhEZWxldGVJbXBsIiwib2JqIiwicGF0aCIsImNvcHlXaXRoRGVsZXRlIiwiY29weVdpdGhSZW5hbWVJbXBsIiwib2xkUGF0aCIsIm5ld1BhdGgiLCJvbGRLZXkiLCJuZXdLZXkiLCJjb3B5V2l0aFJlbmFtZSIsImNvcHlXaXRoU2V0SW1wbCIsImNvcHlXaXRoU2V0IiwiZmluZEhvb2siLCJuZXdTaG91bGRFcnJvckltcGwiLCJuZXdTaG91bGRTdXNwZW5kSW1wbCIsImZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyIiwiZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSIsImdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZGV2VG9vbHNDb25maWciLCJmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSIsImJ1bmRsZVR5cGUiLCJ2ZXJzaW9uIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsInJlbmRlcmVyQ29uZmlnIiwiY3VycmVudERpc3BhdGNoZXJSZWYiLCJnZXRDdXJyZW50RmliZXIiLCJyZWNvbmNpbGVyVmVyc2lvbiIsImRlZmF1bHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtMQUEyRTtBQUM3RSIsInNvdXJjZXMiOlsiL1VzZXJzL3NvdWxlbWFuZXNvdy9Eb3dubG9hZHMvQ29kZS8zZCBHbGFzc2VzL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyIvVXNlcnMvc291bGVtYW5lc293L0Rvd25sb2Fkcy9Db2RlLzNkIEdsYXNzZXMvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/index.js\n");

/***/ })

};
;